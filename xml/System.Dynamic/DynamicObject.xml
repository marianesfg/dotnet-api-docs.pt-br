<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ed4462f9d7a16e9217568c22ea8566bf818f60e5" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51893824" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma classe base para especificar o comportamento dinâmico no tempo de execução. Essa classe deve ser herdada. Não é possível instanciá-la diretamente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `DynamicObject` classe permite que você defina quais operações podem ser executadas em objetos dinâmicos e como executar essas operações. Por exemplo, você pode definir o que acontece quando você tentar obter ou definir uma propriedade de objeto, chamar um método ou executar operações matemáticas padrão, como adição e multiplicação.  
  
 Essa classe pode ser útil se você quiser criar um protocolo mais conveniente para uma biblioteca. Por exemplo, se os usuários da sua biblioteca tem que usar uma sintaxe como `Scriptobj.SetProperty("Count", 1)`, você pode fornecer a capacidade de usar a sintaxe muito mais simples, como `scriptobj.Count = 1`.  
  
 Você não pode criar diretamente uma instância da `DynamicObject` classe. Para implementar o comportamento dinâmico, você talvez queira herdam o `DynamicObject` de classe e substituir os métodos necessários. Por exemplo, se você precisar somente as operações para definir e obter as propriedades, você pode substituir apenas a <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos.  
  
 No c#, para habilitar o comportamento dinâmico para instâncias de classes derivam de `DynamicObject` classe, você deve usar o `dynamic` palavra-chave. Para obter mais informações, veja [Usando o tipo dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 No Visual Basic, operações dinâmicas têm suporte por associação tardia. Para obter mais informações, consulte [associação antecipada e tardia](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 O exemplo de código a seguir demonstra como criar uma instância de uma classe que deriva de `DynamicObject` classe.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Você também pode adicionar seus próprios membros para classes derivadas de `DynamicObject` classe. Se sua classe define propriedades e também substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método, o tempo de execução de linguagem dinâmica (DLR) primeiro usa o associador de linguagem para procurar por uma definição estática de uma propriedade na classe. Se não houver nenhuma propriedade, o DLR chama o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método.  
  
 O `DynamicObject` classe implementa a interface do DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, que permite que você compartilhe instâncias do `DynamicObject` classe entre linguagens com suporte para o modelo de interoperabilidade do DLR. Por exemplo, você pode criar uma instância da `DynamicObject` de classe em c# e, em seguida, passá-lo para uma função de IronPython. Para obter mais informações, consulte [visão geral do Dynamic Language Runtime](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Se você tiver um cenário simples em que você precisa de um objeto que só pode adicionar e remover membros em tempo de execução, mas que não precisa definir as operações específicas e não têm membros estáticos, use o <xref:System.Dynamic.ExpandoObject> classe.  
>   
>  Se você tiver um cenário mais avançado em que você precisa definir como objetos dinâmicos participa do protocolo de interoperabilidade, ou você precisa para gerenciar o cache de expedição dinâmica rápidas do DLR, crie sua própria implementação do <xref:System.Dynamic.IDynamicMetaObjectProvider> interface.  
  
   
  
## Examples  
 Suponha que você deseja fornecer a sintaxe alternativa para acessar valores em um dicionário, portanto, que, em vez de escrever `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` no Visual Basic), você pode escrever `sampleDictionary.Text = "Sample text"`. Além disso, você deseja que essa sintaxe para diferenciar maiusculas de minúsculas, para que `sampleDictionary.Text` é equivalente a `sampleDictionary.text`.  
  
 O exemplo de código a seguir demonstra a `DynamicDictionary` classe, que é derivado do `DynamicObject` classe. O `DynamicDictionary` classe contém um objeto do `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` no Visual Basic) para armazenar os pares chave-valor e substituições de <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para dar suporte a nova sintaxe. Ele também fornece um `Count` propriedade, que mostra quantas propriedades dinâmicas o dicionário contém.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Para obter mais exemplos, consulte [criando Wrappers com DynamicObject](https://go.microsoft.com/fwlink/?LinkId=169008) no blog do c# perguntas frequentes.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Habilita os tipos derivados para inicializarem uma nova instância do tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não pode criar diretamente uma instância da <xref:System.Dynamic.DynamicObject> classe. Para implementar o comportamento dinâmico, você precisa herdar o <xref:System.Dynamic.DynamicObject> de classe e substituir os métodos necessários.  
  
 No c#, para habilitar o comportamento dinâmico para instâncias de classes derivam de <xref:System.Dynamic.DynamicObject> classe, você deve usar o `dynamic` palavra-chave. Para obter mais informações, veja [Usando o tipo dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 No Visual Basic, operações dinâmicas têm suporte por associação tardia. Para obter mais informações, consulte [associação antecipada e tardia](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar uma instância de classes que derivam de <xref:System.Dynamic.DynamicObject> classe.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a enumeração de todos os nomes de membro dinâmico.</summary>
        <returns>Uma sequência que contém os nomes de membro dinâmico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método existe apenas para fins de depuração.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">A expressão que representa o <see cref="T:System.Dynamic.DynamicMetaObject" /> para expedir para os métodos virtuais dinâmicos.</param>
        <summary>Fornece um <see cref="T:System.Dynamic.DynamicMetaObject" /> que expede para os métodos virtuais dinâmicos. O objeto pode ser encapsulado em outro <see cref="T:System.Dynamic.DynamicMetaObject" /> para fornecer um comportamento personalizado para ações individuais. Esse método dá suporte à infraestrutura do Dynamic Language Runtime para implementadores de linguagem e não se destina a ser usado diretamente do seu código.</summary>
        <returns>Um objeto do tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação binária. A propriedade <c>binder.Operation</c> retorna um objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por exemplo, para a instrução <c>sum = first + second</c>, em que <c>first</c> e <c>second</c> são derivados da classe <see langword="DynamicObject" />, <c>binder.Operation</c> retorna <c>ExpressionType.Add</c>.</param>
        <param name="arg">O operando direito da operação binária. Por exemplo, para a instrução <c>sum = first + second</c>, em que <c>first</c> e <c>second</c> são derivados da classe <see langword="DynamicObject" />, <c>arg</c> é igual a <c>second</c>.</param>
        <param name="result">O resultado da operação binária.</param>
        <summary>Fornece implementação para operações binárias. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método a fim de especificar o comportamento dinâmico para operações como adição e multiplicação.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como as operações binárias deve ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Esse método é chamado quando você tiver operações binárias, como adição ou multiplicação. Por exemplo, se o <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método for substituído, ele é invocado automaticamente para instruções, como `sum = first + second` ou `multiply = first*second`, onde `first` deriva o `DynamicObject` classe.  
  
 Você pode obter informações sobre o tipo da operação binária usando o `Operation` propriedade do `binder` parâmetro.  
  
 Se o objeto dinâmico é usado somente em c# e Visual Basic, o `binder.Operation` propriedade pode ter um dos seguintes valores do <xref:System.Linq.Expressions.ExpressionType> enumeração. No entanto, em outras linguagens como o IronPython ou IronRuby, você pode ter outros valores.
  
|Valor|Descrição|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Uma operação de adição sem verificação de estouro, para operandos numéricos.|`a + b`|`a + b`|  
|`AddAssign`|Uma operação de atribuição composta de adição sem verificação de estouro, para operandos numéricos.|`a += b`|Sem suporte.|  
|`And`|Um bit a bit `AND` operação.|`a & b`|`a And b`|  
|`AndAssign`|Um bit a bit `AND` operação de atribuição composta.|`a &= b`|Sem suporte.|  
|`Divide`|Uma operação de divisão aritmética.|`a / b`|`a / b`|  
|`DivideAssign`|Uma operação de atribuição composta de divisão aritmética.|`a /= b`|Sem suporte.|  
|`ExclusiveOr`|Um bit a bit `XOR` operação.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Um bit a bit `XOR` operação de atribuição composta.|`a ^= b`|Sem suporte.|  
|`GreaterThan`|Uma comparação "maior que".|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Uma comparação "maior que ou igual a".|`a >= b`|Sem suporte.|  
|`LeftShift`|Uma operação bit a bit de deslocamento à esquerda.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Uma operação de atribuição composta bit a bit de deslocamento à esquerda.|`a <<= b`|Sem suporte.|  
|`LessThan`|Uma comparação "menor que".|`a < b`|`a < b`|  
|`LessThanOrEqual`|Uma comparação "menor ou igual a".|`a <= b`|Sem suporte.|  
|`Modulo`|Uma operação aritmética restante.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Uma operação de atribuição composta restante aritmética.|`a %= b`|Sem suporte.|  
|`Multiply`|Uma operação de multiplicação sem verificação de estouro, para operandos numéricos.|`a * b`|`a * b`|  
|`MultiplyAssign`|Uma operação de atribuição composta de multiplicação sem verificação de estouro, para operandos numéricos.|`a *= b`|Sem suporte.|  
|`NotEqual`|Uma comparação de desigualdade.|`a != b`|`a <> b`|  
|`Or`|A lógica ou bit a bit `OR` operação.|`a &#124; b`|`a Or b`|  
|`OrAssign`|A lógica ou bit a bit `OR` atribuição composta.|`a &#124;= b`|Sem suporte.|  
|`Power`|Uma operação matemática de elevar um número a uma potência.|Sem suporte.|`a ^ b`|  
|`RightShift`|Uma operação bit a bit de deslocamento à direita.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Uma operação de atribuição composta bit a bit de deslocamento à direita.|`a >>= b`|Sem suporte.|  
|`Subtract`|Uma operação de subtração sem verificação de estouro, para operandos numéricos.|`a - b`|`a - b`|  
|`SubtractAssign`|Uma operação de atribuição composta de subtração sem verificação de estouro, para operandos numéricos.|`a -= b`|Sem suporte.|  
  
> [!NOTE]
>  Para implementar `OrElse` (`a || b`) e `AndAlso` (`a && b`) operações para objetos dinâmicos no c#, você talvez queira implementar ambos os <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método e o <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método.  
>   
>  O `OrElse` consiste em operação unária `IsTrue` operação e o binário `Or` operação. O `Or` operação é executada apenas se o resultado do `IsTrue` operação é `false`.  
>   
>  O `AndAlso` consiste em operação unária `IsFalse` operação e o binário `And` operação. O `And` operação é executada apenas se o resultado do `IsFalse` operação é `false`.  
  
   
  
## Examples  
 Suponha que você precisa de uma estrutura de dados para armazenar representações textuais e numéricas de números, e você deseja definir operações matemáticas básicas, como adição e subtração para esses dados.  
  
 O exemplo de código a seguir demonstra a `DynamicNumber` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` substitui o <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método para permitir operações matemáticas. Ele também substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar o acesso aos elementos.  
  
 Neste exemplo, as únicas operações de adição e subtração têm suporte. Se você tentar gravar uma instrução como `resultNumber = firstNumber*secondNumber`, uma exceção de tempo de execução é gerada.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação de conversão. A propriedade <c>binder.Type</c> fornece o tipo para o qual o objeto deve ser convertido. Por exemplo, a instrução <c>(String)sampleObject</c> em C# (<c>CType(sampleObject, Type)</c> em Visual Basic), em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> retorna o tipo <see cref="T:System.String" />. A propriedade <c>binder.Explicit</c> fornece informações sobre o tipo de conversão que ocorre. Ela retorna <see langword="true" /> para conversão explícita e <see langword="false" /> para conversão implícita.</param>
        <param name="result">O resultado da operação de conversão de tipo.</param>
        <summary>Fornece implementação para operações de conversão de tipo. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações que convertem um objeto de um tipo em outro.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como uma conversão de tipo deve ser executada para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 No c#, se esse método for substituído, ele é invocado automaticamente quando você tem uma conversão explícita ou implícita, conforme mostrado no exemplo de código abaixo.  
  
 No Visual Basic, há suporte para apenas para uma conversão explícita. Se você substituir esse método, você chamá-lo usando o <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> ou <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> funções.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Suponha que você precisa de uma estrutura de dados para armazenar representações textuais e numéricas de números, e você deseja definir conversões dessa estrutura de dados de cadeias de caracteres e inteiros.  
  
 O exemplo de código a seguir demonstra a `DynamicNumber` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` substitui o <xref:System.Dynamic.DynamicObject.TryConvert%2A> método para habilitar a conversão de tipo. Ele também substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar o acesso aos elementos de dados.  
  
 Neste exemplo, há suporte para apenas uma conversão de cadeias de caracteres e inteiros. Se você tentar converter um objeto em qualquer outro tipo, uma exceção de tempo de execução é gerada.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação de inicialização.</param>
        <param name="args">Os argumentos que são passados ao objeto durante inicialização. Por exemplo, para a operação <c>new SampleType(100)</c>, em que <c>SampleType</c> é o tipo derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
        <param name="result">O resultado da inicialização.</param>
        <summary>Fornece a implementação para operações que inicializam uma nova instância de um objeto dinâmico. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como uma nova instância do objeto dinâmico deve ser inicializada. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Compiladores c# e Visual Basic nunca emitem o código para usar esse método, porque eles não dão suporte a tipos de primeira classe. Este método destina-se para linguagens que dão suporte a inicialização de objetos dinâmicos usando uma sintaxe como `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a exclusão.</param>
        <param name="indexes">Os índices a serem excluídos.</param>
        <summary>Fornece a implementação para operações que excluem um objeto pelo índice. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como um valor que tem um índice especificado deve ser excluído. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Compiladores c# e Visual Basic nunca emitem o código para usar esse método, porque eles não dão suporte a esse tipo de operação. Este método destina-se para linguagens que dão suporte à sintaxe para a exclusão de objetos por índice, tais como `del sampleObject[1,2]` em Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a exclusão.</param>
        <summary>Fornece a implementação para operações que excluem um membro de objeto. Esse método não se destina ao uso em C# ou Visual Basic.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como um membro de objeto deve ser excluído. Quando esse método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Compiladores c# e Visual Basic nunca emitem o código para usar esse método, porque eles não dão suporte a esse tipo de operação. Este método destina-se para linguagens que dão suporte à sintaxe para a exclusão de membros, como `del sampleObject.SampleMember` em Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação.</param>
        <param name="indexes">Os índices usados na operação. Por exemplo, para a operação <c>sampleObject[3]</c> em C# (<c>sampleObject(3)</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see langword="DynamicObject" />, <c>indexes[0]</c> é igual a 3.</param>
        <param name="result">O resultado da operação de índice.</param>
        <summary>Fornece a implementação para operações que obtêm um valor por índice. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método para especificar o comportamento dinâmico das operações de indexação.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como a obtenção de um valor por índice deve ser executada para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)  
  
 Se esse método for substituído, ele é invocado automaticamente quando você tem uma operação como `sampleObject[3]` em c# ou `sampleObject(3)` no Visual Basic, em que `sampleObject` deriva o <xref:System.Dynamic.DynamicObject> classe.  
  
   
  
## Examples  
 Suponha que você deseja criar um objeto no qual as propriedades podem ser acessados por nomes, como `Property0`, `Property1`e assim por diante, ou por índice, para que, por exemplo, `sampleObject.Property0` é equivalente a `sampleObject[0]` em c# ou `sampleObject(0)` no Visual Basic.  
  
 O exemplo de código a seguir demonstra a `SampleDynamicObject` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. O `SampleDynamicObject` classe contém um objeto do `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` no Visual Basic) para armazenar os pares chave-valor. `SampleDynamicObject` substitui o <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> e <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> métodos para habilitar o acesso por índice. Ele substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar o acesso pelo nome da propriedade.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre o objeto que chamou a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro no qual a operação dinâmica é executada. Por exemplo, para a instrução <c>Console.WriteLine(sampleObject.SampleProperty)</c>, em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleProperty". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
        <param name="result">O resultado da operação get. Por exemplo, se o método é chamado para uma propriedade, atribua o valor da propriedade a <c>result</c>.</param>
        <summary>Fornece a implementação para operações que obtêm valores de membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como obtenção de um valor para uma propriedade.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como as operações que obtêm valores de membro devem ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)  
  
 Esse método é chamado quando você tiver instruções como `Console.WriteLine(sampleObject.SampleProperty)`, onde `sampleObject` é uma instância da classe que deriva de <xref:System.Dynamic.DynamicObject> classe.  
  
 Você também pode adicionar seus próprios membros para classes derivadas de `DynamicObject` classe. Se sua classe define propriedades e também substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método, o tempo de execução de linguagem dinâmica (DLR) primeiro usa o associador de linguagem para procurar por uma definição estática de uma propriedade na classe. Se não houver nenhuma propriedade, o DLR chama o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método.  
  
   
  
## Examples  
 Suponha que você deseja fornecer a sintaxe alternativa para acessar valores em um dicionário, portanto, que, em vez de escrever `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` no Visual Basic), você pode escrever `sampleDictionary.Text = "Sample text"`. Além disso, essa sintaxe deve ser diferencia maiusculas de minúsculas, de modo que `sampleDictionary.Text` é equivalente a `sampleDictionary.text`.  
  
 O exemplo de código a seguir demonstra a `DynamicDictionary` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. O `DynamicDictionary` classe contém um objeto do `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` no Visual Basic) para armazenar os pares chave-valor e substituições de <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para dar suporte a nova sintaxe. Ele também fornece um `Count` propriedade, que mostra quantas propriedades dinâmicas o dicionário contém.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação de invocação.</param>
        <param name="args">Os argumentos que são passados ao objeto durante a operação de invocação. Por exemplo, para a operação <c>sampleObject(100)</c>, em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
        <param name="result">O resultado da invocação do objeto.</param>
        <summary>Fornece a implementação para operações que invocam um objeto. Classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como invocar um objeto ou um delegado.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como as operações que invocam um objeto devem ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução é gerada.)  
  
 Se esse método for substituído, ele é invocado automaticamente quando você tem uma operação semelhante `sampleObject(100)`, onde `sampleObject` deriva o <xref:System.Dynamic.DynamicObject> classe.  
  
 A operação para invocar um objeto é suportada em c#, mas não no Visual Basic. O compilador do Visual Basic nunca emite código para usar esse método, e a linguagem Visual Basic não oferece suporte a uma sintaxe como `sampleObject(100)`.  
  
   
  
## Examples  
 Suponha que você precisa de uma estrutura de dados para armazenar representações textuais e numéricas de números. Você deseja ser capaz de especificar o valor para cada propriedade individualmente e também ser capaz de inicializar todas as propriedades em uma única instrução.  
  
 O exemplo de código a seguir demonstra a `DynamicNumber` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` substitui o <xref:System.Dynamic.DynamicObject.TryInvoke%2A> método para habilitar a inicialização de todas as propriedades de uma só vez. Ele também substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar o acesso às propriedades de objeto individuais.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro no qual a operação dinâmica é executada. Por exemplo, para a instrução <c>sampleObject.SampleMethod(100)</c>, em que <c>sampleObject</c> é uma instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleMethod". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
        <param name="args">Os argumentos passados ao membro do objeto durante a operação de invocação. Por exemplo, para a instrução <c>sampleObject.SampleMethod(100)</c>, em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> é igual a 100.</param>
        <param name="result">O resultado da invocação do membro.</param>
        <summary>Fornece a implementação para operações que invocam um membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir esse método a fim de especificar o comportamento dinâmico para operações como chamar um método.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como as operações que invocam um membro de objeto devem ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Se esse método for substituído, ele é invocado automaticamente quando você executa uma operação semelhante `sampleObject.SampleMethod(100)`, onde `sampleObject` deriva o `DynamicObject` classe.  
  
 Você também pode adicionar seus próprios métodos para classes que derivam de <xref:System.Dynamic.DynamicObject> classe. Por exemplo, se você substituir o <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> método, o sistema de expedição dinâmica primeiro tenta determinar se o método especificado existe na classe. Se não encontrar o método, ele usa o <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> implementação.  
  
 Esse método não suporta `ref` e `out` parâmetros. Todos os parâmetros no `args` matriz são passados por valor.  
  
   
  
## Examples  
 Suponha que você deseja fornecer a sintaxe alternativa para acessar valores em um dicionário, portanto, que, em vez de escrever `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` no Visual Basic), você pode escrever `sampleDictionary.Text = "Sample text"`. Além disso, você deseja ser capaz de chamar os métodos de dicionário padrão neste dicionário.  
  
 O exemplo de código a seguir demonstra a `DynamicDictionary` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. O `DynamicDictionary` classe contém um objeto do `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` no Visual Basic) para armazenar os pares chave-valor. Ele substitui o <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> método para dar suporte a métodos do <xref:System.Collections.Generic.Dictionary%602> classe e substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para dar suporte a nova sintaxe. Ele também fornece um `Print` método, que imprime todos os valores e chaves de dicionário.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação.</param>
        <param name="indexes">Os índices usados na operação. Por exemplo, para a operação <c>sampleObject[3] = 10</c> em C# (<c>sampleObject(3) = 10</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> é igual a 3.</param>
        <param name="value">O valor a ser definido para o objeto que tem o índice especificado. Por exemplo, para a operação <c>sampleObject[3] = 10</c> em C# (<c>sampleObject(3) = 10</c> em Visual Basic), em que <c>sampleObject</c> é derivado da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>value</c> é igual a 10.</param>
        <summary>Fornece a implementação para operações que definem um valor por índice. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações que acessam os objetos por um índice especificado.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como as operações que acessam um objeto pelo índice devem ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Se esse método for substituído, ele é invocado automaticamente quando você tem uma operação como `sampleObject[3] = 10` em c# ou `sampleObject(3) = 10` no Visual Basic, em que `sampleObject` deriva o <xref:System.Dynamic.DynamicObject> classe.  
  
   
  
## Examples  
 Suponha que você deseja criar um objeto no qual as propriedades podem ser acessados por nomes, como `Property0`, `Property1`e assim por diante, ou por índice, para que, por exemplo, `sampleObject.Property0` é equivalente a `sampleObject[0]` em c# ou `sampleObject(0)` no Visual Basic.  
  
 O exemplo de código a seguir demonstra a `SampleDynamicObject` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. O `SampleDynamicObject` classe contém um objeto do `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` no Visual Basic) para armazenar os pares chave-valor. `SampleDynamicObject` substitui o <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> e <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> métodos para habilitar o acesso por índice. Ele substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar o acesso pelo nome da propriedade.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre o objeto que chamou a operação dinâmica. A propriedade <c>binder.Name</c> fornece o nome do membro ao qual o valor está sendo atribuído. Por exemplo, para a instrução <c>sampleObject.SampleProperty = "Test"</c>, em que <c>sampleObject</c> é a instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> retorna "SampleProperty". A propriedade <c>binder.IgnoreCase</c> especifica se o nome do membro diferencia maiúsculas de minúsculas.</param>
        <param name="value">O valor a ser definido para o membro. Por exemplo, para <c>sampleObject.SampleProperty = "Test"</c>, em que <c>sampleObject</c> é a instância da classe derivada da classe <see cref="T:System.Dynamic.DynamicObject" />, o <c>value</c> é "Test".</param>
        <summary>Fornece a implementação para operações que definem valores de membro. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como definição de um valor para uma propriedade.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como as operações que definem um valor a um membro devem ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Esse método é chamado quando você tiver instruções como `sampleObject.SampleProperty = "Test"`, onde `sampleObject` é uma instância da classe que deriva de <xref:System.Dynamic.DynamicObject> classe.  
  
 Você também pode adicionar seus próprios membros para classes derivadas de `DynamicObject` classe. Se sua classe define propriedades e também substitui o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método, o tempo de execução de linguagem dinâmica (DLR) primeiro usa o associador de linguagem para procurar por uma definição estática de uma propriedade na classe. Se não houver nenhuma propriedade, o DLR chama o <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método.  
  
   
  
## Examples  
 Suponha que você deseja fornecer a sintaxe alternativa para acessar valores em um dicionário, portanto, que, em vez de escrever `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` no Visual Basic), você pode escrever `sampleDictionary.Text = "Sample text"`. Além disso, essa sintaxe deve ser diferencia maiusculas de minúsculas, de modo que `sampleDictionary.Text` é equivalente a `sampleDictionary.text`.  
  
 O exemplo de código a seguir demonstra a `DynamicDictionary` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. O `DynamicDictionary` classe contém um objeto do `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` no Visual Basic) para armazenar os pares chave-valor e substituições de <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para dar suporte a nova sintaxe. Ele também fornece um `Count` propriedade, que mostra quantas propriedades dinâmicas o dicionário contém.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Fornece informações sobre a operação unária. A propriedade <c>binder.Operation</c> retorna um objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por exemplo, para a instrução <c>negativeNumber = -number</c>, em que <c>number</c> é derivado da classe <see langword="DynamicObject" />, <c>binder.Operation</c> retorna "Negate".</param>
        <param name="result">O resultado da operação unária.</param>
        <summary>Fornece implementação para operações unárias. As classes derivadas da classe <see cref="T:System.Dynamic.DynamicObject" /> podem substituir este método para especificar o comportamento dinâmico para operações como uma negação, incremento ou decremento.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />. Se esse método retornar <see langword="false" />, o associador de tempo de execução da linguagem determinará o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As classes derivadas de <xref:System.Dynamic.DynamicObject> classe pode substituir este método para especificar como operações unárias devem ser executadas para um objeto dinâmico. Quando o método não for substituído, o associador de tempo de execução da linguagem determina o comportamento. (Na maioria dos casos, uma exceção de tempo de execução específica a um idioma é gerada.)  
  
 Esse método é chamado quando você tiver operações unárias, como negação, incremento ou decremento. Por exemplo, se o <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método for substituído, esse método é invocado automaticamente para instruções, como `negativeNumber = -number`, onde `number` deriva o <xref:System.Dynamic.DynamicObject> classe.  
  
 Você pode obter informações sobre o tipo da operação unária, usando o `Operation` propriedade do `binder` parâmetro.  
  
 Se o objeto dinâmico é usado somente em c# e Visual Basic, o `binder.Operation` propriedade pode ter um dos seguintes valores do <xref:System.Linq.Expressions.ExpressionType> enumeração. No entanto, em outras linguagens como o IronPython ou IronRuby, você pode ter outros valores.
  
|Valor|Descrição|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Uma operação de decremento unária.|`a--`|Sem suporte.|  
|`Increment`|Uma operação de incremento unária.|`a++`|Sem suporte.|  
|`Negate`|Uma negação aritmética.|`-a`|`-a`|  
|`Not`|Uma negação lógica.|`!a`|`Not a`|  
|`OnesComplement`|Um aqueles complemento.|`~a`|Sem suporte.|  
|`IsFalse`|Um valor de condição falsa.|`a && b`|Sem suporte.|  
|`IsTrue`|Um valor de condição verdadeira.|`a &#124;&#124; b`|Sem suporte.|  
|`UnaryPlus`|Uma adição unária.|`+a`|`+a`|  
  
> [!NOTE]
>  Para implementar `OrElse` (`a || b`) e `AndAlso` (`a && b`) operações para objetos dinâmicos no c#, você talvez queira implementar ambos os <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método e o <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método.  
>   
>  O `OrElse` consiste em operação unária `IsTrue` operação e o binário `Or` operação. O `Or` operação é executada apenas se o resultado do `IsTrue` operação é `false`.  
>   
>  O `AndAlso` consiste em operação unária `IsFalse` operação e o binário `And` operação. O `And` operação é executada apenas se o resultado do `IsFalse` operação é `false`.  
  
   
  
## Examples  
 Suponha que você precisa de uma estrutura de dados para armazenar representações textuais e numéricas de números, e você deseja definir uma operação de negação de matemática para esses dados.  
  
 O exemplo de código a seguir demonstra a `DynamicNumber` classe, que é derivado do <xref:System.Dynamic.DynamicObject> classe. `DynamicNumber` substitui o <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método para habilitar a operação de negação de matemática. Também é substituições de <xref:System.Dynamic.DynamicObject.TrySetMember%2A> e <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar o acesso aos elementos.  
  
 Neste exemplo, há suporte para apenas a operação de negação de matemática. Se você tentar gravar uma instrução como `negativeNumber = +number`, ocorre uma exceção de tempo de execução.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>