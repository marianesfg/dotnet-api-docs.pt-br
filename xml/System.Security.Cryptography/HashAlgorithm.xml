<Type Name="HashAlgorithm" FullName="System.Security.Cryptography.HashAlgorithm">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="337dbc56f7f766824323fb7d5e8159f86f762087" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52602783" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class HashAlgorithm : System.Security.Cryptography.ICryptoTransform" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit HashAlgorithm extends System.Object implements class System.IDisposable, class System.Security.Cryptography.ICryptoTransform" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.HashAlgorithm" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class HashAlgorithm&#xA;Implements ICryptoTransform" />
  <TypeSignature Language="C++ CLI" Value="public ref class HashAlgorithm abstract : System::Security::Cryptography::ICryptoTransform" />
  <TypeSignature Language="F#" Value="type HashAlgorithm = class&#xA;    interface IDisposable&#xA;    interface ICryptoTransform" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.Cryptography.ICryptoTransform</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b55de-101">Representa a classe base abstrata da qual todas as implementações de algoritmo de hash criptográficos devem derivar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b55de-101">Represents the base class from which all implementations of cryptographic hash algorithms must derive.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-102">Funções de hash são fundamentais para a criptografia moderna.</span><span class="sxs-lookup"><span data-stu-id="b55de-102">Hash functions are fundamental to modern cryptography.</span></span> <span data-ttu-id="b55de-103">Essas funções são cadeias de caracteres binárias de um comprimento arbitrário mapeiam para pequenas cadeias de caracteres binárias de comprimento fixo, conhecido como valores de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-103">These functions map binary strings of an arbitrary length to small binary strings of a fixed length, known as hash values.</span></span> <span data-ttu-id="b55de-104">Uma função de hash criptográfico tem a propriedade que é impraticável para encontrar duas entradas distintas esse hash com o mesmo valor.</span><span class="sxs-lookup"><span data-stu-id="b55de-104">A cryptographic hash function has the property that it is computationally infeasible to find two distinct inputs that hash to the same value.</span></span> <span data-ttu-id="b55de-105">Funções de hash são usadas com assinaturas digitais e integridade dos dados.</span><span class="sxs-lookup"><span data-stu-id="b55de-105">Hash functions are commonly used with digital signatures and for data integrity.</span></span>  
  
 <span data-ttu-id="b55de-106">O hash é usado como um valor exclusivo de tamanho fixo que representa uma grande quantidade de dados.</span><span class="sxs-lookup"><span data-stu-id="b55de-106">The hash is used as a unique value of fixed size representing a large amount of data.</span></span> <span data-ttu-id="b55de-107">Hashes de dois conjuntos de dados devem corresponder ao se os dados correspondentes também correspondem.</span><span class="sxs-lookup"><span data-stu-id="b55de-107">Hashes of two sets of data should match if the corresponding data also matches.</span></span> <span data-ttu-id="b55de-108">Pequenas alterações aos dados resultar em grandes mudanças repentinas no hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-108">Small changes to the data result in large unpredictable changes in the hash.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b55de-109">O seguinte código de exemplo computa o <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> hash para uma matriz.</span><span class="sxs-lookup"><span data-stu-id="b55de-109">The following code example computes the <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> hash for an array.</span></span> <span data-ttu-id="b55de-110">Este exemplo assume que há uma matriz de bytes predefinido `dataArray[]`.</span><span class="sxs-lookup"><span data-stu-id="b55de-110">This example assumes that there is a predefined byte array `dataArray[]`.</span></span> <span data-ttu-id="b55de-111"><xref:System.Security.Cryptography.SHA1CryptoServiceProvider> é uma classe derivada de <xref:System.Security.Cryptography.HashAlgorithm>.</span><span class="sxs-lookup"><span data-stu-id="b55de-111"><xref:System.Security.Cryptography.SHA1CryptoServiceProvider> is a derived class of <xref:System.Security.Cryptography.HashAlgorithm>.</span></span>  
  
 [!code-cpp[Classic HashAlgorithm Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic HashAlgorithm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HashAlgorithm Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic HashAlgorithm Example/CS/source.cs#1)]
 [!code-vb[Classic HashAlgorithm Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic HashAlgorithm Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="b55de-112">Quando você herda de <see cref="T:System.Security.Cryptography.HashAlgorithm" /> classe, você deve substituir os seguintes membros: <see cref="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.Security.Cryptography.HashAlgorithm.HashFinal" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="b55de-112">When you inherit from the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class, you must override the following members:  <see cref="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.Security.Cryptography.HashAlgorithm.HashFinal" />.</span>
        </span>
      </para>
    </block>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">
      <span data-ttu-id="b55de-113">Serviços criptográficos</span>
      <span class="sxs-lookup">
        <span data-stu-id="b55de-113">Cryptographic Services</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashAlgorithm ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashAlgorithm();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-114">Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-114">Initializes a new instance of the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-115">Você não pode criar uma instância de uma classe abstrata.</span><span class="sxs-lookup"><span data-stu-id="b55de-115">You cannot create an instance of an abstract class.</span></span> <span data-ttu-id="b55de-116">O código do aplicativo cria uma nova instância de uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="b55de-116">Application code creates a new instance of a derived class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReuseTransform">
      <MemberSignature Language="C#" Value="public virtual bool CanReuseTransform { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReuseTransform" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.CanReuseTransform" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReuseTransform As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReuseTransform { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReuseTransform : bool" Usage="System.Security.Cryptography.HashAlgorithm.CanReuseTransform" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.CanReuseTransform</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-117">Obtém um valor que indica se a transformação atual pode ser reutilizada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-117">Gets a value indicating whether the current transform can be reused.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b55de-118">Sempre <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-118">Always <see langword="true" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTransformMultipleBlocks">
      <MemberSignature Language="C#" Value="public virtual bool CanTransformMultipleBlocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTransformMultipleBlocks" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTransformMultipleBlocks As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTransformMultipleBlocks { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTransformMultipleBlocks : bool" Usage="System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.CanTransformMultipleBlocks</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-119">Quando substituído em uma classe derivada, obtém um valor que indica se vários blocos podem ser transformados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-119">When overridden in a derived class, gets a value indicating whether multiple blocks can be transformed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b55de-120">
            <see langword="true" /> Se vários blocos podem ser transformados; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-120">
              <see langword="true" /> if multiple blocks can be transformed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="hashAlgorithm.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-121">Libera todos os recursos usados pela classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-121">Releases all resources used by the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-122">Esse método é uma chamada simples para o <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b55de-122">This method is a simple call to the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b55de-123">Chamando `Dispose` permite que os recursos usados pelo <xref:System.Security.Cryptography.HashAlgorithm> classe a ser realocados para outras finalidades.</span><span class="sxs-lookup"><span data-stu-id="b55de-123">Calling `Dispose` allows the resources used by the <xref:System.Security.Cryptography.HashAlgorithm> class to be reallocated for other purposes.</span></span> <span data-ttu-id="b55de-124">Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="b55de-124">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ComputeHash">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-125">Calcula o valor de hash para os dados de entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-125">Computes the hash value for the input data.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ComputeHash">
      <MemberSignature Language="C#" Value="public byte[] ComputeHash (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ComputeHash(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ComputeHash (buffer As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ComputeHash(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.ComputeHash : byte[] -&gt; byte[]" Usage="hashAlgorithm.ComputeHash buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="b55de-126">A entrada para a qual calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-126">The input to compute the hash code for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-127">Calcula o valor do hash da matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-127">Computes the hash value for the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-128">O código hash calculado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-128">The computed hash code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b55de-129">O exemplo a seguir calcula o <xref:System.Security.Cryptography.SHA256> o valor de uma cadeia de caracteres de hash e retorna o hash como uma cadeia de caracteres de 64 caracteres, em formato hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="b55de-129">The following example computes the <xref:System.Security.Cryptography.SHA256> hash value of a string and returns the hash as a 64-character, hexadecimal-formatted string.</span></span>  <span data-ttu-id="b55de-130">A cadeia de caracteres de hash criada por este exemplo de código é compatível com qualquer função de hash SHA256 (em qualquer plataforma) que cria uma cadeia de caracteres de hash de 64 caracteres, em formato hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="b55de-130">The hash string created by this code example is compatible with any SHA256 hash function (on any platform) that creates a 64-character, hexadecimal-formatted hash string.</span></span>  
  
 [!code-csharp[HashAlgorithm.ComputeHash-1](~/samples/snippets/csharp/api/system.security.cryptography/hashalgorithm/example1.cs)]
 [!code-vb[HashAlgorithm.ComputeHash-1](~/samples/snippets/visualbasic/api/system.security.cryptography/hashalgorithm/example1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b55de-131">
            <paramref name="buffer" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-131">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b55de-132">O objeto já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-132">The object has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ComputeHash">
      <MemberSignature Language="C#" Value="public byte[] ComputeHash (System.IO.Stream inputStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ComputeHash(class System.IO.Stream inputStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function ComputeHash (inputStream As Stream) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ComputeHash(System::IO::Stream ^ inputStream);" />
      <MemberSignature Language="F#" Value="member this.ComputeHash : System.IO.Stream -&gt; byte[]" Usage="hashAlgorithm.ComputeHash inputStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inputStream">
          <span data-ttu-id="b55de-133">A entrada para a qual calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-133">The input to compute the hash code for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-134">Calcula o valor do hash do objeto <see cref="T:System.IO.Stream" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-134">Computes the hash value for the specified <see cref="T:System.IO.Stream" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-135">O código hash calculado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-135">The computed hash code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  

<span data-ttu-id="b55de-136">O exemplo a seguir calcula o <xref:System.Security.Cryptography.SHA256> hash para todos os arquivos em um diretório.</span><span class="sxs-lookup"><span data-stu-id="b55de-136">The following example calculates the <xref:System.Security.Cryptography.SHA256> hash for all files in a directory.</span></span>  
  
[!code-csharp[HashAlgorithm.ComputeHash Example](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic SHA256 Example/CS/source.cs#1)]
[!code-vb[HashAlgorithm.ComputeHash Example](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic SHA256 Example/VB/source.vb#1)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b55de-137">O objeto já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-137">The object has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ComputeHash">
      <MemberSignature Language="C#" Value="public byte[] ComputeHash (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ComputeHash(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ComputeHash (buffer As Byte(), offset As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ComputeHash(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ComputeHash : byte[] * int * int -&gt; byte[]" Usage="hashAlgorithm.ComputeHash (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="b55de-138">A entrada para a qual calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-138">The input to compute the hash code for.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="b55de-139">O deslocamento para a matriz de bytes com base na qual os dados começarão a ser usados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-139">The offset into the byte array from which to begin using data.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="b55de-140">O número de bytes na matriz a ser usado como dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-140">The number of bytes in the array to use as data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-141">Calcula o valor de hash para a região especificada da matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-141">Computes the hash value for the specified region of the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-142">O código hash calculado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-142">The computed hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b55de-143">
            <paramref name="count" /> é um valor inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-143">
              <paramref name="count" /> is an invalid value.</span>
          </span>
          <span data-ttu-id="b55de-144">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-144">-or-</span>
          </span>
          <span data-ttu-id="b55de-145">O comprimento <paramref name="buffer" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-145">
              <paramref name="buffer" /> length is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b55de-146">
            <paramref name="buffer" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-146">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b55de-147">
            <paramref name="offset" /> está fora do intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-147">
              <paramref name="offset" /> is out of range.</span>
          </span>
          <span data-ttu-id="b55de-148">Esse parâmetro requer um número não negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-148">This parameter requires a non-negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b55de-149">O objeto já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-149">The object has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-150">Cria uma instância de uma implementação especificada de um algoritmo de hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-150">Creates an instance of an implementation of a hash algorithm.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.HashAlgorithm Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.HashAlgorithm Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::HashAlgorithm ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.HashAlgorithm" Usage="System.Security.Cryptography.HashAlgorithm.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-151">Cria uma instância da implementação padrão de um algoritmo de hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-151">Creates an instance of the default implementation of a hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-152">Uma nova instância de <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />, a menos que as configurações padrão tenham sido alteradas usando o.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-152">A new <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /> instance, unless the default settings have been changed using the .</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-153">Por padrão, essa sobrecarga usa o <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> implementação de um algoritmo de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-153">By default, this overload uses the <xref:System.Security.Cryptography.SHA1CryptoServiceProvider> implementation of a hash algorithm.</span></span> <span data-ttu-id="b55de-154">Se você quiser especificar uma implementação diferente, use o <xref:System.Security.Cryptography.HashAlgorithm.Create%28System.String%29> sobrecarregar, que permite que você especifique um nome de algoritmo, em vez disso.</span><span class="sxs-lookup"><span data-stu-id="b55de-154">If you want to specify a different implementation, use the <xref:System.Security.Cryptography.HashAlgorithm.Create%28System.String%29> overload, which lets you specify an algorithm name, instead.</span></span> <span data-ttu-id="b55de-155">O sistema de configuração de criptografia define a implementação padrão de <xref:System.Security.Cryptography.HashAlgorithm>.</span><span class="sxs-lookup"><span data-stu-id="b55de-155">The cryptography configuration system defines the default implementation of <xref:System.Security.Cryptography.HashAlgorithm>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.HashAlgorithm Create (string hashName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.HashAlgorithm Create(string hashName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (hashName As String) As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::HashAlgorithm ^ Create(System::String ^ hashName);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.HashAlgorithm" Usage="System.Security.Cryptography.HashAlgorithm.Create hashName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hashName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hashName">
          <span data-ttu-id="b55de-156">A implementação do algoritmo de hash a ser usada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-156">The hash algorithm implementation to use.</span>
          </span>
          <span data-ttu-id="b55de-157">A tabela a seguir mostra os valores válidos para o parâmetro <paramref name="hashName" /> e os algoritmos para os quais são mapeados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-157">The following table shows the valid values for the <paramref name="hashName" /> parameter and the algorithms they map to.</span>
          </span>
          <list type="table">
            <listheader>
              <term>
                <span data-ttu-id="b55de-158">Valor do parâmetro</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-158">Parameter value</span>
                </span>
              </term>
              <description>
                <span data-ttu-id="b55de-159">Implements</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-159">Implements</span>
                </span>
              </description>
            </listheader>
            <item>
              <term>
                <span data-ttu-id="b55de-160">SHA</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-160">SHA</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-161">SHA1</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-161">SHA1</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-162">System.Security.Cryptography.SHA1</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-162">System.Security.Cryptography.SHA1</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-163">System.Security.Cryptography.HashAlgorithm</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-163">System.Security.Cryptography.HashAlgorithm</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-164">MD5</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-164">MD5</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-165">System.Security.Cryptography.MD5</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-165">System.Security.Cryptography.MD5</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-166">SHA256</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-166">SHA256</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA256Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-167">SHA-256</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-167">SHA-256</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA256Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-168">System.Security.Cryptography.SHA256</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-168">System.Security.Cryptography.SHA256</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA256Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-169">SHA384</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-169">SHA384</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA384Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-170">SHA-384</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-170">SHA-384</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA384Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-171">System.Security.Cryptography.SHA384</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-171">System.Security.Cryptography.SHA384</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA384Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-172">SHA512</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-172">SHA512</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA512Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-173">SHA-512</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-173">SHA-512</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA512Managed" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="b55de-174">System.Security.Cryptography.SHA512</span>
                <span class="sxs-lookup">
                  <span data-stu-id="b55de-174">System.Security.Cryptography.SHA512</span>
                </span>
              </term>
              <description>
                <see cref="T:System.Security.Cryptography.SHA512Managed" />
              </description>
            </item>
          </list>
        </param>
        <summary>
          <span data-ttu-id="b55de-175">Cria uma instância da implementação especificada de um algoritmo de hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-175">Creates an instance of the specified implementation of a hash algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-176">Uma nova instância do algoritmo de hash especificado ou <see langword="null" /> se <paramref name="hashName" /> não for um algoritmo de hash válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-176">A new instance of the specified hash algorithm, or <see langword="null" /> if <paramref name="hashName" /> is not a valid hash algorithm.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-177">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-177">Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="hashAlgorithm.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-178">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-178">Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-179">Chame `Dispose` quando tiver terminado de usar o <xref:System.Security.Cryptography.HashAlgorithm>.</span><span class="sxs-lookup"><span data-stu-id="b55de-179">Call `Dispose` when you are finished using the <xref:System.Security.Cryptography.HashAlgorithm>.</span></span> <span data-ttu-id="b55de-180">O `Dispose` método deixa o <xref:System.Security.Cryptography.HashAlgorithm> em um estado inutilizável.</span><span class="sxs-lookup"><span data-stu-id="b55de-180">The `Dispose` method leaves the <xref:System.Security.Cryptography.HashAlgorithm> in an unusable state.</span></span> <span data-ttu-id="b55de-181">Depois de chamar `Dispose`, você deve liberar todas as referências para o <xref:System.Security.Cryptography.HashAlgorithm> para que o coletor de lixo possa recuperar a memória que o <xref:System.Security.Cryptography.HashAlgorithm> estava ocupando.</span><span class="sxs-lookup"><span data-stu-id="b55de-181">After calling `Dispose`, you must release all references to the <xref:System.Security.Cryptography.HashAlgorithm> so the garbage collector can reclaim the memory that the <xref:System.Security.Cryptography.HashAlgorithm> was occupying.</span></span>  
  
 <span data-ttu-id="b55de-182">Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="b55de-182">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b55de-183">Sempre chamar `Dispose` antes de liberar sua última referência para o <xref:System.Security.Cryptography.HashAlgorithm>.</span><span class="sxs-lookup"><span data-stu-id="b55de-183">Always call `Dispose` before you release your last reference to the <xref:System.Security.Cryptography.HashAlgorithm>.</span></span> <span data-ttu-id="b55de-184">Caso contrário, os recursos que ele está usando não serão liberados até que o coletor de lixo chame o <xref:System.Security.Cryptography.HashAlgorithm> do objeto `Finalize` método.</span><span class="sxs-lookup"><span data-stu-id="b55de-184">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Security.Cryptography.HashAlgorithm> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="hashAlgorithm.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="b55de-185">
            <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-185">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-186">Libera os recursos não gerenciados usados pelo <see cref="T:System.Security.Cryptography.HashAlgorithm" /> e opcionalmente libera os recursos gerenciados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-186">Releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-187">Este método é chamado pelo método público `Dispose()` e pelo método `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="b55de-187">This method is called by the public `Dispose()` method and the `Finalize` method.</span></span> <span data-ttu-id="b55de-188">`Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="b55de-188">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="b55de-189">`Finalize` invoca `Dispose` com `disposing` definido como `false`.</span><span class="sxs-lookup"><span data-stu-id="b55de-189">`Finalize` invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="b55de-190">Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Security.Cryptography.HashAlgorithm> referências.</span><span class="sxs-lookup"><span data-stu-id="b55de-190">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Security.Cryptography.HashAlgorithm> references.</span></span> <span data-ttu-id="b55de-191">Este método invoca o método `Dispose()` de cada objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="b55de-191">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="b55de-192">
              <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="b55de-192">
                <see langword="Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="b55de-193">Ao substituir <see langword="Dispose(Boolean)" />, tenha cuidado para referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para não <see langword="Dispose" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="b55de-193">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" />.</span>
            </span>
            <span data-ttu-id="b55de-194">Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="b55de-194">For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="b55de-195">Para obter mais informações sobre <see langword="Dispose" /> e <see langword="Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="b55de-195">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Hash">
      <MemberSignature Language="C#" Value="public virtual byte[] Hash { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Hash" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.Hash" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Hash As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ Hash { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hash : byte[]" Usage="System.Security.Cryptography.HashAlgorithm.Hash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-196">Obtém o valor do código hash computado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-196">Gets the value of the computed hash code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b55de-197">Obtém o valor atual do código hash computado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-197">The current value of the computed hash code.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-198">O <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> propriedade é uma matriz de bytes; o <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A> propriedade é um valor que representam o bits.</span><span class="sxs-lookup"><span data-stu-id="b55de-198">The <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> property is a byte array; the <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A> property is a value that represent bits.</span></span> <span data-ttu-id="b55de-199">Portanto, o número de elementos na <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> é um oitavo o tamanho de <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A>.</span><span class="sxs-lookup"><span data-stu-id="b55de-199">Therefore, the number of elements in <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> is one-eighth the size of <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">
          <span data-ttu-id="b55de-200">
            <see cref="F:System.Security.Cryptography.HashAlgorithm.HashValue" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-200">
              <see cref="F:System.Security.Cryptography.HashAlgorithm.HashValue" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b55de-201">O objeto já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-201">The object has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="HashCore">
      <MemberSignature Language="C#" Value="protected virtual void HashCore (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void HashCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub HashCore (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void HashCore(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="abstract member HashCore : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.HashCore : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="hashAlgorithm.HashCore source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashCore">
      <MemberSignature Language="C#" Value="protected abstract void HashCore (byte[] array, int ibStart, int cbSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void HashCore(unsigned int8[] array, int32 ibStart, int32 cbSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub HashCore (array As Byte(), ibStart As Integer, cbSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void HashCore(cli::array &lt;System::Byte&gt; ^ array, int ibStart, int cbSize);" />
      <MemberSignature Language="F#" Value="abstract member HashCore : byte[] * int * int -&gt; unit" Usage="hashAlgorithm.HashCore (array, ibStart, cbSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="ibStart" Type="System.Int32" />
        <Parameter Name="cbSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="b55de-202">A entrada para a qual calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-202">The input to compute the hash code for.</span>
          </span>
        </param>
        <param name="ibStart">
          <span data-ttu-id="b55de-203">O deslocamento para a matriz de bytes com base na qual os dados começarão a ser usados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-203">The offset into the byte array from which to begin using data.</span>
          </span>
        </param>
        <param name="cbSize">
          <span data-ttu-id="b55de-204">O número de bytes na matriz de bytes a ser usado como dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-204">The number of bytes in the byte array to use as data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-205">Quando substituído em uma classe derivada, roteia os dados gravados no objeto para o algoritmo de hash para computar o hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-205">When overridden in a derived class, routes data written to the object into the hash algorithm for computing the hash.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-206">Esse método não é chamado pelo código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="b55de-206">This method is not called by application code.</span></span>  
  
 <span data-ttu-id="b55de-207">Esse método abstract realiza o cálculo de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-207">This abstract method performs the hash computation.</span></span> <span data-ttu-id="b55de-208">Todas as gravações para o objeto de fluxo de criptografia passam os dados por meio desse método.</span><span class="sxs-lookup"><span data-stu-id="b55de-208">Every write to the cryptographic stream object passes the data through this method.</span></span> <span data-ttu-id="b55de-209">Para cada bloco de dados, esse método atualiza o estado do objeto de hash, portanto, um valor de hash correto é retornado no final do fluxo de dados.</span><span class="sxs-lookup"><span data-stu-id="b55de-209">For each block of data, this method updates the state of the hash object so a correct hash value is returned at the end of the data stream.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashFinal">
      <MemberSignature Language="C#" Value="protected abstract byte[] HashFinal ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] HashFinal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.HashFinal" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HashFinal () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::Byte&gt; ^ HashFinal();" />
      <MemberSignature Language="F#" Value="abstract member HashFinal : unit -&gt; byte[]" Usage="hashAlgorithm.HashFinal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-210">Quando substituído em uma classe derivada, finaliza o cálculo de hash depois que os últimos dados são processados pelo objeto de fluxo criptográfico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-210">When overridden in a derived class, finalizes the hash computation after the last data is processed by the cryptographic stream object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-211">O código hash calculado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-211">The computed hash code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-212">Esse método finaliza qualquer computação parcial e retorna o valor de hash correto para o fluxo de dados.</span><span class="sxs-lookup"><span data-stu-id="b55de-212">This method finalizes any partial computation and returns the correct hash value for the data stream.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashSize">
      <MemberSignature Language="C#" Value="public virtual int HashSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.HashSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HashSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HashSize : int" Usage="System.Security.Cryptography.HashAlgorithm.HashSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-213">Obtém o tamanho, em bits, do código hash computado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-213">Gets the size, in bits, of the computed hash code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b55de-214">O tamanho, em bits, o código hash computado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-214">The size, in bits, of the computed hash code.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashSizeValue">
      <MemberSignature Language="C#" Value="protected int HashSizeValue;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 HashSizeValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.HashAlgorithm.HashSizeValue" />
      <MemberSignature Language="VB.NET" Value="Protected HashSizeValue As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int HashSizeValue;" />
      <MemberSignature Language="F#" Value="val mutable HashSizeValue : int" Usage="System.Security.Cryptography.HashAlgorithm.HashSizeValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-215">Representa o tamanho, em bits, do código hash calculado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-215">Represents the size, in bits, of the computed hash code.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-216">O algoritmo de hash Especifica o tamanho do código hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-216">The hash algorithm specifies the size of the hash code.</span></span> <span data-ttu-id="b55de-217">Por exemplo, <xref:System.Security.Cryptography.SHA1> usa um tamanho de hash de 160 bits.</span><span class="sxs-lookup"><span data-stu-id="b55de-217">For example, <xref:System.Security.Cryptography.SHA1> uses a hash size of 160 bits.</span></span>  
  
 <span data-ttu-id="b55de-218">Este campo é acessado por meio de <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="b55de-218">This field is accessed through the <xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashValue">
      <MemberSignature Language="C#" Value="protected internal byte[] HashValue;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly unsigned int8[] HashValue" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.HashAlgorithm.HashValue" />
      <MemberSignature Language="VB.NET" Value="Protected Friend HashValue As Byte() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::Byte&gt; ^ HashValue;" />
      <MemberSignature Language="F#" Value="val mutable HashValue : byte[]" Usage="System.Security.Cryptography.HashAlgorithm.HashValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-219">Representa o valor do código hash computado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-219">Represents the value of the computed hash code.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-220">Este campo é acessado por meio de <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="b55de-220">This field is accessed through the <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public abstract void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Initialize();" />
      <MemberSignature Language="F#" Value="abstract member Initialize : unit -&gt; unit" Usage="hashAlgorithm.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-221">Inicializa uma implementação da classe <see cref="T:System.Security.Cryptography.HashAlgorithm" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-221">Initializes an implementation of the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBlockSize">
      <MemberSignature Language="C#" Value="public virtual int InputBlockSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InputBlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.InputBlockSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property InputBlockSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int InputBlockSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBlockSize : int" Usage="System.Security.Cryptography.HashAlgorithm.InputBlockSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.InputBlockSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-222">Quando substituído em uma classe derivada, obtém o tamanho do bloco de entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-222">When overridden in a derived class, gets the input block size.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b55de-223">O tamanho do bloco de entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-223">The input block size.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-224">A menos que substituída, essa propriedade retorna o valor 1.</span><span class="sxs-lookup"><span data-stu-id="b55de-224">Unless overridden, this property returns the value 1.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputBlockSize">
      <MemberSignature Language="C#" Value="public virtual int OutputBlockSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputBlockSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HashAlgorithm.OutputBlockSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OutputBlockSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int OutputBlockSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputBlockSize : int" Usage="System.Security.Cryptography.HashAlgorithm.OutputBlockSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.Cryptography.ICryptoTransform.OutputBlockSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-225">Quando substituído em uma classe derivada, obtém o tamanho do bloco de saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-225">When overridden in a derived class, gets the output block size.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b55de-226">O tamanho do bloco de saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-226">The output block size.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-227">A menos que substituída, essa propriedade retorna o valor 1.</span><span class="sxs-lookup"><span data-stu-id="b55de-227">Unless overridden, this property returns the value 1.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="State">
      <MemberSignature Language="C#" Value="protected int State;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 State" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.HashAlgorithm.State" />
      <MemberSignature Language="VB.NET" Value="Protected State As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int State;" />
      <MemberSignature Language="F#" Value="val mutable State : int" Usage="System.Security.Cryptography.HashAlgorithm.State" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b55de-228">Representa o estado do cálculo de hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-228">Represents the state of the hash computation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-229">Este campo é usado para impedir que usuários alterem a chave de um algoritmo de hash com chave durante uma operação de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-229">This field is used to prevent users from changing the key of a keyed hash algorithm during a hash operation.</span></span> <span data-ttu-id="b55de-230">Quando uma alteração de chave for legítima, o valor desse campo é zero antes e após uma operação de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-230">When a key change is legitimate, the value of this field is zero both before and after a hash operation.</span></span> <span data-ttu-id="b55de-231">Quando uma alteração de chave não for legítima, o valor desse campo é diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="b55de-231">When a key change is not legitimate, the value of this field is nonzero.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b55de-232">Libera os recursos não gerenciados usados pelo <see cref="T:System.Security.Cryptography.HashAlgorithm" /> e opcionalmente libera os recursos gerenciados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-232">Releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.HashAlgorithm" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="b55de-233">Esse método é chamado pelo método Dispose () público e o método Finalize.</span><span class="sxs-lookup"><span data-stu-id="b55de-233">This method is called by the public Dispose() method and the Finalize method.</span></span> <span data-ttu-id="b55de-234">Dispose () chama o método Dispose (Boolean) protegido com o parâmetro de descarte definido como true.</span><span class="sxs-lookup"><span data-stu-id="b55de-234">Dispose() invokes the protected Dispose(Boolean) method with the disposing parameter set to true.</span></span> <span data-ttu-id="b55de-235">Finalizar chama Dispose com disposing conjunto como false.</span><span class="sxs-lookup"><span data-stu-id="b55de-235">Finalize invokes Dispose with disposing set to false.</span></span>

<span data-ttu-id="b55de-236">Quando o parâmetro disposing for true, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Security.Cryptography.HashAlgorithm> referências.</span><span class="sxs-lookup"><span data-stu-id="b55de-236">When the disposing parameter is true, this method releases all resources held by any managed objects that this <xref:System.Security.Cryptography.HashAlgorithm> references.</span></span> <span data-ttu-id="b55de-237">Esse método chama o método Dispose () de cada objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="b55de-237">This method invokes the Dispose() method of each referenced object.</span></span>

<span data-ttu-id="b55de-238">**Observações para herdeiros:**</span><span class="sxs-lookup"><span data-stu-id="b55de-238">**Notes to Inheritors:**</span></span>

<span data-ttu-id="b55de-239">Dispose pode ser chamado várias vezes por outros objetos.</span><span class="sxs-lookup"><span data-stu-id="b55de-239">Dispose can be called multiple times by other objects.</span></span> <span data-ttu-id="b55de-240">Ao substituir Dispose (Boolean), tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para descarte.</span><span class="sxs-lookup"><span data-stu-id="b55de-240">When overriding Dispose(Boolean), be careful not to reference objects that have been previously disposed in an earlier call to Dispose.</span></span> <span data-ttu-id="b55de-241">Para obter mais informações sobre como implementar Dispose (Boolean), consulte [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="b55de-241">For more information about how to implement Dispose(Boolean), see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>

<span data-ttu-id="b55de-242">Para obter mais informações sobre Dispose e Finalize, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [substituindo o método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v%3dvs.100)).</span><span class="sxs-lookup"><span data-stu-id="b55de-242">For more information about Dispose and Finalize, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v%3dvs.100)).</span></span>

]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">
          <span data-ttu-id="b55de-243">Serviços criptográficos</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-243">Cryptographic Services</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TransformBlock">
      <MemberSignature Language="C#" Value="public int TransformBlock (byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 TransformBlock(unsigned int8[] inputBuffer, int32 inputOffset, int32 inputCount, unsigned int8[] outputBuffer, int32 outputOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformBlock (inputBuffer As Byte(), inputOffset As Integer, inputCount As Integer, outputBuffer As Byte(), outputOffset As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int TransformBlock(cli::array &lt;System::Byte&gt; ^ inputBuffer, int inputOffset, int inputCount, cli::array &lt;System::Byte&gt; ^ outputBuffer, int outputOffset);" />
      <MemberSignature Language="F#" Value="abstract member TransformBlock : byte[] * int * int * byte[] * int -&gt; int&#xA;override this.TransformBlock : byte[] * int * int * byte[] * int -&gt; int" Usage="hashAlgorithm.TransformBlock (inputBuffer, inputOffset, inputCount, outputBuffer, outputOffset)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Cryptography.ICryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputBuffer" Type="System.Byte[]" />
        <Parameter Name="inputOffset" Type="System.Int32" />
        <Parameter Name="inputCount" Type="System.Int32" />
        <Parameter Name="outputBuffer" Type="System.Byte[]" />
        <Parameter Name="outputOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inputBuffer">
          <span data-ttu-id="b55de-244">A entrada para a qual calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-244">The input to compute the hash code for.</span>
          </span>
        </param>
        <param name="inputOffset">
          <span data-ttu-id="b55de-245">O deslocamento na matriz de bytes de entrada do qual começar a usar os dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-245">The offset into the input byte array from which to begin using data.</span>
          </span>
        </param>
        <param name="inputCount">
          <span data-ttu-id="b55de-246">O número de bytes na matriz de bytes de entrada a ser usado como dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-246">The number of bytes in the input byte array to use as data.</span>
          </span>
        </param>
        <param name="outputBuffer">
          <span data-ttu-id="b55de-247">Uma cópia da parte da matriz de entrada usada para calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-247">A copy of the part of the input array used to compute the hash code.</span>
          </span>
        </param>
        <param name="outputOffset">
          <span data-ttu-id="b55de-248">O deslocamento na matriz de bytes de saída do qual começar a gravar os dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-248">The offset into the output byte array from which to begin writing data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-249">Calcula o valor de hash para a região especificada da matriz de bytes de entrada e copia a região especificada da matriz de bytes de entrada para a região especificada da matriz de bytes de saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-249">Computes the hash value for the specified region of the input byte array and copies the specified region of the input byte array to the specified region of the output byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-250">O número de bytes gravados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-250">The number of bytes written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-251">Você deve chamar o <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> método antes de chamar o <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> método.</span><span class="sxs-lookup"><span data-stu-id="b55de-251">You must call the <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> method before calling the <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> method.</span></span> <span data-ttu-id="b55de-252">Você deve chamar os dois métodos antes de recuperar o valor de hash final.</span><span class="sxs-lookup"><span data-stu-id="b55de-252">You must call both methods before you retrieve the final hash value.</span></span>  
  
 <span data-ttu-id="b55de-253">Para recuperar o valor de hash final após a chamada a <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> método, obter a matriz de bytes contida o <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="b55de-253">To retrieve the final hash value after calling the <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> method, get the byte array contained within the <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> property.</span></span>  
  
 <span data-ttu-id="b55de-254">Chamar o <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> método com matrizes de saída e entrada diferentes resulta em um <xref:System.IO.IOException>.</span><span class="sxs-lookup"><span data-stu-id="b55de-254">Calling the <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> method with different input and output arrays results in an <xref:System.IO.IOException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b55de-255">O código a seguir exemplos de uso de <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> método com o <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> método para uma cadeia de caracteres de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-255">The following code examples use the <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> method with the <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> method to hash a string.</span></span>  
  
 [!code-csharp[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/CS/sample.cs#1)]
 [!code-vb[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b55de-256">
            <paramref name="inputCount" /> usa um valor inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-256">
              <paramref name="inputCount" /> uses an invalid value.</span>
          </span>
          <span data-ttu-id="b55de-257">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-257">-or-</span>
          </span>
          <span data-ttu-id="b55de-258">
            <paramref name="inputBuffer" /> tem um tamanho inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-258">
              <paramref name="inputBuffer" /> has an invalid length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b55de-259">
            <paramref name="inputBuffer" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-259">
              <paramref name="inputBuffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b55de-260">
            <paramref name="inputOffset" /> está fora do intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-260">
              <paramref name="inputOffset" /> is out of range.</span>
          </span>
          <span data-ttu-id="b55de-261">Esse parâmetro requer um número não negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-261">This parameter requires a non-negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b55de-262">O objeto já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-262">The object has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TransformFinalBlock">
      <MemberSignature Language="C#" Value="public byte[] TransformFinalBlock (byte[] inputBuffer, int inputOffset, int inputCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] TransformFinalBlock(unsigned int8[] inputBuffer, int32 inputOffset, int32 inputCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformFinalBlock (inputBuffer As Byte(), inputOffset As Integer, inputCount As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ TransformFinalBlock(cli::array &lt;System::Byte&gt; ^ inputBuffer, int inputOffset, int inputCount);" />
      <MemberSignature Language="F#" Value="abstract member TransformFinalBlock : byte[] * int * int -&gt; byte[]&#xA;override this.TransformFinalBlock : byte[] * int * int -&gt; byte[]" Usage="hashAlgorithm.TransformFinalBlock (inputBuffer, inputOffset, inputCount)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.Cryptography.ICryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputBuffer" Type="System.Byte[]" />
        <Parameter Name="inputOffset" Type="System.Int32" />
        <Parameter Name="inputCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inputBuffer">
          <span data-ttu-id="b55de-263">A entrada para a qual calcular o código hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-263">The input to compute the hash code for.</span>
          </span>
        </param>
        <param name="inputOffset">
          <span data-ttu-id="b55de-264">O deslocamento para a matriz de bytes com base na qual os dados começarão a ser usados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-264">The offset into the byte array from which to begin using data.</span>
          </span>
        </param>
        <param name="inputCount">
          <span data-ttu-id="b55de-265">O número de bytes na matriz de bytes a ser usado como dados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-265">The number of bytes in the byte array to use as data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b55de-266">Calcula o valor de hash para a região especificada da matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-266">Computes the hash value for the specified region of the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b55de-267">Uma matriz que é uma cópia da parte da entrada que é transformada em hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-267">An array that is a copy of the part of the input that is hashed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b55de-268">Você deve chamar o <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> método depois de chamar o <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> método, mas antes de recuperar o valor de hash final.</span><span class="sxs-lookup"><span data-stu-id="b55de-268">You must call the <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> method after calling the <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> method but before you retrieve the final hash value.</span></span>  
  
 <span data-ttu-id="b55de-269">Observe que o valor de retorno desse método não é o valor de hash, mas apenas uma cópia da parte de hash dos dados de entrada.</span><span class="sxs-lookup"><span data-stu-id="b55de-269">Note that the return value of this method is not the hash value, but only a copy of the hashed part of the input data.</span></span>  <span data-ttu-id="b55de-270">Para recuperar o último valor com hash após a chamada a <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> obter a matriz de bytes contida em um método, o <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="b55de-270">To retrieve the final hashed value after calling the <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> method, get the byte array contained in the <xref:System.Security.Cryptography.HashAlgorithm.Hash%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b55de-271">O código a seguir exemplos de uso de <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> método com o <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> método para uma cadeia de caracteres de hash.</span><span class="sxs-lookup"><span data-stu-id="b55de-271">The following code examples use the <xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A> method with the <xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A> method to hash a string.</span></span>  
  
 [!code-csharp[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/CS/sample.cs#1)]
 [!code-vb[Cryptography.HashAlgorithm.TransformFinalBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.HashAlgorithm.TransformFinalBlock/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b55de-272">
            <paramref name="inputCount" /> usa um valor inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-272">
              <paramref name="inputCount" /> uses an invalid value.</span>
          </span>
          <span data-ttu-id="b55de-273">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-273">-or-</span>
          </span>
          <span data-ttu-id="b55de-274">
            <paramref name="inputBuffer" /> tem um tamanho inválido de deslocamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-274">
              <paramref name="inputBuffer" /> has an invalid offset length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b55de-275">
            <paramref name="inputBuffer" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-275">
              <paramref name="inputBuffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b55de-276">
            <paramref name="inputOffset" /> está fora do intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-276">
              <paramref name="inputOffset" /> is out of range.</span>
          </span>
          <span data-ttu-id="b55de-277">Esse parâmetro requer um número não negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-277">This parameter requires a non-negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b55de-278">O objeto já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b55de-278">The object has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryComputeHash">
      <MemberSignature Language="C#" Value="public bool TryComputeHash (ReadOnlySpan&lt;byte&gt; source, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryComputeHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TryComputeHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryComputeHash (source As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryComputeHash(ReadOnlySpan&lt;System::Byte&gt; source, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryComputeHash : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; *  -&gt; bool" Usage="hashAlgorithm.TryComputeHash (source, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryHashFinal">
      <MemberSignature Language="C#" Value="protected virtual bool TryHashFinal (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryHashFinal(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HashAlgorithm.TryHashFinal(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TryHashFinal (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TryHashFinal(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryHashFinal : Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryHashFinal : Span&lt;byte&gt; *  -&gt; bool" Usage="hashAlgorithm.TryHashFinal (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>