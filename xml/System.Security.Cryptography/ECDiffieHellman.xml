<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cef0e3eb8c4ba4ff1fa400100051babc104009b8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57933723" /></Metadata><TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDiffieHellman = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece uma classe base abstrata da qual as implementações do algoritmo ECDH (Diffie-Hellman de curva elíptica) podem ser derivadas. Essa classe fornece o conjunto básico de operações ao qual todas as implementações de ECDH devem dar suporte.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta classe serve como a classe base abstrata para implementações de ECDH.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado por classes que derivam de <xref:System.Security.Cryptography.ECDiffieHellman> classe. O <xref:System.Security.Cryptography.ECDiffieHellmanCng> classe é a única implementação que atualmente está incluída no [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Para obter informações sobre como criar uma nova implementação do algoritmo Diffie-Hellman de curva elíptica (ECDH), consulte o <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma nova instância de uma implementação do algoritmo ECDH (Diffie-Hellman de curva elíptica).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma nova instância da implementação padrão do algoritmo ECDH (Diffie-Hellman de curva elíptica).</summary>
        <returns>Uma nova instância da implementação padrão desta classe.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="curve">A curva a ser usada para gerar um novo par de chaves pública/privada.</param>
        <summary>Cria uma nova instância da implementação padrão do algoritmo Diffie-Hellman de Curva Elíptica (ECDH) com um novo par de chaves pública/privada gerado com a curva especificada.</summary>
        <returns>Uma nova instância da implementação padrão do algoritmo Diffie-Hellman de Curva Elíptica (ECDH).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 curva deve validar (ou seja, ele deve retornar true quando passados para o <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> método.  
  
 Não há suporte para curvas de característica 2 no Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" /> não é validado.</exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="parameters">O parâmetros para o algoritmo ECC (criptografia de curva elíptica).</param>
        <summary>Cria uma nova instância da implementação padrão do algoritmo Diffie-Hellman de Curva Elíptica (ECDH) com a chave descrita pelo objeto <see cref="T:System.Security.Cryptography.ECParameters" /> especificado.</summary>
        <returns>Uma nova instância da implementação padrão do algoritmo Diffie-Hellman de Curva Elíptica (ECDH).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters` deve validar (ou seja, ele deve retornar `true`) quando passados para o <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> método. Não há suporte para parâmetros de curvas implícitas.  
  
 Não há suporte para curvas de característica 2 no Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" /> não é validado.</exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create algorithm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm">O nome de uma implementação do algoritmo ECDH.</param>
        <summary>Cria uma nova instância da implementação especificada do algoritmo ECDH (Diffie-Hellman de Curva Elíptica).</summary>
        <returns>Uma nova instância da implementação especificada desta classe. Se o nome do algoritmo especificado não for mapeado para uma implementação ECDH, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você desenvolver sua própria implementação de um <xref:System.Security.Cryptography.ECDiffieHellman> objeto, você pode usar o <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> sobrecarga de método para criar um personalizado `algorithm` cadeia de caracteres que especifica sua implementação.  
  
 O `algorithm` parâmetro especifica o nome de uma implementação do algoritmo ECDH. Todas as seguintes cadeias de caracteres se referem à mesma implementação, o que é a única implementação compatível atualmente no [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:  
  
-   "ECDH"  
  
-   "ECDiffieHellman"  
  
-   "ECDiffieHellmanCng"  
  
-   "System.Security.Cryptography.ECDiffieHellmanCng"  
  
 Você também pode fornecer o nome de uma implementação ECDH personalizada para o `algorithm` parâmetro. Se você fizer isso, o <xref:System.Security.Cryptography.CryptoConfig> objeto usá-lo para determinar se um objeto ECDH pode ser criado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="algorithm" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deriva de bytes que podem ser usados como uma chave usando uma função de hash.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">A chave pública do outro participante.</param>
        <param name="hashAlgorithm">O algoritmo de hash a ser usado para derivar o material de chave.</param>
        <summary>Deriva bytes que podem ser usados como uma chave com uma função de hash, dada a chave pública e o nome do algoritmo de hash de terceiros.</summary>
        <returns>O material de chave da troca de chaves com a chave pública da outra parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga chama o <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> método passando `null` como o prefixo e acrescente os valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">A chave pública do outro participante.</param>
        <param name="hashAlgorithm">O algoritmo de hash a ser usado para derivar o material de chave.</param>
        <param name="secretPrepend">Um valor a ser precedido ao segredo derivado antes do hash.</param>
        <param name="secretAppend">Um valor a ser acrescentado ao segredo derivado antes do hash.</param>
        <summary>Quando implementado em uma classe derivada, deriva os bytes que podem ser usados como uma chave usando uma função de hash, dada a chave pública do outro participante, o nome do algoritmo de hash, um valor de prefixo e um valor de acréscimo.</summary>
        <returns>O material de chave da troca de chaves com a chave pública da outra parte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deriva de bytes que podem ser usados como uma chave usando um HMAC (Hash-based Message Authentication Code).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">A chave pública do outro participante.</param>
        <param name="hashAlgorithm">O algoritmo de hash a ser usado para derivar o material de chave.</param>
        <param name="hmacKey">A chave para o HMAC.</param>
        <summary>Deriva de bytes que podem ser usados como uma chave usando um HMAC (Hash-based Message Authentication Code).</summary>
        <returns>O material de chave da troca de chaves com a chave pública da outra parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga chama o <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> método passando `null` como o prefixo e acrescente os valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">A chave pública do outro participante.</param>
        <param name="hashAlgorithm">O algoritmo de hash a ser usado para derivar o material de chave.</param>
        <param name="hmacKey">A chave para o HMAC.</param>
        <param name="secretPrepend">Um valor a ser precedido ao segredo derivado antes do hash.</param>
        <param name="secretAppend">Um valor a ser acrescentado ao segredo derivado antes do hash.</param>
        <summary>Quando implementado em uma classe derivada, deriva bytes que podem ser usados como uma chave utilizando um HMAC (Hash-based Message Authentication Code).</summary>
        <returns>O material de chave da troca de chaves com a chave pública da outra parte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]&#xA;override this.DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">A chave pública do outro participante.</param>
        <summary>Deriva bytes que podem ser usados como uma chave, dada a chave pública de terceiros.</summary>
        <returns>O material de chave da troca de chaves com a chave pública da outra parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre as chaves públicas, consulte o <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyTls (otherPartyPublicKey, prfLabel, prfSeed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="prfLabel" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="prfSeed" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">A chave pública do outro participante.</param>
        <param name="prfLabel">O rótulo PRF codificado em ASCII.</param>
        <param name="prfSeed">A semente PRF de 64 bytes.</param>
        <summary>Quando implementado em uma classe derivada, deriva bytes que podem ser usados como uma chave utilizando um algoritmo de derivação de PRF (Função Pseudoaleatória) do protocolo TLS.</summary>
        <returns>O material de chave da troca de chaves com a chave pública da outra parte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportECPrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportECPrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportECPrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportECPrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportECPrivateKey : unit -&gt; byte[]&#xA;override this.ExportECPrivateKey : unit -&gt; byte[]" Usage="eCDiffieHellman.ExportECPrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><see langword="true" /> para incluir parâmetros particulares; caso contrário, <see langword="false" />.</param>
        <summary>Quando substituído em uma classe derivada, exporta as informações de chave pública ou chaves públicas e privadas usando o formulário de curva explícita de uma chave <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> de trabalho para uma estrutura <see cref="T:System.Security.Cryptography.ECParameters" /> para que ela possa ser passada para o método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
        <returns>Um objeto que representa o ponto na curva para essa chave, usando o formato de curva explícita.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><see langword="true" /> para incluir parâmetros particulares; caso contrário, <see langword="false" /> para incluir somente os parâmetros públicos.</param>
        <summary>Quando substituído em uma classe derivada, exporta as informações de chave pública ou chaves públicas e privadas de uma chave <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> de trabalho em uma estrutura <see cref="T:System.Security.Cryptography.ECParameters" />, por isso pode ser passado para o método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</summary>
        <returns>Um objeto que representa o ponto na curva para essa chave. Ele pode ser passado para o método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a curva tem um nome, o <xref:System.Security.Cryptography.ECParameters.Curve> propriedade contém parâmetros de curva nomeada; caso contrário, ele conterá parâmetros explícitos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDiffieHellman.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="xmlString">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDiffieHellman.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="curve">A curva usada para gerar um par de chaves pública/privada efêmero.</param>
        <summary>Quando substituído em uma classe derivada, gera um novo par de chaves pública/privada efêmero para a curva especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` deve validar (ou seja, ele deve retornar `true`) quando passados para o <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> método) e não deve ser implícito.  
  
 Não há suporte para curvas de característica 2 no Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" /> não é validado.</exception>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportECPrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportECPrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportECPrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportECPrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportECPrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="bytesRead">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDiffieHellman.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="parameters">Os parâmetros da curva a serem importados.</param>
        <summary>Quando substituído em uma classe derivada, importa os parâmetros especificados para um <see cref="T:System.Security.Cryptography.ECCurve" /> como uma chave efêmera para o objeto <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `parameters` deve validar (ou seja, ele deve retornar `true`) quando passados para o <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> método. Não há suporte para parâmetros de curvas implícitas.  
  
 Não há suporte para curvas de característica 2 no Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" /> não é validado.</exception>
        <exception cref="T:System.NotImplementedException">Uma classe derivada deve substituir esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do algoritmo de troca de chaves.</summary>
        <value>O nome do algoritmo de troca de chaves.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação do padrão (não substituído), essa propriedade retorna a cadeia de caracteres "ECDiffieHellman".  
  
 Essa propriedade é herdada do <xref:System.Security.Cryptography.AsymmetricAlgorithm> classe base.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.ECDiffieHellmanPublicKey" Usage="System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a chave pública que está sendo usada pela instância atual do ECDH (Diffie-Hellman de curva elíptica).</summary>
        <value>A parte pública do par de chaves ECDH que está sendo usado por este <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instância.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do algoritmo de assinatura.</summary>
        <value>Sempre <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é herdada do <xref:System.Security.Cryptography.AsymmetricAlgorithm> classe base.  
  
 O algoritmo Diffie-Hellman de curva elíptica (ECDH) é usado para derivação de chaves, geração de assinatura digital não. Portanto, essa propriedade retornará `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDiffieHellman.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportECPrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportECPrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportECPrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportECPrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportECPrivateKey : Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportECPrivateKey : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportECPrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>