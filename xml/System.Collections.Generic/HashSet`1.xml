<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="HashSet`1.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">037e736f-f76f-422a-bcb7-5d2d599f851d80a00da304c112bae9b8a9e88874531b93b7e753.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">80a00da304c112bae9b8a9e88874531b93b7e753</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6fc53860cd2661bb7bde6e4b2858fcda4ec4c889</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/10/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The type of elements in the hash set.</source>
          <target state="translated">O tipo dos elementos no conjunto de hash.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.HashSet`1">
          <source>Represents a set of values.</source>
          <target state="translated">Representa um conjunto de valores.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class provides high-performance set operations.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe fornece operações de conjunto de alto desempenho.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</source>
          <target state="translated">Um conjunto é uma coleção que não contém elementos duplicados, e cujos elementos estão em nenhuma ordem específica.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601&gt;</ph> interface starting with the <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>; in previous versions of the .NET Framework, the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class did not implement this interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> implementa o <ph id="ph2">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601&gt;</ph> interface começando com o <ph id="ph3">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>; nas versões anteriores do .NET Framework, o <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe não implementou esta interface.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> é o número de elementos que o objeto pode conter.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> aumenta automaticamente à medida que elementos são adicionados ao objeto.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> collections.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe baseia-se no modelo de conjuntos matemáticos e fornece operações de conjunto de alto desempenho semelhantes a acessar as chaves do <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> coleções.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>In simple terms, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class can be thought of as a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> collection without values.</source>
          <target state="translated">Em termos simples, o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe pode ser pensada como um <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> coleção sem valores.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection is not sorted and cannot contain duplicate elements.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção não está classificada e não pode conter elementos duplicados.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>If order or element duplication is more important than performance for your application, consider using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class together with the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> method.</source>
          <target state="translated">Se ordem ou elemento de duplicação é mais importante que o desempenho de seu aplicativo, considere o uso de <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> classe junto com o <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> provides many mathematical set operations, such as set addition (unions) and set subtraction.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> fornece muitos matemática conjunto de operações, como a adição de conjunto (uniões) e subtração do conjunto.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The following table lists the provided <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operations and their mathematical equivalents.</source>
          <target state="translated">A tabela a seguir lista fornecido <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operações e seus equivalentes matemáticos.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>HashSet(Of T) operation</source>
          <target state="translated">Operação HashSet (Of T)</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Mathematical equivalent</source>
          <target state="translated">Equivalente de matemática</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Union or set addition</source>
          <target state="translated">União ou conjunto de adição</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Intersection</source>
          <target state="translated">Interseção</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Set subtraction</source>
          <target state="translated">Conjunto de subtração</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Symmetric difference</source>
          <target state="translated">Diferença simétrica</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>In addition to the listed set operations, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</source>
          <target state="translated">Além de operações de conjunto listadas, a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe também fornece métodos para determinar conjuntos de igualdade, sobreposição de conjuntos, e se um conjunto é um subconjunto ou superconjunto de outro conjunto.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Para grandes <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits definindo o <ph id="ph2">`enabled`</ph> atributo do elemento de configuração para <ph id="ph3">`true`</ph> no ambiente de tempo de execução.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class implements the <ph id="ph3">&lt;xref:System.Collections.Generic.ISet%601&gt;</ph> interface.</source>
          <target state="translated">Começando com o <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, o <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe implementa o <ph id="ph3">&lt;xref:System.Collections.Generic.ISet%601&gt;</ph> interface.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>HashSet and LINQ Set Operations</source>
          <target state="translated">Operações de conjunto com HashSet e LINQ</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>LINQ provides access to the <ph id="ph1">`Distinct`</ph>, <ph id="ph2">`Union`</ph>, <ph id="ph3">`Intersect`</ph> and <ph id="ph4">`Except`</ph> set operations on any data source that implements the <ph id="ph5">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph6">&lt;xref:System.Linq.IQueryable&gt;</ph> interfaces.</source>
          <target state="translated">LINQ fornece acesso para o <ph id="ph1">`Distinct`</ph>, <ph id="ph2">`Union`</ph>, <ph id="ph3">`Intersect`</ph> e <ph id="ph4">`Except`</ph> definir operações em qualquer fonte de dados que implementa o <ph id="ph5">&lt;xref:System.Collections.IEnumerable&gt;</ph> ou <ph id="ph6">&lt;xref:System.Linq.IQueryable&gt;</ph> interfaces.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> provides a larger and more robust collection of set operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> Fornece um conjunto maior e mais robusto de operações de conjunto.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>For example, <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> provides comparisons such as <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A&gt;</ph>.</source>
          <target state="translated">Por exemplo, <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> fornece comparações como <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The primary difference between LINQ set operations and <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operations is that LINQ set operations always return a new <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection, whereas the <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> equivalent methods modify the current collection.</source>
          <target state="translated">As operações de conjunto a principal diferença entre LINQ e <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operações é que as operações de conjunto do LINQ sempre retornam um novo <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> coleção, enquanto o <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> métodos equivalentes modificam a coleção atual.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection or array will be sufficient.</source>
          <target state="translated">Normalmente, se você deve criar um novo conjunto ou se seu aplicativo precisa acessar apenas as operações de conjunto fornecidas, usando o LINQ definida operações em qualquer <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> coleção ou matriz será suficiente.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> class.</source>
          <target state="translated">No entanto, se seu aplicativo requer acesso a operações de conjunto adicionais, ou se não for desejável ou necessárias para criar uma nova coleção, use o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> operations and their equivalent LINQ set operations.</source>
          <target state="translated">A tabela a seguir mostra o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> as operações de conjunto de operações e seus equivalentes do LINQ.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>HashSet(Of T) operation</source>
          <target state="translated">Operação HashSet (Of T)</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>LINQ equivalent</source>
          <target state="translated">Equivalente a LINQ</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>Not provided.</source>
          <target state="translated">Não fornecido.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The following example demonstrates how to merge two disparate sets.</source>
          <target state="translated">O exemplo a seguir demonstra como mesclar dois conjuntos distintos.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>This example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects, and populates them with even and odd numbers, respectively.</source>
          <target state="translated">Este exemplo cria dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos e a preenche com números e ímpares, respectivamente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>A third <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is created from the set that contains the even numbers.</source>
          <target state="translated">Um terceiro <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto é criado a partir do conjunto que contém os números pares.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.HashSet`1">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method, which adds the odd number set to the third set.</source>
          <target state="translated">O exemplo, em seguida, chama o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> método, que adiciona o número ímpar definido para o terceiro conjunto.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.HashSet`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that is empty and uses the default equality comparer for the set type.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> que está vazia e usa o comparador de igualdade padrão para o tipo de conjunto.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> é o número de elementos que o objeto pode conter.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> aumenta automaticamente à medida que elementos são adicionados ao objeto.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>The following example demonstrates how to create and populate two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects.</source>
          <target state="translated">O exemplo a seguir demonstra como criar e popular dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection whose elements are copied to the new set.</source>
          <target state="translated">A coleção cujos elementos são copiados para o novo conjunto.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> que usa o comparador de igualdade padrão para o tipo de conjunto, contém os elementos copiados da coleção especificada e tem capacidade suficiente para acomodar o número de elementos copiados.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> é o número de elementos que o objeto pode conter.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> aumenta automaticamente à medida que elementos são adicionados ao objeto.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>If <ph id="ph1">`collection`</ph> contains duplicates, the set will contain one of each unique element.</source>
          <target state="translated">Se <ph id="ph1">`collection`</ph> contém duplicatas, o conjunto irá conter uma de cada elemento exclusivo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>No exception will be thrown.</source>
          <target state="translated">Nenhuma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, the size of the resulting set is not identical to the size of <ph id="ph1">`collection`</ph>.</source>
          <target state="translated">Portanto, o tamanho do conjunto resultante não é idêntico ao tamanho de <ph id="ph1">`collection`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`collection`</ph> parameter.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos de <ph id="ph3">`collection`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example shows how to create a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection from an existing set.</source>
          <target state="translated">O exemplo a seguir mostra como criar um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção de um conjunto existente.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, two sets are created with even and odd integers, respectively.</source>
          <target state="translated">Neste exemplo, dois conjuntos são criados com números inteiros e ímpares, respectivamente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>A third <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is then created from the even integer set.</source>
          <target state="translated">Um terceiro <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto é criado do conjunto de inteiro mesmo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing values in the set, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> implementation for the set type.</source>
          <target state="translated">A implementação do <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> a ser usada ao comparar valores no conjunto ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> para usar implementação padrão do <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> para o tipo de conjunto.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that is empty and uses the specified equality comparer for the set type.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> que está vazia e usa a comparação de igualdade especificada para o tipo de conjunto.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> é o número de elementos que o objeto pode conter.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> aumenta automaticamente à medida que elementos são adicionados ao objeto.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este construtor é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)">
          <source>The initial size of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph></source>
          <target state="translated">O tamanho inicial de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that is empty, but has reserved space for <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> items and uses the default equality comparer for the set type.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> que está vazia, mas tem espaço reservado para <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> itens e usa o comparador de igualdade padrão para o tipo de conjunto.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)">
          <source>Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the <ph id="ph1">`capacity`</ph>.</source>
          <target state="translated">Como redimensiona é relativamente cara (exigem refazendo o hash), isso tenta minimizar a necessidade de redimensionar, definindo a capacidade inicial com base no valor da <ph id="ph1">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The collection whose elements are copied to the new set.</source>
          <target state="translated">A coleção cujos elementos são copiados para o novo conjunto.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing values in the set, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> implementation for the set type.</source>
          <target state="translated">A implementação do <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> a ser usada ao comparar valores no conjunto ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> para usar implementação padrão do <ph id="ph3">&lt;see cref="T:System.Collections.Generic.EqualityComparer`1" /&gt;</ph> para o tipo de conjunto.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> que usa o comparador de igualdado especificado para o tipo de conjunto, que contém os elementos copiados da coleção especificada e que tem capacidade suficiente para acomodar o número de elementos copiados.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> é o número de elementos que o objeto pode conter.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> aumenta automaticamente à medida que elementos são adicionados ao objeto.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>If <ph id="ph1">`collection`</ph> contains duplicates, the set will contain one of each unique element.</source>
          <target state="translated">Se <ph id="ph1">`collection`</ph> contém duplicatas, o conjunto irá conter uma de cada elemento exclusivo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>No exception will be thrown.</source>
          <target state="translated">Nenhuma exceção será gerada.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>Therefore, the size of the resulting set is not identical to the size of <ph id="ph1">`collection`</ph>.</source>
          <target state="translated">Portanto, o tamanho do conjunto resultante não é idêntico ao tamanho de <ph id="ph1">`collection`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>This constructor is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`collection`</ph> parameter.</source>
          <target state="translated">Este construtor é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos de <ph id="ph3">`collection`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source>The following example uses a supplied <ph id="ph1">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> to allow case-insensitive comparisons on the elements of a  <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection of vehicle types.</source>
          <target state="translated">O exemplo a seguir usa uma fornecido <ph id="ph1">&lt;xref:System.Collections.Generic.IEqualityComparer%601&gt;</ph> para permitir que as comparações de maiusculas e minúsculas nos elementos de uma <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção de tipos de veículo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>The initial size of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph></source>
          <target state="translated">O tamanho inicial de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> implementation for the set type.</source>
          <target state="translated">A implementação <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> a ser usada ao comparar valores no conjunto ou nulo (Nothing no Visual Basic) para usar a implementação padrão <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> no tipo de conjunto.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> elements.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> que usa o comparador de igualdade especificado para o tipo de conjunto e tem capacidade suficiente para acomodar elementos <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
          <source>Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the <ph id="ph1">`capacity`</ph>.</source>
          <target state="translated">Como redimensiona é relativamente cara (exigem refazendo o hash), isso tenta minimizar a necessidade de redimensionar, definindo a capacidade inicial com base no valor da <ph id="ph1">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object that contains the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> que contém as informações necessárias para serializar o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> structure that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Uma estrutura <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> que contém a origem e o destino do fluxo serializado associado ao objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> class with serialized data.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> com dados serializados.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</source>
          <target state="translated">Este construtor é chamado durante a desserialização para reconstituir a um objeto que é transmitido em um fluxo.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>XML e serialização SOAP<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>The element to add to the set.</source>
          <target state="translated">O elemento a ser adicionado ao conjunto.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>Adds the specified element to a set.</source>
          <target state="translated">Adiciona o elemento especificado a um conjunto.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is added to the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the element is already present.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento for adicionado ao objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>, <ph id="ph3">&lt;see langword="false" /&gt;</ph> se o elemento já estiver presente.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> already equals the capacity of the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, the capacity is automatically adjusted to accommodate the new item.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> já for igual à capacidade do <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> do objeto, a capacidade é automaticamente ajustada para acomodar o novo item.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is less than the capacity of the internal array, this method is an O(1) operation.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> é menor que a capacidade da matriz interna, esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object must be resized, this method becomes an O(<ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto deve ser redimensionado, esse método se torna um O (<ph id="ph2">`n`</ph>) operação, onde <ph id="ph3">`n`</ph> é <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>The following example demonstrates how to create and populate two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects.</source>
          <target state="translated">O exemplo a seguir demonstra como criar e popular dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Add(`0)">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>Removes all elements from a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Remove todos os elementos de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is set to zero and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> é definido como zero e referências a outros objetos de elementos da coleção também são liberadas.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>The capacity remains unchanged until a call to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> is made.</source>
          <target state="translated">A capacidade permanece inalterada até que uma chamada para <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> é feita.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Clear">
          <source>The following example creates and populates a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection, then clears it and releases the memory referenced by the collection.</source>
          <target state="translated">O exemplo a seguir cria e preenche um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção, em seguida, limpar e libera a memória referenciada pela coleção.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.HashSet`1.Comparer">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> object that is used to determine equality for the values in the set.</source>
          <target state="translated">Obtém o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> que é usado para determinar igualdade para os valores no conjunto.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Comparer">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> object that is used to determine equality for the values in the set.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEqualityComparer`1" /&gt;</ph> que é usado para determinar igualdade para os valores no conjunto.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Comparer">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>The element to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">O elemento a ser localizado no objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object contains the specified element.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> contém o elemento especificado.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object contains the specified element; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> contiver o elemento especificado; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>The following example demonstrates how to remove values from a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection using the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra como remover valores de um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção usando o <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Contains(`0)">
          <source>In this example, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Contains%2A&gt;</ph> method verifies that the set contains a value before removing it.</source>
          <target state="translated">Neste exemplo, o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Contains%2A&gt;</ph> método confirma que o conjunto contém um valor antes de removê-lo.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.HashSet`1">
          <source>Copies the elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> collection to an array.</source>
          <target state="translated">Copia os elementos de uma coleção <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> para uma matriz.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A matriz unidimensional que é o destino dos elementos copiados do objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">A matriz deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>Copies the elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to an array.</source>
          <target state="translated">Copia os elementos de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> para uma matriz.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A matriz unidimensional que é o destino dos elementos copiados do objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">A matriz deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>Copies the elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to an array, starting at the specified array index.</source>
          <target state="translated">Copia os elementos de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> para uma matriz, começando no índice da matriz especificada.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is greater than the length of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é maior que o tamanho da <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A matriz unidimensional que é o destino dos elementos copiados do objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The array must have zero-based indexing.</source>
          <target state="translated">A matriz deve ter indexação com base em zero.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">O índice baseado em zero na <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> na qual a cópia começa.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>The number of elements to copy to <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">O número de elementos a serem copiados para <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>Copies the specified number of elements of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to an array, starting at the specified array index.</source>
          <target state="translated">Copia o número especificado de elementos de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> para uma matriz, começando no índice especificado da matriz.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is greater than the length of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> é maior que o tamanho da <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the available space from the <ph id="ph2">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> é maior que o espaço disponível do <ph id="ph2">&lt;paramref name="index" /&gt;</ph> até o final da <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>Gets the number of elements that are contained in a set.</source>
          <target state="translated">Obtém o número de elementos contidos em um conjunto.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The number of elements that are contained in the set.</source>
          <target state="translated">O número de elementos contidos no conjunto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is the number of elements that the object can hold.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> é o número de elementos que o objeto pode conter.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's capacity automatically increases as elements are added to the object.</source>
          <target state="translated">A capacidade de um objeto <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> aumenta automaticamente à medida que elementos são adicionados ao objeto.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The capacity is always greater than or equal to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">A capacidade é sempre maior que ou igual a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> excede a capacidade durante a adição de elementos, a capacidade é definida como o primeiro número primo é maior do que o dobro da capacidade anterior.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>The following example demonstrates how to create, populate, and manipulate two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects.</source>
          <target state="translated">O exemplo a seguir demonstra como criar, preencher e manipular dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.Count">
          <source>In this example, both the contents of the set and <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> display to the console.</source>
          <target state="translated">Neste exemplo, o conteúdo do conjunto e <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> exibir no console.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that can be used for equality testing of a <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> que pode ser usado para teste de igualdade de um objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> object that can be used for deep equality testing of the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IEqualityComparer" /&gt;</ph> que pode ser usado para teste de igualdade profunda de um objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> objeto verifica a igualdade apenas em um nível; no entanto, você pode encadear comparadores em níveis adicionais para executar o teste de igualdade mais profunda.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.CreateSetComparer">
          <source>Calling this method is an O(1) operation.</source>
          <target state="translated">Chamar esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection of items to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção de itens a serem removidos do objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Removes all elements in the specified collection from the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Remove todos os elementos na coleção especificada do objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> method is the equivalent of mathematical set subtraction.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> método é o equivalente da subtração de conjunto de matemática.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`other`</ph> parameter.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos de <ph id="ph3">`other`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collections with overlapping sets of data.</source>
          <target state="translated">O exemplo a seguir cria dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleções com sobreposição de conjuntos de dados.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The lower range of values is then removed from the larger set using the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> method.</source>
          <target state="translated">O menor intervalo de valores, em seguida, é removido do conjunto de maior usando o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.ExceptWith%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Returns an enumerator that iterates through a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Retorna um enumerador que itera por meio de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /&gt;</ph> object for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /&gt;</ph> para o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of enumerators.</source>
          <target state="translated">A instrução <ph id="ph1">`foreach`</ph> da linguagem C# (<ph id="ph2">`for each`</ph> em C++, <ph id="ph3">`For Each`</ph> no Visual Basic) oculta a complexidade de enumeradores.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, usando <ph id="ph1">`foreach`</ph> é recomendado em vez de manipulação direta do enumerador.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">Nesta posição, o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> propriedade está definida.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar o método <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> is called.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> propriedade retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator object instead.</source>
          <target state="translated">Não é possível definir <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> para o primeiro elemento da coleção novamente, você deve criar um novo objeto de enumerador em vez disso.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> ou <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A&gt;</ph> lança um <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>If the collection is modified between calling <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> method and obtaining the value of the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> property, <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> returns the element that it is set to, even if the enumerator is already invalidated.</source>
          <target state="translated">Se a coleção é modificada entre chamada <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A&gt;</ph> método e obter o valor da <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> propriedade <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A&gt;</ph> retorna o elemento que está definido como, mesmo se o enumerador já é invalidado.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">As implementações padrão de coleções no namespace <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> não são sincronizadas.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object that contains the information required to serialize the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> que contém as informações necessárias para serializar o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> structure that contains the source and destination of the serialized stream associated with the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Uma estrutura <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph> que contém a origem e o destino do fluxo serializado associado ao objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and returns the data needed to serialize a <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Implementa a interface <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> e retorna os dados necessários para serializar um objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Calling this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Chamar esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source><ph id="ph1">&lt;paramref name="info" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="info" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>for providing serialization services.</source>
          <target state="translated">para fornecer serviços de serialização.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Ação de segurança: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph></source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Modifies the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to contain only elements that are present in that object and in the specified collection.</source>
          <target state="translated">Modifica o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual para que ele contenha somente elementos presentes no objeto e na coleção especificada.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by the <ph id="ph1">`other`</ph> parameter is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Se a coleção é representado pelo <ph id="ph1">`other`</ph> parâmetro é um <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção com o comparador de igualdade mesmo do atual <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> do objeto, esse método é um O (<ph id="ph4">`n`</ph>) operação.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> and <ph id="ph6">`m`</ph> is the number of elements in <ph id="ph7">`other`</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> e <ph id="ph6">`m`</ph> é o número de elementos em <ph id="ph7">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper subset of the specified collection.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> é um subconjunto apropriado da coleção especificada.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper subset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> for um subconjunto apropriado de <ph id="ph3">&lt;paramref name="other" /&gt;</ph>, caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>An empty set is a proper subset of any other collection.</source>
          <target state="translated">Um conjunto vazio é um subconjunto apropriado de qualquer outra coleção.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the current <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is empty unless the <ph id="ph3">`other`</ph> parameter is also an empty set.</source>
          <target state="translated">Portanto, esse método retorna <ph id="ph1">`true`</ph> se a coleção é representado por atual <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto estiver vazio, a menos que o <ph id="ph3">`other`</ph> parâmetro também é um conjunto vazio.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is greater than or equal to the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">Esse método sempre retornará <ph id="ph1">`false`</ph> se <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> é maior que ou igual ao número de elementos em <ph id="ph3">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, then this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Se a coleção é representado por <ph id="ph1">`other`</ph> é um <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção com o comparador de igualdade mesmo do atual <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> do objeto, em seguida, esse método é um O (<ph id="ph4">`n`</ph>) operação.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> and <ph id="ph6">`m`</ph> is the number of elements in <ph id="ph7">`other`</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> e <ph id="ph6">`m`</ph> é o número de elementos em <ph id="ph7">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">O exemplo a seguir cria dois objetos <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> separados e compara-os entre si.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`lowNumbers`</ph> is both a subset and a proper subset of <ph id="ph2">`allNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">Neste exemplo, <ph id="ph1">`lowNumbers`</ph> é um subconjunto e um subconjunto apropriado do <ph id="ph2">`allNumbers`</ph> até <ph id="ph3">`allNumbers`</ph> for modificada, usando o <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> método para conter somente os valores que estão presentes em ambos os conjuntos.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`lowNumbers`</ph> is still a subset of <ph id="ph4">`allNumbers`</ph> but is no longer a proper subset.</source>
          <target state="translated">Uma vez <ph id="ph1">`allNumbers`</ph> e <ph id="ph2">`lowNumbers`</ph> são idênticos, <ph id="ph3">`lowNumbers`</ph> ainda é um subconjunto de <ph id="ph4">`allNumbers`</ph> , mas não é mais um subconjunto apropriado.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper superset of the specified collection.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> é um superconjunto apropriado da coleção especificada.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a proper superset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> for um superconjunto apropriado de <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>An empty set is a proper superset of any other collection.</source>
          <target state="translated">Um conjunto vazio é um superconjunto apropriado de qualquer outra coleção.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the <ph id="ph2">`other`</ph> parameter is empty unless the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection is also empty.</source>
          <target state="translated">Portanto, esse método retorna <ph id="ph1">`true`</ph> se a coleção é representado pelo <ph id="ph2">`other`</ph> parâmetro estiver vazio, a menos que atual <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> também a coleção está vazia.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is less than or equal to the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">Esse método sempre retornará <ph id="ph1">`false`</ph> se <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> é menor ou igual ao número de elementos no <ph id="ph3">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Caso a coleção representada por <ph id="ph1">`other`</ph> seja uma coleção <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> com a mesma comparação de igualdade do objeto <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> atual, esse método é uma operação O(<ph id="ph4">`n`</ph>).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos em <ph id="ph5">`other`</ph> e <ph id="ph6">`m`</ph> é <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">O exemplo a seguir cria dois objetos <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> separados e compara-os entre si.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`allNumbers`</ph> is both a superset and a proper superset of <ph id="ph2">`lowNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">Neste exemplo, <ph id="ph1">`allNumbers`</ph> é um superconjunto e um superconjunto apropriado do <ph id="ph2">`lowNumbers`</ph> até que <ph id="ph3">`allNumbers`</ph> for modificada, usando o <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> método para conter somente os valores que estão presentes em ambos os conjuntos.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`allNumbers`</ph> is still a superset of <ph id="ph4">`lowNumbers`</ph> but is no longer a proper superset.</source>
          <target state="translated">Uma vez <ph id="ph1">`allNumbers`</ph> e <ph id="ph2">`lowNumbers`</ph> são idênticos, <ph id="ph3">`allNumbers`</ph> ainda é um superconjunto de <ph id="ph4">`lowNumbers`</ph> , mas não é um superconjunto apropriado.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a subset of the specified collection.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> é um subconjunto da coleção especificada.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a subset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> for um subconjunto de <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>An empty set is a subset of any other collection, including an empty set; therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the current <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is empty, even if the <ph id="ph3">`other`</ph> parameter is an empty set.</source>
          <target state="translated">Um conjunto vazio é um subconjunto de outra coleção, incluindo um conjunto vazio; Portanto, esse método retorna <ph id="ph1">`true`</ph> se a coleção é representado por atual <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto está vazio, mesmo se o <ph id="ph3">`other`</ph> parâmetro é um conjunto vazio.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is greater than the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">Esse método sempre retornará <ph id="ph1">`false`</ph> se <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> é maior que o número de elementos em <ph id="ph3">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Caso a coleção representada por <ph id="ph1">`other`</ph> seja uma coleção <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> com a mesma comparação de igualdade do objeto <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> atual, esse método é uma operação O(<ph id="ph4">`n`</ph>).</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> and <ph id="ph6">`m`</ph> is the number of elements in <ph id="ph7">`other`</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é <ph id="ph5">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> e <ph id="ph6">`m`</ph> é o número de elementos em <ph id="ph7">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">O exemplo a seguir cria dois objetos <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> separados e compara-os entre si.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`lowNumbers`</ph> is both a subset and a proper subset of <ph id="ph2">`allNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">Neste exemplo, <ph id="ph1">`lowNumbers`</ph> é um subconjunto e um subconjunto apropriado do <ph id="ph2">`allNumbers`</ph> até <ph id="ph3">`allNumbers`</ph> for modificada, usando o <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> método para conter somente os valores que estão presentes em ambos os conjuntos.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`lowNumbers`</ph> is still a subset of <ph id="ph4">`allNumbers`</ph> but is no longer a proper subset.</source>
          <target state="translated">Uma vez <ph id="ph1">`allNumbers`</ph> e <ph id="ph2">`lowNumbers`</ph> são idênticos, <ph id="ph3">`lowNumbers`</ph> ainda é um subconjunto de <ph id="ph4">`allNumbers`</ph> , mas não é mais um subconjunto apropriado.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a superset of the specified collection.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> é um superconjunto da coleção especificada.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is a superset of <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> for um superconjunto de <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>All collections, including the empty set, are supersets of the empty set.</source>
          <target state="translated">Todas as coleções, inclusive o conjunto vazio, são subconjuntos do conjunto vazio.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Therefore, this method returns <ph id="ph1">`true`</ph> if the collection represented by the <ph id="ph2">`other`</ph> parameter is empty, even if the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is empty.</source>
          <target state="translated">Portanto, esse método retorna <ph id="ph1">`true`</ph> se a coleção é representado pelo <ph id="ph2">`other`</ph> parâmetro estiver vazio, mesmo se atual <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto está vazio.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>This method always returns <ph id="ph1">`false`</ph> if <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> is less than the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">Esse método sempre retornará <ph id="ph1">`false`</ph> se <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph> é menor que o número de elementos em <ph id="ph3">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Caso a coleção representada por <ph id="ph1">`other`</ph> seja uma coleção <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> com a mesma comparação de igualdade do objeto <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> atual, esse método é uma operação O(<ph id="ph4">`n`</ph>).</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos em <ph id="ph5">`other`</ph> e <ph id="ph6">`m`</ph> é <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each other.</source>
          <target state="translated">O exemplo a seguir cria dois objetos <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> separados e compara-os entre si.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`allNumbers`</ph> is both a superset and a proper superset of <ph id="ph2">`lowNumbers`</ph> until <ph id="ph3">`allNumbers`</ph> is modified, using the <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> method, to contain only values that are present in both sets.</source>
          <target state="translated">Neste exemplo, <ph id="ph1">`allNumbers`</ph> é um superconjunto e um superconjunto apropriado do <ph id="ph2">`lowNumbers`</ph> até que <ph id="ph3">`allNumbers`</ph> for modificada, usando o <ph id="ph4">&lt;xref:System.Collections.Generic.HashSet%601.IntersectWith%2A&gt;</ph> método para conter somente os valores que estão presentes em ambos os conjuntos.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source>Once <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are identical, <ph id="ph3">`allNumbers`</ph> is still a superset of <ph id="ph4">`lowNumbers`</ph> but is no longer a proper superset.</source>
          <target state="translated">Uma vez <ph id="ph1">`allNumbers`</ph> e <ph id="ph2">`lowNumbers`</ph> são idênticos, <ph id="ph3">`allNumbers`</ph> ainda é um superconjunto de <ph id="ph4">`lowNumbers`</ph> , mas não é um superconjunto apropriado.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>The source of the deserialization event.</source>
          <target state="translated">A fonte do evento de desserialização.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>Implements the <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> interface and raises the deserialization event when the deserialization is complete.</source>
          <target state="translated">Implementa a interface <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.ISerializable" /&gt;</ph> e gera o evento de desserialização quando a desserialização for concluída.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>Calling this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Chamar esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> object associated with the current <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is invalid.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> associado ao objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual é inválido.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object and a specified collection share common elements.</source>
          <target state="translated">Determina se o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual e uma coleção especificada compartilham elementos comuns.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> share at least one common element; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> e <ph id="ph3">&lt;paramref name="other" /&gt;</ph> compartilharem pelo menos um elemento comum; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in <ph id="ph3">`other`</ph>.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos em <ph id="ph3">`other`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each another.</source>
          <target state="translated">O exemplo a seguir cria dois diferentes <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos e compara-as entre si.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source>In this example, <ph id="ph1">`allNumbers`</ph> and <ph id="ph2">`lowNumbers`</ph> are shown to share common elements using the <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Overlaps%2A&gt;</ph> method.</source>
          <target state="translated">Neste exemplo, <ph id="ph1">`allNumbers`</ph> e <ph id="ph2">`lowNumbers`</ph> são mostradas para compartilhar elementos comuns usando o <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Overlaps%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>The element to remove.</source>
          <target state="translated">O elemento a ser removido.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>Removes the specified element from a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Remove o elemento especificado de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is successfully found and removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o elemento for encontrado e removido com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>This method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is not found in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">Esse método retornará <ph id="ph1">&lt;see langword="false" /&gt;</ph> se <ph id="ph2">&lt;paramref name="item" /&gt;</ph> não for encontrado no objeto <ph id="ph3">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object does not contain the specified element, the object remains unchanged.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto não contém o elemento especificado, o objeto permanece inalterado.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>No exception is thrown.</source>
          <target state="translated">Nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>The following example demonstrates how to remove values from a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection using the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra como remover valores de um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção usando o <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.Remove(`0)">
          <source>In this example, zero is arbitrarily removed from the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection.</source>
          <target state="translated">Neste exemplo, zero arbitrariamente é removida do <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the elements to remove.</source>
          <target state="translated">O delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define as condições dos elementos a serem removidos.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>Removes all elements that match the conditions defined by the specified predicate from a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> collection.</source>
          <target state="translated">Remove todos os elementos que correspondem às condições definidas pelo predicado especificado de uma coleção de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>The number of elements that were removed from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> collection.</source>
          <target state="translated">O número de elementos que foram removidos da coleção de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>Calling this method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Chamar esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>The following example demonstrates how to remove values from a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection using the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra como remover valores de um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção usando o <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Remove%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source>In this example, all odd integers are removed from the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection as specified by the <ph id="ph2">`match`</ph> delegate.</source>
          <target state="translated">Neste exemplo, todos os números inteiros ímpares são removidos do <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção conforme especificado pelo <ph id="ph2">`match`</ph> delegate.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>Determines whether a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object and the specified collection contain the same elements.</source>
          <target state="translated">Determina se um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> e coleção especificada contêm os mesmos elementos.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object is equal to <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; otherwise, false.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o objeto <ph id="ph2">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> é igual a <ph id="ph3">&lt;paramref name="other" /&gt;</ph>; caso contrário, falso.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> method ignores duplicate entries and the order of elements in the <ph id="ph2">`other`</ph> parameter.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> método ignora entradas duplicadas e a ordem dos elementos no <ph id="ph2">`other`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>If the collection represented by <ph id="ph1">`other`</ph> is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Caso a coleção representada por <ph id="ph1">`other`</ph> seja uma coleção <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> com a mesma comparação de igualdade do objeto <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> atual, esse método é uma operação O(<ph id="ph4">`n`</ph>).</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos em <ph id="ph5">`other`</ph> e <ph id="ph6">`m`</ph> é <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two disparate <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects and compares them to each another.</source>
          <target state="translated">O exemplo a seguir cria dois diferentes <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos e compara-as entre si.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>Initially, the two sets are not equal, which is demonstrated by using the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> method.</source>
          <target state="translated">Inicialmente, os dois conjuntos não são iguais, que é mostrado usando o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SetEquals%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">`allNumbers`</ph><ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is then modified, after which the sets are equal.</source>
          <target state="translated">O <ph id="ph1">`allNumbers`</ph> <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto modificado, após o qual os conjuntos são iguais.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Modifies the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to contain only elements that are present either in that object or in the specified collection, but not both.</source>
          <target state="translated">Modifica o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual para que ele contenha somente elementos que estão presentes no objeto ou na coleção especificada, mas não em ambos.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>If the <ph id="ph1">`other`</ph> parameter is a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection with the same equality comparer as the current <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object, this method is an O(<ph id="ph4">`n`</ph>) operation.</source>
          <target state="translated">Se o <ph id="ph1">`other`</ph> parâmetro é um <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção com o comparador de igualdade mesmo do atual <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> do objeto, esse método é um O (<ph id="ph4">`n`</ph>) operação.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Otherwise, this method is an O(<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operation, where <ph id="ph4">`n`</ph> is the number of elements in <ph id="ph5">`other`</ph> and <ph id="ph6">`m`</ph> is <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Caso contrário, esse método é um O (<ph id="ph1">`n`</ph><ph id="ph2"> + </ph><ph id="ph3">`m`</ph>) operação, onde <ph id="ph4">`n`</ph> é o número de elementos em <ph id="ph5">`other`</ph> e <ph id="ph6">`m`</ph> é <ph id="ph7">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collections with overlapping sets of data.</source>
          <target state="translated">O exemplo a seguir cria dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleções com sobreposição de conjuntos de dados.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The set that contains the lower values is then modified, using the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A&gt;</ph> method, to contain only the values that are not present in both sets.</source>
          <target state="translated">O conjunto que contém os valores mais baixos, em seguida, é modificado, usando o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A&gt;</ph> método para conter somente os valores que não estão presentes em ambos os conjuntos.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>The object to add to the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> object.</source>
          <target state="translated">O objeto a ser adicionado ao objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>Adds an item to an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> object.</source>
          <target state="translated">Adiciona um item a um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> é menor que <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, esse método é uma operação de (1).</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>If the capacity must be increased to accommodate the new element, this method becomes an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Se a capacidade deve ser aumentada para acomodar o novo elemento, esse método se torna um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#Add(`0)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> is read-only.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> é somente leitura.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>Gets a value indicating whether a collection is read-only.</source>
          <target state="translated">Obtém um valor que indica se uma coleção é somente leitura.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the collection is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a coleção for somente leitura; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">A recuperação do valor dessa propriedade é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">Retorna um enumerador que itera em uma coleção.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> object that can be used to iterate through the collection.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> que pode ser usado para iterar pela coleção.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of enumerators.</source>
          <target state="translated">A instrução <ph id="ph1">`foreach`</ph> da linguagem C# (<ph id="ph2">`for each`</ph> em C++, <ph id="ph3">`For Each`</ph> no Visual Basic) oculta a complexidade de enumeradores.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">Nesta posição, o <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> propriedade está definida.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar o método <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> is called.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> propriedade retorna o mesmo objeto até <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator object instead.</source>
          <target state="translated">Não é possível definir <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> para o primeiro elemento da coleção novamente, você deve criar um novo objeto de enumerador em vez disso.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">As implementações padrão de coleções no namespace <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> não são sincronizadas.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">Retorna um enumerador que itera em uma coleção.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> object that can be used to iterate through the collection.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> que pode ser usado para iterar pela coleção.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of enumerators.</source>
          <target state="translated">A instrução <ph id="ph1">`foreach`</ph> da linguagem C# (<ph id="ph2">`for each`</ph> em C++, <ph id="ph3">`For Each`</ph> no Visual Basic) oculta a complexidade de enumeradores.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Portanto, o uso de <ph id="ph1">`foreach`</ph> é recomendado, em vez de manipular diretamente o enumerador.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> também traz o enumerador de volta para essa posição.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">Nesta posição, o <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> propriedade está definida.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por isso, você deve chamar o método <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> propriedade retorna o mesmo objeto até que o <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> é chamado.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> define <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o próximo elemento.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Caso <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> retorna <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Quando o enumerador está nessa posição, as chamadas subsequentes para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> também retornam <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Caso a última chamada para <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> tenha retornado <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> está indefinido.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para definir <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> como o primeiro elemento da coleção novamente, é possível chamar <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> seguido de <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Um enumerador permanece válido desde que a coleção continue inalterada.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">As implementações padrão de coleções no namespace <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> não são sincronizadas.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método é uma operação O(1).</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>Sets the capacity of a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</source>
          <target state="translated">Define a capacidade de um objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> para o número real de elementos que ele contém, arredondado para cima para um valor próximo específico da implementação.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>You can use the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> method to minimize a <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object's memory overhead once it is known that no new elements will be added.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.TrimExcess%2A&gt;</ph> método minimizar uma <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> sobrecarga de memória do objeto quando se sabe que nenhum novo elemento será adicionado.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>To completely clear a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object and release all memory referenced by it, call this method after calling the <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Clear%2A&gt;</ph> method.</source>
          <target state="translated">Limpar completamente uma <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> de objeto e liberar memória de todos os referenciados por ele, chamar este método depois de chamar o <ph id="ph2">&lt;xref:System.Collections.Generic.HashSet%601.Clear%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método é uma operação O(<ph id="ph1">`n`</ph>), em que <ph id="ph2">`n`</ph> é <ph id="ph3">&lt;xref:System.Collections.Generic.HashSet%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TrimExcess">
          <source>The following example creates and populates a <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> collection, and then clears the collection and releases the memory referenced by it.</source>
          <target state="translated">O exemplo a seguir cria e preenche um <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> coleção e limpa a coleção e libera a memória referenciada por ele.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
          <source>The value to search for.</source>
          <target state="translated">O valor a ser procurado.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
          <source>The value from the set that the search found, or the default value of T when the search yielded no match.</source>
          <target state="translated">O valor do conjunto encontrado pela pesquisa ou o valor padrão de T quando a pesquisa não gera correspondência.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
          <source>Searches the set for a given value and returns the equal value it finds, if any.</source>
          <target state="translated">Pesquisa um determinado valor no conjunto e retorna o valor igual que for encontrado, se houver.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
          <source>A value indicating whether the search was successful.</source>
          <target state="translated">Um valor que indica se a pesquisa foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)">
          <source>This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</source>
          <target state="translated">Isso pode ser útil quando você quiser reutilizar uma referência armazenada anteriormente em vez de um recentemente construído (de forma que pode ocorrer mais de compartilhamento de referências) ou para pesquisar um valor que tem mais completar os dados que o valor que você tem, embora suas funções de comparador indicam que eles são iguais.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection to compare to the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object.</source>
          <target state="translated">A coleção a ser comparada com o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>Modifies the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> object to contain all elements that are present in itself, the specified collection, or both.</source>
          <target state="translated">Modifica o objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.HashSet`1" /&gt;</ph> atual para que ele contenha todos os elementos presentes nele, na coleção especificada ou em ambos.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements in the <ph id="ph3">`other`</ph> parameter.</source>
          <target state="translated">Esse método é um O (<ph id="ph1">`n`</ph>) operação, onde <ph id="ph2">`n`</ph> é o número de elementos de <ph id="ph3">`other`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example demonstrates how to merge two disparate sets.</source>
          <target state="translated">O exemplo a seguir demonstra como mesclar dois conjuntos distintos.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>This example creates two <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objects, and populates them with even and odd numbers, respectively.</source>
          <target state="translated">Este exemplo cria dois <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objetos e a preenche com números e ímpares, respectivamente.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>A third <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> object is created from the set that contains the even numbers.</source>
          <target state="translated">Um terceiro <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601&gt;</ph> objeto é criado a partir do conjunto que contém os números pares.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> method, which adds the odd number set to the third set.</source>
          <target state="translated">O exemplo, em seguida, chama o <ph id="ph1">&lt;xref:System.Collections.Generic.HashSet%601.UnionWith%2A&gt;</ph> método, que adiciona o número ímpar definido para o terceiro conjunto.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="other" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="other" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>