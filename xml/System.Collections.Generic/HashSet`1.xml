<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="2de18-101">O tipo dos elementos no conjunto de hash.</span><span class="sxs-lookup"><span data-stu-id="2de18-101">The type of elements in the hash set.</span></span></typeparam>
    <summary><span data-ttu-id="2de18-102">Representa um conjunto de valores.</span><span class="sxs-lookup"><span data-stu-id="2de18-102">Represents a set of values.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-103">O <xref:System.Collections.Generic.HashSet%601> classe fornece operações de conjunto de alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="2de18-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="2de18-104">Um conjunto é uma coleção que não contém elementos duplicados, e cujos elementos estão em nenhuma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="2de18-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2de18-105"><xref:System.Collections.Generic.HashSet%601> implementa o <xref:System.Collections.Generic.IReadOnlyCollection%601> interface começando com o [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; nas versões anteriores do .NET Framework, o <xref:System.Collections.Generic.HashSet%601> classe não implementou esta interface.</span><span class="sxs-lookup"><span data-stu-id="2de18-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="2de18-106">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> é o número de elementos que o objeto pode conter.</span><span class="sxs-lookup"><span data-stu-id="2de18-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="2de18-107">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> aumenta automaticamente à medida que elementos são adicionados ao objeto.</span><span class="sxs-lookup"><span data-stu-id="2de18-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="2de18-108">O <xref:System.Collections.Generic.HashSet%601> classe baseia-se no modelo de conjuntos matemáticos e fornece operações de conjunto de alto desempenho semelhantes a acessar as chaves do <xref:System.Collections.Generic.Dictionary%602> ou <xref:System.Collections.Hashtable> coleções.</span><span class="sxs-lookup"><span data-stu-id="2de18-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="2de18-109">Em termos simples, o <xref:System.Collections.Generic.HashSet%601> classe pode ser pensada como um <xref:System.Collections.Generic.Dictionary%602> coleção sem valores.</span><span class="sxs-lookup"><span data-stu-id="2de18-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="2de18-110">Um <xref:System.Collections.Generic.HashSet%601> coleção não está classificada e não pode conter elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="2de18-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="2de18-111">Se ordem ou elemento de duplicação é mais importante que o desempenho de seu aplicativo, considere o uso de <xref:System.Collections.Generic.List%601> classe junto com o <xref:System.Collections.Generic.List%601.Sort%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="2de18-112"><xref:System.Collections.Generic.HashSet%601> fornece muitos matemática conjunto de operações, como a adição de conjunto (uniões) e subtração do conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="2de18-113">A tabela a seguir lista fornecido <xref:System.Collections.Generic.HashSet%601> operações e seus equivalentes matemáticos.</span><span class="sxs-lookup"><span data-stu-id="2de18-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="2de18-114">Operação HashSet (Of T)</span><span class="sxs-lookup"><span data-stu-id="2de18-114">HashSet(Of T) operation</span></span>|<span data-ttu-id="2de18-115">Equivalente de matemática</span><span class="sxs-lookup"><span data-stu-id="2de18-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="2de18-116">União ou conjunto de adição</span><span class="sxs-lookup"><span data-stu-id="2de18-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="2de18-117">Interseção</span><span class="sxs-lookup"><span data-stu-id="2de18-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="2de18-118">Conjunto de subtração</span><span class="sxs-lookup"><span data-stu-id="2de18-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="2de18-119">Diferença simétrica</span><span class="sxs-lookup"><span data-stu-id="2de18-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="2de18-120">Além de operações de conjunto listadas, a <xref:System.Collections.Generic.HashSet%601> classe também fornece métodos para determinar conjuntos de igualdade, sobreposição de conjuntos, e se um conjunto é um subconjunto ou superconjunto de outro conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
 <span data-ttu-id="2de18-121">Para grandes <xref:System.Collections.Generic.HashSet%601> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits definindo o `enabled` atributo do elemento de configuração para `true` no ambiente de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="2de18-121">For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the  configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="2de18-122">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.Collections.Generic.HashSet%601> classe implementa o <xref:System.Collections.Generic.ISet%601> interface.</span><span class="sxs-lookup"><span data-stu-id="2de18-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="2de18-123">Operações de conjunto com HashSet e LINQ</span><span class="sxs-lookup"><span data-stu-id="2de18-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="2de18-124">LINQ fornece acesso para o `Distinct`, `Union`, `Intersect` e `Except` definir operações em qualquer fonte de dados que implementa o <xref:System.Collections.IEnumerable> ou <xref:System.Linq.IQueryable> interfaces.</span><span class="sxs-lookup"><span data-stu-id="2de18-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="2de18-125"><xref:System.Collections.Generic.HashSet%601> Fornece um conjunto maior e mais robusto de operações de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="2de18-126">Por exemplo, <xref:System.Collections.Generic.HashSet%601> fornece comparações como <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> e <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="2de18-127">As operações de conjunto a principal diferença entre LINQ e <xref:System.Collections.Generic.HashSet%601> operações é que as operações de conjunto do LINQ sempre retornam um novo <xref:System.Collections.Generic.IEnumerable%601> coleção, enquanto o <xref:System.Collections.Generic.HashSet%601> métodos equivalentes modificam a coleção atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="2de18-128">Normalmente, se você deve criar um novo conjunto ou se seu aplicativo precisa acessar apenas as operações de conjunto fornecidas, usando o LINQ definida operações em qualquer <xref:System.Collections.Generic.IEnumerable%601> coleção ou matriz será suficiente.</span><span class="sxs-lookup"><span data-stu-id="2de18-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="2de18-129">No entanto, se seu aplicativo requer acesso a operações de conjunto adicionais, ou se não for desejável ou necessárias para criar uma nova coleção, use o <xref:System.Collections.Generic.HashSet%601> classe.</span><span class="sxs-lookup"><span data-stu-id="2de18-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="2de18-130">A tabela a seguir mostra o <xref:System.Collections.Generic.HashSet%601> as operações de conjunto de operações e seus equivalentes do LINQ.</span><span class="sxs-lookup"><span data-stu-id="2de18-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="2de18-131">Operação HashSet (Of T)</span><span class="sxs-lookup"><span data-stu-id="2de18-131">HashSet(Of T) operation</span></span>|<span data-ttu-id="2de18-132">Equivalente a LINQ</span><span class="sxs-lookup"><span data-stu-id="2de18-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="2de18-133">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="2de18-134">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="2de18-135">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="2de18-136">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="2de18-137">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="2de18-138">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="2de18-139">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="2de18-140">Não fornecido.</span><span class="sxs-lookup"><span data-stu-id="2de18-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2de18-141">O exemplo a seguir demonstra como mesclar dois conjuntos distintos.</span><span class="sxs-lookup"><span data-stu-id="2de18-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="2de18-142">Este exemplo cria dois <xref:System.Collections.Generic.HashSet%601> objetos e a preenche com números e ímpares, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="2de18-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="2de18-143">Um terceiro <xref:System.Collections.Generic.HashSet%601> objeto é criado a partir do conjunto que contém os números pares.</span><span class="sxs-lookup"><span data-stu-id="2de18-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="2de18-144">O exemplo, em seguida, chama o <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método, que adiciona o número ímpar definido para o terceiro conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2de18-145">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-146">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> que está vazia e usa o comparador de igualdade padrão para o tipo de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-147">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> é o número de elementos que o objeto pode conter.</span><span class="sxs-lookup"><span data-stu-id="2de18-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="2de18-148">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> aumenta automaticamente à medida que elementos são adicionados ao objeto.</span><span class="sxs-lookup"><span data-stu-id="2de18-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="2de18-149">Este construtor é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-150">O exemplo a seguir demonstra como criar e popular dois <xref:System.Collections.Generic.HashSet%601> objetos.</span><span class="sxs-lookup"><span data-stu-id="2de18-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="2de18-151">Este exemplo é parte de um exemplo maior fornecido para o <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="2de18-152">A coleção cujos elementos são copiados para o novo conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-152">The collection whose elements are copied to the new set.</span></span></param>
        <summary><span data-ttu-id="2de18-153">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> que usa o comparador de igualdade padrão para o tipo de conjunto, contém os elementos copiados da coleção especificada e tem capacidade suficiente para acomodar o número de elementos copiados.</span><span class="sxs-lookup"><span data-stu-id="2de18-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-154">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> é o número de elementos que o objeto pode conter.</span><span class="sxs-lookup"><span data-stu-id="2de18-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="2de18-155">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> aumenta automaticamente à medida que elementos são adicionados ao objeto.</span><span class="sxs-lookup"><span data-stu-id="2de18-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="2de18-156">Se `collection` contém duplicatas, o conjunto irá conter uma de cada elemento exclusivo.</span><span class="sxs-lookup"><span data-stu-id="2de18-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="2de18-157">Nenhuma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="2de18-157">No exception will be thrown.</span></span> <span data-ttu-id="2de18-158">Portanto, o tamanho do conjunto resultante não é idêntico ao tamanho de `collection`.</span><span class="sxs-lookup"><span data-stu-id="2de18-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="2de18-159">Este construtor é um O (`n`) operação, onde `n` é o número de elementos de `collection` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="2de18-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-160">O exemplo a seguir mostra como criar um <xref:System.Collections.Generic.HashSet%601> coleção de um conjunto existente.</span><span class="sxs-lookup"><span data-stu-id="2de18-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="2de18-161">Neste exemplo, dois conjuntos são criados com números inteiros e ímpares, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="2de18-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="2de18-162">Um terceiro <xref:System.Collections.Generic.HashSet%601> objeto é criado do conjunto de inteiro mesmo.</span><span class="sxs-lookup"><span data-stu-id="2de18-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-163"><paramref name="collection" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-163"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="2de18-164">A implementação do <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar valores no conjunto ou <see langword="null" /> para usar implementação padrão do <see cref="T:System.Collections.Generic.EqualityComparer`1" /> para o tipo de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="2de18-165">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> que está vazia e usa a comparação de igualdade especificada para o tipo de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-166">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> é o número de elementos que o objeto pode conter.</span><span class="sxs-lookup"><span data-stu-id="2de18-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="2de18-167">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> aumenta automaticamente à medida que elementos são adicionados ao objeto.</span><span class="sxs-lookup"><span data-stu-id="2de18-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="2de18-168">Este construtor é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="2de18-169">O tamanho inicial de <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="2de18-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <summary><span data-ttu-id="2de18-170">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> que está vazia, mas tem espaço reservado para <paramref name="capacity" /> itens e usa o comparador de igualdade padrão para o tipo de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-171">Como redimensiona é relativamente cara (exigem refazendo o hash), isso tenta minimizar a necessidade de redimensionar, definindo a capacidade inicial com base no valor da `capacity`.</span><span class="sxs-lookup"><span data-stu-id="2de18-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="2de18-172">A coleção cujos elementos são copiados para o novo conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-172">The collection whose elements are copied to the new set.</span></span></param>
        <param name="comparer"><span data-ttu-id="2de18-173">A implementação do <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar valores no conjunto ou <see langword="null" /> para usar implementação padrão do <see cref="T:System.Collections.Generic.EqualityComparer`1" /> para o tipo de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="2de18-174">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> que usa o comparador de igualdado especificado para o tipo de conjunto, que contém os elementos copiados da coleção especificada e que tem capacidade suficiente para acomodar o número de elementos copiados.</span><span class="sxs-lookup"><span data-stu-id="2de18-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-175">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> é o número de elementos que o objeto pode conter.</span><span class="sxs-lookup"><span data-stu-id="2de18-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="2de18-176">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> aumenta automaticamente à medida que elementos são adicionados ao objeto.</span><span class="sxs-lookup"><span data-stu-id="2de18-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="2de18-177">Se `collection` contém duplicatas, o conjunto irá conter uma de cada elemento exclusivo.</span><span class="sxs-lookup"><span data-stu-id="2de18-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="2de18-178">Nenhuma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="2de18-178">No exception will be thrown.</span></span> <span data-ttu-id="2de18-179">Portanto, o tamanho do conjunto resultante não é idêntico ao tamanho de `collection`.</span><span class="sxs-lookup"><span data-stu-id="2de18-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="2de18-180">Este construtor é um O (`n`) operação, onde `n` é o número de elementos de `collection` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="2de18-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-181">O exemplo a seguir usa uma fornecido <xref:System.Collections.Generic.IEqualityComparer%601> para permitir que as comparações de maiusculas e minúsculas nos elementos de uma <xref:System.Collections.Generic.HashSet%601> coleção de tipos de veículo.</span><span class="sxs-lookup"><span data-stu-id="2de18-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-182"><paramref name="collection" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-182"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="2de18-183">O tamanho inicial de <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="2de18-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <param name="comparer"><span data-ttu-id="2de18-184">A implementação <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usada ao comparar valores no conjunto ou nulo (Nothing no Visual Basic) para usar a implementação padrão <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> no tipo de conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="2de18-185">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> que usa o comparador de igualdade especificado para o tipo de conjunto e tem capacidade suficiente para acomodar elementos <paramref name="capacity" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-186">Como redimensiona é relativamente cara (exigem refazendo o hash), isso tenta minimizar a necessidade de redimensionar, definindo a capacidade inicial com base no valor da `capacity`.</span><span class="sxs-lookup"><span data-stu-id="2de18-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="2de18-187">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="2de18-188">Uma estrutura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado ao objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-189">Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.HashSet`1" /> com dados serializados.</span><span class="sxs-lookup"><span data-stu-id="2de18-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-190">Este construtor é chamado durante a desserialização para reconstituir a um objeto que é transmitido em um fluxo.</span><span class="sxs-lookup"><span data-stu-id="2de18-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="2de18-191">Para obter mais informações, consulte [XML e serialização SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="2de18-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="2de18-192">O elemento a ser adicionado ao conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-192">The element to add to the set.</span></span></param>
        <summary><span data-ttu-id="2de18-193">Adiciona o elemento especificado a um conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-193">Adds the specified element to a set.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-194"><see langword="true" /> se o elemento for adicionado ao objeto <see cref="T:System.Collections.Generic.HashSet`1" />, <see langword="false" /> se o elemento já estiver presente.</span><span class="sxs-lookup"><span data-stu-id="2de18-194"><see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-195">Se <xref:System.Collections.Generic.HashSet%601.Count%2A> já for igual à capacidade do <xref:System.Collections.Generic.HashSet%601> do objeto, a capacidade é automaticamente ajustada para acomodar o novo item.</span><span class="sxs-lookup"><span data-stu-id="2de18-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="2de18-196">Se <xref:System.Collections.Generic.HashSet%601.Count%2A> é menor que a capacidade da matriz interna, esse método é uma operação de (1).</span><span class="sxs-lookup"><span data-stu-id="2de18-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="2de18-197">Se o <xref:System.Collections.Generic.HashSet%601> objeto deve ser redimensionado, esse método se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-198">O exemplo a seguir demonstra como criar e popular dois <xref:System.Collections.Generic.HashSet%601> objetos.</span><span class="sxs-lookup"><span data-stu-id="2de18-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="2de18-199">Este exemplo é parte de um exemplo maior fornecido para o <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-200">Remove todos os elementos de um objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> é definido como zero e referências a outros objetos de elementos da coleção também são liberadas.</span><span class="sxs-lookup"><span data-stu-id="2de18-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="2de18-202">A capacidade permanece inalterada até que uma chamada para <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> é feita.</span><span class="sxs-lookup"><span data-stu-id="2de18-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="2de18-203">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-204">O exemplo a seguir cria e preenche um <xref:System.Collections.Generic.HashSet%601> coleção, em seguida, limpar e libera a memória referenciada pela coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2de18-205">Obtém o objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que é usado para determinar igualdade para os valores no conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></summary>
        <value><span data-ttu-id="2de18-206">O objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que é usado para determinar igualdade para os valores no conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-207">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="2de18-208">O elemento a ser localizado no objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-209">Determina se um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> contém o elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="2de18-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-210"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> contiver o elemento especificado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-210"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-211">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-212">O exemplo a seguir demonstra como remover valores de um <xref:System.Collections.Generic.HashSet%601> coleção usando o <xref:System.Collections.Generic.HashSet%601.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="2de18-213">Neste exemplo, o <xref:System.Collections.Generic.HashSet%601.Contains%2A> método confirma que o conjunto contém um valor antes de removê-lo.</span><span class="sxs-lookup"><span data-stu-id="2de18-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="2de18-214">Copia os elementos de uma coleção <see cref="T:System.Collections.Generic.HashSet`1" /> para uma matriz.</span><span class="sxs-lookup"><span data-stu-id="2de18-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="2de18-215">A matriz unidimensional que é o destino dos elementos copiados do objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="2de18-216">A matriz deve ter indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="2de18-216">The array must have zero-based indexing.</span></span></param>
        <summary><span data-ttu-id="2de18-217">Copia os elementos de um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> para uma matriz.</span><span class="sxs-lookup"><span data-stu-id="2de18-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-218">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-219"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-219"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="2de18-220">A matriz unidimensional que é o destino dos elementos copiados do objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="2de18-221">A matriz deve ter indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="2de18-221">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="2de18-222">O índice baseado em zero na <c>array</c> na qual a cópia começa.</span><span class="sxs-lookup"><span data-stu-id="2de18-222">The zero-based index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="2de18-223">Copia os elementos de um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> para uma matriz, começando no índice da matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="2de18-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-224">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-225"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-225"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2de18-226"><paramref name="arrayIndex" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="2de18-226"><paramref name="arrayIndex" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2de18-227"><paramref name="arrayIndex" /> é maior que o tamanho da <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="2de18-227"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="2de18-228">A matriz unidimensional que é o destino dos elementos copiados do objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="2de18-229">A matriz deve ter indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="2de18-229">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="2de18-230">O índice baseado em zero na <c>array</c> na qual a cópia começa.</span><span class="sxs-lookup"><span data-stu-id="2de18-230">The zero-based index in <c>array</c> at which copying begins.</span></span></param>
        <param name="count"><span data-ttu-id="2de18-231">O número de elementos a serem copiados para <c>array</c>.</span><span class="sxs-lookup"><span data-stu-id="2de18-231">The number of elements to copy to <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="2de18-232">Copia o número especificado de elementos de um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> para uma matriz, começando no índice especificado da matriz.</span><span class="sxs-lookup"><span data-stu-id="2de18-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-233">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="2de18-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-234"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-234"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2de18-235"><paramref name="arrayIndex" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="2de18-235"><paramref name="arrayIndex" /> is less than 0.</span></span>  
  
 <span data-ttu-id="2de18-236">- ou -</span><span class="sxs-lookup"><span data-stu-id="2de18-236">-or-</span></span>  
  
 <span data-ttu-id="2de18-237"><paramref name="count" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="2de18-237"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2de18-238"><paramref name="arrayIndex" /> é maior que o tamanho da <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="2de18-238"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="2de18-239">- ou -</span><span class="sxs-lookup"><span data-stu-id="2de18-239">-or-</span></span>  
  
 <span data-ttu-id="2de18-240"><paramref name="count" /> é maior que o espaço disponível do <paramref name="index" /> até o final da <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="2de18-240"><paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2de18-241">Obtém o número de elementos contidos em um conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-241">Gets the number of elements that are contained in a set.</span></span></summary>
        <value><span data-ttu-id="2de18-242">O número de elementos contidos no conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-242">The number of elements that are contained in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-243">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> é o número de elementos que o objeto pode conter.</span><span class="sxs-lookup"><span data-stu-id="2de18-243">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="2de18-244">A capacidade de um objeto <xref:System.Collections.Generic.HashSet%601> aumenta automaticamente à medida que elementos são adicionados ao objeto.</span><span class="sxs-lookup"><span data-stu-id="2de18-244">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="2de18-245">A capacidade é sempre maior que ou igual a <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-245">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="2de18-246">Se <xref:System.Collections.Generic.HashSet%601.Count%2A> excede a capacidade durante a adição de elementos, a capacidade é definida como o primeiro número primo é maior do que o dobro da capacidade anterior.</span><span class="sxs-lookup"><span data-stu-id="2de18-246">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="2de18-247">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-247">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-248">O exemplo a seguir demonstra como criar, preencher e manipular dois <xref:System.Collections.Generic.HashSet%601> objetos.</span><span class="sxs-lookup"><span data-stu-id="2de18-248">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="2de18-249">Neste exemplo, o conteúdo do conjunto e <xref:System.Collections.Generic.HashSet%601.Count%2A> exibir no console.</span><span class="sxs-lookup"><span data-stu-id="2de18-249">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-250">Retorna um objeto <see cref="T:System.Collections.IEqualityComparer" /> que pode ser usado para teste de igualdade de um objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-250">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="2de18-251">Um objeto <see cref="T:System.Collections.IEqualityComparer" /> que pode ser usado para teste de igualdade profunda de um objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-251">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-252">O <xref:System.Collections.IEqualityComparer> objeto verifica a igualdade apenas em um nível; no entanto, você pode encadear comparadores em níveis adicionais para executar o teste de igualdade mais profunda.</span><span class="sxs-lookup"><span data-stu-id="2de18-252">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="2de18-253">Chamar esse método é uma operação de (1).</span><span class="sxs-lookup"><span data-stu-id="2de18-253">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-254">A coleção de itens a serem removidos do objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-254">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-255">Remove todos os elementos na coleção especificada do objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-255">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-256">O <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> método é o equivalente da subtração de conjunto de matemática.</span><span class="sxs-lookup"><span data-stu-id="2de18-256">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="2de18-257">Esse método é um O (`n`) operação, onde `n` é o número de elementos de `other` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="2de18-257">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-258">O exemplo a seguir cria dois <xref:System.Collections.Generic.HashSet%601> coleções com sobreposição de conjuntos de dados.</span><span class="sxs-lookup"><span data-stu-id="2de18-258">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="2de18-259">O menor intervalo de valores, em seguida, é removido do conjunto de maior usando o <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-259">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-260"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-260"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-261">Retorna um enumerador que itera por meio de um objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-261">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="2de18-262">Um objeto <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> para o objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-262">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-263">A instrução `foreach` da linguagem C# (`for each` em C++, `For Each` no Visual Basic) oculta a complexidade de enumeradores.</span><span class="sxs-lookup"><span data-stu-id="2de18-263">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="2de18-264">Portanto, usando `foreach` é recomendado em vez de manipulação direta do enumerador.</span><span class="sxs-lookup"><span data-stu-id="2de18-264">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="2de18-265">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</span><span class="sxs-lookup"><span data-stu-id="2de18-265">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="2de18-266">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-266">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="2de18-267">Nesta posição, o <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propriedade está definida.</span><span class="sxs-lookup"><span data-stu-id="2de18-267">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="2de18-268">Por isso, você deve chamar o método <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-268">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="2de18-269">O <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propriedade retorna o mesmo objeto até <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="2de18-269">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="2de18-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> define <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> como o próximo elemento.</span><span class="sxs-lookup"><span data-stu-id="2de18-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="2de18-271">Caso <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="2de18-271">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="2de18-272">Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> também retornam `false`.</span><span class="sxs-lookup"><span data-stu-id="2de18-272">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="2de18-273">Caso a última chamada para <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="2de18-273">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="2de18-274">Não é possível definir <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> para o primeiro elemento da coleção novamente, você deve criar um novo objeto de enumerador em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2de18-274">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="2de18-275">Um enumerador permanece válido desde que a coleção continue inalterada.</span><span class="sxs-lookup"><span data-stu-id="2de18-275">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="2de18-276">Se forem feitas alterações na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> ou <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> lança um <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="2de18-276">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="2de18-277">Se a coleção é modificada entre chamada <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> método e obter o valor da <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propriedade <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> retorna o elemento que está definido como, mesmo se o enumerador já é invalidado.</span><span class="sxs-lookup"><span data-stu-id="2de18-277">If the collection is modified between calling <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method and obtaining the value of the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> returns the element that it is set to, even if the enumerator is already invalidated.</span></span>  
  
 <span data-ttu-id="2de18-278">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="2de18-278">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="2de18-279">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="2de18-279">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="2de18-280">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</span><span class="sxs-lookup"><span data-stu-id="2de18-280">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="2de18-281">As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="2de18-281">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="2de18-282">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-282">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="2de18-283">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-283">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="2de18-284">Uma estrutura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado ao objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-284">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-285">Implementa a interface <see cref="T:System.Runtime.Serialization.ISerializable" /> e retorna os dados necessários para serializar um objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-285">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-286">Chamar esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-286">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-287"><paramref name="info" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-287"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="2de18-288">para fornecer serviços de serialização.</span><span class="sxs-lookup"><span data-stu-id="2de18-288">for providing serialization services.</span></span> <span data-ttu-id="2de18-289">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-289">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="2de18-290">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="2de18-290">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-291">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-291">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-292">Modifica o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual para que ele contenha somente elementos presentes no objeto e na coleção especificada.</span><span class="sxs-lookup"><span data-stu-id="2de18-292">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-293">Se a coleção é representado pelo `other` parâmetro é um <xref:System.Collections.Generic.HashSet%601> coleção com o comparador de igualdade mesmo do atual <xref:System.Collections.Generic.HashSet%601> do objeto, esse método é um O (`n`) operação.</span><span class="sxs-lookup"><span data-stu-id="2de18-293">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-294">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A> e `m` é o número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-294">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-295"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-295"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-296">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-296">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-297">Determina se um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> é um subconjunto apropriado da coleção especificada.</span><span class="sxs-lookup"><span data-stu-id="2de18-297">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-298"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> for um subconjunto apropriado de <paramref name="other" />, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-298"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-299">Um conjunto vazio é um subconjunto apropriado de qualquer outra coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-299">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="2de18-300">Portanto, esse método retorna `true` se a coleção é representado por atual <xref:System.Collections.Generic.HashSet%601> objeto estiver vazio, a menos que o `other` parâmetro também é um conjunto vazio.</span><span class="sxs-lookup"><span data-stu-id="2de18-300">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="2de18-301">Esse método sempre retornará `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> é maior que ou igual ao número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-301">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="2de18-302">Se a coleção é representado por `other` é um <xref:System.Collections.Generic.HashSet%601> coleção com o comparador de igualdade mesmo do atual <xref:System.Collections.Generic.HashSet%601> do objeto, em seguida, esse método é um O (`n`) operação.</span><span class="sxs-lookup"><span data-stu-id="2de18-302">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-303">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A> e `m` é o número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-303">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-304">O exemplo a seguir cria dois objetos <xref:System.Collections.Generic.HashSet%601> separados e compara-os entre si.</span><span class="sxs-lookup"><span data-stu-id="2de18-304">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="2de18-305">Neste exemplo, `lowNumbers` é um subconjunto e um subconjunto apropriado do `allNumbers` até `allNumbers` for modificada, usando o <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para conter somente os valores que estão presentes em ambos os conjuntos.</span><span class="sxs-lookup"><span data-stu-id="2de18-305">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="2de18-306">Uma vez `allNumbers` e `lowNumbers` são idênticos, `lowNumbers` ainda é um subconjunto de `allNumbers` , mas não é mais um subconjunto apropriado.</span><span class="sxs-lookup"><span data-stu-id="2de18-306">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-307"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-307"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-308">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-308">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-309">Determina se um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> é um superconjunto apropriado da coleção especificada.</span><span class="sxs-lookup"><span data-stu-id="2de18-309">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-310"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> for um superconjunto apropriado de <paramref name="other" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-310"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-311">Um conjunto vazio é um superconjunto apropriado de qualquer outra coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-311">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="2de18-312">Portanto, esse método retorna `true` se a coleção é representado pelo `other` parâmetro estiver vazio, a menos que atual <xref:System.Collections.Generic.HashSet%601> também a coleção está vazia.</span><span class="sxs-lookup"><span data-stu-id="2de18-312">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="2de18-313">Esse método sempre retornará `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> é menor ou igual ao número de elementos no `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-313">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="2de18-314">Caso a coleção representada por `other` seja uma coleção <xref:System.Collections.Generic.HashSet%601> com a mesma comparação de igualdade do objeto <xref:System.Collections.Generic.HashSet%601> atual, esse método é uma operação O(`n`).</span><span class="sxs-lookup"><span data-stu-id="2de18-314">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-315">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é o número de elementos em `other` e `m` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-315">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-316">O exemplo a seguir cria dois objetos <xref:System.Collections.Generic.HashSet%601> separados e compara-os entre si.</span><span class="sxs-lookup"><span data-stu-id="2de18-316">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="2de18-317">Neste exemplo, `allNumbers` é um superconjunto e um superconjunto apropriado do `lowNumbers` até que `allNumbers` for modificada, usando o <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para conter somente os valores que estão presentes em ambos os conjuntos.</span><span class="sxs-lookup"><span data-stu-id="2de18-317">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="2de18-318">Uma vez `allNumbers` e `lowNumbers` são idênticos, `allNumbers` ainda é um superconjunto de `lowNumbers` , mas não é um superconjunto apropriado.</span><span class="sxs-lookup"><span data-stu-id="2de18-318">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-319"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-319"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-320">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-320">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-321">Determina se um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> é um subconjunto da coleção especificada.</span><span class="sxs-lookup"><span data-stu-id="2de18-321">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-322"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> for um subconjunto de <paramref name="other" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-322"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-323">Um conjunto vazio é um subconjunto de outra coleção, incluindo um conjunto vazio; Portanto, esse método retorna `true` se a coleção é representado por atual <xref:System.Collections.Generic.HashSet%601> objeto está vazio, mesmo se o `other` parâmetro é um conjunto vazio.</span><span class="sxs-lookup"><span data-stu-id="2de18-323">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="2de18-324">Esse método sempre retornará `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> é maior que o número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-324">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="2de18-325">Caso a coleção representada por `other` seja uma coleção <xref:System.Collections.Generic.HashSet%601> com a mesma comparação de igualdade do objeto <xref:System.Collections.Generic.HashSet%601> atual, esse método é uma operação O(`n`).</span><span class="sxs-lookup"><span data-stu-id="2de18-325">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-326">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A> e `m` é o número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-326">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-327">O exemplo a seguir cria dois objetos <xref:System.Collections.Generic.HashSet%601> separados e compara-os entre si.</span><span class="sxs-lookup"><span data-stu-id="2de18-327">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="2de18-328">Neste exemplo, `lowNumbers` é um subconjunto e um subconjunto apropriado do `allNumbers` até `allNumbers` for modificada, usando o <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para conter somente os valores que estão presentes em ambos os conjuntos.</span><span class="sxs-lookup"><span data-stu-id="2de18-328">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="2de18-329">Uma vez `allNumbers` e `lowNumbers` são idênticos, `lowNumbers` ainda é um subconjunto de `allNumbers` , mas não é mais um subconjunto apropriado.</span><span class="sxs-lookup"><span data-stu-id="2de18-329">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-330"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-330"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-331">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-331">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-332">Determina se um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> é um superconjunto da coleção especificada.</span><span class="sxs-lookup"><span data-stu-id="2de18-332">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-333"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> for um superconjunto de <paramref name="other" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-333"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-334">Todas as coleções, inclusive o conjunto vazio, são subconjuntos do conjunto vazio.</span><span class="sxs-lookup"><span data-stu-id="2de18-334">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="2de18-335">Portanto, esse método retorna `true` se a coleção é representado pelo `other` parâmetro estiver vazio, mesmo se atual <xref:System.Collections.Generic.HashSet%601> objeto está vazio.</span><span class="sxs-lookup"><span data-stu-id="2de18-335">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="2de18-336">Esse método sempre retornará `false` se <xref:System.Collections.Generic.HashSet%601.Count%2A> é menor que o número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-336">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="2de18-337">Caso a coleção representada por `other` seja uma coleção <xref:System.Collections.Generic.HashSet%601> com a mesma comparação de igualdade do objeto <xref:System.Collections.Generic.HashSet%601> atual, esse método é uma operação O(`n`).</span><span class="sxs-lookup"><span data-stu-id="2de18-337">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-338">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é o número de elementos em `other` e `m` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-338">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-339">O exemplo a seguir cria dois objetos <xref:System.Collections.Generic.HashSet%601> separados e compara-os entre si.</span><span class="sxs-lookup"><span data-stu-id="2de18-339">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="2de18-340">Neste exemplo, `allNumbers` é um superconjunto e um superconjunto apropriado do `lowNumbers` até que `allNumbers` for modificada, usando o <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para conter somente os valores que estão presentes em ambos os conjuntos.</span><span class="sxs-lookup"><span data-stu-id="2de18-340">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="2de18-341">Uma vez `allNumbers` e `lowNumbers` são idênticos, `allNumbers` ainda é um superconjunto de `lowNumbers` , mas não é um superconjunto apropriado.</span><span class="sxs-lookup"><span data-stu-id="2de18-341">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-342"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-342"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="2de18-343">A fonte do evento de desserialização.</span><span class="sxs-lookup"><span data-stu-id="2de18-343">The source of the deserialization event.</span></span></param>
        <summary><span data-ttu-id="2de18-344">Implementa a interface <see cref="T:System.Runtime.Serialization.ISerializable" /> e gera o evento de desserialização quando a desserialização for concluída.</span><span class="sxs-lookup"><span data-stu-id="2de18-344">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-345">Chamar esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-345">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="2de18-346">O objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> associado ao objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual é inválido.</span><span class="sxs-lookup"><span data-stu-id="2de18-346">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-347">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-347">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-348">Determina se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual e uma coleção especificada compartilham elementos comuns.</span><span class="sxs-lookup"><span data-stu-id="2de18-348">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-349"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> e <paramref name="other" /> compartilharem pelo menos um elemento comum; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-349"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-350">Esse método é um O (`n`) operação, onde `n` é o número de elementos em `other`.</span><span class="sxs-lookup"><span data-stu-id="2de18-350">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-351">O exemplo a seguir cria dois diferentes <xref:System.Collections.Generic.HashSet%601> objetos e compara-as entre si.</span><span class="sxs-lookup"><span data-stu-id="2de18-351">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="2de18-352">Neste exemplo, `allNumbers` e `lowNumbers` são mostradas para compartilhar elementos comuns usando o <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-352">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-353"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-353"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="2de18-354">O elemento a ser removido.</span><span class="sxs-lookup"><span data-stu-id="2de18-354">The element to remove.</span></span></param>
        <summary><span data-ttu-id="2de18-355">Remove o elemento especificado de um objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-355">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-356"><see langword="true" /> se o elemento for encontrado e removido com êxito; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-356"><see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="2de18-357">Esse método retornará <see langword="false" /> se <paramref name="item" /> não for encontrado no objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-357">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-358">Se o <xref:System.Collections.Generic.HashSet%601> objeto não contém o elemento especificado, o objeto permanece inalterado.</span><span class="sxs-lookup"><span data-stu-id="2de18-358">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="2de18-359">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="2de18-359">No exception is thrown.</span></span>  
  
 <span data-ttu-id="2de18-360">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-360">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-361">O exemplo a seguir demonstra como remover valores de um <xref:System.Collections.Generic.HashSet%601> coleção usando o <xref:System.Collections.Generic.HashSet%601.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-361">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="2de18-362">Neste exemplo, zero arbitrariamente é removida do <xref:System.Collections.Generic.HashSet%601> coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-362">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><span data-ttu-id="2de18-363">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem removidos.</span><span class="sxs-lookup"><span data-stu-id="2de18-363">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span></span></param>
        <summary><span data-ttu-id="2de18-364">Remove todos os elementos que correspondem às condições definidas pelo predicado especificado de uma coleção de <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-364">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></summary>
        <returns><span data-ttu-id="2de18-365">O número de elementos que foram removidos da coleção de <see cref="T:System.Collections.Generic.HashSet`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-365">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-366">Chamar esse método é um O (`n`) operação, onde `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-366">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-367">O exemplo a seguir demonstra como remover valores de um <xref:System.Collections.Generic.HashSet%601> coleção usando o <xref:System.Collections.Generic.HashSet%601.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-367">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="2de18-368">Neste exemplo, todos os números inteiros ímpares são removidos do <xref:System.Collections.Generic.HashSet%601> coleção conforme especificado pelo `match` delegate.</span><span class="sxs-lookup"><span data-stu-id="2de18-368">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-369"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-369"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-370">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-370">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-371">Determina se um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> e coleção especificada contêm os mesmos elementos.</span><span class="sxs-lookup"><span data-stu-id="2de18-371">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span></span></summary>
        <returns>
          <span data-ttu-id="2de18-372"><see langword="true" /> se o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> é igual a <paramref name="other" />; caso contrário, falso.</span><span class="sxs-lookup"><span data-stu-id="2de18-372"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-373">O <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> método ignora entradas duplicadas e a ordem dos elementos no `other` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="2de18-373">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="2de18-374">Caso a coleção representada por `other` seja uma coleção <xref:System.Collections.Generic.HashSet%601> com a mesma comparação de igualdade do objeto <xref:System.Collections.Generic.HashSet%601> atual, esse método é uma operação O(`n`).</span><span class="sxs-lookup"><span data-stu-id="2de18-374">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-375">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é o número de elementos em `other` e `m` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-375">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-376">O exemplo a seguir cria dois diferentes <xref:System.Collections.Generic.HashSet%601> objetos e compara-as entre si.</span><span class="sxs-lookup"><span data-stu-id="2de18-376">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="2de18-377">Inicialmente, os dois conjuntos não são iguais, que é mostrado usando o <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-377">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="2de18-378">O `allNumbers` <xref:System.Collections.Generic.HashSet%601> objeto modificado, após o qual os conjuntos são iguais.</span><span class="sxs-lookup"><span data-stu-id="2de18-378">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-379"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-379"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-380">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-380">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-381">Modifica o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual para que ele contenha somente elementos que estão presentes no objeto ou na coleção especificada, mas não em ambos.</span><span class="sxs-lookup"><span data-stu-id="2de18-381">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-382">Se o `other` parâmetro é um <xref:System.Collections.Generic.HashSet%601> coleção com o comparador de igualdade mesmo do atual <xref:System.Collections.Generic.HashSet%601> do objeto, esse método é um O (`n`) operação.</span><span class="sxs-lookup"><span data-stu-id="2de18-382">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="2de18-383">Caso contrário, esse método é um O (`n` + `m`) operação, onde `n` é o número de elementos em `other` e `m` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-383">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-384">O exemplo a seguir cria dois <xref:System.Collections.Generic.HashSet%601> coleções com sobreposição de conjuntos de dados.</span><span class="sxs-lookup"><span data-stu-id="2de18-384">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="2de18-385">O conjunto que contém os valores mais baixos, em seguida, é modificado, usando o <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> método para conter somente os valores que não estão presentes em ambos os conjuntos.</span><span class="sxs-lookup"><span data-stu-id="2de18-385">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-386"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-386"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="2de18-387">O objeto a ser adicionado ao objeto <see cref="T:System.Collections.Generic.ICollection`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-387">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-388">Adiciona um item a um objeto <see cref="T:System.Collections.Generic.ICollection`1" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-388">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-389">Se <xref:System.Collections.Generic.List%601.Count%2A> é menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é uma operação de (1).</span><span class="sxs-lookup"><span data-stu-id="2de18-389">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="2de18-390">Se a capacidade deve ser aumentada para acomodar o novo elemento, esse método se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Generic.List%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-390">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="2de18-391">O <see cref="T:System.Collections.Generic.ICollection`1" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="2de18-391">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="2de18-392">Obtém um valor que indica se uma coleção é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="2de18-392">Gets a value indicating whether a collection is read-only.</span></span></summary>
        <value>
          <span data-ttu-id="2de18-393"><see langword="true" /> se a coleção for somente leitura; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-393"><see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-394">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-394">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-395">Retorna um enumerador que itera em uma coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-395">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="2de18-396">Um objeto <see cref="T:System.Collections.Generic.IEnumerator`1" /> que pode ser usado para iterar pela coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-396">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-397">A instrução `foreach` da linguagem C# (`for each` em C++, `For Each` no Visual Basic) oculta a complexidade de enumeradores.</span><span class="sxs-lookup"><span data-stu-id="2de18-397">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="2de18-398">Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.</span><span class="sxs-lookup"><span data-stu-id="2de18-398">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="2de18-399">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</span><span class="sxs-lookup"><span data-stu-id="2de18-399">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="2de18-400">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-400">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="2de18-401">Nesta posição, o <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriedade está definida.</span><span class="sxs-lookup"><span data-stu-id="2de18-401">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="2de18-402">Por isso, você deve chamar o método <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-402">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="2de18-403">O <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriedade retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="2de18-403">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="2de18-404"><xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.Generic.IEnumerator%601.Current%2A> como o próximo elemento.</span><span class="sxs-lookup"><span data-stu-id="2de18-404"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="2de18-405">Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="2de18-405">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="2de18-406">Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`.</span><span class="sxs-lookup"><span data-stu-id="2de18-406">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="2de18-407">Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="2de18-407">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="2de18-408">Não é possível definir <xref:System.Collections.Generic.IEnumerator%601.Current%2A> para o primeiro elemento da coleção novamente, você deve criar um novo objeto de enumerador em vez disso.</span><span class="sxs-lookup"><span data-stu-id="2de18-408">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="2de18-409">Um enumerador permanece válido desde que a coleção continue inalterada.</span><span class="sxs-lookup"><span data-stu-id="2de18-409">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="2de18-410">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</span><span class="sxs-lookup"><span data-stu-id="2de18-410">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="2de18-411">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="2de18-411">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="2de18-412">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="2de18-412">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="2de18-413">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</span><span class="sxs-lookup"><span data-stu-id="2de18-413">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="2de18-414">As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="2de18-414">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="2de18-415">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-415">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-416">Retorna um enumerador que itera em uma coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-416">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="2de18-417">Um objeto <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-417">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-418">A instrução `foreach` da linguagem C# (`for each` em C++, `For Each` no Visual Basic) oculta a complexidade de enumeradores.</span><span class="sxs-lookup"><span data-stu-id="2de18-418">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="2de18-419">Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.</span><span class="sxs-lookup"><span data-stu-id="2de18-419">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="2de18-420">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</span><span class="sxs-lookup"><span data-stu-id="2de18-420">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="2de18-421">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</span><span class="sxs-lookup"><span data-stu-id="2de18-421">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="2de18-422"><xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.</span><span class="sxs-lookup"><span data-stu-id="2de18-422"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="2de18-423">Nesta posição, o <xref:System.Collections.IEnumerator.Current%2A> propriedade está definida.</span><span class="sxs-lookup"><span data-stu-id="2de18-423">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="2de18-424">Por isso, você deve chamar o método <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-424">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="2de18-425">O <xref:System.Collections.IEnumerator.Current%2A> propriedade retorna o mesmo objeto até que o <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="2de18-425">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="2de18-426"><xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.</span><span class="sxs-lookup"><span data-stu-id="2de18-426"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="2de18-427">Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="2de18-427">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="2de18-428">Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`.</span><span class="sxs-lookup"><span data-stu-id="2de18-428">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="2de18-429">Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="2de18-429">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="2de18-430">Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-430">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="2de18-431">Um enumerador permanece válido desde que a coleção continue inalterada.</span><span class="sxs-lookup"><span data-stu-id="2de18-431">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="2de18-432">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</span><span class="sxs-lookup"><span data-stu-id="2de18-432">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="2de18-433">O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="2de18-433">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="2de18-434">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="2de18-434">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="2de18-435">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</span><span class="sxs-lookup"><span data-stu-id="2de18-435">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="2de18-436">As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="2de18-436">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="2de18-437">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="2de18-437">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="2de18-438">Define a capacidade de um objeto <see cref="T:System.Collections.Generic.HashSet`1" /> para o número real de elementos que ele contém, arredondado para cima para um valor próximo específico da implementação.</span><span class="sxs-lookup"><span data-stu-id="2de18-438">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-439">Você pode usar o <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> método minimizar uma <xref:System.Collections.Generic.HashSet%601> sobrecarga de memória do objeto quando se sabe que nenhum novo elemento será adicionado.</span><span class="sxs-lookup"><span data-stu-id="2de18-439">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="2de18-440">Limpar completamente uma <xref:System.Collections.Generic.HashSet%601> de objeto e liberar memória de todos os referenciados por ele, chamar este método depois de chamar o <xref:System.Collections.Generic.HashSet%601.Clear%2A> método.</span><span class="sxs-lookup"><span data-stu-id="2de18-440">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="2de18-441">Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="2de18-441">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-442">O exemplo a seguir cria e preenche um <xref:System.Collections.Generic.HashSet%601> coleção e limpa a coleção e libera a memória referenciada por ele.</span><span class="sxs-lookup"><span data-stu-id="2de18-442">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue"><span data-ttu-id="2de18-443">O valor a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="2de18-443">The value to search for.</span></span></param>
        <param name="actualValue"><span data-ttu-id="2de18-444">O valor do conjunto encontrado pela pesquisa ou o valor padrão de T quando a pesquisa não gera correspondência.</span><span class="sxs-lookup"><span data-stu-id="2de18-444">The value from the set that the search found, or the default value of T when the search yielded no match.</span></span></param>
        <summary><span data-ttu-id="2de18-445">Pesquisa um determinado valor no conjunto e retorna o valor igual que for encontrado, se houver.</span><span class="sxs-lookup"><span data-stu-id="2de18-445">Searches the set for a given value and returns the equal value it finds, if any.</span></span></summary>
        <returns><span data-ttu-id="2de18-446">Um valor que indica se a pesquisa foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="2de18-446">A value indicating whether the search was successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-447">Isso pode ser útil quando você quiser reutilizar uma referência armazenada anteriormente em vez de um recentemente construído (de forma que pode ocorrer mais de compartilhamento de referências) ou para pesquisar um valor que tem mais completar os dados que o valor que você tem, embora suas funções de comparador indicam que eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="2de18-447">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="2de18-448">A coleção a ser comparada com o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual.</span><span class="sxs-lookup"><span data-stu-id="2de18-448">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="2de18-449">Modifica o objeto <see cref="T:System.Collections.Generic.HashSet`1" /> atual para que ele contenha todos os elementos presentes nele, na coleção especificada ou em ambos.</span><span class="sxs-lookup"><span data-stu-id="2de18-449">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2de18-450">Esse método é um O (`n`) operação, onde `n` é o número de elementos de `other` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="2de18-450">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2de18-451">O exemplo a seguir demonstra como mesclar dois conjuntos distintos.</span><span class="sxs-lookup"><span data-stu-id="2de18-451">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="2de18-452">Este exemplo cria dois <xref:System.Collections.Generic.HashSet%601> objetos e a preenche com números e ímpares, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="2de18-452">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="2de18-453">Um terceiro <xref:System.Collections.Generic.HashSet%601> objeto é criado a partir do conjunto que contém os números pares.</span><span class="sxs-lookup"><span data-stu-id="2de18-453">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="2de18-454">O exemplo, em seguida, chama o <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método, que adiciona o número ímpar definido para o terceiro conjunto.</span><span class="sxs-lookup"><span data-stu-id="2de18-454">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2de18-455"><paramref name="other" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2de18-455"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>