<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c8b70f84f6227059b8b978c586d8a6659cab5711" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39793667" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">O tipo dos elementos na lista.</typeparam>
    <summary>Representa uma lista fortemente tipada de objetos que podem ser acessados por índice. Fornece métodos para pesquisar, classificar e manipular listas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> classe é o equivalente genérico a <xref:System.Collections.ArrayList> classe. Ele implementa o <xref:System.Collections.Generic.IList%601> interface genérica usando uma matriz cujo tamanho é aumentado dinamicamente conforme necessário.  
  
 Você pode adicionar itens a um <xref:System.Collections.Generic.List%601> usando o <xref:System.Collections.Generic.List%601.Add%2A> ou <xref:System.Collections.Generic.List%601.AddRange%2A> métodos.  
  
 O <xref:System.Collections.Generic.List%601> classe usa um comparador de igualdade e um comparador de classificação.  
  
-   Métodos como <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, e <xref:System.Collections.Generic.Dictionary%602.Remove%2A> usam um comparador de igualdade para os elementos de lista. O comparador de igualdade padrão para o tipo `T` é determinado da seguinte maneira. Se tipo `T` implementa o <xref:System.IEquatable%601> interface genérica, então o comparador de igualdade será o <xref:System.IEquatable%601.Equals%28%600%29> método dessa interface; caso contrário, o comparador de igualdade padrão é <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Métodos como <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> usam um comparador de classificação para os elementos de lista. O comparador padrão para o tipo `T` é determinado da seguinte maneira.  Se tipo `T` implementa o <xref:System.IComparable%601> interface genérica, então o comparador padrão será o <xref:System.IComparable%601.CompareTo%28%600%29> método dessa interface; caso contrário, se tipo `T` implementa não genérica <xref:System.IComparable> interface e, em seguida, o padrão comparador é o <xref:System.IComparable.CompareTo%28System.Object%29> método dessa interface. Se tipo `T` implementa nenhuma interface, em seguida, não há nenhum comparador padrão e um delegado de comparação ou de comparador deve ser fornecido explicitamente.  
  
 O <xref:System.Collections.Generic.List%601> não é garantida a serem classificados.  Você deve classificar as <xref:System.Collections.Generic.List%601> antes de executar operações (como <xref:System.Collections.Generic.List%601.BinarySearch%2A>) que exigem o <xref:System.Collections.Generic.List%601> a serem classificados.  
  
 Elementos nesta coleção podem ser acessados usando um índice de inteiro.  Nesta coleção, os índices são baseados em zero.  
  
 Para grandes <xref:System.Collections.Generic.List%601> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits, definindo o `enabled` atributo do elemento de configuração para `true` no ambiente de tempo de execução.  
  
 <xref:System.Collections.Generic.List%601> aceita `null` como um valor válido para a referência de tipos e permite elementos duplicados.  
  
 Para uma versão imutável do <xref:System.Collections.Generic.List%601> classe, consulte <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Ao decidir se deve usar o <xref:System.Collections.Generic.List%601> ou <xref:System.Collections.ArrayList> classe, sendo que ambos têm funcionalidade semelhante, lembre-se de que o <xref:System.Collections.Generic.List%601> classe executa melhor na maioria dos casos e é do tipo seguro. Se um tipo de referência é usado para o tipo `T` do <xref:System.Collections.Generic.List%601> classe, o comportamento das duas classes é idêntico. No entanto, se um tipo de valor é usado para o tipo `T`, você precisa considerar a implementação e problemas de conversão boxing.  
  
 Se um tipo de valor é usado para o tipo `T`, o compilador gera uma implementação do <xref:System.Collections.Generic.List%601> classe especificamente para esse tipo de valor. Isso significa que um elemento de lista de um <xref:System.Collections.Generic.List%601> objeto não tem que ser boxed antes que o elemento pode ser usado, e depois de aproximadamente 500 elementos da lista são criados a memória economizada não conversão boxing de elementos da lista é maior que a memória usada para gerar a implementação da classe.  
  
 Certifique-se o tipo de valor usado para o tipo `T` implementa o <xref:System.IEquatable%601> interface genérica. Se não, os métodos, tais como <xref:System.Collections.Generic.List%601.Contains%2A> deve chamar o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, que o elemento afetado list-caixas. Se o tipo de valor implementa a <xref:System.IComparable> interface e você possuir o código-fonte, também implementam as <xref:System.IComparable%601> interface genérica para impedir que o <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> métodos de conversão boxing de elementos da lista. Se você não possui o código-fonte, passe uma <xref:System.Collections.Generic.IComparer%601> do objeto para o <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> métodos  
  
 É vantajoso usar a implementação do tipo específico do <xref:System.Collections.Generic.List%601> classe em vez de usar o <xref:System.Collections.ArrayList> classe ou escrever uma coleção de wrapper fortemente tipado por conta própria. O motivo pelo qual é sua implementação deve fazer o que o .NET Framework faz para você já, e o common language runtime pode compartilhar código Microsoft intermediate language e metadados, que não pode ser sua implementação.  
  
## <a name="f-considerations"></a>Considerações sobre o F #  
 O <xref:System.Collections.Generic.List%601> classe é usada com pouca frequência no código F #.  Em vez disso, [lista](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), que são listas imutáveis, vinculada exclusivamente, são geralmente preferido. Uma lista de F # fornece uma série imutável, ordenada, de valores e há suporte para uso no desenvolvimento de estilo funcional. Quando usado com F #, o <xref:System.Collections.Generic.List%601> classe costuma ser referenciado pela [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) abreviação para evitar conflitos com listas do F # de nomenclatura de tipo  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 O exemplo a seguir demonstra várias propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica do tipo cadeia de caracteres. (Para obter um exemplo de uma <xref:System.Collections.Generic.List%601> dos tipos complexos, consulte o <xref:System.Collections.Generic.List%601.Contains%2A> método.)  
  
 O construtor padrão é usado para criar uma lista de cadeias de caracteres com a capacidade padrão. O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida e, em seguida, o <xref:System.Collections.Generic.List%601.Add%2A> método é usado para adicionar vários itens. Os itens são listados e o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente, juntamente com o <xref:System.Collections.Generic.List%601.Count%2A> propriedade, para mostrar que a capacidade foi aumentada conforme necessário.  
  
 O <xref:System.Collections.Generic.List%601.Contains%2A> método é usado para testar a presença de um item na lista, o <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir um novo item no meio da lista, e o conteúdo da lista é exibido novamente.  
  
 O padrão <xref:System.Collections.Generic.List%601.Item%2A> propriedade (o indexador em c#) é usada para recuperar um item, o <xref:System.Collections.Generic.List%601.Remove%2A> método é usado para remover a primeira instância do item duplicado adicionado anteriormente, e o conteúdo é exibido novamente. O <xref:System.Collections.Generic.List%601.Remove%2A> método sempre remove a primeira instância encontra.  
  
 O <xref:System.Collections.Generic.List%601.TrimExcess%2A> método é usado para reduzir a capacidade de corresponder à contagem e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas. Se a capacidade não utilizada tivesse sido menor que 10% da capacidade total, a lista seria não ter foi redimensionada.  
  
 Por fim, o <xref:System.Collections.Generic.List%601.Clear%2A> método é usado para remover todos os itens da lista e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
É seguro executar várias operações de leitura em um <see cref="T:System.Collections.Generic.List`1" />, mas podem ocorrer problemas se a coleção é modificada enquanto ele está sendo lido. Para garantir acesso thread-safe, bloquear a coleção durante uma leitura ou operação de gravação. Para habilitar uma coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização. Para coleções com sincronização interna, consulte as classes de <see cref="N:System.Collections.Concurrent" /> namespace. Para obter uma alternativa inerentemente thread-safe, consulte o <see cref="T:System.Collections.Immutable.ImmutableList`1" /> classe.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" /> que está vazia e tem a capacidade inicial padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Generic.List%601> é o número de elementos que o <xref:System.Collections.Generic.List%601> pode conter. Como os elementos são adicionados a um <xref:System.Collections.Generic.List%601>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser previsto, usando o <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> construtor e especificando a capacidade inicial elimina a necessidade de realizar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Generic.List%601>.  
  
 A capacidade pode ser diminuída chamando o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou definindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade explicitamente. Diminuindo a capacidade de realocar a memória e copia todos os elementos de <xref:System.Collections.Generic.List%601>.  
  
 Este construtor é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o construtor padrão da <xref:System.Collections.Generic.List%601> classe genérica. O construtor padrão cria uma lista com a capacidade padrão, conforme demonstrado, exibindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade.  
  
 O exemplo adiciona, insere e remove itens, mostrando como a capacidade muda à medida que esses métodos são usados.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção cujos elementos são copiados para a nova lista.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" />, que contém os elementos copiados da coleção especificada e tem capacidade suficiente para acomodar o número de elementos copiados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são copiados para o <xref:System.Collections.Generic.List%601> na mesma ordem que são lidas pelo enumerador da coleção.  
  
 Este construtor é um O (*n*) a operação, onde *n* é o número de elementos em `collection`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.%23ctor%2A> construtor e vários métodos do <xref:System.Collections.Generic.List%601> que atuam em intervalos de classe. Uma matriz de cadeias de caracteres é criada e passada para o construtor, popular a lista com os elementos da matriz. O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade, em seguida, é exibida para mostrar que a capacidade inicial é exatamente o que é necessário para manter os elementos de entrada.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O número de elementos que a nova lista pode armazenar inicialmente.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" /> que está vazia e tem a capacidade inicial especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Generic.List%601> é o número de elementos que o <xref:System.Collections.Generic.List%601> pode conter. Como os elementos são adicionados a um <xref:System.Collections.Generic.List%601>, a capacidade é aumentada automaticamente conforme necessário, realocando a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Generic.List%601>.  
  
 A capacidade pode ser diminuída chamando o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou definindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade explicitamente. Diminuindo a capacidade de realocar a memória e copia todos os elementos de <xref:System.Collections.Generic.List%601>.  
  
 Este construtor é um O (*n*) a operação, onde *n* é `capacity`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> construtor. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres com uma capacidade de 4 é criada, porque o tamanho final da lista é conhecido por ser exatamente 4. A lista é preenchida com quatro cadeias de caracteres e uma cópia somente leitura é criada usando o <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser adicionado ao final do <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Adiciona um objeto ao final do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> aceita `null` como um valor válido para a referência de tipos e permite elementos duplicados.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> já for igual a <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando a matriz interna, e os elementos existentes são copiados para a nova matriz antes do novo elemento é adicionado.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> é menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é uma operação de (1). Se a capacidade precisar ser aumentada para acomodar o novo elemento, esse método se torna um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 O exemplo a seguir demonstra várias propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica, incluindo o <xref:System.Collections.Generic.List%601.Add%2A> método. O construtor padrão é usado para criar uma lista de cadeias de caracteres com uma capacidade igual a 0. O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida e, em seguida, o <xref:System.Collections.Generic.List%601.Add%2A> método é usado para adicionar vários itens. Os itens são listados e o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente, juntamente com o <xref:System.Collections.Generic.List%601.Count%2A> propriedade, para mostrar que a capacidade foi aumentada conforme necessário.  
  
 Outras propriedades e métodos são usados para pesquisar, inserir e remover elementos de lista e, finalmente, para limpar a lista.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção cujos elementos devem ser adicionados ao final do <see cref="T:System.Collections.Generic.List`1" />. A coleção em si não pode ser <see langword="null" />, mas poderá conter elementos que são <see langword="null" />, se tipo <c>T</c> for um tipo de referência.</param>
        <summary>Adiciona os elementos da coleção especificada ao final do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos elementos na coleção é preservada no <xref:System.Collections.Generic.List%601>.  
  
 Se o novo <xref:System.Collections.Generic.List%601.Count%2A> (atual <xref:System.Collections.Generic.List%601.Count%2A> mais o tamanho da coleção) será maior que <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando a matriz interna para acomodar os novos elementos e o os elementos existentes são copiados para a nova matriz antes dos novos elementos adicionados.  
  
 Se o <xref:System.Collections.Generic.List%601> pode acomodar os novos elementos sem aumentar os <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é um O (*n*) operação, onde *n* é o número de elementos a serem adicionados. Se a capacidade precisar ser aumentada para acomodar os novos elementos, esse método se torna um O (*n* + *m*) a operação, onde *n* é o número de elementos a ser adicionado e *m* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.AddRange%2A> método e vários outros métodos do <xref:System.Collections.Generic.List%601> que atuam em intervalos de classe. Uma matriz de cadeias de caracteres é criada e passada para o construtor, popular a lista com os elementos da matriz. O <xref:System.Collections.Generic.List%601.AddRange%2A> método é chamado, com a lista como seu argumento. O resultado é que os elementos atuais da lista são adicionados ao final da lista, duplicar todos os elementos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> somente leitura para a coleção atual.</summary>
        <returns>Um objeto que atua como um wrapper somente leitura em torno do <see cref="T:System.Collections.Generic.List`1" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para impedir que todas as modificações a <xref:System.Collections.Generic.List%601> de objeto, expô-lo por meio desse wrapper. Um <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> objeto não expõe métodos que modificam a coleção. No entanto, se forem feitas alterações para subjacente <xref:System.Collections.Generic.List%601> do objeto, a coleção somente leitura reflete essas alterações.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres com uma capacidade de 4 é criada, porque o tamanho final da lista é conhecido por ser exatamente 4. A lista é preenchida com quatro cadeias de caracteres e o <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método é usado para obter um somente leitura <xref:System.Collections.Generic.IList%601> implementação da interface genérica que encapsula a lista original.  
  
 Um elemento da lista original é definido para "Coelophysis" usando o <xref:System.Collections.Generic.List%601.Item%2A> propriedade (o indexador em c#) e o conteúdo da lista somente leitura é exibidos novamente para demonstrar que ela é apenas um wrapper para a lista original.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usa um algoritmo de pesquisa binária para localizar um elemento específico no <see cref="T:System.Collections.Generic.List`1" /> classificado ou parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Pesquisa todo o <see cref="T:System.Collections.Generic.List`1" /> classificado para um elemento usando o comparador padrão e retorna o índice baseado em zero do elemento.</summary>
        <returns>O índice baseado em zero da <paramref name="item" /> no <see cref="T:System.Collections.Generic.List`1" /> classificado, se <paramref name="item" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="item" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> para o tipo `T` para determinar a ordem dos elementos da lista. O <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verificações de propriedade se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Collections.Generic.List%601> já devem ser classificados de acordo com a implementação de comparador; caso contrário, o resultado é incorreto.  
  
 Comparando `null` com qualquer referência de tipo é permitido e não gera uma exceção ao usar o <xref:System.IComparable%601> interface genérica. Durante a classificação, `null` é considerado menor que qualquer outro objeto.  
  
 Se o <xref:System.Collections.Generic.List%601> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.  
  
 Caso o <xref:System.Collections.Generic.List%601> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento maior que o valor de pesquisa. Ao inserir o valor para o <xref:System.Collections.Generic.List%601>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.  
  
 Esse método é um O (log *n*) a operação, onde *n* é o número de elementos no intervalo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga de método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, sem nenhuma ordem específica. A lista é exibida, classificada e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga do método é usada para procurar por duas cadeias de caracteres que não estão na lista, e o <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inseri-los. O valor de retorno de <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> método é negativo em cada caso, porque as cadeias de caracteres não estão na lista. Levando o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) disso produz número negativo, o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa e inserção neste local preserva a classificação ordem. A segunda cadeia de caracteres de pesquisa é maior que qualquer elemento na lista, portanto, a posição de inserção é no final da lista.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Pesquisa um elemento em todo o <see cref="T:System.Collections.Generic.List`1" /> classificado usando o comparador especificado e retorna o índice baseado em zero do elemento.</summary>
        <returns>O índice baseado em zero da <paramref name="item" /> no <see cref="T:System.Collections.Generic.List`1" /> classificado, se <paramref name="item" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="item" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação personaliza como os elementos são comparados. Por exemplo, você pode usar um <xref:System.Collections.CaseInsensitiveComparer> instância como o comparador para executar pesquisas de cadeia de caracteres diferencia maiusculas de minúsculas.  
  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança <xref:System.InvalidOperationException>.  
  
 O <xref:System.Collections.Generic.List%601> já devem ser classificados de acordo com a implementação de comparador; caso contrário, o resultado é incorreto.  
  
 Comparando `null` com qualquer referência de tipo é permitido e não gera uma exceção ao usar o <xref:System.IComparable%601> interface genérica. Durante a classificação, `null` é considerado menor que qualquer outro objeto.  
  
 Se o <xref:System.Collections.Generic.List%601> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.  
  
 Caso o <xref:System.Collections.Generic.List%601> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento maior que o valor de pesquisa. Ao inserir o valor para o <xref:System.Collections.Generic.List%601>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.  
  
 Esse método é um O (log *n*) a operação, onde *n* é o número de elementos no intervalo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método.  
  
 O exemplo define uma comparação alternativa para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que um não-nulo. Em segundo lugar, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais é considerada como sendo maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, sem nenhuma ordem específica. A lista é exibida, classificada usando o comparador alternativo e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar várias cadeias de caracteres que não estão na lista, empregando o comparador alternativo. O <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir as cadeias de caracteres. Esses dois métodos estão localizados na função nomeada `SearchAndInsert`, junto com o código para levar o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado por <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e usá-lo como um índice para Inserir nova cadeia de caracteres.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero inicial do intervalo a ser pesquisado.</param>
        <param name="count">O tamanho do intervalo a ser procurado.</param>
        <param name="item">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Pesquisa um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> classificado para encontrar um elemento que usa o comparador especificado e retorna o índice baseado em zero do elemento.</summary>
        <returns>O índice baseado em zero da <paramref name="item" /> no <see cref="T:System.Collections.Generic.List`1" /> classificado, se <paramref name="item" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="item" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação personaliza como os elementos são comparados. Por exemplo, você pode usar um <xref:System.Collections.CaseInsensitiveComparer> instância como o comparador para executar pesquisas de cadeia de caracteres diferencia maiusculas de minúsculas.  
  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança <xref:System.InvalidOperationException>.  
  
 O <xref:System.Collections.Generic.List%601> já devem ser classificados de acordo com a implementação de comparador; caso contrário, o resultado é incorreto.  
  
 Comparando `null` com qualquer referência de tipo é permitido e não gera uma exceção ao usar o <xref:System.IComparable%601> interface genérica. Durante a classificação, `null` é considerado menor que qualquer outro objeto.  
  
 Se o <xref:System.Collections.Generic.List%601> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.  
  
 Caso o <xref:System.Collections.Generic.List%601> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento maior que o valor de pesquisa. Ao inserir o valor para o <xref:System.Collections.Generic.List%601>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.  
  
 Esse método é um O (log *n*) a operação, onde *n* é o número de elementos no intervalo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método.  
  
 O exemplo define uma comparação alternativa para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que um não-nulo. Em segundo lugar, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais é considerada como sendo maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com os nomes de dinossauros herbivorous cinco e três dinossauros carnivorous. Dentro de cada um dos dois grupos, os nomes não são em qualquer ordem de classificação específico. A lista é exibida, o intervalo de herbivores é classificado usando o comparador alternativo e a lista é exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar somente o intervalo de herbivores "Brachiosaurus". A cadeia de caracteres não for encontrada e o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado pelo <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> método é usado como um índice para a nova cadeia de caracteres de inserção.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número total de elementos que a estrutura de dados interna pode manter sem redimensionamento.</summary>
        <value>O número de elementos que <see cref="T:System.Collections.Generic.List`1" /> pode conter antes que o redimensionamento seja necessário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> é o número de elementos que o <xref:System.Collections.Generic.List%601> pode armazenar antes de redimensionamento seja necessário, enquanto <xref:System.Collections.Generic.List%601.Count%2A> é o número de elementos que estão realmente no <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> é sempre maior que ou igual a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> excede <xref:System.Collections.Generic.List%601.Capacity%2A> durante a adição de elementos, o aumento da capacidade, automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.  
  
 Se a capacidade é significativamente maior do que a contagem de e para reduzir a memória usada pelo <xref:System.Collections.Generic.List%601>, você pode diminuir a capacidade por meio da chamada a <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou definindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade explicitamente como um valor menor. Quando o valor de <xref:System.Collections.Generic.List%601.Capacity%2A> for definido explicitamente, a matriz interna é realocada também para acomodar a capacidade especificada e todos os elementos são copiados.  
  
 Recuperando o valor dessa propriedade é uma operação de (1); configuração da propriedade é um O (*n*) a operação, onde *n* é a nova capacidade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como verificar a capacidade e contagem de um <xref:System.Collections.Generic.List%601> que contém um objeto comercial simples e ilustra o uso de <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para remover a capacidade extra.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 A exemplo a seguir mostra o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade em vários pontos na vida de uma lista. O construtor padrão é usado para criar uma lista de cadeias de caracteres com uma capacidade igual a 0 e o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida para demonstrar isso. Após o <xref:System.Collections.Generic.List%601.Add%2A> método ter sido usado para adicionar vários itens, os itens são listados e, em seguida, o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente, juntamente com o <xref:System.Collections.Generic.List%601.Count%2A> propriedade, para mostrar que a capacidade foi aumentada conforme necessário.  
  
 O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente após o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método é usado para reduzir a capacidade de corresponder à contagem. Por fim, o <xref:System.Collections.Generic.List%601.Clear%2A> método é usado para remover todos os itens da lista e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas novamente.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.List`1.Capacity" /> é definido como um valor menor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível no sistema.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os elementos do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> é definido como 0, e referências a outros objetos de elementos da coleção também são liberadas.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> permanece inalterado. Para redefinir a capacidade do <xref:System.Collections.Generic.List%601>, chamar o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou um conjunto de <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade diretamente. Diminuindo a capacidade de realocar a memória e copia todos os elementos de <xref:System.Collections.Generic.List%601>. Cortar um vazio <xref:System.Collections.Generic.List%601> define a capacidade do <xref:System.Collections.Generic.List%601> para a capacidade padrão.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Clear%2A> método e várias outras propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica. O <xref:System.Collections.Generic.List%601.Clear%2A> método é usado no final do programa, para remover todos os itens da lista e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades, em seguida, são exibidas.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Determina se um elemento está no <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> for encontrado no <see cref="T:System.Collections.Generic.List`1" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão, conforme definido pela implementação do objeto do <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método para `T` (o tipo de valores na lista).  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> métodos em um <xref:System.Collections.Generic.List%601> que contém um objeto comercial simples que implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 O exemplo a seguir contém uma lista de objetos complexos do tipo `Cube`. O `Cube` classe implementa o <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método para que dois cubos são considerados iguais se suas dimensões forem iguais. Neste exemplo, o <xref:System.Collections.Generic.List%601.Contains%2A> método retorna `true`, porque um cubo com as dimensões especificadas já está na coleção.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">O tipo dos elementos da matriz de destino.</typeparam>
        <param name="converter">Um delegado <see cref="T:System.Converter`2" /> que converte cada elemento de um tipo em outro tipo.</param>
        <summary>Converte os elementos no <see cref="T:System.Collections.Generic.List`1" /> atual para outro tipo e retorna uma lista contendo os elementos convertidos.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1" /> do tipo de destino que contém os elementos convertidos do <see cref="T:System.Collections.Generic.List`1" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Converter%602> é um delegado para um método que converte um objeto para o tipo de destino.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Converter%602> delegado e os elementos convertidos são salvos no novo <xref:System.Collections.Generic.List%601>.  
  
 Atual <xref:System.Collections.Generic.List%601> permanece inalterado.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define um método chamado `PointFToPoint` que converte um <xref:System.Drawing.PointF> estrutura para um <xref:System.Drawing.Point> estrutura. O exemplo a seguir cria uma <xref:System.Collections.Generic.List%601> de <xref:System.Drawing.PointF> estruturas, cria um `Converter\<PointF, Point>` delegar (`Converter(Of PointF, Point)` no Visual Basic) para representar o `PointFToPoint` método e passa o delegado para o <xref:System.Collections.Generic.List%601.ConvertAll%2A> método. O <xref:System.Collections.Generic.List%601.ConvertAll%2A> método passa cada elemento da lista de entrada para o `PointFToPoint` método e coloca os elementos convertidos em uma nova lista de <xref:System.Drawing.Point> estruturas. Ambas as listas são exibidas.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia o <see cref="T:System.Collections.Generic.List`1" /> ou parte dele para uma matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <summary>Copia todo o <see cref="T:System.Collections.Generic.List`1" /> em uma matriz unidimensional compatível, a partir do início da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar os elementos.  
  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com cadeias de caracteres de 5. Uma matriz de cadeia de caracteres vazia de 15 elementos é criada e o <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz, começando no primeiro elemento da matriz. O <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz, começando no índice de matriz 6 (deixando vazio de índice 5). Por fim, o <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para copiar elementos de 3 da lista, começando com o índice 2, a matriz que começa em matriz de índice 12 (deixando vazio 11 índice). O conteúdo da matriz é exibido.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos no <see cref="T:System.Collections.Generic.List`1" /> de origem é maior que o número de elementos que o <paramref name="array" /> de destino pode conter.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice baseado em zero na <c>array</c> na qual a cópia começa.</param>
        <summary>Copia todo o <see cref="T:System.Collections.Generic.List`1" /> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar os elementos.  
  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com cadeias de caracteres de 5. Uma matriz de cadeia de caracteres vazia de 15 elementos é criada e o <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz, começando no primeiro elemento da matriz. O <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz, começando no índice de matriz 6 (deixando vazio de índice 5). Por fim, o <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para copiar elementos de 3 da lista, começando com o índice 2, a matriz que começa em matriz de índice 12 (deixando vazio 11 índice). O conteúdo da matriz é exibido.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos na origem <see cref="T:System.Collections.Generic.List`1" /> é maior do que o espaço disponível de <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no <see cref="T:System.Collections.Generic.List`1" /> de origem em que a cópia começa.</param>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice baseado em zero na <c>array</c> na qual a cópia começa.</param>
        <param name="count">O número de elementos a serem copiados.</param>
        <summary>Copia um intervalo de elementos do <see cref="T:System.Collections.Generic.List`1" /> para uma matriz unidimensional compatível, começando pelo índice especificado da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar os elementos.  
  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) a operação, onde *n* é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com cadeias de caracteres de 5. Uma matriz de cadeia de caracteres vazia de 15 elementos é criada e o <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz, começando no primeiro elemento da matriz. O <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz, começando no índice de matriz 6 (deixando vazio de índice 5). Por fim, o <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para copiar elementos de 3 da lista, começando com o índice 2, a matriz que começa em matriz de índice 12 (deixando vazio 11 índice). O conteúdo da matriz é exibido.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="arrayIndex" /> é menor que 0.  
  
- ou - 
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> é igual a ou maior que o <see cref="P:System.Collections.Generic.List`1.Count" /> do <see cref="T:System.Collections.Generic.List`1" /> de origem.  
  
- ou - 
O número de elementos de <paramref name="index" /> até o final do <see cref="T:System.Collections.Generic.List`1" /> de origem é maior que o espaço disponível do <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>O número de elementos contidos no <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> é o número de elementos que o <xref:System.Collections.Generic.List%601> pode armazenar antes de redimensionamento seja necessário. <xref:System.Collections.Generic.List%601.Count%2A> é o número de elementos que estão realmente no <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> é sempre maior que ou igual a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> excede <xref:System.Collections.Generic.List%601.Capacity%2A> durante a adição de elementos, o aumento da capacidade, automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como verificar a capacidade e contagem de um <xref:System.Collections.Generic.List%601> que contém um objeto comercial simples e ilustra o uso de <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para remover a capacidade extra.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 O exemplo a seguir mostra o valor da <xref:System.Collections.Generic.List%601.Count%2A> propriedade em vários pontos na vida de uma lista. Depois que a lista foi criada e preenchida e seus elementos exibidos, o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas. Essas propriedades são exibidas novamente após o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método foi chamado e novamente após o conteúdo da lista é desmarcado.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Determina se o <see cref="T:System.Collections.Generic.List`1" /> contém elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Collections.Generic.List`1" /> contiver um ou mais elementos que correspondem às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegado e o processamento é interrompido quando uma correspondência for encontrada.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> métodos em um <xref:System.Collections.Generic.List%601> que contém um objeto comercial simples que implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Exists%2A> método e vários outros métodos que usam o <xref:System.Predicate%601> delegado genérico.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> métodos são usados para pesquisar a lista com o método de predicado de pesquisa e, em seguida, o <xref:System.Collections.Generic.List%601.RemoveAll%2A> método é usado para remover todas as entradas que terminam com "saurus".  
  
 Por fim, o <xref:System.Collections.Generic.List%601.Exists%2A> método é chamado. Ele percorre a lista desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida e o método retorna `true` se o `EndsWithSaurus` retorno do método `true` para qualquer elemento. O <xref:System.Collections.Generic.List%601.Exists%2A> método retorna `false` porque todos esses elementos foram removidos.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O primeiro elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegado, mais adiante <xref:System.Collections.Generic.List%601>, começando com o primeiro elemento e terminando com o último elemento.  O processamento é interrompido quando uma correspondência for encontrada.  
  
> [!IMPORTANT]
>  Ao procurar uma lista que contém os tipos de valor, verifique se que o valor padrão para o tipo não satisfaz o predicado de pesquisa. Caso contrário, não há nenhuma maneira de distinguir entre um valor de padrão que indica que nenhuma correspondência for encontrada e um elemento de lista que tem o valor padrão para o tipo. Se o valor padrão satisfaz o predicado de pesquisa, use o <xref:System.Collections.Generic.List%601.FindIndex%2A> método em vez disso.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Find%2A> método em um <xref:System.Collections.Generic.List%601> que contém um objeto complexo simple.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados das [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos find.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cuja `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último livro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Recupera todos os elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1" /> que contém todos os elementos que correspondem às condições definidas pelo predicado especificado, se encontrados; caso contrário, um <see cref="T:System.Collections.Generic.List`1" /> vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegado e os elementos que correspondem às condições são salvos no retornado <xref:System.Collections.Generic.List%601>.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados das [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos find.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cuja `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último livro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa um elemento que corresponda às condições definidas por um predicado especificado e retorna o índice baseado em zero da primeira ocorrência no <see cref="T:System.Collections.Generic.List`1" /> ou parte dele. Esse método retornará -1 se não for encontrado um item que corresponda às condições.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para frente, começando no primeiro elemento e termina no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegar. O delegado tem a assinatura:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Employee` classe com dois campos, `Name` e `Id`. Ele também define uma `EmployeeSearch` classe com um único método, `StartsWith`, que indica se o `Employee.Name` campo começa com uma subcadeia de caracteres especificada que é fornecida para o `EmployeeSearch` construtor de classe. Observe a assinatura desse método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde à assinatura do delegado que pode ser passado para o <xref:System.Collections.Generic.List%601.FindIndex%2A> método. O exemplo cria uma instância uma `List<Employee>` de objeto, adiciona um número de `Employee` objetos para ele e, em seguida, chama o <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método duas vezes para pesquisar toda a coleção, na primeira vez para o primeiro `Employee` do objeto cuja `Name` começa de campo com "J" e na segunda vez para a primeira `Employee` do objeto cuja `Name` campo começa com "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que se estende do índice especificado ao último elemento.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para frente, começando em `startIndex` e terminando no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegar. O delegado tem a assinatura:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é o número de elementos da `startIndex` até o final do <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Employee` classe com dois campos, `Name` e `Id`. Ele também define uma `EmployeeSearch` classe com um único método, `StartsWith`, que indica se o `Employee.Name` campo começa com uma subcadeia de caracteres especificada que é fornecida para o `EmployeeSearch` construtor de classe. Observe a assinatura desse método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde à assinatura do delegado que pode ser passado para o <xref:System.Collections.Generic.List%601.FindIndex%2A> método. O exemplo instancia um `List<Employee>` de objeto, adiciona um número de `Employee` objetos para ele e, em seguida, chama o <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método duas vezes para pesquisar a coleção a partir de seu membro quinto (ou seja, o membro no índice 4). Na primeira vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "J"; na segunda vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que coincida com as condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos na <see cref="T:System.Collections.Generic.List`1" /> que começa no índice especificado e contém o número de elementos especificado.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para frente, começando em `startIndex` e termina em `startIndex` plus `count` menos 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegar. O delegado tem a assinatura:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é `count`.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Employee` classe com dois campos, `Name` e `Id`. Ele também define uma `EmployeeSearch` classe com um único método, `StartsWith`, que indica se o `Employee.Name` campo começa com uma subcadeia de caracteres especificada que é fornecida para o `EmployeeSearch` construtor de classe. Observe a assinatura desse método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde à assinatura do delegado que pode ser passado para o <xref:System.Collections.Generic.List%601.FindIndex%2A> método. O exemplo cria uma instância uma `List<Employee>` de objeto, adiciona um número de `Employee` objetos para ele e, em seguida, chama o <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método duas vezes para pesquisar toda a coleção (ou seja, os membros do índice 0 para índice <xref:System.Collections.Generic.List%601.Count%2A> - 1). Na primeira vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "J"; na segunda vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> é menor que 0.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O último elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegado, Voltar no <xref:System.Collections.Generic.List%601>, começando com o último elemento e terminando com o primeiro elemento.  O processamento é interrompido quando uma correspondência for encontrada.  
  
> [!IMPORTANT]
>  Ao procurar uma lista que contém os tipos de valor, verifique se que o valor padrão para o tipo não satisfaz o predicado de pesquisa. Caso contrário, não há nenhuma maneira de distinguir entre um valor de padrão que indica que nenhuma correspondência for encontrada e um elemento de lista que tem o valor padrão para o tipo. Se o valor padrão satisfaz o predicado de pesquisa, use o <xref:System.Collections.Generic.List%601.FindLastIndex%2A> método em vez disso.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados das [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos find.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cuja `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último livro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa um elemento que corresponda às condições definidas por um predicado especificado e retorna o índice baseado em zero da última ocorrência no <see cref="T:System.Collections.Generic.List`1" /> ou parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para trás começando no último elemento e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegar.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados das [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos find.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cuja `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último livro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegar.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é o número de elementos desde o início do <xref:System.Collections.Generic.List%601> para `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa por um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada com versões anteriores começando `startIndex` e termina em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegar.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados das [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ to XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos find.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cuja `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> Exemplo de c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último livro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro livro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> é menor que 0.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">O delegado <see cref="T:System.Action`1" /> a ser executado em cada elemento do <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Executa a ação especificada em cada elemento do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Action%601> é um delegado para um método que executa uma ação no objeto passado para ele.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Action%601> delegar.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modificando a coleção subjacente no corpo do <xref:System.Action%601> delegado não é suportado e causa um comportamento indefinido.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Action%601> delegado para imprimir o conteúdo de um <xref:System.Collections.Generic.List%601> objeto. Neste exemplo o `Print` método é usado para exibir o conteúdo da lista para o console.  
  
> [!NOTE]
>  Além de exibir o conteúdo usando o `Print` método, o exemplo de c# demonstra o uso de exibir os resultados no console.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um elemento na coleção foi modificado.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera por meio de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1.Enumerator" /> para o <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. Nessa posição, o <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propriedade é indefinida. Por isso, você deve chamar o método <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 O <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propriedade retorna o mesmo objeto até <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> é chamado. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> define <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> está indefinido. Não é possível definir <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> como o primeiro elemento da coleção novamente; você deve criar uma nova instância de enumerador em vez disso.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se as alterações são feitas na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> ou <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> lança um <xref:System.InvalidOperationException>.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice <see cref="T:System.Collections.Generic.List`1" /> baseado em zero no qual é iniciado o intervalo.</param>
        <param name="count">O número de elementos no intervalo.</param>
        <summary>Cria uma cópia superficial de um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> de origem.</summary>
        <returns>Uma cópia superficial de um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cópia superficial de uma coleção de tipos de referência, ou um subconjunto da coleção, contém somente as referências aos elementos da coleção. Os objetos em si não são copiados. As referências na nova lista apontam para os mesmos objetos como as referências na lista original.  
  
 Uma cópia superficial de uma coleção de tipos de valor, ou um subconjunto dessa coleção contém os elementos da coleção. No entanto, se os elementos da coleção contêm referências a outros objetos, esses objetos não são copiados. As referências nos elementos da nova coleção apontam para os mesmos objetos como as referências nos elementos da coleção original.  
  
 Em contraste, uma cópia em profundidade de uma coleção copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Esse método é um O (*n*) a operação, onde *n* é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.GetRange%2A> método e outros métodos do <xref:System.Collections.Generic.List%601> que atuam em intervalos de classe. No final do exemplo, o <xref:System.Collections.Generic.List%601.GetRange%2A> método é usado para obter três itens na lista, começando com o local do índice 2. O <xref:System.Collections.Generic.List%601.ToArray%2A> método é chamado em resultante <xref:System.Collections.Generic.List%601>, criando uma matriz de três elementos. Os elementos da matriz são exibidos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido de elementos no <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o índice baseado em zero da primeira ocorrência de um valor no <see cref="T:System.Collections.Generic.List`1" /> ou em uma parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da primeira ocorrência dentro de todo o <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="item" /> em todo o <see cref="T:System.Collections.Generic.List`1" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para frente, começando no primeiro elemento e termina no último elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e o local do índice 5. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga do método pesquisa a lista desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o lista começando com o local do índice 3 e continua até o final da lista e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retornará -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma lista vazia.</param>
        <summary>Procura o objeto especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> que se estende do índice especificado para o último elemento.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="item" /> dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que se estende do <paramref name="index" /> ao último elemento, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para frente, começando em `index` e terminando no último elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é o número de elementos da `index` até o final do <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e o local do índice 5. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga do método pesquisa a lista desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o lista começando com o local do índice 3 e continua até o final da lista e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retornará -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma lista vazia.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da primeira ocorrência em um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que começa no índice especificado e contém o número de elementos especificado.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="item" /> no intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que começa em <paramref name="index" /> e contém o número de elementos <paramref name="count" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para frente, começando em `index` e termina em `index` plus `count` menos 1, se `count` for maior que 0.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e o local do índice 5. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga do método pesquisa a lista desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o lista começando com o local do índice 3 e continua até o final da lista e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retornará -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> é menor que 0.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no qual o <c>item</c> deve ser inserido.</param>
        <param name="item">O objeto a ser inserido. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Insere um elemento no <see cref="T:System.Collections.Generic.List`1" />, no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> aceita `null` como um valor válido para a referência de tipos e permite elementos duplicados.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> já for igual a <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando a matriz interna, e os elementos existentes são copiados para a nova matriz antes do novo elemento é adicionado.  
  
 Se `index` é igual a <xref:System.Collections.Generic.List%601.Count%2A>, `item` é adicionado ao final da <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Insert%2A> método, juntamente com várias outras propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica. Depois que a lista é criada, os elementos são adicionados. O <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir um item no meio da lista. O item inserido é uma duplicata, que é removida posteriormente usando o <xref:System.Collections.Generic.List%601.Remove%2A> método.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="index" /> é maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no qual os novos elementos devem ser inseridos.</param>
        <param name="collection">A coleção cujos elementos devem ser inseridos no <see cref="T:System.Collections.Generic.List`1" />. A coleção em si não pode ser <see langword="null" />, mas poderá conter elementos que são <see langword="null" />, se tipo <c>T</c> for um tipo de referência.</param>
        <summary>Insere os elementos de uma coleção no <see cref="T:System.Collections.Generic.List`1" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> aceita `null` como um valor válido para a referência de tipos e permite elementos duplicados.  
  
 Se o novo <xref:System.Collections.Generic.List%601.Count%2A> (atual <xref:System.Collections.Generic.List%601.Count%2A> mais o tamanho da coleção) será maior que <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando a matriz interna para acomodar os novos elementos e o os elementos existentes são copiados para a nova matriz antes dos novos elementos adicionados.  
  
 Se `index` é igual a <xref:System.Collections.Generic.List%601.Count%2A>, os elementos são adicionados ao final da <xref:System.Collections.Generic.List%601>.  
  
 A ordem dos elementos na coleção é preservada no <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n* * *m*) a operação, onde *n* é o número de elementos a serem adicionados e *m* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra <xref:System.Collections.Generic.List%601.InsertRange%2A> método e vários outros métodos do <xref:System.Collections.Generic.List%601> que atuam em intervalos de classe. Depois que a lista foi criada e preenchida com os nomes dos vários tranquilo destruidores planta dinossauros, o <xref:System.Collections.Generic.List%601.InsertRange%2A> método é usado para inserir uma matriz de três dinossauros um Feroz destruidores Carne na lista, começando no local de índice 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="index" /> é maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice com base em zero do elemento a ser obtido ou definido.</param>
        <summary>Obtém ou define o elemento no índice especificado.</summary>
        <value>O elemento no índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> aceita `null` como um valor válido para a referência de tipos e permite elementos duplicados.  
  
 Esta propriedade fornece a capacidade de acessar um elemento específico na coleção usando a seguinte sintaxe: `myCollection[index]`.  
  
 Recuperando o valor dessa propriedade é uma operação de (1); definindo a propriedade também é uma operação de (1).  
  
   
  
## Examples  
 O exemplo nesta seção demonstra a <xref:System.Collections.Generic.List%601.Item%2A> propriedade (o indexador em c#) e várias outras propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica. Depois que a lista tiver sido criado e preenchido usando o <xref:System.Collections.Generic.List%601.Add%2A> método, um elemento é recuperado e exibido usando o <xref:System.Collections.Generic.List%601.Item%2A> propriedade. (Para obter um exemplo que usa o <xref:System.Collections.Generic.List%601.Item%2A> propriedade para definir o valor de um elemento da lista, consulte <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# e C++ todos têm a sintaxe para acessar o <xref:System.Collections.Generic.List%601.Item%2A> propriedade sem usar seu nome. Em vez disso, a variável que contém o <xref:System.Collections.Generic.List%601> é usado como se fosse uma matriz.  
  
 A linguagem c# usa a palavra-chave para definir os indexadores em vez de implementar o <xref:System.Collections.Generic.List%601.Item%2A> propriedade. Visual Basic implementa <xref:System.Collections.Generic.List%601.Item%2A> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o índice baseado em zero da última ocorrência de um valor no <see cref="T:System.Collections.Generic.List`1" /> ou em uma parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da última ocorrência dentro de todo o <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="item" /> em todo o <see cref="T:System.Collections.Generic.List`1" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para trás começando no último elemento e terminando no primeiro elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e o local do índice 5. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga do método pesquisa a lista inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a lista de versões anteriores, começando com o local do índice 3 e continuando até o início da lista, para que ele localiza a primeira ocorrência da cadeia de caracteres na lista. Por fim, o <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estender para trás (ou seja, ele pesquisa os itens nos locais 4, 3, 2 e 1); essa pesquisa retorna – 1, porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa inversa.</param>
        <summary>Procura o objeto especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="item" /> dentro do intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> que se estende do primeiro elemento a <paramref name="index" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada começando com versões anteriores em `index` e terminando no primeiro elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é o número de elementos desde o início do <xref:System.Collections.Generic.List%601> para `index`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e o local do índice 5. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga do método pesquisa a lista inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a lista de versões anteriores, começando com o local do índice 3 e continuando até o início da lista, para que ele localiza a primeira ocorrência da cadeia de caracteres na lista. Por fim, o <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estender para trás (ou seja, ele pesquisa os itens nos locais 4, 3, 2 e 1); essa pesquisa retorna – 1, porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos na <see cref="T:System.Collections.Generic.List`1" /> que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="item" /> dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que contém a <paramref name="count" /> de número de elementos e termina no <paramref name="index" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada com versões anteriores começando `index` e termina em `index` menos `count` mais 1, se `count` for maior que 0.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas do <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e o local do índice 5. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga do método pesquisa a lista inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a lista de versões anteriores, começando com o local do índice 3 e continuando até o início da lista, para que ele localiza a primeira ocorrência da cadeia de caracteres na lista. Por fim, o <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de entradas de 4, começando no local de índice 4 e estender para trás (ou seja, ele pesquisa os itens nos locais 4, 3, 2 e 1); essa pesquisa retorna – 1, porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
 <paramref name="count" /> é menor que 0.  
  
- ou - 
 <paramref name="index" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a remover do <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> for removido com êxito; caso contrário, <see langword="false" />.  Esse método também retornará <see langword="false" /> se <paramref name="item" /> não tiver sido encontrado no <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `T` implementa o <xref:System.IEquatable%601> interface genérica, o comparador de igualdade será o <xref:System.IEquatable%601.Equals%2A> método dessa interface; caso contrário, o comparador de igualdade padrão é <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 O exemplo a seguir demonstra <xref:System.Collections.Generic.List%601.Remove%2A> método. Várias propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica são usados para adicionar, inserir e pesquisar a lista. Depois que essas operações, a lista contém uma duplicata. O <xref:System.Collections.Generic.List%601.Remove%2A> método é usado para remover a primeira instância do item duplicado e o conteúdo é exibido. O <xref:System.Collections.Generic.List%601.Remove%2A> método sempre remove a primeira instância encontra.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem removidos.</param>
        <summary>Remove todos os elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>O número de elementos removidos de <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegado e os elementos que correspondem às condições são removidos do <xref:System.Collections.Generic.List%601>.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.RemoveAll%2A> método e vários outros métodos que usam o <xref:System.Predicate%601> delegado genérico.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> métodos são usados para pesquisar a lista com o método de predicado de pesquisa.  
  
 O <xref:System.Collections.Generic.List%601.RemoveAll%2A> método é usado para remover todas as entradas que terminam com "saurus". Ele percorre a lista desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. O elemento será removido se o `EndsWithSaurus` retorno do método `true`.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto do contexto e criá-lo automaticamente.  
  
 Por fim, o <xref:System.Collections.Generic.List%601.Exists%2A> método confirma que não há nenhuma cadeias de caracteres na lista que terminam com "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice de base zero do elemento a ser removido.</param>
        <summary>Remove o elemento no índice especificado do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Collections.Generic.List%601.RemoveAt%2A> para remover um item, os itens restantes na lista são renumerados para substituir o item removido. Por exemplo, se você remover o item no índice 3, o item no índice 4 é movido para a posição 3. Além disso, o número de itens na lista (conforme representado pelo <xref:System.Collections.Generic.List%601.Count%2A> propriedade) é reduzida em 1.  
  
 Esse método é um O (*n*) a operação, onde *n* é (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice inicial baseado em zero do intervalo de elementos a serem removidos.</param>
        <param name="count">O número de elementos a serem removidos.</param>
        <summary>Remove um intervalo de elementos do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os itens são removidos e todos os elementos que segui-las na <xref:System.Collections.Generic.List%601> ter seus índices reduzidas `count`.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.RemoveRange%2A> método e vários outros métodos do <xref:System.Collections.Generic.List%601> que atuam em intervalos de classe. Depois que a lista foi criada e modificada, o <xref:System.Collections.Generic.List%601.RemoveRange%2A> método é usado para remover os dois elementos da lista, começando no local de índice 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido de elementos no <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverte a ordem dos elementos no <see cref="T:System.Collections.Generic.List`1" /> em uma parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverte a ordem dos elementos em todo o <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para inverter a ordem dos elementos.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra as duas sobrecargas do <xref:System.Collections.Generic.List%601.Reverse%2A> método. O exemplo cria um <xref:System.Collections.Generic.List%601> de cadeias de caracteres e adiciona seis cadeias de caracteres. O <xref:System.Collections.Generic.List%601.Reverse> sobrecarga do método usada para reverter a lista e, em seguida, o <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> sobrecarga do método usada para reverter o meio da lista, começando com o elemento 1 e que abrange quatro elementos.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice inicial baseado em zero do intervalo a ser revertido.</param>
        <param name="count">O número de elementos no intervalo a serem revertidos.</param>
        <summary>Inverte a ordem dos elementos no intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para inverter a ordem dos elementos.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra as duas sobrecargas do <xref:System.Collections.Generic.List%601.Reverse%2A> método. O exemplo cria um <xref:System.Collections.Generic.List%601> de cadeias de caracteres e adiciona seis cadeias de caracteres. O <xref:System.Collections.Generic.List%601.Reverse> sobrecarga do método usada para reverter a lista e, em seguida, o <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> sobrecarga do método usada para reverter o meio da lista, começando com o elemento 1 e que abrange quatro elementos.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido de elementos no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Classifica os elementos no <see cref="T:System.Collections.Generic.List`1" /> ou parte dele.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>Sintaxe de método sobrecarregada  
 O <xref:System.Collections.Generic.List%601.Sort%2A> métodos permitem que você classifique com o comparador padrão para o tipo de objeto na lista ou especifique um método de classificação do cliente.  
  
 [Lista\<T >. Sort ()](xref:System.Collections.Generic.List`1.Sort*) classifica os elementos em toda a lista usando o comparador padrão do tipo de objeto é mantido na lista.  
  
 [Lista\<T >. Classificação M (comparação\<T > comparação)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) classifica os elementos em toda a lista usando o comparador especificado.  
  
 [Lista\<T >. Classificação (IComparer\<T > comparador)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) classifica os elementos em toda a lista usando especificado <xref:System.Comparison%601?displayProperty=nameWithType>.  
  
 [Lista\<T >. Classificação (índice de Int32, Int32 contagem, IComparer\<T > comparador)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) classifica os elementos em um intervalo de elementos na lista usando o comparador especificado.  
  
## <a name="parameters"></a>Parâmetros  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|O método de delegado a ser usado ao comparar elementos|  
|comparador|<xref:System.Collections.Generic.IComparer%601>|O <xref:System.Collections.Generic.IComparer%601> implementação a ser usada ao comparar elementos ou nulo para usar o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default>.|  
|`index`|<xref:System.Int32>|O índice inicial baseado em zero do intervalo a ser classificado.|  
|`count`|<xref:System.Int32>|O tamanho do intervalo a ser classificado.|  
  
## <a name="exceptions"></a>Exceções  
  
|Exceção|Condição|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer` não foi especificado ou `null`e o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> não é possível encontrar a implementação da <xref:System.IComparable%601?displayProperty=nameWithType> interface genérica ou o <xref:System.IComparable?displayProperty=nameWithType> interface para o tipo T.|  
|<xref:System.ArgumentNullException>|`comparison` é `null`.|  
|<xref:System.ArgumentException>|A implementação de `comparison` ou `comparer` causou um erro durante a classificação. Por exemplo, `comparison` não pode retornar 0 ao comparar um item com ele próprio.<br /><br /> - ou -<br /><br /> `index` e `count` não especificam um intervalo válido no <xref:System.Collections.Generic.List%601>.|  
|<xref:System.ArgumentOutOfRangeException>|`index` é menor que 0 ou `count` é menor que 0.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Classifica os elementos em todo o <see cref="T:System.Collections.Generic.List`1" /> usando o comparador padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> para o tipo `T` para determinar a ordem dos elementos da lista. O <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verificações de propriedade se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 Esse método usa o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um algoritmo de classificação de inserção.  
  
-   Se o log 2 excede o número de partições *n*, onde *n* é o intervalo da matriz de entrada, ele usa um algoritmo de Heapsort.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (*n* log *n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n* <sup>2</sup>) operação.  
  
   
  
## Examples  
 O exemplo a seguir adiciona alguns nomes para um `List<String>` object, exibe a lista em ordem classificada, chama o <xref:System.Collections.Generic.List%601.Sort%2A> método e, em seguida, exibe a lista classificada.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 O código a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort> e <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecargas de método em um objeto de negócios simples. Chamar o <xref:System.Collections.Generic.List%601.Sort> método resulta no uso do comparador padrão para o tipo de parte e o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> método é implementado usando um método anônimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga de método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, sem nenhuma ordem específica. A lista é exibida, classificada e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga do método é usada para procurar por duas cadeias de caracteres que não estão na lista, e o <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inseri-los. O valor de retorno de <xref:System.Collections.Generic.List%601.BinarySearch%2A> método é negativo em cada caso, porque as cadeias de caracteres não estão na lista. Levando o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) disso produz número negativo, o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa e inserção neste local preserva a classificação ordem. A segunda cadeia de caracteres de pesquisa é maior que qualquer elemento na lista, portanto, a posição de inserção é no final da lista.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Classifica os elementos em todo o <see cref="T:System.Collections.Generic.List`1" /> usando o comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são classificadas usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 Esse método usa o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um algoritmo de classificação de inserção.  
  
-   Se o log 2 excede o número de partições *n*, onde *n* é o intervalo da matriz de entrada, ele usa um algoritmo de Heapsort.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (*n* log *n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n* <sup>2</sup>) operação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método.  
  
 O exemplo define uma comparação alternativa para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que um não-nulo. Em segundo lugar, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais é considerada como sendo maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, sem nenhuma ordem específica. A lista é exibida, classificada usando o comparador alternativo e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar várias cadeias de caracteres que não estão na lista, empregando o comparador alternativo. O <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir as cadeias de caracteres. Esses dois métodos estão localizados na função nomeada `SearchAndInsert`, junto com o código para levar o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado por <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e usá-lo como um índice para Inserir nova cadeia de caracteres.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não pode encontrar a implementação da interface genérica <see cref="T:System.IComparable`1" /> ou da interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</param>
        <summary>Classifica os elementos em todo o <see cref="T:System.Collections.Generic.List`1" /> usando o <see cref="T:System.Comparison`1" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparison` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são classificados usando o método representado pelo delegado.  
  
 Se `comparison` está `null`, um <xref:System.ArgumentNullException> é gerada.  
  
 Esse método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um algoritmo de classificação de inserção  
  
-   Se o log 2 excede o número de partições *n*, onde *n* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (*n* log *n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n* <sup>2</sup>) operação.  
  
   
  
## Examples  
 O código a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> sobrecargas de método em um objeto de negócios simples. Chamar o <xref:System.Collections.Generic.List%601.Sort%2A> método resulta no uso do comparador padrão para o tipo de parte e o <xref:System.Collections.Generic.List%601.Sort%2A> método é implementado usando um método anônimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga de método.  
  
 O exemplo define um método de comparação alternativa para cadeias de caracteres, chamado `CompareDinosByLength`. Esse método funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que um não-nulo. Em segundo lugar, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais é considerada como sendo maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, sem nenhuma ordem específica. A lista também inclui uma cadeia de caracteres vazia e uma referência nula. A lista é exibida, classificada usando um <xref:System.Comparison%601> delegado genérico que representa o `CompareDinosByLength` método e exibida novamente.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparison" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparison" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <altmember cref="T:System.Comparison`1" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">O índice inicial baseado em zero do intervalo a ser classificado.</param>
        <param name="count">O tamanho do intervalo a ser classificado.</param>
        <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Classifica os elementos em um intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> usando o comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são classificadas usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` está `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 Esse método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um algoritmo de classificação de inserção  
  
-   Se o log 2 excede o número de partições *n*, onde *n* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (*n* log *n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n* <sup>2</sup>) operação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método.  
  
 O exemplo define uma comparação alternativa para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que um não-nulo. Em segundo lugar, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais é considerada como sendo maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com os nomes de dinossauros herbivorous cinco e três dinossauros carnivorous. Dentro de cada um dos dois grupos, os nomes não são em qualquer ordem de classificação específico. A lista é exibida, o intervalo de herbivores é classificado usando o comparador alternativo e a lista é exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar somente o intervalo de herbivores "Brachiosaurus". A cadeia de caracteres não for encontrada e o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado pelo <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> método é usado como um índice para a nova cadeia de caracteres de inserção.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
- ou - 
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não especificam um intervalo válido no <see cref="T:System.Collections.Generic.List`1" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não pode encontrar a implementação da interface genérica <see cref="T:System.IComparable`1" /> ou da interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Collections.Generic.ICollection`1" /> é somente leitura.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Collections.Generic.ICollection`1" /> for somente leitura; caso contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera em uma coleção.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerator`1" /> que pode ser usado para iterar pela coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. Nessa posição, o <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriedade é indefinida. Por isso, você deve chamar o método <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 O <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriedade retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> é chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.Generic.IEnumerator%601.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está indefinido. Não é possível definir <xref:System.Collections.Generic.IEnumerator%601.Current%2A> como o primeiro elemento da coleção novamente; você deve criar uma nova instância de enumerador em vez disso.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se as alterações são feitas na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lança um <xref:System.InvalidOperationException>.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.ICollection" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice baseado em zero na <c>array</c> na qual a cópia começa.</param>
        <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para um <see cref="T:System.Array" />, começando em um determinado índice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se o tipo da fonte de <xref:System.Collections.ICollection> não pode ser convertido automaticamente para o tipo de destino `array`, as implementações não genéricas <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> lançar <xref:System.InvalidCastException>, enquanto as implementações de genéricas geram <xref:System.ArgumentException>.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional.  
  
- ou - 
 O <paramref name="array" /> não tem indexação baseada em zero.  
  
- ou - 
O número de elementos na origem <see cref="T:System.Collections.ICollection" /> é maior do que o espaço disponível de <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.  
  
- ou - 
O tipo do <see cref="T:System.Collections.ICollection" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Collections.ICollection" /> é sincronizado (thread-safe).</summary>
        <value>
          <see langword="true" /> caso o acesso ao <see cref="T:System.Collections.ICollection" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  No caso raro em que a enumeração compete com os acessos de gravação, você pode bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Retorna um objeto que pode ser usado para sincronizar o acesso para o <xref:System.Collections.ICollection>. A sincronização é eficaz somente se todos os threads bloquear este objeto antes de acessar a coleção.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.  Na implementação padrão da <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna a instância atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Retorna um objeto que pode ser usado para sincronizar o acesso para o <xref:System.Collections.ICollection>. A sincronização é eficaz somente se todos os threads bloquear este objeto antes de acessar a coleção. O código a seguir mostra o uso do <xref:System.Collections.ICollection.SyncRoot%2A> propriedade para c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera em uma coleção.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.  Nessa posição, o <xref:System.Collections.IEnumerator.Current%2A> propriedade é indefinida. Por isso, você deve chamar o método <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 O <xref:System.Collections.IEnumerator.Current%2A> propriedade retorna o mesmo objeto até que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> é chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se as alterações são feitas na coleção, como adicionar, modificar, ou excluir elementos, o enumerador é invalidado invalidado e a próxima chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> lança um <xref:System.InvalidOperationException>.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O <see cref="T:System.Object" /> para adicionar ao <see cref="T:System.Collections.IList" />.</param>
        <summary>Adiciona um item ao <see cref="T:System.Collections.IList" />.</summary>
        <returns>A posição na qual o novo elemento foi inserido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Collections.Generic.List%601.Count%2A> é menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é uma operação de (1). Se a capacidade precisar ser aumentada para acomodar o novo elemento, esse método se torna um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O <see cref="T:System.Object" /> a ser localizado no <see cref="T:System.Collections.IList" />.</param>
        <summary>Determinará se o <see cref="T:System.Collections.IList" /> contiver um valor específico.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</summary>
        <returns>O índice de <paramref name="item" /> se encontrado na lista; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no qual o <c>item</c> deve ser inserido.</param>
        <param name="item">O objeto a ser inserido no <see cref="T:System.Collections.IList" />.</param>
        <summary>Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `index` é igual ao número de itens em de <xref:System.Collections.IList>, em seguida, `item` é acrescentado ao final.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Collections.IList" /> tiver um valor fixo; caso contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção com um tamanho fixo não permite a adição ou a remoção de elementos após a coleção ser criada, mas permite a modificação de elementos existentes.  
  
 Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> é somente leitura.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Collections.IList" /> for somente leitura; caso contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice com base em zero do elemento a ser obtido ou definido.</param>
        <summary>Obtém ou define o elemento no índice especificado.</summary>
        <value>O elemento no índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A linguagem c# usa a [isso](~/docs/csharp/language-reference/keywords/this.md) palavra-chave para definir os indexadores em vez de implementar o <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> propriedade. Visual Basic implementa <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.  
  
 Recuperando o valor dessa propriedade é uma operação de (1); definindo a propriedade também é uma operação de (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade é definida e <paramref name="value" /> é de um tipo que não é atribuível ao <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a remover do <see cref="T:System.Collections.IList" />.</param>
        <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo dos valores na lista.  
  
 Esse método executa uma pesquisa linear. Portanto, esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os elementos do <see cref="T:System.Collections.Generic.List`1" /> em uma nova matriz.</summary>
        <returns>Uma matriz que contém cópias dos elementos do <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são copiados usando <xref:System.Array.Copy%2A?displayProperty=nameWithType>, que é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.ToArray%2A> método e outros métodos do <xref:System.Collections.Generic.List%601> que atuam em intervalos de classe. No final do exemplo, o <xref:System.Collections.Generic.List%601.GetRange%2A> método é usado para obter três itens na lista, começando com o local do índice 2. O <xref:System.Collections.Generic.List%601.ToArray%2A> método é chamado em resultante <xref:System.Collections.Generic.List%601>, criando uma matriz de três elementos. Os elementos da matriz são exibidos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define a capacidade para o número real de elementos de <see cref="T:System.Collections.Generic.List`1" />, se esse número for menor que um valor limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para minimizar a memória de uma coleção sobrecarga se nenhum elemento novo será adicionado à coleção. O custo de realocar e copiar uma grande <xref:System.Collections.Generic.List%601> pode ser considerável, no entanto, para que o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método não fará nada se a lista estiver em mais de 90% da capacidade. Isso evita a incorrer um custo de realocação grande para um ganho relativamente pequeno.  
  
> [!NOTE]
>  O limite atual de 90 por cento pode mudar em versões futuras.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Para redefinir uma <xref:System.Collections.Generic.List%601> para seu estado inicial, chamar o <xref:System.Collections.Generic.List%601.Clear%2A> método antes de chamar o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método. Cortar um vazio <xref:System.Collections.Generic.List%601> define a capacidade do <xref:System.Collections.Generic.List%601> para a capacidade padrão.  
  
 A capacidade também pode ser definida usando o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como verificar a capacidade e contagem de um <xref:System.Collections.Generic.List%601> que contém um objeto comercial simples e ilustra o uso de <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para remover a capacidade extra.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método. Várias propriedades e métodos do <xref:System.Collections.Generic.List%601> classe são usados para adicionar, inserir e remover itens de uma lista de cadeias de caracteres. Em seguida, a <xref:System.Collections.Generic.List%601.TrimExcess%2A> método é usado para reduzir a capacidade de corresponder à contagem e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas. Se a capacidade não utilizada tivesse sido menor que 10% da capacidade total, a lista seria não ter foi redimensionada. Por fim, o conteúdo da lista é desmarcado.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições a serem verificadas nos elementos.</param>
        <summary>Determina se cada elemento do <see cref="T:System.Collections.Generic.List`1" /> corresponde às condições definidas pelo predicado especificado.</summary>
        <returns>
          <see langword="true" /> se cada elemento do <see cref="T:System.Collections.Generic.List`1" /> corresponder às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />. Se a lista não tiver elementos, o valor retornado será <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos do atual <xref:System.Collections.Generic.List%601> são passados individualmente para o <xref:System.Predicate%601> delegado e o processamento é interrompido quando o delegado retorna `false` para qualquer elemento. Os elementos são processados na ordem, e todas as chamadas são feitas em um único thread.  
  
 Esse método é um O (*n*) a operação, onde *n* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Collections.Generic.List%601.TrueForAll%2A> método e vários outros métodos que usam <xref:System.Predicate%601> delegado genérico.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Collections.Generic.List%601.TrueForAll%2A> método percorre a lista desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `false`.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>