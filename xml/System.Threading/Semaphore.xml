<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Semaphore.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Limits the number of threads that can access a resource or pool of resources concurrently.</source>
          <target state="translated">Limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class to control access to a pool of resources.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> classe para controlar o acesso a um pool de recursos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Threads enter the semaphore by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method, which is inherited from the <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, and release the semaphore by calling the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Threads de inserir o semáforo chamando o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método, que é herdado do <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe e liberar o semáforo chamando o <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</source>
          <target state="translated">A contagem em um semáforo é decrementada cada vez que um thread entra o semáforo e incrementado quando um thread libera o sinal.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When the count is zero, subsequent requests block until other threads release the semaphore.</source>
          <target state="translated">Quando a contagem for zero, as solicitações subsequentes bloqueiam até que outros threads de liberar o semáforo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</source>
          <target state="translated">Depois que todos os threads libera o sinal, a contagem é o valor máximo especificada quando o semáforo foi criado.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</source>
          <target state="translated">Não há nenhuma garantia de ordem, como PEPS ou UEPS, na qual os threads bloqueados inserir o sinal.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A thread can enter the semaphore multiple times, by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method repeatedly.</source>
          <target state="translated">Um thread pode inserir várias vezes, do semáforo chamando o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método repetidamente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>To release some or all of these entries, the thread can call the parameterless <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload multiple times, or it can call the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload that specifies the number of entries to be released.</source>
          <target state="translated">Para liberar algumas ou todas essas entradas, o thread pode chamar o sem parâmetros <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> sobrecarga do método várias vezes, ou ele pode chamar o <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> sobrecarga do método que especifica o número de entradas para ser liberado.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity on calls to <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> classe não impõe a identidade do thread em chamadas para <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> ou <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</source>
          <target state="translated">É responsabilidade do programador para garantir que threads não liberar o semáforo muitas vezes.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</source>
          <target state="translated">Por exemplo, suponha que um sinal tenha uma contagem máxima de dois, e que o thread A e o thread B insiram o sinal.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If a programming error in thread B causes it to call <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> twice, both calls succeed.</source>
          <target state="translated">Se um erro de programação em thread B faz com que ele chame <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> duas vezes, as duas chamadas tenha êxito.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on the semaphore is full, and when thread A eventually calls <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, a <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown.</source>
          <target state="translated">A contagem no sinal está completa e quando o thread A eventualmente chama <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, uma <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> é lançada.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Semaphores are of two types: local semaphores and named system semaphores.</source>
          <target state="translated">São sinais de dois tipos: locais semáforos e semáforos sistema nomeado.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If you create a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</source>
          <target state="translated">Se você criar um <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> usando um construtor que aceita um nome de objeto é associado com um sinal de sistema operacional do nome.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">Chamado sistema de semáforos são visíveis em todo o sistema operacional e podem ser usados para sincronizar as atividades de processos.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore, and you can use the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method to open an existing named system semaphore.</source>
          <target state="translated">Você pode criar várias <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objetos que representam o mesmo sistema semáforo e você pode usar o <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> sistema semáforo de método para abrir um existente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A local semaphore exists only within your process.</source>
          <target state="translated">Um semáforo local existe somente em seu processo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It can be used by any thread in your process that has a reference to the local <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">Ele pode ser usado por qualquer thread em seu processo que tenha referência ao objeto <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> local.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object is a separate local semaphore.</source>
          <target state="translated">Cada <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto é um semáforo local separado.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">O exemplo inicia cinco threads, que bloqueiam aguardando o sinal.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">O thread principal usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Cada thread usa o <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> sobrecarga do método para liberar o semáforo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Console mensagens controlar o uso do sinal.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo é thread-safe.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, especificando o número inicial de entradas e o número máximo de entradas simultâneas.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>This constructor initializes an unnamed semaphore.</source>
          <target state="translated">Este construtor inicializa um sinal sem nome.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>All threads that use an instance of such a semaphore must have references to the instance.</source>
          <target state="translated">Todos os threads que usam uma instância de tal um semáforo devem ter referências à instância.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> é menor que <ph id="ph2">`maximumCount`</ph>, o efeito é o mesmo como se tivesse chamado do thread atual <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> menos <ph id="ph5">`initialCount`</ph>) vezes.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <ph id="ph1">`maximumCount`</ph> and <ph id="ph2">`initialCount`</ph>.</source>
          <target state="translated">Se você não deseja reservar todas as entradas para o thread que cria o sinal, use o mesmo número de <ph id="ph1">`maximumCount`</ph> e <ph id="ph2">`initialCount`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The following example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">O exemplo a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">O exemplo inicia cinco threads, que bloqueiam aguardando o sinal.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">O thread principal usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Cada thread usa o <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> sobrecarga do método para liberar o semáforo.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Console mensagens controlar o uso do sinal.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é maior que <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> é menor que 1.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">O nome de um objeto de sinal de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, especificando o número inicial de entradas e o número máximo de entradas simultâneas e, opcionalmente, especificando o nome de um objeto de sinal de sistema.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Este construtor inicializa um <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto que representa um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">Você pode criar várias <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objetos que representam o mesmo sistema semáforo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Se o sinal do sistema nomeada não existir, ele será criado com a contagem inicial e máximo especificados por <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Se o sinal do sistema nomeado já existir, <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph> não são usados, embora ainda, valores inválidos causam exceções.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you need to determine whether or not a named system semaphore was created, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor overload instead.</source>
          <target state="translated">Se você precisar determinar se ou não um sinal de sistema nomeado foi criado, use o <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> sobrecarga do construtor.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>When you use this constructor overload, the recommended practice is to specify the same number for <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Quando você usa essa sobrecarga de construtor, a prática recomendada é especificar o mesmo número de <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and a named system semaphore is created, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> é menor que <ph id="ph2">`maximumCount`</ph>e um semáforo de sistema nomeado é criado, o efeito é o mesmo como se tivesse chamado do thread atual <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> menos <ph id="ph5">`initialCount`</ph>) vezes.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>However, with this constructor overload there is no way to determine whether a named system semaphore was created.</source>
          <target state="translated">No entanto, com essa sobrecarga de construtor não é possível determinar se um semáforo de sistema nomeado foi criado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Se você especificar <ph id="ph1">`null`</ph> ou uma cadeia de caracteres vazia para <ph id="ph2">`name`</ph>, um semáforo local é criado, como se você tivesse chamado o <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos além dos limites do processo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you want to find out whether a named system semaphore exists, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Se você deseja saber se existe um semáforo de sistema nomeado, use o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> método tenta abrir um semáforo existente e lança uma exceção se o sinal do sistema não existe.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of five.</source>
          <target state="translated">O exemplo cria um semáforo com nome com uma contagem máxima de cinco e uma contagem inicial de cinco.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The program makes three calls to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">O programa faz três chamadas para o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará na terceira chamada <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">Liberar uma ou mais entradas na primeira cópia do programa para desbloquear o segundo.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é maior que <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> é menor que 1.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Ação de segurança: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">O nome de um objeto de sinal de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">Quando este método retorna, contém <ph id="ph1">&lt;see langword="true" /&gt;</ph> se um semáforo local foi criado (ou seja, se <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou uma cadeia de caracteres vazia) ou se o semáforo do sistema nomeado especificado foi criado; <ph id="ph3">&lt;see langword="false" /&gt;</ph> se o semáforo do sistema nomeado especificado já existia.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema e especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Este construtor inicializa um <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto que representa um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">Você pode criar várias <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objetos que representam o mesmo sistema semáforo.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Se o sinal do sistema nomeada não existir, ele será criado com a contagem inicial e máximo especificados por <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Se o sinal do sistema nomeado já existir, <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph> não são usados, embora ainda, valores inválidos causam exceções.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Use <ph id="ph1">`createdNew`</ph> to determine whether the system semaphore was created.</source>
          <target state="translated">Use <ph id="ph1">`createdNew`</ph> para determinar se o sinal do sistema foi criado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> é menor que <ph id="ph2">`maximumCount`</ph>, e <ph id="ph3">`createdNew`</ph> é <ph id="ph4">`true`</ph>, o efeito é o mesmo como se tivesse chamado do thread atual <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> menos <ph id="ph7">`initialCount`</ph>) vezes.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Se você especificar <ph id="ph1">`null`</ph> ou uma cadeia de caracteres vazia para <ph id="ph2">`name`</ph>, um semáforo local é criado, como se você tivesse chamado o <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Nesse caso, <ph id="ph1">`createdNew`</ph> é sempre <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos além dos limites do processo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of two.</source>
          <target state="translated">O exemplo cria um semáforo com nome com uma contagem máxima de cinco e uma contagem inicial de dois.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>That is, it reserves three entries for the thread that calls the constructor.</source>
          <target state="translated">Ou seja, ele reserva três entradas para o thread que chama o construtor.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`createNew`</ph> is <ph id="ph2">`false`</ph>, the program makes three calls to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`createNew`</ph> é <ph id="ph2">`false`</ph>, o programa faz três chamadas para o <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará na terceira chamada <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">Liberar uma ou mais entradas na primeira cópia do programa para desbloquear o segundo.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é maior que <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> é menor que 1.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Ação de segurança: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">O nome de um objeto de sinal de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">Quando este método retorna, contém <ph id="ph1">&lt;see langword="true" /&gt;</ph> se um semáforo local foi criado (ou seja, se <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou uma cadeia de caracteres vazia) ou se o semáforo do sistema nomeado especificado foi criado; <ph id="ph3">&lt;see langword="false" /&gt;</ph> se o semáforo do sistema nomeado especificado já existia.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> que representa a segurança de controle de acesso a ser aplicada ao semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema, especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado e especificando o controle de acesso de segurança para o semáforo do sistema.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</source>
          <target state="translated">Use este construtor para aplicar segurança de controle de acesso a um semáforo de sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle de semáforo.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Este construtor inicializa um <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto que representa um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">Você pode criar várias <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objetos que representam o mesmo sistema semáforo.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the specified access control security.</source>
          <target state="translated">Se o sinal do sistema nomeada não existir, ele será criado com a segurança de controle de acesso especificado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named semaphore exists, the specified access control security is ignored.</source>
          <target state="translated">Se o sinal nomeado existir, a segurança de controle de acesso especificado será ignorada.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object even if <ph id="ph2">`semaphoreSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">O chamador tem controle total sobre recém-criado <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto mesmo se <ph id="ph2">`semaphoreSecurity`</ph> nega ou falhar ao conceder a alguns direitos de acesso para o usuário atual.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object to represent the same named semaphore, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">No entanto, se o usuário atual tenta obter outro <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> representar o mesmo semáforo, usando um construtor do objeto ou o <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> método, Windows, segurança de controle de acesso é aplicada.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Se o sinal do sistema nomeada não existir, ele será criado com a contagem inicial e máximo especificados por <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Se o sinal do sistema nomeado já existir, <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph> não são usados, embora ainda, valores inválidos causam exceções.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use the <ph id="ph1">`createdNew`</ph> parameter to determine whether the system semaphore was created by this constructor.</source>
          <target state="translated">Use o <ph id="ph1">`createdNew`</ph> parâmetro para determinar se o sinal do sistema foi criado por este construtor.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> é menor que <ph id="ph2">`maximumCount`</ph>, e <ph id="ph3">`createdNew`</ph> é <ph id="ph4">`true`</ph>, o efeito é o mesmo como se tivesse chamado do thread atual <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> menos <ph id="ph7">`initialCount`</ph>) vezes.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Se você especificar <ph id="ph1">`null`</ph> ou uma cadeia de caracteres vazia para <ph id="ph2">`name`</ph>, um semáforo local é criado, como se você tivesse chamado o <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga de construtor.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Nesse caso, <ph id="ph1">`createdNew`</ph> é sempre <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos além dos limites do processo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e versão.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é maior que <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> é menor que 1.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Ação de segurança: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Gets the access control security for a named system semaphore.</source>
          <target state="translated">Define a segurança de controle de acesso para um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security for the named system semaphore.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> que representa a segurança do controle de acesso para o semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para procurar permissões: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, e <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">O usuário deve ter <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> direitos para chamar esse método e o sinal devem ter sido abertos com <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> direitos.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>On a local semaphore, access control security is irrelevant.</source>
          <target state="translated">Em um semáforo local, a segurança de controle de acesso é irrelevante.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object does not represent a named system semaphore, this method returns a <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object that grants all rights to any user.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto não representa um semáforo de sistema nomeada, esse método retorna um <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> objeto que concede todos os direitos a qualquer usuário.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The access control security for the system semaphore is obtained using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method.</source>
          <target state="translated">A segurança de controle de acesso para o sinal do sistema é obtida por meio de <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e versão.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> atual representa um semáforo de sistema nomeado e o usuário não tem direitos de <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> atual representa um semáforo de sistema nomeado e não foi aberto com os direitos de <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists.</source>
          <target state="translated">Abre um semáforo nomeado especificado, caso ele já exista.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">O nome do semáforo do sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Opens the specified named semaphore, if it already exists.</source>
          <target state="translated">Abre o semáforo nomeado especificado, caso ele já exista.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">Um objeto que representa o semáforo do sistema nomeado.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open the specified named semaphore.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> método tenta abrir o semáforo especificado.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">Se o sinal do sistema não existir, este método lança uma exceção em vez de criar o semáforo de sistema.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o semáforo de sistema quando ele ainda não existir, use um do <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> do objeto, embora os objetos que são retornados representam o mesmo sinal do sistema.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Essa sobrecarga de método é equivalente a chamar o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> sobrecarga de método e especificando <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> direitos, combinados com a operação OR bit a bit.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Especificando o <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread entrar no sinal e especificando o <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread chamar o <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas que concede o direito de leitura e alterar permissões o semáforo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada a <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">O semáforo nomeado não existe.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>for calling unmanaged code to open a named system semaphore.</source>
          <target state="translated">para chamar código não gerenciado para abrir um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Ação de segurança: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">O nome do semáforo do sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access.</source>
          <target state="translated">Abre o semáforo nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">Um objeto que representa o semáforo do sistema nomeado.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`rights`</ph> parâmetro deve incluir o <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads entrar no sinal e o <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads chamar o <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open an existing named semaphore.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> método tenta abrir um semáforo existente.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">Se o sinal do sistema não existir, este método lança uma exceção em vez de criar o semáforo de sistema.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o semáforo de sistema quando ele ainda não existir, use um do <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> do objeto, embora os objetos que são retornados representam o mesmo sinal do sistema.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">O semáforo nomeado não existe.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore exists, but the user does not have the desired security access rights.</source>
          <target state="translated">O semáforo nomeado existe, mas o usuário não tem os direitos de acesso de segurança desejados.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Ação de segurança: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Exits the semaphore.</source>
          <target state="translated">O semáforo é encerrado.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>Exits the semaphore and returns the previous count.</source>
          <target state="translated">Sai do sinal e retorna à contagem anterior.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">A contagem no sinal antes do método <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Threads typically use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method to enter the semaphore, and they typically use this method overload to exit.</source>
          <target state="translated">Os threads geralmente usam o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método para inserir o sinal e eles normalmente usam essa sobrecarga de método para sair.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">Se um <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> é gerada pelo <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método, ele não indica necessariamente um problema com o thread de chamada.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">Um erro de programação em outro thread pode ter causado essa thread para sair do sinal do mais vezes que ele inserido.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto representa um semáforo de sistema nomeado, o usuário deve ter <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> direitos e o sinal devem ter sido abertos com <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> direitos.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">O exemplo inicia cinco threads, que bloqueiam aguardando o sinal.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">O thread principal usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Cada thread usa o <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> sobrecarga do método para liberar o semáforo.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Console mensagens controlar o uso do sinal.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">A contagem de semáforo já está no valor máximo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">Ocorreu um erro de Win32 com um semáforo nomeado.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">O sinal do atual representa um sinal de sistema nomeado, mas não foi aberto com <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The number of times to exit the semaphore.</source>
          <target state="translated">O número de vezes para sair do sinal.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Exits the semaphore a specified number of times and returns the previous count.</source>
          <target state="translated">Sai do sinal de um número de vezes especificado e retorna à contagem anterior.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">A contagem no sinal antes do método <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> ser chamado.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</source>
          <target state="translated">Se um thread entrou o semáforo várias vezes, essa sobrecarga de método permite que a contagem de semáforo toda a ser restaurado com uma chamada.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">Se um <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> é gerada pelo <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método, ele não indica necessariamente um problema com o thread de chamada.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">Um erro de programação em outro thread pode ter causado essa thread para sair do sinal do mais vezes que ele inserido.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objeto representa um semáforo de sistema nomeado, o usuário deve ter <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> direitos e o sinal devem ter sido abertos com <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> direitos.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">O exemplo inicia cinco threads, que bloqueiam aguardando o sinal.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">O thread principal usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Cada thread usa o <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> sobrecarga do método para liberar o semáforo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Console mensagens controlar o uso do sinal.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> é menor que 1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">A contagem de semáforo já está no valor máximo.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">Ocorreu um erro de Win32 com um semáforo nomeado.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem direitos de <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">O sinal atual representa um sinal de sistema nomeado, mas não foi aberto com direitos de <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> que representa a segurança de controle de acesso a ser aplicada ao semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>Sets the access control security for a named system semaphore.</source>
          <target state="translated">Define a segurança de controle de acesso para um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can set access control security only on <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent named system semaphores.</source>
          <target state="translated">Você pode definir a segurança de controle de acesso somente no <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objetos que representam o sistema nomeado semáforos.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">O usuário deve ter <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> direitos para chamar esse método e o sinal devem ter sido abertos com <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> direitos.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um semáforo com nome.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> method, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Depois que as permissões forem alteradas, usando o <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> método, o sinal é aberto com os direitos necessários para inserir e versão.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">O usuário não tem direitos de <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The semaphore was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">O semáforo não foi aberto com direitos de <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object does not represent a named system semaphore.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> atual não representa um semáforo de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre um semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">O nome do semáforo do sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quando esse método retorna, contém um objeto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se a chamada falhou.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Esse parâmetro é tratado como não inicializado.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre o semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o semáforo nomeado foi aberto com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">Se o sinal nomeado não existir, este método não criá-lo.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o semáforo de sistema quando ele ainda não existir, use um do <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">Se você não tiver certeza se existe um semáforo nomeado, use essa sobrecarga de método em vez do <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> sobrecarga de método, o que gera uma exceção se o sinal não existe.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Essa sobrecarga de método é equivalente a chamar o <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> sobrecarga de método e especificando <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> direitos, combinados com a operação OR bit a bit.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the   <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Especificando o <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread entrar no sinal e especificando o <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread chamar o <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">O nome do semáforo do sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quando esse método retorna, contém um objeto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se a chamada falhou.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Esse parâmetro é tratado como não inicializado.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Se o semáforo nomeado especificado já existe, abre-o com o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o semáforo nomeado foi aberto com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">Se o sinal nomeado não existir, este método não criá-lo.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o semáforo de sistema quando ele ainda não existir, use um do <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">Se você não tiver certeza se existe um semáforo nomeado, use essa sobrecarga de método em vez do <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> sobrecarga de método, o que gera uma exceção se o sinal não existe.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`rights`</ph> parâmetro deve incluir o <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads entrar no sinal e o <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads chamar o <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> do objeto, embora os objetos que são retornados representam o mesmo sinal do sistema.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>