<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dfd4af5a6146da7c3a1e0bf3e9198f1ae1ef7404" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52214164" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9244e-101">Limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</span>
      <span class="sxs-lookup">
        <span data-stu-id="9244e-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-102">Use o <xref:System.Threading.Semaphore> classe para controlar o acesso a um pool de recursos.</span><span class="sxs-lookup"><span data-stu-id="9244e-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="9244e-103">Threads inserem o sinal chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método, que é herdado do <xref:System.Threading.WaitHandle> classe e liberar o semáforo, chamando o <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="9244e-104">A contagem em um semáforo é decrementada sempre que um thread entra o semáforo e incrementado quando um thread libera o semaphore.</span><span class="sxs-lookup"><span data-stu-id="9244e-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="9244e-105">Quando a contagem for zero, as solicitações subsequentes bloqueiam até que outros threads liberam o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="9244e-106">Quando todos os threads lançaram o semáforo, a contagem é o valor máximo especificada quando o sinal foi criado.</span><span class="sxs-lookup"><span data-stu-id="9244e-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="9244e-107">Não há nenhuma garantia de ordem, como PEPS ou UEPS, no qual os threads bloqueados inserem o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-108">Um thread pode inserir várias vezes, do semáforo, chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método repetidamente.</span><span class="sxs-lookup"><span data-stu-id="9244e-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="9244e-109">Para algumas ou todas essas entradas de versão, o thread pode chamar o Next sem parâmetros <xref:System.Threading.Semaphore.Release> sobrecarga do método várias vezes, ou ele pode chamar o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método que especifica o número de entradas a ser liberado.</span><span class="sxs-lookup"><span data-stu-id="9244e-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="9244e-110">O <xref:System.Threading.Semaphore> classe não impõe a identidade do thread em chamadas para <xref:System.Threading.WaitHandle.WaitOne%2A> ou <xref:System.Threading.Semaphore.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="9244e-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="9244e-111">É responsabilidade do programador garantir que threads não liberam o sinal muitas vezes.</span><span class="sxs-lookup"><span data-stu-id="9244e-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="9244e-112">Por exemplo, suponha que um sinal tenha uma contagem máxima de dois, e que o thread A e o thread B insiram o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="9244e-113">Se um erro de programação no thread B faz com que ele chame <xref:System.Threading.Semaphore.Release%2A> duas vezes, as duas chamadas tenha êxito.</span><span class="sxs-lookup"><span data-stu-id="9244e-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="9244e-114">A contagem no sinal está completa e quando o thread A eventualmente chama <xref:System.Threading.Semaphore.Release%2A>, uma <xref:System.Threading.SemaphoreFullException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="9244e-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="9244e-115">Semáforos são de dois tipos: locais semáforos e sinais de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="9244e-116">Se você criar um <xref:System.Threading.Semaphore> usando um construtor que aceita um nome de objeto é associado com um semáforo de sistema operacional desse nome.</span><span class="sxs-lookup"><span data-stu-id="9244e-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="9244e-117">Do sistema nomeado semáforos são visíveis em todo o sistema operacional e podem ser usados para sincronizar as atividades de processos.</span><span class="sxs-lookup"><span data-stu-id="9244e-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="9244e-118">Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo, e você pode usar o <xref:System.Threading.Semaphore.OpenExisting%2A> semáforo de sistema nomeado do método para abrir um existente.</span><span class="sxs-lookup"><span data-stu-id="9244e-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="9244e-119">Um semáforo local existe somente dentro de seu processo.</span><span class="sxs-lookup"><span data-stu-id="9244e-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="9244e-120">Ele pode ser usado por qualquer thread em seu processo que tenha referência ao objeto <xref:System.Threading.Semaphore> local.</span><span class="sxs-lookup"><span data-stu-id="9244e-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="9244e-121">Cada <xref:System.Threading.Semaphore> objeto é um semáforo local separado.</span><span class="sxs-lookup"><span data-stu-id="9244e-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-122">O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</span><span class="sxs-lookup"><span data-stu-id="9244e-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="9244e-123">O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="9244e-124">O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="9244e-125">Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="9244e-126">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</span><span class="sxs-lookup"><span data-stu-id="9244e-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="9244e-127">Console mensagens controlar o uso do semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-127">Console messages track semaphore use.</span></span> <span data-ttu-id="9244e-128">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</span><span class="sxs-lookup"><span data-stu-id="9244e-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="9244e-129">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="9244e-129">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="9244e-130">Threading gerenciado</span>
      <span class="sxs-lookup">
        <span data-stu-id="9244e-130">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="9244e-131">Sinal</span>
      <span class="sxs-lookup">
        <span data-stu-id="9244e-131">Semaphore</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9244e-132">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-132">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="9244e-133">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-133">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="9244e-134">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-134">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-135">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-135">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-136">Este construtor inicializa um semáforo sem nome.</span><span class="sxs-lookup"><span data-stu-id="9244e-136">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="9244e-137">Todos os threads que usam uma instância de tal um semáforo devem ter referências à instância.</span><span class="sxs-lookup"><span data-stu-id="9244e-137">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="9244e-138">Se `initialCount` é menor que `maximumCount`, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.</span><span class="sxs-lookup"><span data-stu-id="9244e-138">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="9244e-139">Se não desejar reservar todas as entradas para o thread que cria o semáforo, use o mesmo número para `maximumCount` e `initialCount`.</span><span class="sxs-lookup"><span data-stu-id="9244e-139">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-140">O exemplo a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</span><span class="sxs-lookup"><span data-stu-id="9244e-140">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="9244e-141">O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-141">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="9244e-142">O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-142">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="9244e-143">Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-143">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="9244e-144">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</span><span class="sxs-lookup"><span data-stu-id="9244e-144">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="9244e-145">Console mensagens controlar o uso do semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-145">Console messages track semaphore use.</span></span> <span data-ttu-id="9244e-146">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</span><span class="sxs-lookup"><span data-stu-id="9244e-146">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-147">
            <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-147">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9244e-148">
            <paramref name="maximumCount" /> é menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-148">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="9244e-149">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-149">-or-</span>
          </span>
          <span data-ttu-id="9244e-150">
            <paramref name="initialCount" /> é menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-150">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-151">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-151">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-152">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-152">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="9244e-153">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-153">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="9244e-154">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-154">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="9244e-155">O nome de um objeto de sinal de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-155">The name of a named system semaphore object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-156">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas e, opcionalmente, especificando o nome de um objeto de sinal de sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-156">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-157">Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-157">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="9244e-158">Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo.</span><span class="sxs-lookup"><span data-stu-id="9244e-158">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="9244e-159">Se o semáforo de sistema nomeado não existir, ele será criado com a contagem inicial e máximo especificado por `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="9244e-159">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="9244e-160">Se o semáforo de sistema nomeado já existir, `initialCount` e `maximumCount` não forem usados, embora ainda, valores inválidos causam exceções.</span><span class="sxs-lookup"><span data-stu-id="9244e-160">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="9244e-161">Se você precisar determinar se ou não um semáforo de sistema nomeado foi criado, use o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> sobrecarga do construtor.</span><span class="sxs-lookup"><span data-stu-id="9244e-161">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9244e-162">Quando você usa essa sobrecarga de construtor, a prática recomendada é especificar o mesmo número para `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="9244e-162">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="9244e-163">Se `initialCount` é menor que `maximumCount`e um semáforo de sistema nomeado é criado, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.</span><span class="sxs-lookup"><span data-stu-id="9244e-163">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="9244e-164">No entanto, com essa sobrecarga de construtor não há nenhuma maneira de determinar se um semáforo de sistema nomeado foi criado.</span><span class="sxs-lookup"><span data-stu-id="9244e-164">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="9244e-165">Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor.</span><span class="sxs-lookup"><span data-stu-id="9244e-165">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="9244e-166">Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos entre os limites do processo.</span><span class="sxs-lookup"><span data-stu-id="9244e-166">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="9244e-167">Se você deseja saber se existe um semáforo de sistema nomeado, use o <xref:System.Threading.Semaphore.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-167">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="9244e-168">O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir um semáforo nomeado existente e gera uma exceção se o semáforo do sistema não existe.</span><span class="sxs-lookup"><span data-stu-id="9244e-168">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-169">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-169">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="9244e-170">O exemplo cria um semáforo nomeado com uma contagem máxima de cinco e uma contagem inicial de cinco.</span><span class="sxs-lookup"><span data-stu-id="9244e-170">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="9244e-171">O programa faz três chamadas para o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-171">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="9244e-172">Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará a terceira chamada para <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="9244e-172">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="9244e-173">Solte um ou mais entradas na primeira cópia do programa para desbloquear o segundo.</span><span class="sxs-lookup"><span data-stu-id="9244e-173">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-174">
            <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-174">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="9244e-175">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-175">-or-</span>
          </span>
          <span data-ttu-id="9244e-176">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-176">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9244e-177">
            <paramref name="maximumCount" /> é menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-177">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="9244e-178">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-178">-or-</span>
          </span>
          <span data-ttu-id="9244e-179">
            <paramref name="initialCount" /> é menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-179">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-180">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-180">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-181">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-181">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="9244e-182">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-182">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9244e-183">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-183">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="9244e-184">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-184">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="9244e-185">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-185">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-186">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-186">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-187">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-187">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="9244e-188">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-188">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="9244e-189">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-189">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="9244e-190">O nome de um objeto de sinal de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-190">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="9244e-191">Quando este método retorna, ele conterá <see langword="true" />, se um semáforo local tiver sido criado (isto é, se <paramref name="name" /> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o semáforo de sistema nomeado especificado tiver sido criado, <see langword="false" /> se o semáforo de sistema nomeado especificado já existia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-191">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="9244e-192">Este parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-192">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-193">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema e especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-193">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-194">Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-194">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="9244e-195">Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo.</span><span class="sxs-lookup"><span data-stu-id="9244e-195">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="9244e-196">Se o semáforo de sistema nomeado não existir, ele será criado com a contagem inicial e máximo especificado por `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="9244e-196">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="9244e-197">Se o semáforo de sistema nomeado já existir, `initialCount` e `maximumCount` não forem usados, embora ainda, valores inválidos causam exceções.</span><span class="sxs-lookup"><span data-stu-id="9244e-197">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="9244e-198">Use `createdNew` para determinar se o semáforo do sistema foi criado.</span><span class="sxs-lookup"><span data-stu-id="9244e-198">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="9244e-199">Se `initialCount` é menor que `maximumCount`, e `createdNew` é `true`, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.</span><span class="sxs-lookup"><span data-stu-id="9244e-199">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="9244e-200">Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor.</span><span class="sxs-lookup"><span data-stu-id="9244e-200">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="9244e-201">Nesse caso, `createdNew` é sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="9244e-201">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="9244e-202">Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos entre os limites do processo.</span><span class="sxs-lookup"><span data-stu-id="9244e-202">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-203">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-203">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="9244e-204">O exemplo cria um semáforo nomeado com uma contagem máxima de cinco e uma contagem inicial de dois.</span><span class="sxs-lookup"><span data-stu-id="9244e-204">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="9244e-205">Ou seja, ele reserva três entradas para o thread que chama o construtor.</span><span class="sxs-lookup"><span data-stu-id="9244e-205">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="9244e-206">Se `createNew` está `false`, o programa faz três chamadas para o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-206">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="9244e-207">Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará a terceira chamada para <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="9244e-207">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="9244e-208">Solte um ou mais entradas na primeira cópia do programa para desbloquear o segundo.</span><span class="sxs-lookup"><span data-stu-id="9244e-208">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-209">
            <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-209">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="9244e-210">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-210">-or-</span>
          </span>
          <span data-ttu-id="9244e-211">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-211">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9244e-212">
            <paramref name="maximumCount" /> é menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-212">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="9244e-213">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-213">-or-</span>
          </span>
          <span data-ttu-id="9244e-214">
            <paramref name="initialCount" /> é menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-214">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-215">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-215">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-216">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-216">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="9244e-217">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-217">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9244e-218">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-218">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="9244e-219">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-219">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="9244e-220">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-220">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-221">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-221">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-222">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-222">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="9244e-223">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-223">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="9244e-224">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-224">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="9244e-225">O nome de um objeto de sinal de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-225">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="9244e-226">Quando este método retorna, ele conterá <see langword="true" />, se um semáforo local tiver sido criado (isto é, se <paramref name="name" /> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o semáforo de sistema nomeado especificado tiver sido criado, <see langword="false" /> se o semáforo de sistema nomeado especificado já existia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-226">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="9244e-227">Este parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-227">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="semaphoreSecurity">
          <span data-ttu-id="9244e-228">Um objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-228">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-229">Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema, especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado e especificando o controle de acesso de segurança para o semáforo do sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-229">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-230">Use esse construtor para aplicar a segurança de controle de acesso a um semáforo de sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle do sinal do.</span><span class="sxs-lookup"><span data-stu-id="9244e-230">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-231">Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-231">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="9244e-232">Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo.</span><span class="sxs-lookup"><span data-stu-id="9244e-232">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="9244e-233">Se o semáforo de sistema nomeado não existir, ele é criado com a segurança de controle de acesso especificado.</span><span class="sxs-lookup"><span data-stu-id="9244e-233">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="9244e-234">Se o semáforo nomeado existe, a segurança de controle de acesso especificado será ignorada.</span><span class="sxs-lookup"><span data-stu-id="9244e-234">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9244e-235">O chamador tem controle total sobre o recém-criado <xref:System.Threading.Semaphore> objeto mesmo se `semaphoreSecurity` nega ou falha em conceder a alguns direitos de acesso para o usuário atual.</span><span class="sxs-lookup"><span data-stu-id="9244e-235">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="9244e-236">No entanto, se o usuário atual tenta obter outra <xref:System.Threading.Semaphore> representar o mesmo semáforo nomeado, usando um construtor de objeto ou o <xref:System.Threading.Semaphore.OpenExisting%2A> método, o Windows a segurança de controle de acesso é aplicada.</span><span class="sxs-lookup"><span data-stu-id="9244e-236">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="9244e-237">Se o semáforo de sistema nomeado não existir, ele será criado com a contagem inicial e máximo especificado por `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="9244e-237">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="9244e-238">Se o semáforo de sistema nomeado já existir, `initialCount` e `maximumCount` não forem usados, embora ainda, valores inválidos causam exceções.</span><span class="sxs-lookup"><span data-stu-id="9244e-238">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="9244e-239">Use o `createdNew` parâmetro para determinar se o semáforo do sistema foi criado por esse construtor.</span><span class="sxs-lookup"><span data-stu-id="9244e-239">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="9244e-240">Se `initialCount` é menor que `maximumCount`, e `createdNew` é `true`, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.</span><span class="sxs-lookup"><span data-stu-id="9244e-240">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="9244e-241">Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor.</span><span class="sxs-lookup"><span data-stu-id="9244e-241">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="9244e-242">Nesse caso, `createdNew` é sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="9244e-242">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="9244e-243">Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos entre os limites do processo.</span><span class="sxs-lookup"><span data-stu-id="9244e-243">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-244">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="9244e-244">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="9244e-245">O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-245">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="9244e-246">Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-246">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="9244e-247">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-247">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="9244e-248">A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-248">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9244e-249">Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e de versão.</span><span class="sxs-lookup"><span data-stu-id="9244e-249">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="9244e-250">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-250">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-251">
            <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-251">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="9244e-252">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-252">-or-</span>
          </span>
          <span data-ttu-id="9244e-253">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-253">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9244e-254">
            <paramref name="maximumCount" /> é menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-254">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="9244e-255">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-255">-or-</span>
          </span>
          <span data-ttu-id="9244e-256">
            <paramref name="initialCount" /> é menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-256">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-257">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-257">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-258">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-258">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="9244e-259">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-259">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9244e-260">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-260">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="9244e-261">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="9244e-262">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-262">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-263">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-263">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-264">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-264">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9244e-265">Define a segurança de controle de acesso para um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-265">Gets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-266">Um objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa a segurança do controle de acesso para o semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-266">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-267">O <xref:System.Threading.Semaphore.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para pesquisar as permissões: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9244e-267">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9244e-268">O usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> direitos para chamar esse método e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> direitos.</span><span class="sxs-lookup"><span data-stu-id="9244e-268">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="9244e-269">Em um semáforo local, a segurança de controle de acesso é irrelevante.</span><span class="sxs-lookup"><span data-stu-id="9244e-269">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="9244e-270">Se o <xref:System.Threading.Semaphore> objeto não representa um semáforo de sistema nomeado, esse método retorna um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que concede todos os direitos a qualquer usuário.</span><span class="sxs-lookup"><span data-stu-id="9244e-270">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-271">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="9244e-271">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="9244e-272">O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-272">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="9244e-273">Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-273">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-274">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-274">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="9244e-275">A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-275">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="9244e-276">A segurança de controle de acesso para o semáforo do sistema é obtida usando o <xref:System.Threading.Semaphore.GetAccessControl%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-276">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="9244e-277">Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e de versão.</span><span class="sxs-lookup"><span data-stu-id="9244e-277">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="9244e-278">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-278">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-279">O objeto <see cref="T:System.Threading.Semaphore" /> atual representa um semáforo de sistema nomeado e o usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-279">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
          <span data-ttu-id="9244e-280">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-280">-or-</span>
          </span>
          <span data-ttu-id="9244e-281">O objeto <see cref="T:System.Threading.Semaphore" /> atual representa um semáforo de sistema nomeado e não foi aberto com os direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-281">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9244e-282">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-282">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-283">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-283">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-284">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-284">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9244e-285">Abre um semáforo nomeado especificado, caso ele já exista.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-285">Opens a specified named semaphore, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9244e-286">O nome do semáforo do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-286">The name of the system semaphore to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-287">Abre o semáforo nomeado especificado, caso ele já exista.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-287">Opens the specified named semaphore, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-288">Um objeto que representa o semáforo do sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-288">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-289">O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir o semáforo nomeado especificado.</span><span class="sxs-lookup"><span data-stu-id="9244e-289">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="9244e-290">Se o semáforo do sistema não existir, este método lança uma exceção em vez de criar o semáforo do sistema.</span><span class="sxs-lookup"><span data-stu-id="9244e-290">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="9244e-291">Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="9244e-291">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9244e-292">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, mesmo que os objetos que são retornados representam a mesma semáforo de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-292">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="9244e-293">Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Semaphore.OpenExisting%2A> sobrecarga de método e especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="9244e-293">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="9244e-294">Especificando o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread inserir o sinal e especificando as <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-294">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-295">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="9244e-295">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="9244e-296">O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-296">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="9244e-297">Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede que o usuário atual o direito de usar o semáforo, mas que concede o direito de ler e alterar as permissões no sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-297">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-298">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="9244e-298">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="9244e-299">A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-299">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9244e-300">Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="9244e-300">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9244e-301">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-301">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-302">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-302">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="9244e-303">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-303">-or-</span>
          </span>
          <span data-ttu-id="9244e-304">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-304">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9244e-305">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-305">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="9244e-306">O semáforo nomeado não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-306">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-307">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-307">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-308">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-308">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9244e-309">para chamar código não gerenciado para abrir um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-309">for calling unmanaged code to open a named system semaphore.</span>
          </span>
          <span data-ttu-id="9244e-310">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-310">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="9244e-311">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-311">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-312">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-312">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-313">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-313">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9244e-314">O nome do semáforo do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-314">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="9244e-315">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-315">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-316">Abre o semáforo nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-316">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-317">Um objeto que representa o semáforo do sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-317">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-318">O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads inserir o sinal e o <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-318">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="9244e-319">O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir um semáforo nomeado existente.</span><span class="sxs-lookup"><span data-stu-id="9244e-319">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="9244e-320">Se o semáforo do sistema não existir, este método lança uma exceção em vez de criar o semáforo do sistema.</span><span class="sxs-lookup"><span data-stu-id="9244e-320">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="9244e-321">Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="9244e-321">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9244e-322">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, mesmo que os objetos que são retornados representam a mesma semáforo de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-322">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-323">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="9244e-323">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="9244e-324">O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-324">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="9244e-325">Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-325">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-326">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-326">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="9244e-327">A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-327">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9244e-328">Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="9244e-328">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9244e-329">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-329">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-330">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-330">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="9244e-331">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-331">-or-</span>
          </span>
          <span data-ttu-id="9244e-332">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-332">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9244e-333">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-333">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="9244e-334">O semáforo nomeado não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-334">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-335">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-335">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-336">O semáforo nomeado existe, mas o usuário não tem os direitos de acesso de segurança desejados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-336">The named semaphore exists, but the user does not have the desired security access rights.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="9244e-337">para chamar código não gerenciado para criar um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-337">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="9244e-338">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="9244e-339">Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-340">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-340">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-341">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-341">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9244e-342">O semáforo é encerrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-342">Exits the semaphore.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9244e-343">Sai do sinal e retorna à contagem anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-343">Exits the semaphore and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-344">A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-344">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-345">Os threads geralmente usam o <xref:System.Threading.WaitHandle.WaitOne%2A> método para inserir o sinal e eles normalmente usar essa sobrecarga de método para sair.</span><span class="sxs-lookup"><span data-stu-id="9244e-345">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="9244e-346">Se um <xref:System.Threading.SemaphoreFullException> é lançada pelo <xref:System.Threading.Semaphore.Release%2A> método, ele não indica necessariamente um problema com o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="9244e-346">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="9244e-347">Um erro de programação em outro thread pode ter causado esse thread sair do sinal mais vezes que ele é inserido.</span><span class="sxs-lookup"><span data-stu-id="9244e-347">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="9244e-348">Se o atual <xref:System.Threading.Semaphore> objeto representa um semáforo de sistema nomeado, o usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos.</span><span class="sxs-lookup"><span data-stu-id="9244e-348">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-349">O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</span><span class="sxs-lookup"><span data-stu-id="9244e-349">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="9244e-350">O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-350">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="9244e-351">O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-351">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="9244e-352">Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-352">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-353">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</span><span class="sxs-lookup"><span data-stu-id="9244e-353">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="9244e-354">Console mensagens controlar o uso do semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-354">Console messages track semaphore use.</span></span> <span data-ttu-id="9244e-355">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</span><span class="sxs-lookup"><span data-stu-id="9244e-355">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="9244e-356">A contagem de semáforo já está no valor máximo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-356">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-357">Ocorreu um erro de Win32 com um semáforo nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-357">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-358">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-358">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
          <span data-ttu-id="9244e-359">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-359">-or-</span>
          </span>
          <span data-ttu-id="9244e-360">O sinal do atual representa um sinal de sistema nomeado, mas não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-360">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-361">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-361">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-362">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-362">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">
          <span data-ttu-id="9244e-363">O número de vezes para sair do sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-363">The number of times to exit the semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-364">Sai do sinal de um número de vezes especificado e retorna à contagem anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-364">Exits the semaphore a specified number of times and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-365">A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-365">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-366">Se um thread tiver inserido o sinal várias vezes, essa sobrecarga de método permite que a contagem de semáforo inteiro a ser restaurado com uma chamada.</span><span class="sxs-lookup"><span data-stu-id="9244e-366">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="9244e-367">Se um <xref:System.Threading.SemaphoreFullException> é lançada pelo <xref:System.Threading.Semaphore.Release%2A> método, ele não indica necessariamente um problema com o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="9244e-367">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="9244e-368">Um erro de programação em outro thread pode ter causado esse thread sair do sinal mais vezes que ele é inserido.</span><span class="sxs-lookup"><span data-stu-id="9244e-368">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="9244e-369">Se o atual <xref:System.Threading.Semaphore> objeto representa um semáforo de sistema nomeado, o usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos.</span><span class="sxs-lookup"><span data-stu-id="9244e-369">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-370">O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero.</span><span class="sxs-lookup"><span data-stu-id="9244e-370">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="9244e-371">O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-371">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="9244e-372">O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-372">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="9244e-373">Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-373">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-374">Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida.</span><span class="sxs-lookup"><span data-stu-id="9244e-374">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="9244e-375">Console mensagens controlar o uso do semáforo.</span><span class="sxs-lookup"><span data-stu-id="9244e-375">Console messages track semaphore use.</span></span> <span data-ttu-id="9244e-376">O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.</span><span class="sxs-lookup"><span data-stu-id="9244e-376">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="9244e-377">
            <paramref name="releaseCount" /> é menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-377">
              <paramref name="releaseCount" /> is less than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="9244e-378">A contagem de semáforo já está no valor máximo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-378">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-379">Ocorreu um erro de Win32 com um semáforo nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-379">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-380">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-380">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
          <span data-ttu-id="9244e-381">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-381">-or-</span>
          </span>
          <span data-ttu-id="9244e-382">O sinal atual representa um sinal de sistema nomeado, mas não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-382">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-383">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-383">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-384">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-384">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">
          <span data-ttu-id="9244e-385">Um objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-385">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-386">Define a segurança de controle de acesso para um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-386">Sets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-387">Você pode definir a segurança de controle de acesso somente no <xref:System.Threading.Semaphore> objetos que representam os sinais de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-387">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="9244e-388">O usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> direitos para chamar esse método e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> direitos.</span><span class="sxs-lookup"><span data-stu-id="9244e-388">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9244e-389">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="9244e-389">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="9244e-390">O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-390">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="9244e-391">Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.</span><span class="sxs-lookup"><span data-stu-id="9244e-391">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="9244e-392">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-392">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="9244e-393">A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-393">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9244e-394">Depois que as permissões forem alteradas, usando o <xref:System.Threading.Semaphore.SetAccessControl%2A> método, o sinal é aberto com os direitos necessários para inserir e de versão.</span><span class="sxs-lookup"><span data-stu-id="9244e-394">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="9244e-395">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="9244e-395">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9244e-396">
            <paramref name="semaphoreSecurity" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-396">
              <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-397">O usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-397">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
          <span data-ttu-id="9244e-398">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-398">-or-</span>
          </span>
          <span data-ttu-id="9244e-399">O semáforo não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-399">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="9244e-400">O objeto <see cref="T:System.Threading.Semaphore" /> atual não representa um semáforo de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-400">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="9244e-401">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-401">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
          <span data-ttu-id="9244e-402">Sinal</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-402">Semaphore</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9244e-403">Abre um semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-403">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9244e-404">O nome do semáforo do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-404">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="9244e-405">Quando esse método retorna, contém um objeto <see cref="T:System.Threading.Semaphore" /> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-405">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="9244e-406">Esse parâmetro é tratado como não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-406">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-407">Abre o semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-407">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-408">
            <see langword="true" /> se o semáforo nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-408">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-409">Se o semáforo nomeado não existir, esse método não cria-lo.</span><span class="sxs-lookup"><span data-stu-id="9244e-409">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="9244e-410">Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="9244e-410">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9244e-411">Se você não tiver certeza se um semáforo nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método que lança uma exceção se o semáforo não existir.</span><span class="sxs-lookup"><span data-stu-id="9244e-411">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="9244e-412">Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Semaphore.TryOpenExisting%2A> sobrecarga de método e especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="9244e-412">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="9244e-413">Especificando o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread inserir o sinal e especificando as <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-413">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-414">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-414">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="9244e-415">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-415">-or-</span>
          </span>
          <span data-ttu-id="9244e-416">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-416">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9244e-417">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-417">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-418">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-418">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-419">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-419">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="9244e-420">O nome do semáforo do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-420">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="9244e-421">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-421">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="9244e-422">Quando esse método retorna, contém um objeto <see cref="T:System.Threading.Semaphore" /> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-422">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="9244e-423">Esse parâmetro é tratado como não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-423">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9244e-424">Se o semáforo nomeado especificado já existe, abre-o com o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-424">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9244e-425">
            <see langword="true" /> se o semáforo nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-425">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9244e-426">Se o semáforo nomeado não existir, esse método não cria-lo.</span><span class="sxs-lookup"><span data-stu-id="9244e-426">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="9244e-427">Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="9244e-427">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9244e-428">Se você não tiver certeza se um semáforo nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método que lança uma exceção se o semáforo não existir.</span><span class="sxs-lookup"><span data-stu-id="9244e-428">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="9244e-429">O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads inserir o sinal e o <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9244e-429">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="9244e-430">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, mesmo que os objetos que são retornados representam a mesma semáforo de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="9244e-430">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="9244e-431">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-431">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="9244e-432">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-432">-or-</span>
          </span>
          <span data-ttu-id="9244e-433">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-433">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="9244e-434">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-434">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="9244e-435">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-435">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="9244e-436">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9244e-436">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>