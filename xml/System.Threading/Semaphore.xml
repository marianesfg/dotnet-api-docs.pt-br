<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="341a2bbc0c3988004ab57f93d5e715cb713edbe1" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48748917" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Threading.Semaphore> classe para controlar o acesso a um pool de recursos. Threads inserem o sinal chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método, que é herdado do <xref:System.Threading.WaitHandle> classe e liberar o semáforo, chamando o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 A contagem em um semáforo é decrementada sempre que um thread entra o semáforo e incrementado quando um thread libera o semaphore. Quando a contagem for zero, as solicitações subsequentes bloqueiam até que outros threads liberam o sinal. Quando todos os threads lançaram o semáforo, a contagem é o valor máximo especificada quando o sinal foi criado.  
  
 Não há nenhuma garantia de ordem, como PEPS ou UEPS, no qual os threads bloqueados inserem o sinal.  
  
 Um thread pode inserir várias vezes, do semáforo, chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método repetidamente. Para algumas ou todas essas entradas de versão, o thread pode chamar o Next sem parâmetros <xref:System.Threading.Semaphore.Release> sobrecarga do método várias vezes, ou ele pode chamar o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método que especifica o número de entradas a ser liberado.  
  
 O <xref:System.Threading.Semaphore> classe não impõe a identidade do thread em chamadas para <xref:System.Threading.WaitHandle.WaitOne%2A> ou <xref:System.Threading.Semaphore.Release%2A>. É responsabilidade do programador garantir que threads não liberam o sinal muitas vezes. Por exemplo, suponha que um sinal tenha uma contagem máxima de dois, e que o thread A e o thread B insiram o sinal. Se um erro de programação no thread B faz com que ele chame <xref:System.Threading.Semaphore.Release%2A> duas vezes, as duas chamadas tenha êxito. A contagem no sinal está completa e quando o thread A eventualmente chama <xref:System.Threading.Semaphore.Release%2A>, uma <xref:System.Threading.SemaphoreFullException> é lançada.  
  
 Semáforos são de dois tipos: locais semáforos e sinais de sistema nomeado. Se você criar um <xref:System.Threading.Semaphore> usando um construtor que aceita um nome de objeto é associado com um semáforo de sistema operacional desse nome. Do sistema nomeado semáforos são visíveis em todo o sistema operacional e podem ser usados para sincronizar as atividades de processos. Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo, e você pode usar o <xref:System.Threading.Semaphore.OpenExisting%2A> semáforo de sistema nomeado do método para abrir um existente.  
  
 Um semáforo local existe somente dentro de seu processo. Ele pode ser usado por qualquer thread em seu processo que tenha referência ao objeto <xref:System.Threading.Semaphore> local. Cada <xref:System.Threading.Semaphore> objeto é um semáforo local separado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo. Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do semáforo. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um semáforo sem nome. Todos os threads que usam uma instância de tal um semáforo devem ter referências à instância.  
  
 Se `initialCount` é menor que `maximumCount`, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes. Se não desejar reservar todas as entradas para o thread que cria o semáforo, use o mesmo número para `maximumCount` e `initialCount`.  
  
   
  
## Examples  
 O exemplo a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo. Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do semáforo. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
- ou - 
 <paramref name="initialCount" /> é menor que 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas e, opcionalmente, especificando o nome de um objeto de sinal de sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado. Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo.  
  
 Se o semáforo de sistema nomeado não existir, ele será criado com a contagem inicial e máximo especificado por `initialCount` e `maximumCount`. Se o semáforo de sistema nomeado já existir, `initialCount` e `maximumCount` não forem usados, embora ainda, valores inválidos causam exceções. Se você precisar determinar se ou não um semáforo de sistema nomeado foi criado, use o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> sobrecarga do construtor.  
  
> [!IMPORTANT]
>  Quando você usa essa sobrecarga de construtor, a prática recomendada é especificar o mesmo número para `initialCount` e `maximumCount`. Se `initialCount` é menor que `maximumCount`e um semáforo de sistema nomeado é criado, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes. No entanto, com essa sobrecarga de construtor não há nenhuma maneira de determinar se um semáforo de sistema nomeado foi criado.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor.  
  
 Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos entre os limites do processo.  
  
 Se você deseja saber se existe um semáforo de sistema nomeado, use o <xref:System.Threading.Semaphore.OpenExisting%2A> método. O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir um semáforo nomeado existente e gera uma exceção se o semáforo do sistema não existe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado. O exemplo cria um semáforo nomeado com uma contagem máxima de cinco e uma contagem inicial de cinco. O programa faz três chamadas para o <xref:System.Threading.WaitHandle.WaitOne%2A> método. Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará a terceira chamada para <xref:System.Threading.WaitHandle.WaitOne%2A>. Solte um ou mais entradas na primeira cópia do programa para desbloquear o segundo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
- ou - 
 <paramref name="initialCount" /> é menor que 0.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
        <param name="createdNew">Quando este método retorna, contém <see langword="true" /> se um semáforo local foi criado (ou seja, se <c>name</c> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o semáforo do sistema nomeado especificado foi criado; <see langword="false" /> se o semáforo do sistema nomeado especificado já existia. Este parâmetro é passado não inicializado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema e especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado. Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo.  
  
 Se o semáforo de sistema nomeado não existir, ele será criado com a contagem inicial e máximo especificado por `initialCount` e `maximumCount`. Se o semáforo de sistema nomeado já existir, `initialCount` e `maximumCount` não forem usados, embora ainda, valores inválidos causam exceções. Use `createdNew` para determinar se o semáforo do sistema foi criado.  
  
 Se `initialCount` é menor que `maximumCount`, e `createdNew` é `true`, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos entre os limites do processo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado. O exemplo cria um semáforo nomeado com uma contagem máxima de cinco e uma contagem inicial de dois. Ou seja, ele reserva três entradas para o thread que chama o construtor. Se `createNew` está `false`, o programa faz três chamadas para o <xref:System.Threading.WaitHandle.WaitOne%2A> método. Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará a terceira chamada para <xref:System.Threading.WaitHandle.WaitOne%2A>. Solte um ou mais entradas na primeira cópia do programa para desbloquear o segundo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
- ou - 
 <paramref name="initialCount" /> é menor que 0.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
        <param name="createdNew">Quando este método retorna, contém <see langword="true" /> se um semáforo local foi criado (ou seja, se <c>name</c> for <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o semáforo do sistema nomeado especificado foi criado; <see langword="false" /> se o semáforo do sistema nomeado especificado já existia. Este parâmetro é passado não inicializado.</param>
        <param name="semaphoreSecurity">Um objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao semáforo de sistema nomeado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema, especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado e especificando o controle de acesso de segurança para o semáforo do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse construtor para aplicar a segurança de controle de acesso a um semáforo de sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle do sinal do.  
  
 Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado. Você pode criar várias <xref:System.Threading.Semaphore> semáforo de sistema nomeado de objetos que representam o mesmo.  
  
 Se o semáforo de sistema nomeado não existir, ele é criado com a segurança de controle de acesso especificado. Se o semáforo nomeado existe, a segurança de controle de acesso especificado será ignorada.  
  
> [!NOTE]
>  O chamador tem controle total sobre o recém-criado <xref:System.Threading.Semaphore> objeto mesmo se `semaphoreSecurity` nega ou falha em conceder a alguns direitos de acesso para o usuário atual. No entanto, se o usuário atual tenta obter outra <xref:System.Threading.Semaphore> representar o mesmo semáforo nomeado, usando um construtor de objeto ou o <xref:System.Threading.Semaphore.OpenExisting%2A> método, o Windows a segurança de controle de acesso é aplicada.  
  
 Se o semáforo de sistema nomeado não existir, ele será criado com a contagem inicial e máximo especificado por `initialCount` e `maximumCount`. Se o semáforo de sistema nomeado já existir, `initialCount` e `maximumCount` não forem usados, embora ainda, valores inválidos causam exceções. Use o `createdNew` parâmetro para determinar se o semáforo do sistema foi criado por esse construtor.  
  
 Se `initialCount` é menor que `maximumCount`, e `createdNew` é `true`, o efeito é o mesmo como se o thread atual tivesse chamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos entre os limites do processo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado. Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal. Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e de versão. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
- ou - 
 <paramref name="initialCount" /> é menor que 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O sinal nomeado existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define a segurança de controle de acesso para um semáforo de sistema nomeado.</summary>
        <returns>Um objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa a segurança do controle de acesso para o semáforo de sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Semaphore.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para pesquisar as permissões: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 O usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> direitos para chamar esse método e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> direitos.  
  
 Em um semáforo local, a segurança de controle de acesso é irrelevante. Se o <xref:System.Threading.Semaphore> objeto não representa um semáforo de sistema nomeado, esse método retorna um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que concede todos os direitos a qualquer usuário.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.  
  
 Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões. A segurança de controle de acesso para o semáforo do sistema é obtida usando o <xref:System.Threading.Semaphore.GetAccessControl%2A> método.  
  
 Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e de versão. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O objeto <see cref="T:System.Threading.Semaphore" /> atual representa um semáforo de sistema nomeado e o usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
- ou - 
O objeto <see cref="T:System.Threading.Semaphore" /> atual representa um semáforo de sistema nomeado e não foi aberto com os direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um semáforo nomeado especificado, caso ele já exista.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <summary>Abre o semáforo nomeado especificado, caso ele já exista.</summary>
        <returns>Um objeto que representa o semáforo do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir o semáforo nomeado especificado. Se o semáforo do sistema não existir, este método lança uma exceção em vez de criar o semáforo do sistema. Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, mesmo que os objetos que são retornados representam a mesma semáforo de sistema nomeado.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Semaphore.OpenExisting%2A> sobrecarga de método e especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.  
  
 Especificando o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread inserir o sinal e especificando as <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.  
  
 Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede que o usuário atual o direito de usar o semáforo, mas que concede o direito de ler e alterar as permissões no sinal.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O semáforo nomeado não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para abrir um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</param>
        <summary>Abre o semáforo nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</summary>
        <returns>Um objeto que representa o semáforo do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads inserir o sinal e o <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir um semáforo nomeado existente. Se o semáforo do sistema não existir, este método lança uma exceção em vez de criar o semáforo do sistema. Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, mesmo que os objetos que são retornados representam a mesma semáforo de sistema nomeado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.  
  
 Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O semáforo nomeado não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem os direitos de acesso de segurança desejados.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>O semáforo é encerrado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sai do sinal e retorna à contagem anterior.</summary>
        <returns>A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os threads geralmente usam o <xref:System.Threading.WaitHandle.WaitOne%2A> método para inserir o sinal e eles normalmente usar essa sobrecarga de método para sair.  
  
 Se um <xref:System.Threading.SemaphoreFullException> é lançada pelo <xref:System.Threading.Semaphore.Release%2A> método, ele não indica necessariamente um problema com o thread de chamada. Um erro de programação em outro thread pode ter causado esse thread sair do sinal mais vezes que ele é inserido.  
  
 Se o atual <xref:System.Threading.Semaphore> objeto representa um semáforo de sistema nomeado, o usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo.  
  
 Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do semáforo. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">A contagem de semáforo já está no valor máximo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de Win32 com um semáforo nomeado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- ou - 
O sinal do atual representa um sinal de sistema nomeado, mas não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">O número de vezes para sair do sinal.</param>
        <summary>Sai do sinal de um número de vezes especificado e retorna à contagem anterior.</summary>
        <returns>A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um thread tiver inserido o sinal várias vezes, essa sobrecarga de método permite que a contagem de semáforo inteiro a ser restaurado com uma chamada.  
  
 Se um <xref:System.Threading.SemaphoreFullException> é lançada pelo <xref:System.Threading.Semaphore.Release%2A> método, ele não indica necessariamente um problema com o thread de chamada. Um erro de programação em outro thread pode ter causado esse thread sair do sinal mais vezes que ele é inserido.  
  
 Se o atual <xref:System.Threading.Semaphore> objeto representa um semáforo de sistema nomeado, o usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, o que bloqueiam ao aguardar o semáforo. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga de método para aumentar a contagem do semáforo ao máximo, permitindo que os três threads inserir o sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para aguardar um segundo, para simular trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga de método para liberar o semáforo.  
  
 Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do semáforo. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> é menor que 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">A contagem de semáforo já está no valor máximo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de Win32 com um semáforo nomeado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo atual representa um semáforo de sistema nomeado, mas o usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- ou - 
O sinal atual representa um sinal de sistema nomeado, mas não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Um objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao semáforo de sistema nomeado.</param>
        <summary>Define a segurança de controle de acesso para um semáforo de sistema nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir a segurança de controle de acesso somente no <xref:System.Threading.Semaphore> objetos que representam os sinais de sistema nomeado.  
  
 O usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> direitos para chamar esse método e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> direitos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um semáforo nomeado.  
  
 Se o semáforo não existir, ele será criado com uma contagem máxima de dois e com segurança de controle de acesso que impede o direito de usar o semáforo que o usuário atual, mas concede o direito de ler e alterar as permissões no sinal.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, usando o <xref:System.Threading.Semaphore.SetAccessControl%2A> método, o sinal é aberto com os direitos necessários para inserir e de versão. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
- ou - 
O semáforo não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">O objeto <see cref="T:System.Threading.Semaphore" /> atual não representa um semáforo de sistema nomeado.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Sinal</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <param name="result">Quando esse método retorna, contém um objeto <see cref="T:System.Threading.Semaphore" /> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Abre o semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns>
          <see langword="true" /> se o semáforo nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o semáforo nomeado não existir, esse método não cria-lo. Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se um semáforo nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método que lança uma exceção se o semáforo não existir.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Semaphore.TryOpenExisting%2A> sobrecarga de método e especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit. Especificando o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread inserir o sinal e especificando as <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</param>
        <param name="result">Quando esse método retorna, contém um objeto <see cref="T:System.Threading.Semaphore" /> que representa o semáforo nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Se o semáforo nomeado especificado já existe, abre-o com o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns>
          <see langword="true" /> se o semáforo nomeado foi aberto com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o semáforo nomeado não existir, esse método não cria-lo. Para criar o semáforo do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se um semáforo nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método que lança uma exceção se o semáforo não existir.  
  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads inserir o sinal e o <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, mesmo que os objetos que são retornados representam a mesma semáforo de sistema nomeado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>