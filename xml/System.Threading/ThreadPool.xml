<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7542193821586bc0241b3b3025f0ccf05510af2f" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609229" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="abbc4-101">Fornece um pool de threads que podem ser usados para executar tarefas, postar os itens de trabalho, processar E/S assíncrona, aguardar em nome de outros threads e processar temporizadores.</span>
      <span class="sxs-lookup">
        <span data-stu-id="abbc4-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-102">Muitos aplicativos criam threads que passam muito tempo no estado de repouso, aguardando um evento ocorra.</span><span class="sxs-lookup"><span data-stu-id="abbc4-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="abbc4-103">Outros threads podem entrar em um estado suspenso apenas para ser despertado periodicamente para sondar uma alteração ou atualizar as informações de status.</span><span class="sxs-lookup"><span data-stu-id="abbc4-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="abbc4-104">O pool de threads permite que você use threads com mais eficiência, fornecendo seu aplicativo com um pool de threads de trabalho que são gerenciados pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="abbc4-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="abbc4-105">Exemplos de operações que usam threads do pool incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="abbc4-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="abbc4-106">Quando você cria um <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> objeto para executar uma tarefa de forma assíncrona, por padrão, a tarefa está agendada para execução em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="abbc4-107">Temporizadores assíncronos usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="abbc4-108">Retornos de chamada de execução do thread do pool de threads a <xref:System.Threading.Timer?displayProperty=nameWithType> de classe e gerar eventos do <xref:System.Timers.Timer?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="abbc4-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="abbc4-109">Quando você usa identificadores de espera registrada, um thread do sistema monitora o status dos identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="abbc4-110">Quando uma operação de espera for concluída, um thread de trabalho do pool de threads executa a função de retorno de chamada correspondente.</span><span class="sxs-lookup"><span data-stu-id="abbc4-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="abbc4-111">Quando você chama o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método para enfileirar um método para execução em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="abbc4-112">Faça isso passando o método um <xref:System.Threading.WaitCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="abbc4-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="abbc4-113">O delegado tem a assinatura</span><span class="sxs-lookup"><span data-stu-id="abbc4-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="abbc4-114">onde `state` é um objeto que contém dados a serem usados pelo delegado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="abbc4-115">Os dados reais podem ser passados para o delegado, chamando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abbc4-116">Os threads no pool de threads gerenciados são threads em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="abbc4-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="abbc4-117">Ou seja, seus <xref:System.Threading.Thread.IsBackground%2A> são propriedades `true`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="abbc4-118">Isso significa que um <xref:System.Threading.ThreadPool> thread não manterá um aplicativo em execução depois que todos os threads de primeiro plano tenham saído.</span><span class="sxs-lookup"><span data-stu-id="abbc4-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="abbc4-119">Quando o pool de threads reutiliza um thread, ele não limpa os dados no armazenamento local de thread ou nos campos marcados com o <xref:System.ThreadStaticAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="abbc4-120">Portanto, quando um método examina o armazenamento local de thread ou campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo, os valores que ele encontra podem ser deixados de uso anterior do thread do pool.</span><span class="sxs-lookup"><span data-stu-id="abbc4-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="abbc4-121">Também é possível enfileirar itens de trabalho que não estão relacionados a uma operação de espera para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="abbc4-122">Para solicitar que um item de trabalho manipulada por um thread no pool de threads, chame o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="abbc4-123">Esse método aceita como um parâmetro de uma referência para o método ou delegate que será chamado pelo thread selecionado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="abbc4-124">Não há nenhuma maneira de cancelar um item de trabalho depois que ele foi enfileirado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="abbc4-125">Temporizadores de fila do temporizador e operações de espera registrada também usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="abbc4-126">Suas funções de retorno de chamada são enfileiradas para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="abbc4-127">Há um pool de threads por processo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-127">There is one thread pool per process.</span></span> <span data-ttu-id="abbc4-128">A partir do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o tamanho padrão do pool de threads de um processo depende de vários fatores, como o tamanho do espaço de endereço virtual.</span><span class="sxs-lookup"><span data-stu-id="abbc4-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="abbc4-129">Um processo pode chamar o método <xref:System.Threading.ThreadPool.GetMaxThreads%2A> para determinar o número de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="abbc4-130">O número de threads no pool de threads pode ser alterado usando o <xref:System.Threading.ThreadPool.SetMaxThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="abbc4-131">Cada thread usa o tamanho da pilha padrão e é executado com prioridade padrão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abbc4-132">Código não gerenciado que hospeda o .NET Framework pode alterar o tamanho do pool de threads usando a `CorSetMaxThreads` função, definida no arquivo MSCOREE. h.</span><span class="sxs-lookup"><span data-stu-id="abbc4-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="abbc4-133">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="abbc4-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="abbc4-134">Quando um mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde a conclusão de algumas tarefas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="abbc4-135">A partir do [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads de trabalho a fim de otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="abbc4-136">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abbc4-137">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="abbc4-138">Você pode usar o método <xref:System.Threading.ThreadPool.GetMinThreads%2A> para obter esses valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-139">Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar o número mínimo de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="abbc4-140">No entanto, o aumento desnecessário desses valores pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="abbc4-141">Se muitas tarefas começarem ao mesmo tempo, todas elas podem parecer lentas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="abbc4-142">Na maioria dos casos, o pool de threads terá um desempenho melhor com seu próprio algoritmo de alocação de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-143">No exemplo a seguir, o thread principal do aplicativo enfileira um método chamado `ThreadProc` para executar em um pool de threads, dorme por um segundo e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="abbc4-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="abbc4-144">O `ThreadProc` método simplesmente exibe uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="abbc4-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="abbc4-145">Se você comentar a chamada para o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método, o thread principal é encerrado antes que o método é executado no thread do pool.</span><span class="sxs-lookup"><span data-stu-id="abbc4-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="abbc4-146">O pool de threads usa threads em segundo plano, o que não mantém o aplicativo em execução se todos os threads de primeiro plano tiverem terminado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="abbc4-147">(Isso é um exemplo simples de uma condição de corrida.)</span><span class="sxs-lookup"><span data-stu-id="abbc4-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="abbc4-148">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="abbc4-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="abbc4-149">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="abbc4-150">Um <see cref="T:System.IntPtr" /> que contém o identificador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="abbc4-151">O identificador deve ter sido aberto para o E/S sobreposto no lado não gerenciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-152">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-153">
            <see langword="true" /> se o identificador estiver associado; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="abbc4-154">O chamador não tem a permissão necessária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="abbc4-155">para a capacidade de chamar código não gerenciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="abbc4-156">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="abbc4-157">Um <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que contém o identificador do sistema operacional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="abbc4-158">O identificador deve ter sido aberto para o E/S sobreposto no lado não gerenciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-159">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-160">
            <see langword="true" /> se o identificador estiver associado; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-161">O `osHandle` parâmetro deve ser um <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, que é derivada de abstrata <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="abbc4-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="abbc4-162">
            <paramref name="osHandle" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="abbc4-163">para a capacidade de chamar código não gerenciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="abbc4-164">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="abbc4-165">O número de threads de trabalho disponíveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="abbc4-166">O número de threads de E/S assíncronos disponíveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-167">Recupera a diferença entre o número máximo de threads do pool de threads retornados pelo método <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> e o número de ativos no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-168">Quando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> retorna a variável especificada pela `workerThreads` contém o número de threads de trabalho adicional que podem ser iniciados e a variável especificada pela `completionPortThreads` contém o número de assíncronos threads de e/s adicionais que podem ser iniciado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="abbc4-169">Se não houver nenhum thread disponível, as solicitações de pool de threads adicionais permanecem na fila até que os threads do pool se tornam disponível.</span><span class="sxs-lookup"><span data-stu-id="abbc4-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-170">O exemplo a seguir exibe o número de threads de trabalho e os threads de e/s disponíveis quando um aplicativo simples é iniciado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="abbc4-171">O número máximo de threads de trabalho no pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="abbc4-172">O número máximo de threads de E/S assíncronas no pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-173">Recupera o número de solicitações para o pool de threads que podem estar ativas simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="abbc4-174">Todas as solicitações acima desse número permanecem na fila até que os threads do pool de threads se tornem disponíveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-175">Quando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> retorna a variável especificada pela `workerThreads` contém o número máximo de threads de trabalho permitidos no pool de threads e a variável especificada pela `completionPortThreads` contém o número máximo de threads de e/s assíncronas permitidas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="abbc4-176">Você pode usar o <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> método para determinar o número real de threads no pool de threads em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="abbc4-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="abbc4-177">Você pode usar o <xref:System.Threading.ThreadPool.SetMaxThreads%2A> para definir o número máximo de threads de trabalho e os threads de e/s assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="abbc4-178">É possível enfileirar como muitas solicitações do pool de threads permite a memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="abbc4-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="abbc4-179">Se houver mais solicitações que os threads do pool, as solicitações adicionais permanecem na fila até que os threads do pool se tornam disponível.</span><span class="sxs-lookup"><span data-stu-id="abbc4-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-180">O exemplo de código a seguir mostra como recuperar uma contagem do número de threads no pool de threads máximo e está disponível.</span><span class="sxs-lookup"><span data-stu-id="abbc4-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="abbc4-181">Um item de trabalho é colocada na fila que usa `FileStream` gravar de maneira assíncrona para dois arquivos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="abbc4-182">Os métodos de retorno de chamada são atingiu o tempo limite se sobreponham.</span><span class="sxs-lookup"><span data-stu-id="abbc4-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="abbc4-183">Um thread de trabalho trata o item de trabalho e, dependendo da velocidade e no número de processadores no computador, um ou dois threads de porta de conclusão lidar com as operações de gravação.</span><span class="sxs-lookup"><span data-stu-id="abbc4-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="abbc4-184">Quando este método retorna, ele contém o número mínimo de threads de trabalho que o pool de threads cria sob demanda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="abbc4-185">Quando este método retorna, ele contém o número mínimo de threads de E/S assíncronas que o pool de threads cria sob demanda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-186">Recupera o número mínimo de threads que o pool de threads cria sob demanda à medida que novas solicitações são feitas, antes de mudar para um algoritmo a fim de gerenciar a criação e a destruição de thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-187">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="abbc4-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="abbc4-188">Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema.</span><span class="sxs-lookup"><span data-stu-id="abbc4-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="abbc4-189">Quando o mínimo é atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde a conclusão de algumas tarefas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="abbc4-190">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="abbc4-191">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abbc4-192">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-193">O exemplo a seguir define o número mínimo de threads de trabalho para quatro e preserva o valor original para o número mínimo de threads de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="abbc4-194">Enfileira um método para execução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="abbc4-195">O método é executado quando um thread de pool de threads se torna disponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="abbc4-196">Um <see cref="T:System.Threading.WaitCallback" /> que representa o método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-197">Enfileira um método para execução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="abbc4-198">O método é executado quando um thread de pool de threads se torna disponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-199">
            <see langword="true" /> se o método for colocado na fila com êxito; <see cref="T:System.NotSupportedException" /> será gerado se o item de trabalho não puder ser colocado na fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-200">Você pode colocar os dados necessários para o método em fila nos campos de instância da classe na qual o método é definido, ou você pode usar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> sobrecarga que aceita um objeto que contém os dados necessários.</span><span class="sxs-lookup"><span data-stu-id="abbc4-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abbc4-201">Usuários do Visual Basic podem omitir as <xref:System.Threading.WaitCallback> construtor e simplesmente usar o `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="abbc4-202">Visual Basic chama automaticamente o construtor delegado correto.</span><span class="sxs-lookup"><span data-stu-id="abbc4-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="abbc4-203">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="abbc4-203">Version Information</span></span>  
 <span data-ttu-id="abbc4-204">No .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="abbc4-205">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-206">O exemplo a seguir usa o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> sobrecarga de método para enfileirar uma tarefa, que é representada pelo `ThreadProc` método a ser executado quando um thread fique disponível.</span><span class="sxs-lookup"><span data-stu-id="abbc4-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="abbc4-207">Nenhuma informação de tarefa é fornecida com essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="abbc4-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="abbc4-208">Portanto, as informações que está disponíveis para o `ThreadProc` método é limitado ao objeto ao qual o método pertence.</span><span class="sxs-lookup"><span data-stu-id="abbc4-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="abbc4-209">
            <paramref name="callBack" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="abbc4-210">O CLR (Common Language Runtime) está hospedado e o host não dá suporte a essa ação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="abbc4-211">Um <see cref="T:System.Threading.WaitCallback" /> que representa o método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-212">Um objeto que contém dados a serem usados pelo método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-213">Enfileira um método para execução e especifica um objeto que contém dados a serem usados pelo método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="abbc4-214">O método é executado quando um thread de pool de threads se torna disponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-215">
            <see langword="true" /> se o método for colocado na fila com êxito; <see cref="T:System.NotSupportedException" /> será gerado se o item de trabalho não puder ser colocado na fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-216">Se o método de retorno de chamada requer dados complexos, você pode definir uma classe para conter os dados.</span><span class="sxs-lookup"><span data-stu-id="abbc4-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="abbc4-217">Usuários do Visual Basic podem omitir as <xref:System.Threading.WaitCallback> construtor e simplesmente usar o `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="abbc4-218">Visual Basic chama automaticamente o construtor delegado correto.</span><span class="sxs-lookup"><span data-stu-id="abbc4-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="abbc4-219">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="abbc4-219">Version Information</span></span>  
 <span data-ttu-id="abbc4-220">No .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="abbc4-221">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-222">O exemplo a seguir mostra como criar um objeto que contém informações sobre a tarefa.</span><span class="sxs-lookup"><span data-stu-id="abbc4-222">The following example shows how to create an object that contains task information.</span></span> <span data-ttu-id="abbc4-223">Ele também demonstra como passar esse objeto para uma tarefa que está na fila para execução pelo pool de segmentos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-223">It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="abbc4-224">O CLR (Common Language Runtime) está hospedado e o host não dá suporte a essa ação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-224">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="abbc4-225">
            <paramref name="callBack" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-225">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="abbc4-226">Registra um representante que está aguardando um <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-226">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-227">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-227">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-228">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-228">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-229">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-229">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-230">O objeto que é passado para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-230">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="abbc4-231">O tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-231">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-232">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-232">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-233">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-233">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-234">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-234">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-235">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 32 bits para o tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-235">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-236">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-236">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-237">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-237">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-238">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-238">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-239">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-239">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="abbc4-240">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-240">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="abbc4-241">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="abbc4-241">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="abbc4-242">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-242">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="abbc4-243">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-243">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="abbc4-244">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-244">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="abbc4-245">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-245">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="abbc4-246">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-246">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="abbc4-247">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-247">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="abbc4-248">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-248">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="abbc4-249">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-249">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="abbc4-250">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="abbc4-250">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="abbc4-251">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-251">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="abbc4-252">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-252">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="abbc4-253">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="abbc4-253">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="abbc4-254">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="abbc4-254">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="abbc4-255">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="abbc4-255">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="abbc4-256">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-256">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="abbc4-257">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="abbc4-257">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="abbc4-258">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="abbc4-258">Version Information</span></span>  
 <span data-ttu-id="abbc4-259">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-259">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="abbc4-260">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-260">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-261">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-261">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-262">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-262">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-263">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-263">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-264">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-264">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-265">O objeto passado ao delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-265">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="abbc4-266">O tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-266">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-267">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-267">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-268">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-268">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-269">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-269">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-270">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 64 bits para o tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-270">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-271">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-271">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-272">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-272">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-273">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-273">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-274">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-274">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="abbc4-275">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-275">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="abbc4-276">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="abbc4-276">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="abbc4-277">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-277">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="abbc4-278">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-278">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="abbc4-279">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-279">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="abbc4-280">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-280">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="abbc4-281">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-281">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="abbc4-282">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-282">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="abbc4-283">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-283">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="abbc4-284">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-284">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="abbc4-285">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="abbc4-285">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="abbc4-286">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-286">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="abbc4-287">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-287">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="abbc4-288">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="abbc4-288">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="abbc4-289">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="abbc4-289">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="abbc4-290">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="abbc4-290">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="abbc4-291">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-291">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="abbc4-292">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="abbc4-292">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="abbc4-293">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="abbc4-293">Version Information</span></span>  
 <span data-ttu-id="abbc4-294">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-294">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="abbc4-295">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-295">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-296">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-296">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-297">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-297">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-298">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-298">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-299">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-299">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-300">O objeto passado ao delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-300">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="abbc4-301">O tempo limite representado por um <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-301">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="abbc4-302">Se <c>timeout</c> for 0 (zero), a função testará o estado do objeto e será retornada imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-302">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-303">Se <c>timeout</c> for -1, o intervalo de tempo limite da função nunca transcorrerá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-303">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-304">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-304">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-305">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-305">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-306">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-306">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-307">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-307">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-308">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-308">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-309">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-309">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="abbc4-310">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-310">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="abbc4-311">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="abbc4-311">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="abbc4-312">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-312">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="abbc4-313">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-313">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="abbc4-314">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-314">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="abbc4-315">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-315">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="abbc4-316">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-316">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="abbc4-317">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-317">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="abbc4-318">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-318">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="abbc4-319">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-319">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="abbc4-320">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="abbc4-320">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="abbc4-321">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-321">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="abbc4-322">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-322">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="abbc4-323">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="abbc4-323">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="abbc4-324">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="abbc4-324">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="abbc4-325">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="abbc4-325">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="abbc4-326">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-326">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="abbc4-327">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="abbc4-327">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="abbc4-328">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="abbc4-328">Version Information</span></span>  
 <span data-ttu-id="abbc4-329">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-329">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="abbc4-330">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-330">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-331">O parâmetro <paramref name="timeout" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-331">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="abbc4-332">O parâmetro <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-332">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-333">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-333">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-334">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-334">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-335">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-335">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-336">O objeto passado ao delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-336">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="abbc4-337">O tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-337">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-338">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-338">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-339">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-339">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-340">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-340">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-341">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro sem sinal de 32 bits para o tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-341">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-342">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-342">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-343">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-343">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-344">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-344">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-345">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-345">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="abbc4-346">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-346">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="abbc4-347">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="abbc4-347">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="abbc4-348">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-348">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="abbc4-349">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-349">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="abbc4-350">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-350">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="abbc4-351">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-351">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="abbc4-352">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-352">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="abbc4-353">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-353">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="abbc4-354">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="abbc4-354">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="abbc4-355">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-355">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="abbc4-356">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="abbc4-356">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="abbc4-357">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-357">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="abbc4-358">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-358">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="abbc4-359">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="abbc4-359">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="abbc4-360">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="abbc4-360">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="abbc4-361">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="abbc4-361">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="abbc4-362">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-362">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="abbc4-363">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="abbc4-363">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="abbc4-364">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="abbc4-364">Version Information</span></span>  
 <span data-ttu-id="abbc4-365">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-365">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="abbc4-366">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-366">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-367">O exemplo a seguir mostra como usar o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método para executar um método de retorno de chamada especificado quando um identificador de espera especificado é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-367">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="abbc4-368">Neste exemplo, o método de retorno de chamada é `WaitProc`, e o identificador de espera é um <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-368">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="abbc4-369">O exemplo define um `TaskInfo` classe para manter as informações que são passadas para o retorno de chamada quando ele é executado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-369">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="abbc4-370">O exemplo cria um `TaskInfo` do objeto e o atribui alguns dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="abbc4-370">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="abbc4-371">O <xref:System.Threading.RegisteredWaitHandle> que é retornado pela <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método é atribuído ao `Handle` campo da `TaskInfo` do objeto para que o método de retorno de chamada tem acesso ao <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="abbc4-371">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="abbc4-372">Além de especificar `TaskInfo` como o objeto a ser passado para o método de retorno de chamada, a chamada para o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método Especifica as <xref:System.Threading.AutoResetEvent> que a tarefa irá aguardar um <xref:System.Threading.WaitOrTimerCallback> delegado que representa o `WaitProc` método de retorno de chamada, um intervalo de tempo limite de um segundo e vários retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-372">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="abbc4-373">Quando o thread principal sinaliza a <xref:System.Threading.AutoResetEvent> chamando seus <xref:System.Threading.EventWaitHandle.Set%2A> método, o <xref:System.Threading.WaitOrTimerCallback> delegado é invocado.</span><span class="sxs-lookup"><span data-stu-id="abbc4-373">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="abbc4-374">O `WaitProc` testes de método <xref:System.Threading.RegisteredWaitHandle> para determinar se um tempo limite ocorreu.</span><span class="sxs-lookup"><span data-stu-id="abbc4-374">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="abbc4-375">Se o retorno de chamada foi invocado porque o identificador de espera foi sinalizado, o `WaitProc` método cancela o registro de <xref:System.Threading.RegisteredWaitHandle>, parando adicionais retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-375">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="abbc4-376">No caso de um tempo limite, a tarefa continua a espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-376">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="abbc4-377">O `WaitProc` método termina imprimindo uma mensagem no console.</span><span class="sxs-lookup"><span data-stu-id="abbc4-377">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-378">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-378">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="abbc4-379">O número máximo de threads de trabalho no pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-379">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="abbc4-380">O número máximo de threads de E/S assíncronas no pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-380">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-381">Define o número de solicitações para o pool de threads que podem estar ativas simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-381">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="abbc4-382">Todas as solicitações acima desse número permanecem na fila até que os threads do pool de threads se tornem disponíveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-382">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-383">
            <see langword="true" /> se a alteração for bem-sucedida; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-383">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-384">É possível definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor do que o número de processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="abbc4-384">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="abbc4-385">Para determinar quantos processadores estiverem presentes, recuperar o valor da <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="abbc4-385">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="abbc4-386">Além disso, você não pode definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor que o número correspondente de mínimo de threads de trabalho ou threads de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="abbc4-386">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="abbc4-387">Para determinar o tamanho do pool de threads mínimo, chame o <xref:System.Threading.ThreadPool.GetMinThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="abbc4-387">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="abbc4-388">Se o common language runtime está hospedado, por exemplo, serviços de informações da Internet (IIS) ou SQL Server, o host pode limitar ou impedir alterações para o tamanho do pool de thread.</span><span class="sxs-lookup"><span data-stu-id="abbc4-388">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="abbc4-389">Tenha cuidado ao alterar o número máximo de threads no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-389">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="abbc4-390">Enquanto seu código pode se beneficiar, as alterações podem ter um efeito adverso em bibliotecas de código que você usar.</span><span class="sxs-lookup"><span data-stu-id="abbc4-390">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="abbc4-391">Definir o tamanho do pool de thread muito grande pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-391">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="abbc4-392">Se muitos threads estão em execução ao mesmo tempo, a alternância de tarefas sobrecarga se torna um fator significativo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-392">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="abbc4-393">para a capacidade de controlar os threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-393">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="abbc4-394">Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-394">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="abbc4-395">O número mínimo de threads de trabalho que o pool de threads cria sob demanda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-395">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="abbc4-396">O número mínimo de threads de E/S assíncronos que o pool de threads cria sob demanda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-396">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-397">Define o número mínimo de threads que o pool de threads cria sob demanda à medida que novas solicitações são feitas, antes de mudar para um algoritmo a fim de gerenciar a criação e a destruição de thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-397">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-398">
            <see langword="true" /> se a alteração for bem-sucedida; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-398">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-399">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="abbc4-399">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="abbc4-400">Quando o mínimo é atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde a conclusão de algumas tarefas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-400">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="abbc4-401">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-401">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="abbc4-402">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-402">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="abbc4-403">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-403">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="abbc4-404">Se você especificar um número negativo ou um número maior que o número máximo de threads de pool de thread ativo (obtidos usando o <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> retorna `false` e não altera qualquer um dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="abbc4-404">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-405">Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema.</span><span class="sxs-lookup"><span data-stu-id="abbc4-405">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="abbc4-406">Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar o ofthreads número mínimo.</span><span class="sxs-lookup"><span data-stu-id="abbc4-406">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="abbc4-407">No entanto, o aumento desnecessário desses valores pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-407">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="abbc4-408">Se muitas tarefas começarem ao mesmo tempo, todas elas podem parecer lentas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-408">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="abbc4-409">Na maioria dos casos, o pool de threads terá um desempenho melhor com seu próprio algoritmo de alocação de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-409">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="abbc4-410">Reduzindo o mínimo menor do que o número de processadores também pode prejudicar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-410">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="abbc4-411">O exemplo a seguir define o número mínimo de threads de trabalho para quatro e preserva o valor original para o número mínimo de threads de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="abbc4-411">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="abbc4-412">para a capacidade de controlar os threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-412">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="abbc4-413">Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-413">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="abbc4-414">A estrutura <see cref="T:System.Threading.NativeOverlapped" /> a ser colocada em fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-414">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-415">Enfileira uma operação de E/S sobreposta para a execução.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-415">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-416">
            <see langword="true" /> se a operação foi enfileirada com êxito para uma porta de conclusão de E/S; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-416">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-417">Para obter informações sobre como usar o Win32 nativo e/s sobreposta, consulte o <xref:System.Threading.Overlapped> classe, o <xref:System.Threading.NativeOverlapped> estrutura e o `OVERLAPPED` estrutura no SDK da plataforma do Win32.</span><span class="sxs-lookup"><span data-stu-id="abbc4-417">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-418">Usando o <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> método pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-418">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="abbc4-419">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="abbc4-419">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="abbc4-420">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, a pilha do thread do pool não tem o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="abbc4-420">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="abbc4-421">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-421">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="abbc4-422">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-422">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="abbc4-423">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-423">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="abbc4-424">Um <see cref="T:System.Threading.WaitCallback" /> que retrata o delegado a ser invocado quando um thread no pool de threads coleta o item de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-424">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-425">O objeto que é passado para o representante quando este recebe manutenção do pool de threads.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-425">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-426">Enfileira o delegado especificado no pool de threads, mas não propagar a pilha de chamadas para o thread de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-426">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-427">
            <see langword="true" /> se o método tiver êxito; <see cref="T:System.OutOfMemoryException" /> será gerado se não for possível colocar o item de trabalho na fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-427">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-428">Ao contrário do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-428">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="abbc4-429">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-429">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-430">Usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-430">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="abbc4-431">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="abbc4-431">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="abbc4-432">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="abbc4-432">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="abbc4-433">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-433">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="abbc4-434">O chamador não tem a permissão necessária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-434">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="abbc4-435">Uma condição de memória insuficiente foi encontrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-435">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="abbc4-436">Não foi possível colocar o item de trabalho na fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-436">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="abbc4-437">
            <paramref name="callBack" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-437">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="abbc4-438">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-438">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="abbc4-439">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-439">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="abbc4-440">Registra um representante para aguardar um <see cref="T:System.Threading.WaitHandle" />, mas não propaga a pilha de chamadas para o thread de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-440">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-441">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-441">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-442">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-442">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-443">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-443">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-444">O objeto que é passado para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-444">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="abbc4-445">O tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-445">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-446">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-446">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-447">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-447">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-448">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-448">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-449">Registra um representante para aguardar um <see cref="T:System.Threading.WaitHandle" />, usando um inteiro com sinal de 32 bits para o tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-449">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-450">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-450">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-451">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-451">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-452">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-452">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="abbc4-453">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-453">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-454">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-454">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="abbc4-455">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="abbc4-455">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="abbc4-456">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="abbc4-456">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="abbc4-457">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-457">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="abbc4-458">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-458">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="abbc4-459">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-459">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-460">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-460">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-461">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-461">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-462">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-462">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="abbc4-463">O chamador não tem a permissão necessária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-463">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="abbc4-464">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-464">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="abbc4-465">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-465">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-466">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-466">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-467">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-467">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-468">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-468">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-469">O objeto que é passado para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-469">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="abbc4-470">O tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-470">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-471">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-471">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-472">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-472">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-473">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-473">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-474">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 64 bits para o tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-474">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-475">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-475">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-476">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-476">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-477">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-477">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="abbc4-478">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-478">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-479">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-479">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="abbc4-480">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="abbc4-480">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="abbc4-481">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="abbc4-481">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="abbc4-482">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-482">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="abbc4-483">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-483">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="abbc4-484">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-484">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-485">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-485">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-486">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-486">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-487">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-487">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="abbc4-488">O chamador não tem a permissão necessária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-488">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="abbc4-489">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-489">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="abbc4-490">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-490">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-491">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-491">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-492">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-492">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-493">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-493">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-494">O objeto que é passado para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-494">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="abbc4-495">O tempo limite representado por um <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-495">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="abbc4-496">Se <c>timeout</c> for 0 (zero), a função testará o estado do objeto e será retornada imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-496">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-497">Se <c>timeout</c> for -1, o intervalo de tempo limite da função nunca transcorrerá.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-497">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-498">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-498">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-499">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um valor <see cref="T:System.TimeSpan" /> para o tempo limite. Esse método não propaga a pilha de chamadas para o thread de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-499">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-500">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-500">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-501">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-501">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="abbc4-502">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-502">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-503">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-503">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="abbc4-504">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="abbc4-504">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="abbc4-505">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="abbc4-505">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="abbc4-506">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-506">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="abbc4-507">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-507">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="abbc4-508">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-508">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-509">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-509">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-510">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-510">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="abbc4-511">O parâmetro <paramref name="timeout" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-511">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="abbc4-512">O parâmetro <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-512">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="abbc4-513">O chamador não tem a permissão necessária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-513">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="abbc4-514">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-514">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="abbc4-515">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-515">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="abbc4-516">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-516">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="abbc4-517">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-517">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="abbc4-518">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-518">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="abbc4-519">O objeto que é passado para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-519">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="abbc4-520">O tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-520">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-521">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-521">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="abbc4-522">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-522">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="abbc4-523">
            <see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-523">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="abbc4-524">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro sem sinal de 32 bits para o tempo limite em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-524">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="abbc4-525">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-525">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="abbc4-526">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-526">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="abbc4-527">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="abbc4-527">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="abbc4-528">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-528">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="abbc4-529">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="abbc4-529">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="abbc4-530">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="abbc4-530">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="abbc4-531">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="abbc4-531">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="abbc4-532">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="abbc4-532">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="abbc4-533">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="abbc4-533">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="abbc4-534">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="abbc4-534">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="abbc4-535">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="abbc4-535">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="abbc4-536">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="abbc4-536">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="abbc4-537">O chamador não tem a permissão necessária.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-537">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="abbc4-538">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-538">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="abbc4-539">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="abbc4-539">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>