<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="5bdbc-101">Fornece um pool de threads que podem ser usados para executar tarefas, postar os itens de trabalho, processar E/S assíncrona, aguardar em nome de outros threads e processar temporizadores.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-102">Muitos aplicativos criam threads que gastam uma grande quantidade de tempo no estado suspenso, aguardando um evento ocorra.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="5bdbc-103">Outros threads podem entrar em um estado suspenso apenas para ser ativado periodicamente para sondar uma alteração ou atualizar as informações de status.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="5bdbc-104">O pool de threads permite que você use threads com mais eficiência, fornecendo o seu aplicativo com um pool de threads de trabalho que são gerenciados pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="5bdbc-105">Exemplos de operações que usam threads do pool incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="5bdbc-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="5bdbc-106">Quando você cria um <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> objeto para executar algumas tarefas de forma assíncrona, por padrão, a tarefa está agendada para ser executado em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="5bdbc-107">Temporizadores assíncronas usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="5bdbc-108">Threads de pool executar retornos de chamada do <xref:System.Threading.Timer?displayProperty=nameWithType> classe e disparar eventos do <xref:System.Timers.Timer?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="5bdbc-109">Quando você usa identificadores de espera de registrado, um thread do sistema monitora o status dos identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="5bdbc-110">Quando uma operação de espera é concluída, um thread do pool de threads de trabalho executa a função de retorno de chamada correspondente.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="5bdbc-111">Quando você chama o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método para a fila de um método para execução em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="5bdbc-112">Para fazer isso, passando-o um <xref:System.Threading.WaitCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="5bdbc-113">O representante tem a assinatura</span><span class="sxs-lookup"><span data-stu-id="5bdbc-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="5bdbc-114">onde `state` é um objeto que contém dados a serem usados pelo delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="5bdbc-115">Os dados reais podem ser passados para o delegado chamando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5bdbc-116">Os threads no pool de threads gerenciados são threads em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="5bdbc-117">Isto é, seus <xref:System.Threading.Thread.IsBackground%2A> propriedades são `true`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="5bdbc-118">Isso significa que um <xref:System.Threading.ThreadPool> thread não manterá um aplicativo em execução depois que todos os threads de primeiro plano serem encerrados.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5bdbc-119">Quando o pool de threads reutiliza um thread, ele não limpa os dados no armazenamento local de thread ou em campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="5bdbc-120">Portanto, quando um método examina o armazenamento local de thread ou campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo, os valores encontrados podem ser restantes do uso anterior do thread do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="5bdbc-121">Também é possível enfileirar itens de trabalho que não estão relacionados a uma operação de espera para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="5bdbc-122">Para solicitar que um item de trabalho ser manipulada por um thread no pool de threads, chame o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="5bdbc-123">Esse método aceita como um parâmetro de uma referência para o método ou delegate que será chamado pelo thread selecionado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="5bdbc-124">Não é possível cancelar um item de trabalho depois que ele foi enfileirado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="5bdbc-125">Timers de fila de timer e operações de espera registrado também usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="5bdbc-126">Suas funções de retorno de chamada são enfileiradas para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="5bdbc-127">Há um pool de threads por processo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-127">There is one thread pool per process.</span></span> <span data-ttu-id="5bdbc-128">A partir do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o tamanho padrão do pool de threads de um processo depende de vários fatores, como o tamanho do espaço de endereço virtual.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="5bdbc-129">Um processo pode chamar o método <xref:System.Threading.ThreadPool.GetMaxThreads%2A> para determinar o número de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="5bdbc-130">O número de threads no pool de threads pode ser alterado usando o <xref:System.Threading.ThreadPool.SetMaxThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="5bdbc-131">Cada thread usa o tamanho da pilha padrão e é executado com a prioridade padrão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5bdbc-132">Código não gerenciado que hospeda o .NET Framework pode alterar o tamanho do pool de threads, usando o `CorSetMaxThreads` função, definida no arquivo mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="5bdbc-133">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="5bdbc-134">Quando um mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde até que algumas tarefas são concluídas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="5bdbc-135">A partir do [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads de trabalho a fim de otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="5bdbc-136">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5bdbc-137">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="5bdbc-138">Você pode usar o método <xref:System.Threading.ThreadPool.GetMinThreads%2A> para obter esses valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-139">Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar o número mínimo de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="5bdbc-140">No entanto, o aumento desnecessário desses valores pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="5bdbc-141">Se muitas tarefas começarem ao mesmo tempo, todas elas podem parecer lentas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="5bdbc-142">Na maioria dos casos, o pool de threads terá um desempenho melhor com seu próprio algoritmo de alocação de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-143">No exemplo a seguir, o thread principal do aplicativo enfileira um método chamado `ThreadProc` para executar em um pool de threads, dormem para um segundo e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="5bdbc-144">O `ThreadProc` método simplesmente exibe uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="5bdbc-145">Se você comentar a chamada para o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método, o thread principal será encerrado antes que o método é executado no thread do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="5bdbc-146">O pool de threads usa threads em segundo plano, o que não mantém o aplicativo em execução se todos os threads de primeiro plano tem sido encerrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="5bdbc-147">(Este é um exemplo simples de uma condição de corrida.)</span><span class="sxs-lookup"><span data-stu-id="5bdbc-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="5bdbc-148">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-148">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5bdbc-149">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="5bdbc-150">Um <see cref="T:System.IntPtr" /> que contém o identificador.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="5bdbc-151">O identificador deve ter sido aberto para o E/S sobreposto no lado não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="5bdbc-152">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-153"><see langword="true" /> se o identificador estiver associado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-153"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="5bdbc-154">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-154">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="5bdbc-155">para a capacidade de chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-155">for the ability to call unmanaged code.</span></span> <span data-ttu-id="5bdbc-156">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="5bdbc-157">Um <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que contém o identificador do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="5bdbc-158">O identificador deve ter sido aberto para o E/S sobreposto no lado não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="5bdbc-159">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-160"><see langword="true" /> se o identificador estiver associado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-160"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-161">O `osHandle` parâmetro deve ser um <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, que é derivado de abstrata <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5bdbc-162"><paramref name="osHandle" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-162"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="5bdbc-163">para a capacidade de chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-163">for the ability to call unmanaged code.</span></span> <span data-ttu-id="5bdbc-164">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="5bdbc-165">O número de threads de trabalho disponíveis.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-165">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="5bdbc-166">O número de threads de E/S assíncronos disponíveis.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-166">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="5bdbc-167">Recupera a diferença entre o número máximo de threads do pool de threads retornados pelo método <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> e o número de ativos no momento.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-168">Quando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> retorna a variável especificada pela `workerThreads` contém o número de threads de trabalho adicional que podem ser iniciados e a variável especificada pela `completionPortThreads` contém o número de adicionais threads de e/s assíncronas que pode ser iniciado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="5bdbc-169">Se não houver nenhum threads disponíveis, as solicitações de pool de threads adicionais permanecem na fila até que os threads de pool se tornam disponível.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-170">O exemplo a seguir exibe o número de threads de trabalho e os threads de e/s disponíveis quando um aplicativo simples é iniciado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="5bdbc-171">O número máximo de threads de trabalho no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-171">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="5bdbc-172">O número máximo de threads de E/S assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-172">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="5bdbc-173">Recupera o número de solicitações para o pool de threads que podem estar ativas simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="5bdbc-174">Todas as solicitações acima desse número permanecem na fila até que os threads do pool de threads se tornem disponíveis.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-174">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-175">Quando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> retorna a variável especificada pela `workerThreads` contém o número máximo de threads de trabalho permitidos no pool de threads e a variável especificada pela `completionPortThreads` contém o número máximo de threads de e/s assíncronas permitidas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="5bdbc-176">Você pode usar o <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> método para determinar o número real de threads no pool de threads a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="5bdbc-177">Você pode usar o <xref:System.Threading.ThreadPool.SetMaxThreads%2A> para definir o número máximo de threads de trabalho e os threads de e/s assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="5bdbc-178">É possível enfileirar como muitas solicitações de pool de threads permite a memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="5bdbc-179">Se houver mais solicitações que threads de pool, as solicitações adicionais permanecem na fila até que os threads de pool se tornam disponível.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-180">O exemplo de código a seguir mostra como recuperar uma contagem do número disponível e máximo de threads no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="5bdbc-181">Um item de trabalho em fila que usa `FileStream` para gravar dois arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="5bdbc-182">Os métodos de retorno de chamada são limitados a sobreposição.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="5bdbc-183">Um thread de trabalho trata o item de trabalho e, dependendo da velocidade e o número de processadores no computador, um ou dois threads de porta de conclusão manipular as operações de gravação.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="5bdbc-184">Quando este método retorna, ele contém o número mínimo de threads de trabalho que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="5bdbc-185">Quando este método retorna, ele contém o número mínimo de threads de E/S assíncronas que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="5bdbc-186">Recupera o número mínimo de threads que o pool de threads cria sob demanda à medida que novas solicitações são feitas, antes de mudar para um algoritmo a fim de gerenciar a criação e a destruição de thread.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-187">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="5bdbc-188">Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="5bdbc-189">Quando o mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde até que algumas tarefas são concluídas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="5bdbc-190">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas que são concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="5bdbc-191">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5bdbc-192">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-193">O exemplo a seguir define o número mínimo de threads de trabalho para quatro e preserva o valor original para o número mínimo de threads de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5bdbc-194">Enfileira um método para execução.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-194">Queues a method for execution.</span></span> <span data-ttu-id="5bdbc-195">O método é executado quando um thread de pool de threads se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-195">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="5bdbc-196">Um <see cref="T:System.Threading.WaitCallback" /> que representa o método a ser executado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="5bdbc-197">Enfileira um método para execução.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-197">Queues a method for execution.</span></span> <span data-ttu-id="5bdbc-198">O método é executado quando um thread de pool de threads se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-198">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-199"><see langword="true" /> se o método for colocado na fila com êxito; <see cref="T:System.NotSupportedException" /> será gerado se o item de trabalho não puder ser colocado na fila.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-199"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-200">Você pode colocar dados requeridos pelo método na fila nos campos de instância da classe na qual o método é definido, ou você pode usar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> sobrecarga que aceita um objeto que contém os dados necessários.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5bdbc-201">Usuários do Visual Basic podem omitir o <xref:System.Threading.WaitCallback> construtor e simplesmente usar a `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="5bdbc-202">Visual Basic automaticamente chama construtor delegado correto.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="5bdbc-203">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="5bdbc-203">Version Information</span></span>  
 <span data-ttu-id="5bdbc-204">No .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="5bdbc-205">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-206">O exemplo a seguir usa o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> sobrecarga do método para enfileirar uma tarefa, que é representado pelo `ThreadProc` método para executar quando um thread estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="5bdbc-207">Nenhuma informação de tarefa é fornecida com essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="5bdbc-208">Portanto, as informações que está disponíveis para o `ThreadProc` método é limitado para o objeto ao qual o método pertence.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5bdbc-209"><paramref name="callBack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-209"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5bdbc-210">O CLR (Common Language Runtime) está hospedado e o host não dá suporte a essa ação.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="5bdbc-211">Um <see cref="T:System.Threading.WaitCallback" /> que representa o método a ser executado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-212">Um objeto que contém dados a serem usados pelo método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-212">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="5bdbc-213">Enfileira um método para execução e especifica um objeto que contém dados a serem usados pelo método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="5bdbc-214">O método é executado quando um thread de pool de threads se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-214">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-215"><see langword="true" /> se o método for colocado na fila com êxito; <see cref="T:System.NotSupportedException" /> será gerado se o item de trabalho não puder ser colocado na fila.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-215"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-216">Se o método de retorno de chamada requer dados complexos, você pode definir uma classe para conter os dados.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5bdbc-217">Usuários do Visual Basic podem omitir o <xref:System.Threading.WaitCallback> construtor e simplesmente usar a `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="5bdbc-218">Visual Basic automaticamente chama construtor delegado correto.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="5bdbc-219">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="5bdbc-219">Version Information</span></span>  
 <span data-ttu-id="5bdbc-220">No .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="5bdbc-221">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-222">O exemplo a seguir mostra como criar um objeto que contém informações sobre a tarefa.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-222">The following example shows how to create an object that contains task information.</span></span> <span data-ttu-id="5bdbc-223">Ele também demonstra como transmitir esse objeto para uma tarefa que está na fila para execução pelo pool de thread.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-223">It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5bdbc-224">O CLR (Common Language Runtime) está hospedado e o host não dá suporte a essa ação.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-224">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5bdbc-225"><paramref name="callBack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-225"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5bdbc-226">Registra um representante que está aguardando um <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-226">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-227">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-227">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-228">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-228">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-229">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-229">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-230">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-230">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="5bdbc-231">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-231">The time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-232">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-232">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-233">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-233">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-234"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-234"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-235">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-235">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-236">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-236">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-237">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-237">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-238">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-238">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-239">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-239">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="5bdbc-240">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-240">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="5bdbc-241">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="5bdbc-241">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="5bdbc-242">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-242">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="5bdbc-243">O intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-243">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="5bdbc-244">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-244">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5bdbc-245">Se o estado do objeto for sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-245">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="5bdbc-246">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-246">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="5bdbc-247">O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-247">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="5bdbc-248">Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-248">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5bdbc-249">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-249">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="5bdbc-250">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-250">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="5bdbc-251">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-251">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5bdbc-252">O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-252">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="5bdbc-253">Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deverá duplicar o identificador usando o Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-253">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="5bdbc-254">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-254">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="5bdbc-255">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-255">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="5bdbc-256">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-256">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="5bdbc-257">Por exemplo, a contagem de um semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-257">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="5bdbc-258">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="5bdbc-258">Version Information</span></span>  
 <span data-ttu-id="5bdbc-259">Iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-259">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="5bdbc-260">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-260">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-261">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-261">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-262">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-262">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-263">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-263">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-264">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-264">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-265">O objeto passado ao delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-265">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="5bdbc-266">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-266">The time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-267">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-267">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-268">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-268">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-269"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-269"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-270">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 64 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-270">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-271">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-271">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-272">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-272">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-273">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-273">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-274">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-274">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="5bdbc-275">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-275">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="5bdbc-276">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="5bdbc-276">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="5bdbc-277">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-277">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="5bdbc-278">O intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-278">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="5bdbc-279">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-279">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5bdbc-280">Se o estado do objeto for sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-280">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="5bdbc-281">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-281">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="5bdbc-282">O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-282">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="5bdbc-283">Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-283">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5bdbc-284">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-284">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="5bdbc-285">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-285">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="5bdbc-286">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-286">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5bdbc-287">O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-287">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="5bdbc-288">Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deverá duplicar o identificador usando o Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-288">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="5bdbc-289">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-289">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="5bdbc-290">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-290">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="5bdbc-291">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-291">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="5bdbc-292">Por exemplo, a contagem de um semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-292">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="5bdbc-293">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="5bdbc-293">Version Information</span></span>  
 <span data-ttu-id="5bdbc-294">Iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-294">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="5bdbc-295">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-295">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-296">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-296">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-297">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-297">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-298">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-298">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-299">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-299">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-300">O objeto passado ao delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-300">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="5bdbc-301">O tempo limite representado por um <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-301">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="5bdbc-302">Se <c>timeout</c> for 0 (zero), a função testará o estado do objeto e será retornada imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-302">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-303">Se <c>timeout</c> for -1, o intervalo de tempo limite da função nunca transcorrerá.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-303">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-304"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-304"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-305">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-305">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-306">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-306">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-307">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-307">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-308">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-308">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-309">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-309">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="5bdbc-310">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-310">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="5bdbc-311">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="5bdbc-311">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="5bdbc-312">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-312">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="5bdbc-313">O intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-313">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="5bdbc-314">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-314">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5bdbc-315">Se o estado do objeto for sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-315">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="5bdbc-316">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-316">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="5bdbc-317">O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-317">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="5bdbc-318">Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-318">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5bdbc-319">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-319">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="5bdbc-320">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-320">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="5bdbc-321">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-321">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5bdbc-322">O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-322">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="5bdbc-323">Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deverá duplicar o identificador usando o Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-323">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="5bdbc-324">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-324">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="5bdbc-325">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-325">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="5bdbc-326">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-326">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="5bdbc-327">Por exemplo, a contagem de um semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-327">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="5bdbc-328">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="5bdbc-328">Version Information</span></span>  
 <span data-ttu-id="5bdbc-329">Iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-329">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="5bdbc-330">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-330">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-331">O parâmetro <paramref name="timeout" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-331">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5bdbc-332">O parâmetro <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-332">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-333">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-333">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-334">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-334">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-335">O representante <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-335">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-336">O objeto passado ao delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-336">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="5bdbc-337">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-337">The time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-338">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-338">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-339">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-339">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-340"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-340"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-341">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro sem sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-341">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-342">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-342">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-343">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-343">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-344">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-344">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-345">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-345">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="5bdbc-346">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-346">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="5bdbc-347">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="5bdbc-347">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="5bdbc-348">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-348">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="5bdbc-349">O intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-349">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="5bdbc-350">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-350">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="5bdbc-351">Se o estado do objeto for sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-351">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="5bdbc-352">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-352">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="5bdbc-353">O representante é executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-353">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="5bdbc-354">Se o `timeOutInterval` parâmetro não é 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, ele é zerado sempre que o evento é sinalizado ou o intervalo de tempo limite expira.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-354">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5bdbc-355">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-355">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="5bdbc-356">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-356">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="5bdbc-357">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-357">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="5bdbc-358">O thread de espera usa o Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-358">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="5bdbc-359">Portanto, se você deve usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deverá duplicar o identificador usando o Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-359">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="5bdbc-360">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-360">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="5bdbc-361">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-361">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="5bdbc-362">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera ser atendida.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-362">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="5bdbc-363">Por exemplo, a contagem de um semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-363">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="5bdbc-364">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="5bdbc-364">Version Information</span></span>  
 <span data-ttu-id="5bdbc-365">Iniciando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> o valor da propriedade é propagado para threads de trabalho em fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-365">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="5bdbc-366">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-366">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-367">O exemplo a seguir mostra como usar o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método para executar um método de retorno de chamada especificada quando um identificador de espera especificado é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-367">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="5bdbc-368">Neste exemplo, o método de retorno de chamada é `WaitProc`, e o identificador de espera é um <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-368">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="5bdbc-369">O exemplo define um `TaskInfo` classe para conter as informações que são passadas para o retorno de chamada quando ele é executado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-369">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="5bdbc-370">O exemplo cria um `TaskInfo` do objeto e o atribui alguns dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-370">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="5bdbc-371">O <xref:System.Threading.RegisteredWaitHandle> que é retornado pelo <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método é atribuído ao `Handle` campo do `TaskInfo` do objeto para que o método de retorno de chamada tem acesso ao <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-371">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="5bdbc-372">Além de especificar `TaskInfo` como o objeto para passar para o método de retorno de chamada, a chamada para o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método Especifica o <xref:System.Threading.AutoResetEvent> que a tarefa irá aguardar um <xref:System.Threading.WaitOrTimerCallback> delegado que representa o `WaitProc` método de retorno de chamada, um um intervalo de tempo limite em segundos e vários retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-372">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="5bdbc-373">Quando o thread principal sinaliza o <xref:System.Threading.AutoResetEvent> chamando seu <xref:System.Threading.EventWaitHandle.Set%2A> método, o <xref:System.Threading.WaitOrTimerCallback> delegado é invocado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-373">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="5bdbc-374">O `WaitProc` método testes <xref:System.Threading.RegisteredWaitHandle> para determinar se ocorreu um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-374">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="5bdbc-375">Se o retorno de chamada foi invocado porque o identificador de espera foi sinalizado, o `WaitProc` método cancela o registro de <xref:System.Threading.RegisteredWaitHandle>, parando adicionais retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-375">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="5bdbc-376">No caso de um tempo limite, a tarefa continuará sendo espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-376">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="5bdbc-377">O `WaitProc` método termina imprimindo uma mensagem para o console.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-377">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-378">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-378">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="5bdbc-379">O número máximo de threads de trabalho no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-379">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="5bdbc-380">O número máximo de threads de E/S assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-380">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="5bdbc-381">Define o número de solicitações para o pool de threads que podem estar ativas simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-381">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="5bdbc-382">Todas as solicitações acima desse número permanecem na fila até que os threads do pool de threads se tornem disponíveis.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-382">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-383"><see langword="true" /> se a alteração for bem-sucedida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-383"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-384">Você não pode definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor que o número de processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-384">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="5bdbc-385">Para determinar quantos processadores estão presentes, recuperar o valor da <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-385">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="5bdbc-386">Além disso, você não pode definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor que o número correspondente de mínimo de threads de trabalho ou threads de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-386">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="5bdbc-387">Para determinar o tamanho do pool de threads mínimo, chame o <xref:System.Threading.ThreadPool.GetMinThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-387">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="5bdbc-388">Se o common language runtime está hospedado, por exemplo, serviços de informações da Internet (IIS) ou SQL Server, o host pode limitar ou impedir alterações para o tamanho do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-388">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="5bdbc-389">Tenha cuidado ao alterar o número máximo de threads no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-389">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="5bdbc-390">Enquanto seu código pode se beneficiar, as alterações podem ter um efeito adverso em bibliotecas de código que você usa.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-390">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="5bdbc-391">Definir o tamanho do pool de threads muito grande pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-391">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="5bdbc-392">Se muitos threads estão em execução ao mesmo tempo, a alternância de tarefa sobrecarga se torna um fator importante.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-392">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="5bdbc-393">a capacidade de controlar threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-393">for the ability to control threads.</span></span> <span data-ttu-id="5bdbc-394">Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="5bdbc-394">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="5bdbc-395">O número mínimo de threads de trabalho que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-395">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="5bdbc-396">O número mínimo de threads de E/S assíncronos que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-396">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="5bdbc-397">Define o número mínimo de threads que o pool de threads cria sob demanda à medida que novas solicitações são feitas, antes de mudar para um algoritmo a fim de gerenciar a criação e a destruição de thread.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-397">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-398"><see langword="true" /> se a alteração for bem-sucedida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-398"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-399">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-399">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="5bdbc-400">Quando o mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde até que algumas tarefas são concluídas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-400">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="5bdbc-401">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas que são concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-401">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="5bdbc-402">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-402">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="5bdbc-403">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-403">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="5bdbc-404">Se você especificar um número negativo ou um número maior que o número máximo de threads de pool de thread ativo (obtidos usando <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> retorna `false` e não altera qualquer um dos valores mínimo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-404">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-405">Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-405">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="5bdbc-406">Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar a ofthreads número mínimo.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-406">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="5bdbc-407">No entanto, o aumento desnecessário desses valores pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-407">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="5bdbc-408">Se muitas tarefas começarem ao mesmo tempo, todas elas podem parecer lentas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-408">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="5bdbc-409">Na maioria dos casos, o pool de threads terão um desempenho melhor com seu próprio algoritmo para alocar threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-409">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="5bdbc-410">Reduzindo o mínimo menor que o número de processadores também pode prejudicar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-410">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5bdbc-411">O exemplo a seguir define o número mínimo de threads de trabalho para quatro e preserva o valor original para o número mínimo de threads de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-411">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="5bdbc-412">a capacidade de controlar threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-412">for the ability to control threads.</span></span> <span data-ttu-id="5bdbc-413">Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="5bdbc-413">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="5bdbc-414">A estrutura <see cref="T:System.Threading.NativeOverlapped" /> a ser colocada em fila.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-414">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="5bdbc-415">Enfileira uma operação de E/S sobreposta para a execução.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-415">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-416"><see langword="true" /> se a operação foi enfileirada com êxito para uma porta de conclusão de E/S; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-416"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-417">Para obter informações sobre como usar o Win32 nativo sobreposto e/s, consulte o <xref:System.Threading.Overlapped> classe, o <xref:System.Threading.NativeOverlapped> estrutura e o `OVERLAPPED` estrutura no SDK da plataforma Win32.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-417">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-418">Usando o <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> método inadvertidamente pode abrir uma falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-418">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="5bdbc-419">Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-419">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="5bdbc-420">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, a pilha do thread do pool não tem o contexto de chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-420">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="5bdbc-421">Código mal-intencionado poderá explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-421">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5bdbc-422">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-422">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5bdbc-423">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-423">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="5bdbc-424">Um <see cref="T:System.Threading.WaitCallback" /> que retrata o delegado a ser invocado quando um thread no pool de threads coleta o item de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-424">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-425">O objeto que é passado para o representante quando este recebe manutenção do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-425">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="5bdbc-426">Enfileira o delegado especificado no pool de threads, mas não propagar a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-426">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns>
          <span data-ttu-id="5bdbc-427"><see langword="true" /> se o método tiver êxito; <see cref="T:System.OutOfMemoryException" /> será gerado se não for possível colocar o item de trabalho na fila.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-427"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-428">Ao contrário de <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> não propaga a pilha de chamada para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-428">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="5bdbc-429">Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-429">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-430">Usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> inadvertidamente pode abrir uma falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-430">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="5bdbc-431">Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-431">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="5bdbc-432">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, a pilha do thread do pool não terá o contexto de chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-432">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="5bdbc-433">Código mal-intencionado poderá explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-433">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="5bdbc-434">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-434">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="5bdbc-435">Uma condição de memória insuficiente foi encontrada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-435">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="5bdbc-436">Não foi possível colocar o item de trabalho na fila.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-436">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5bdbc-437"><paramref name="callBack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-437"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5bdbc-438">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-438">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5bdbc-439">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-439">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="5bdbc-440">Registra um representante para aguardar um <see cref="T:System.Threading.WaitHandle" />, mas não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-440">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-441">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-441">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-442">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-442">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-443">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-443">The delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-444">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-444">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="5bdbc-445">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-445">The time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-446">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-446">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-447">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-447">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-448"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-448"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-449">Registra um representante para aguardar um <see cref="T:System.Threading.WaitHandle" />, usando um inteiro com sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-449">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-450">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-450">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-451">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-451">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-452">Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamada para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-452">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="5bdbc-453">Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-453">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-454">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> inadvertidamente pode abrir uma falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-454">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="5bdbc-455">Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-455">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="5bdbc-456">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto de chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-456">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="5bdbc-457">Código mal-intencionado poderá explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-457">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="5bdbc-458">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-458">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="5bdbc-459">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-459">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-460">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-460">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-461">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-461">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-462">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-462">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="5bdbc-463">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-463">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5bdbc-464">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-464">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5bdbc-465">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-465">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-466">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-466">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-467">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-467">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-468">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-468">The delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-469">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-469">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="5bdbc-470">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-470">The time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-471">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-471">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-472">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-472">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-473"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-473"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-474">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 64 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-474">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-475">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-475">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-476">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-476">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-477">Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamada para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-477">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="5bdbc-478">Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-478">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-479">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> inadvertidamente pode abrir uma falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-479">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="5bdbc-480">Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-480">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="5bdbc-481">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto de chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-481">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="5bdbc-482">Código mal-intencionado poderá explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-482">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="5bdbc-483">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-483">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="5bdbc-484">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-484">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-485">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-485">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-486">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-486">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-487">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-487">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="5bdbc-488">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-488">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5bdbc-489">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-489">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5bdbc-490">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-490">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-491">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-491">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-492">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-492">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-493">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-493">The delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-494">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-494">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="5bdbc-495">O tempo limite representado por um <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-495">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="5bdbc-496">Se <c>timeout</c> for 0 (zero), a função testará o estado do objeto e será retornada imediatamente.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-496">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-497">Se <c>timeout</c> for -1, o intervalo de tempo limite da função nunca transcorrerá.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-497">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-498"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-498"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-499">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um valor <see cref="T:System.TimeSpan" /> para o tempo limite. Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-499">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-500">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-500">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-501">Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamada para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-501">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="5bdbc-502">Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-502">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-503">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> inadvertidamente pode abrir uma falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-503">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="5bdbc-504">Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-504">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="5bdbc-505">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto de chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-505">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="5bdbc-506">Código mal-intencionado poderá explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-506">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="5bdbc-507">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-507">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="5bdbc-508">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-508">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-509">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-509">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-510">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-510">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="5bdbc-511">O parâmetro <paramref name="timeout" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-511">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="5bdbc-512">O parâmetro <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-512">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="5bdbc-513">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-513">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5bdbc-514">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-514">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5bdbc-515">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-515">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="5bdbc-516">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-516">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="5bdbc-517">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-517">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="5bdbc-518">O representante a ser chamado quando o parâmetro <c>waitObject</c> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-518">The delegate to call when the <c>waitObject</c> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="5bdbc-519">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-519">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="5bdbc-520">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-520">The time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-521">Se o parâmetro <c>millisecondsTimeOutInterval</c> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-521">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="5bdbc-522">Se <c>millisecondsTimeOutInterval</c> for -1, o intervalo de tempo limite da função nunca será transcorrido.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-522">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="5bdbc-523"><see langword="true" /> para indicar que o thread não esperará mais o parâmetro <c>waitObject</c> depois que o representante for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-523"><see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="5bdbc-524">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro sem sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-524">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="5bdbc-525">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-525">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="5bdbc-526">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-526">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5bdbc-527">Ao contrário de <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamada para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-527">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="5bdbc-528">Isso permite que o código com que percam a pilha de chamada e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-528">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="5bdbc-529">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> inadvertidamente pode abrir uma falha de segurança.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-529">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="5bdbc-530">Segurança de acesso ao código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-530">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="5bdbc-531">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto de chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-531">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="5bdbc-532">Código mal-intencionado poderá explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-532">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="5bdbc-533">Usando um <xref:System.Threading.Mutex> para `waitObject` não fornece exclusão mútua para os retornos de chamada porque a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizador, para cada retorno de chamada é enviado em um thread separado do pool.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-533">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="5bdbc-534">Quando tiver terminado com o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-534">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="5bdbc-535">É recomendável que você sempre chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-535">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="5bdbc-536">Coleta de lixo funciona mais de forma eficaz se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo finalizador do identificador de espera registrado.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-536">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="5bdbc-537">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-537">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="5bdbc-538">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-538">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="5bdbc-539">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="5bdbc-539">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>