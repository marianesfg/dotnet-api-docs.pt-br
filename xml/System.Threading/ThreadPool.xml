<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dfe939fdbc3c31c6797ac84b6e8ba1c1352523f9" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56386463" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="58ec4-101">Fornece um pool de threads que podem ser usados para executar tarefas, postar os itens de trabalho, processar E/S assíncrona, aguardar em nome de outros threads e processar temporizadores.</span><span class="sxs-lookup"><span data-stu-id="58ec4-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-102">Muitos aplicativos criam threads que passam muito tempo no estado de repouso, aguardando um evento ocorra.</span><span class="sxs-lookup"><span data-stu-id="58ec4-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="58ec4-103">Outros threads podem entrar em um estado suspenso apenas para ser despertado periodicamente para sondar uma alteração ou atualizar as informações de status.</span><span class="sxs-lookup"><span data-stu-id="58ec4-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="58ec4-104">O pool de threads permite que você use threads com mais eficiência, fornecendo seu aplicativo com um pool de threads de trabalho que são gerenciados pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="58ec4-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="58ec4-105">Exemplos de operações que usam threads do pool incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58ec4-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="58ec4-106">Quando você cria um <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> objeto para executar uma tarefa de forma assíncrona, por padrão, a tarefa está agendada para execução em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="58ec4-107">Temporizadores assíncronos usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="58ec4-108">Retornos de chamada de execução do thread do pool de threads a <xref:System.Threading.Timer?displayProperty=nameWithType> de classe e gerar eventos do <xref:System.Timers.Timer?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="58ec4-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="58ec4-109">Quando você usa identificadores de espera registrada, um thread do sistema monitora o status dos identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="58ec4-110">Quando uma operação de espera for concluída, um thread de trabalho do pool de threads executa a função de retorno de chamada correspondente.</span><span class="sxs-lookup"><span data-stu-id="58ec4-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="58ec4-111">Quando você chama o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método para enfileirar um método para execução em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="58ec4-112">Faça isso passando o método um <xref:System.Threading.WaitCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="58ec4-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="58ec4-113">O delegado tem a assinatura</span><span class="sxs-lookup"><span data-stu-id="58ec4-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="58ec4-114">onde `state` é um objeto que contém dados a serem usados pelo delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="58ec4-115">Os dados reais podem ser passados para o delegado, chamando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ec4-116">Os threads no pool de threads gerenciados são threads em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="58ec4-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="58ec4-117">Ou seja, seus <xref:System.Threading.Thread.IsBackground%2A> são propriedades `true`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="58ec4-118">Isso significa que um <xref:System.Threading.ThreadPool> thread não manterá um aplicativo em execução depois que todos os threads de primeiro plano tenham saído.</span><span class="sxs-lookup"><span data-stu-id="58ec4-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58ec4-119">Quando o pool de threads reutiliza um thread, ele não limpa os dados no armazenamento local de thread ou nos campos marcados com o <xref:System.ThreadStaticAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="58ec4-120">Portanto, quando um método examina o armazenamento local de thread ou campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo, os valores que ele encontra podem ser deixados de uso anterior do thread do pool.</span><span class="sxs-lookup"><span data-stu-id="58ec4-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="58ec4-121">Também é possível enfileirar itens de trabalho que não estão relacionados a uma operação de espera para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="58ec4-122">Para solicitar que um item de trabalho manipulada por um thread no pool de threads, chame o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="58ec4-123">Esse método aceita como um parâmetro de uma referência para o método ou delegate que será chamado pelo thread selecionado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="58ec4-124">Não há nenhuma maneira de cancelar um item de trabalho depois que ele foi enfileirado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="58ec4-125">Temporizadores de fila do temporizador e operações de espera registrada também usam o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="58ec4-126">Suas funções de retorno de chamada são enfileiradas para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="58ec4-127">Há um pool de threads por processo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-127">There is one thread pool per process.</span></span> <span data-ttu-id="58ec4-128">A partir do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o tamanho padrão do pool de threads de um processo depende de vários fatores, como o tamanho do espaço de endereço virtual.</span><span class="sxs-lookup"><span data-stu-id="58ec4-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="58ec4-129">Um processo pode chamar o método <xref:System.Threading.ThreadPool.GetMaxThreads%2A> para determinar o número de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="58ec4-130">O número de threads no pool de threads pode ser alterado usando o <xref:System.Threading.ThreadPool.SetMaxThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="58ec4-131">Cada thread usa o tamanho da pilha padrão e é executado com prioridade padrão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ec4-132">Código não gerenciado que hospeda o .NET Framework pode alterar o tamanho do pool de threads usando a `CorSetMaxThreads` função, definida no arquivo MSCOREE. h.</span><span class="sxs-lookup"><span data-stu-id="58ec4-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="58ec4-133">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="58ec4-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="58ec4-134">Quando um mínimo for atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde a conclusão de algumas tarefas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="58ec4-135">A partir do [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads de trabalho a fim de otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="58ec4-136">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ec4-137">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="58ec4-138">Você pode usar o método <xref:System.Threading.ThreadPool.GetMinThreads%2A> para obter esses valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-139">Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar o número mínimo de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="58ec4-140">No entanto, o aumento desnecessário desses valores pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="58ec4-141">Se muitas tarefas começarem ao mesmo tempo, todas elas podem parecer lentas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="58ec4-142">Na maioria dos casos, o pool de threads terá um desempenho melhor com seu próprio algoritmo de alocação de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-143">No exemplo a seguir, o thread principal do aplicativo enfileira um método chamado `ThreadProc` para executar em um pool de threads, dorme por um segundo e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="58ec4-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="58ec4-144">O `ThreadProc` método simplesmente exibe uma mensagem.</span><span class="sxs-lookup"><span data-stu-id="58ec4-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="58ec4-145">Se você comentar a chamada para o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método, o thread principal é encerrado antes que o método é executado no thread do pool.</span><span class="sxs-lookup"><span data-stu-id="58ec4-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="58ec4-146">O pool de threads usa threads em segundo plano, o que não mantém o aplicativo em execução se todos os threads de primeiro plano tiverem terminado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="58ec4-147">(Isso é um exemplo simples de uma condição de corrida.)</span><span class="sxs-lookup"><span data-stu-id="58ec4-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="58ec4-148">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="58ec4-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="58ec4-149">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="58ec4-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-150">O Pooling de Thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="58ec4-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58ec4-151">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="58ec4-152">Um <see cref="T:System.IntPtr" /> que contém o identificador.</span><span class="sxs-lookup"><span data-stu-id="58ec4-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="58ec4-153">O identificador deve ter sido aberto para o E/S sobreposto no lado não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="58ec4-154">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="58ec4-155"><see langword="true" /> se o identificador estiver associado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58ec4-156">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="58ec4-156">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="58ec4-157">para a capacidade de chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-157">for the ability to call unmanaged code.</span></span> <span data-ttu-id="58ec4-158">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="58ec4-159">Um <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que contém o identificador do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="58ec4-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="58ec4-160">O identificador deve ter sido aberto para o E/S sobreposto no lado não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="58ec4-161">Associa um identificador de sistema operacional ao <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="58ec4-162"><see langword="true" /> se o identificador estiver associado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-162"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-163">O `osHandle` parâmetro deve ser um <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, que é derivada de abstrata <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="58ec4-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ec4-164"><paramref name="osHandle" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-164"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="58ec4-165">para a capacidade de chamar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-165">for the ability to call unmanaged code.</span></span> <span data-ttu-id="58ec4-166">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="58ec4-167">O número de threads de trabalho disponíveis.</span><span class="sxs-lookup"><span data-stu-id="58ec4-167">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="58ec4-168">O número de threads de E/S assíncronos disponíveis.</span><span class="sxs-lookup"><span data-stu-id="58ec4-168">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="58ec4-169">Recupera a diferença entre o número máximo de threads do pool de threads retornados pelo método <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> e o número de ativos no momento.</span><span class="sxs-lookup"><span data-stu-id="58ec4-169">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-170">Quando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> retorna a variável especificada pela `workerThreads` contém o número de threads de trabalho adicional que podem ser iniciados e a variável especificada pela `completionPortThreads` contém o número de assíncronos threads de e/s adicionais que podem ser iniciado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-170">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="58ec4-171">Se não houver nenhum thread disponível, as solicitações de pool de threads adicionais permanecem na fila até que os threads do pool se tornam disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-171">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-172">O exemplo a seguir exibe o número de threads de trabalho e os threads de e/s disponíveis quando um aplicativo simples é iniciado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-172">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="58ec4-173">O número máximo de threads de trabalho no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-173">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="58ec4-174">O número máximo de threads de E/S assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-174">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="58ec4-175">Recupera o número de solicitações para o pool de threads que podem estar ativas simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="58ec4-175">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="58ec4-176">Todas as solicitações acima desse número permanecem na fila até que os threads do pool de threads se tornem disponíveis.</span><span class="sxs-lookup"><span data-stu-id="58ec4-176">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-177">Quando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> retorna a variável especificada pela `workerThreads` contém o número máximo de threads de trabalho permitidos no pool de threads e a variável especificada pela `completionPortThreads` contém o número máximo de threads de e/s assíncronas permitidas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-177">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="58ec4-178">Você pode usar o <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> método para determinar o número real de threads no pool de threads em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="58ec4-178">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="58ec4-179">Você pode usar o <xref:System.Threading.ThreadPool.SetMaxThreads%2A> para definir o número máximo de threads de trabalho e os threads de e/s assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-179">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="58ec4-180">É possível enfileirar como muitas solicitações do pool de threads permite a memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="58ec4-180">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="58ec4-181">Se houver mais solicitações que os threads do pool, as solicitações adicionais permanecem na fila até que os threads do pool se tornam disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-181">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-182">O exemplo de código a seguir mostra como recuperar uma contagem do número de threads no pool de threads máximo e está disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-182">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="58ec4-183">Um item de trabalho é colocada na fila que usa `FileStream` gravar de maneira assíncrona para dois arquivos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-183">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="58ec4-184">Os métodos de retorno de chamada são atingiu o tempo limite se sobreponham.</span><span class="sxs-lookup"><span data-stu-id="58ec4-184">The callback methods are timed to overlap.</span></span> <span data-ttu-id="58ec4-185">Um thread de trabalho trata o item de trabalho e, dependendo da velocidade e no número de processadores no computador, um ou dois threads de porta de conclusão lidar com as operações de gravação.</span><span class="sxs-lookup"><span data-stu-id="58ec4-185">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="58ec4-186">Quando este método retorna, ele contém o número mínimo de threads de trabalho que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="58ec4-186">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="58ec4-187">Quando este método retorna, ele contém o número mínimo de threads de E/S assíncronas que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="58ec4-187">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="58ec4-188">Recupera o número mínimo de threads que o pool de threads cria sob demanda à medida que novas solicitações são feitas, antes de mudar para um algoritmo a fim de gerenciar a criação e a destruição de thread.</span><span class="sxs-lookup"><span data-stu-id="58ec4-188">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-189">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="58ec4-189">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="58ec4-190">Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema.</span><span class="sxs-lookup"><span data-stu-id="58ec4-190">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="58ec4-191">Quando o mínimo é atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde a conclusão de algumas tarefas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-191">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="58ec4-192">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-192">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="58ec4-193">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-193">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ec4-194">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-194">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-195">O exemplo a seguir define o número mínimo de threads de trabalho para quatro e preserva o valor original para o número mínimo de threads de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-195">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58ec4-196">Enfileira um método para execução.</span><span class="sxs-lookup"><span data-stu-id="58ec4-196">Queues a method for execution.</span></span> <span data-ttu-id="58ec4-197">O método é executado quando um thread de pool de threads se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-197">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="58ec4-198">Um <see cref="T:System.Threading.WaitCallback" /> que representa o método a ser executado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-198">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="58ec4-199">Enfileira um método para execução.</span><span class="sxs-lookup"><span data-stu-id="58ec4-199">Queues a method for execution.</span></span> <span data-ttu-id="58ec4-200">O método é executado quando um thread de pool de threads se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-200">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="58ec4-201"><see langword="true" /> se o método for colocado na fila com êxito; <see cref="T:System.NotSupportedException" /> será gerado se o item de trabalho não puder ser colocado na fila.</span><span class="sxs-lookup"><span data-stu-id="58ec4-201"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-202">Você pode colocar os dados necessários para o método em fila nos campos de instância da classe na qual o método é definido, ou você pode usar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> sobrecarga que aceita um objeto que contém os dados necessários.</span><span class="sxs-lookup"><span data-stu-id="58ec4-202">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ec4-203">Usuários do Visual Basic podem omitir as <xref:System.Threading.WaitCallback> construtor e simplesmente usar o `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-203">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="58ec4-204">Visual Basic chama automaticamente o construtor delegado correto.</span><span class="sxs-lookup"><span data-stu-id="58ec4-204">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="58ec4-205">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58ec4-205">Version Information</span></span>  
 <span data-ttu-id="58ec4-206">No .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-206">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="58ec4-207">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-207">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-208">O exemplo a seguir usa o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> sobrecarga de método para enfileirar uma tarefa, que é representada pelo `ThreadProc` método a ser executado quando um thread fique disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-208">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="58ec4-209">Nenhuma informação de tarefa é fornecida com essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="58ec4-209">No task information is supplied with this overload.</span></span> <span data-ttu-id="58ec4-210">Portanto, as informações que está disponíveis para o `ThreadProc` método é limitado ao objeto ao qual o método pertence.</span><span class="sxs-lookup"><span data-stu-id="58ec4-210">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ec4-211"><paramref name="callBack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-211"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58ec4-212">O CLR (Common Language Runtime) está hospedado e o host não dá suporte a essa ação.</span><span class="sxs-lookup"><span data-stu-id="58ec4-212">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-213">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-213">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="58ec4-214">Um <see cref="T:System.Threading.WaitCallback" /> que representa o método a ser executado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-214">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-215">Um objeto que contém dados a serem usados pelo método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-215">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="58ec4-216">Enfileira um método para execução e especifica um objeto que contém dados a serem usados pelo método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-216">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="58ec4-217">O método é executado quando um thread de pool de threads se torna disponível.</span><span class="sxs-lookup"><span data-stu-id="58ec4-217">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="58ec4-218"><see langword="true" /> se o método for colocado na fila com êxito; <see cref="T:System.NotSupportedException" /> será gerado se o item de trabalho não puder ser colocado na fila.</span><span class="sxs-lookup"><span data-stu-id="58ec4-218"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-219">Se o método de retorno de chamada requer dados complexos, você pode definir uma classe para conter os dados.</span><span class="sxs-lookup"><span data-stu-id="58ec4-219">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58ec4-220">Usuários do Visual Basic podem omitir as <xref:System.Threading.WaitCallback> construtor e simplesmente usar o `AddressOf` operador ao passar o método de retorno de chamada para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-220">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="58ec4-221">Visual Basic chama automaticamente o construtor delegado correto.</span><span class="sxs-lookup"><span data-stu-id="58ec4-221">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="58ec4-222">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58ec4-222">Version Information</span></span>  
 <span data-ttu-id="58ec4-223">No .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-223">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="58ec4-224">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-224">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-225">O exemplo a seguir usa o pool de threads do .NET para calcular o `Fibonacci` resultado para cinco números entre 20 e 40.</span><span class="sxs-lookup"><span data-stu-id="58ec4-225">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="58ec4-226">Cada resultado `Fibonacci` é representado pela classe `Fibonacci`, que fornece um método chamado `ThreadPoolCallback` que executa o cálculo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-226">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="58ec4-227">Um objeto que representa cada valor `Fibonacci` é criado e o método `ThreadPoolCallback` é passado para <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, que atribui um thread disponível no pool para executar o método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-227">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="58ec4-228">Porque cada `Fibonacci` objeto recebe um valor semialeatório para calcular e porque cada thread competirá pelo tempo de processador, é possível saber antecipadamente quanto tempo levará para todos os cinco conjuntos de resultados deve ser calculado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-228">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="58ec4-229">É por isso que cada objeto `Fibonacci` é passado a uma instância da classe <xref:System.Threading.ManualResetEvent> durante a construção.</span><span class="sxs-lookup"><span data-stu-id="58ec4-229">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="58ec4-230">Cada objeto sinaliza o objeto de evento fornecido quando o cálculo é concluído, que permite que o thread primário bloqueie a execução com <xref:System.Threading.WaitHandle.WaitAll%2A> até que todas as cinco `Fibonacci` objetos terem calculado um resultado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-230">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="58ec4-231">O método `Main` exibe então cada resultado de `Fibonacci`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-231">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58ec4-232">O CLR (Common Language Runtime) está hospedado e o host não dá suporte a essa ação.</span><span class="sxs-lookup"><span data-stu-id="58ec4-232">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ec4-233"><paramref name="callBack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-233"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-234">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-234">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58ec4-235">Registra um representante que está aguardando um <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-235">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-236">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-236">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-237">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-237">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-238">O delegado <see cref="T:System.Threading.WaitOrTimerCallback" /> para chamar quando o parâmetro <paramref name="waitObject" /> for sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-238">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-239">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-239">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="58ec4-240">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-240">The time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-241">Se o parâmetro <paramref name="millisecondsTimeOutInterval" /> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-241">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-242">Se <paramref name="millisecondsTimeOutInterval" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-242">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-243"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-243"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-244">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-244">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="58ec4-245">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-245">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-246">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-246">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-247">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-247">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-248">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-248">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="58ec4-249">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="58ec4-250">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="58ec4-250">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="58ec4-251">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-251">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="58ec4-252">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-252">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="58ec4-253">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-253">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="58ec4-254">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-254">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="58ec4-255">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-255">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="58ec4-256">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-256">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="58ec4-257">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-257">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58ec4-258">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-258">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="58ec4-259">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-259">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="58ec4-260">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-260">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58ec4-261">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-261">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="58ec4-262">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="58ec4-262">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="58ec4-263">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="58ec4-263">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="58ec4-264">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="58ec4-264">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="58ec4-265">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-265">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="58ec4-266">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="58ec4-266">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="58ec4-267">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58ec4-267">Version Information</span></span>  
 <span data-ttu-id="58ec4-268">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-268">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="58ec4-269">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-269">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-270">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-270">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-271">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-271">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-272">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-272">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-273">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-273">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-274">O delegado <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-274">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-275">O objeto passado ao delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-275">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="58ec4-276">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-276">The time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-277">Se o parâmetro <paramref name="millisecondsTimeOutInterval" /> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-277">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-278">Se <paramref name="millisecondsTimeOutInterval" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-278">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-279"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-279"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-280">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 64 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-280">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="58ec4-281">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-281">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-282">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-282">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-283">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-283">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-284">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-284">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="58ec4-285">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-285">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="58ec4-286">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="58ec4-286">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="58ec4-287">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-287">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="58ec4-288">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-288">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="58ec4-289">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-289">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="58ec4-290">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-290">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="58ec4-291">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-291">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="58ec4-292">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-292">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="58ec4-293">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-293">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58ec4-294">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-294">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="58ec4-295">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-295">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="58ec4-296">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-296">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58ec4-297">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-297">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="58ec4-298">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="58ec4-298">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="58ec4-299">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="58ec4-299">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="58ec4-300">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="58ec4-300">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="58ec4-301">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-301">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="58ec4-302">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="58ec4-302">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="58ec4-303">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58ec4-303">Version Information</span></span>  
 <span data-ttu-id="58ec4-304">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-304">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="58ec4-305">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-305">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-306">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-306">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-307">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-307">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-308">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-308">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-309">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-309">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-310">O delegado <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-310">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-311">O objeto passado ao delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-311">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="58ec4-312">O tempo limite representado por um <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-312">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="58ec4-313">Se <paramref name="timeout" /> for 0 (zero), a função testará o estado do objeto e será retornada imediatamente.</span><span class="sxs-lookup"><span data-stu-id="58ec4-313">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-314">Se <paramref name="timeout" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-314">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-315"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-315"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-316">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="58ec4-316">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="58ec4-317">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula o identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-317">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-318">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-318">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-319">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-319">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-320">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-320">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="58ec4-321">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-321">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="58ec4-322">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="58ec4-322">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="58ec4-323">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-323">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="58ec4-324">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-324">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="58ec4-325">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-325">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="58ec4-326">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-326">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="58ec4-327">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-327">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="58ec4-328">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-328">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="58ec4-329">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-329">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58ec4-330">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-330">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="58ec4-331">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-331">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="58ec4-332">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-332">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58ec4-333">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-333">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="58ec4-334">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="58ec4-334">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="58ec4-335">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="58ec4-335">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="58ec4-336">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="58ec4-336">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="58ec4-337">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-337">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="58ec4-338">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="58ec4-338">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="58ec4-339">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58ec4-339">Version Information</span></span>  
 <span data-ttu-id="58ec4-340">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-340">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="58ec4-341">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-341">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-342">O parâmetro <paramref name="timeout" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-342">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58ec4-343">O parâmetro <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-343">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-344">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-344">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-345">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-345">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-346">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-346">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-347">O delegado <see cref="T:System.Threading.WaitOrTimerCallback" /> a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-347">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-348">O objeto passado ao delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-348">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="58ec4-349">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-349">The time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-350">Se o parâmetro <paramref name="millisecondsTimeOutInterval" /> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-350">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-351">Se <paramref name="millisecondsTimeOutInterval" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-351">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-352"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-352"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-353">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro sem sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-353">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="58ec4-354">O <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-354">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-355">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-355">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-356">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-356">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-357">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-357">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="58ec4-358">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método enfileira o delegado especificado para o pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-358">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="58ec4-359">Um thread de trabalho será executado o delegado quando ocorre um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="58ec4-359">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="58ec4-360">O objeto especificado está no estado sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-360">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="58ec4-361">O intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-361">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="58ec4-362">O <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método verifica o estado atual do objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-362">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="58ec4-363">Se o estado do objeto é sinalizado, o método registra uma operação de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-363">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="58ec4-364">A operação de espera é executada por um thread do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-364">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="58ec4-365">O delegado seja executado por um thread de trabalho quando o estado do objeto se torna sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-365">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="58ec4-366">Se o `timeOutInterval` parâmetro não for 0 (zero) e o `executeOnlyOnce` parâmetro é `false`, o temporizador será reiniciado sempre que o evento é sinalizado ou o intervalo de tempo limite expire.</span><span class="sxs-lookup"><span data-stu-id="58ec4-366">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58ec4-367">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-367">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="58ec4-368">Em vez de um <xref:System.Threading.Mutex>, use um <xref:System.Threading.Semaphore> com uma contagem máxima de 1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-368">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="58ec4-369">Para cancelar a operação de espera, chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-369">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58ec4-370">O thread de espera usa Win32 `WaitForMultipleObjects` função para monitorar as operações de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-370">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="58ec4-371">Portanto, se você precisar usar o mesmo identificador de sistema operacional nativo em diversas chamadas para <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, você deve duplicar o identificador usando Win32 `DuplicateHandle` função.</span><span class="sxs-lookup"><span data-stu-id="58ec4-371">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="58ec4-372">Observe que você não deve pulso passado para um objeto de evento <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, porque o thread de espera pode não detectar que o evento é sinalizado antes que ela seja redefinida.</span><span class="sxs-lookup"><span data-stu-id="58ec4-372">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="58ec4-373">Antes de retornar, a função modifica o estado de alguns tipos de objetos de sincronização.</span><span class="sxs-lookup"><span data-stu-id="58ec4-373">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="58ec4-374">Modificação ocorre somente para o objeto cujo estado sinalizado causou a condição de espera a serem atendidos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-374">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="58ec4-375">Por exemplo, a contagem do semáforo é reduzida por um.</span><span class="sxs-lookup"><span data-stu-id="58ec4-375">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="58ec4-376">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58ec4-376">Version Information</span></span>  
 <span data-ttu-id="58ec4-377">Começando com o .NET Framework versão 2.0, o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propriedade é propagado para threads de trabalho na fila usando o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-377">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="58ec4-378">Em versões anteriores, as informações de entidade não são propagadas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-378">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-379">O exemplo a seguir mostra como usar o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método para executar um método de retorno de chamada especificado quando um identificador de espera especificado é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-379">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="58ec4-380">Neste exemplo, o método de retorno de chamada é `WaitProc`, e o identificador de espera é um <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-380">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="58ec4-381">O exemplo define um `TaskInfo` classe para manter as informações que são passadas para o retorno de chamada quando ele é executado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-381">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="58ec4-382">O exemplo cria um `TaskInfo` do objeto e o atribui alguns dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58ec4-382">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="58ec4-383">O <xref:System.Threading.RegisteredWaitHandle> que é retornado pela <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método é atribuído ao `Handle` campo da `TaskInfo` do objeto para que o método de retorno de chamada tem acesso ao <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="58ec4-383">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="58ec4-384">Além de especificar `TaskInfo` como o objeto a ser passado para o método de retorno de chamada, a chamada para o <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método Especifica as <xref:System.Threading.AutoResetEvent> que a tarefa irá aguardar um <xref:System.Threading.WaitOrTimerCallback> delegado que representa o `WaitProc` método de retorno de chamada, um intervalo de tempo limite de um segundo e vários retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-384">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="58ec4-385">Quando o thread principal sinaliza a <xref:System.Threading.AutoResetEvent> chamando seus <xref:System.Threading.EventWaitHandle.Set%2A> método, o <xref:System.Threading.WaitOrTimerCallback> delegado é invocado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-385">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="58ec4-386">O `WaitProc` testes de método <xref:System.Threading.RegisteredWaitHandle> para determinar se um tempo limite ocorreu.</span><span class="sxs-lookup"><span data-stu-id="58ec4-386">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="58ec4-387">Se o retorno de chamada foi invocado porque o identificador de espera foi sinalizado, o `WaitProc` método cancela o registro de <xref:System.Threading.RegisteredWaitHandle>, parando adicionais retornos de chamada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-387">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="58ec4-388">No caso de um tempo limite, a tarefa continua a espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-388">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="58ec4-389">O `WaitProc` método termina imprimindo uma mensagem no console.</span><span class="sxs-lookup"><span data-stu-id="58ec4-389">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-390">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-390">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-391">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-391">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="58ec4-392">O número máximo de threads de trabalho no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-392">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="58ec4-393">O número máximo de threads de E/S assíncronas no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-393">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="58ec4-394">Define o número de solicitações para o pool de threads que podem estar ativas simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="58ec4-394">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="58ec4-395">Todas as solicitações acima desse número permanecem na fila até que os threads do pool de threads se tornem disponíveis.</span><span class="sxs-lookup"><span data-stu-id="58ec4-395">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="58ec4-396"><see langword="true" /> se a alteração for bem-sucedida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-396"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-397">É possível definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor do que o número de processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="58ec4-397">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="58ec4-398">Para determinar quantos processadores estiverem presentes, recuperar o valor da <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="58ec4-398">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="58ec4-399">Além disso, você não pode definir o número máximo de threads de trabalho ou threads de conclusão de e/s para um número menor que o número correspondente de mínimo de threads de trabalho ou threads de conclusão de e/s.</span><span class="sxs-lookup"><span data-stu-id="58ec4-399">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="58ec4-400">Para determinar o tamanho do pool de threads mínimo, chame o <xref:System.Threading.ThreadPool.GetMinThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58ec4-400">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="58ec4-401">Se o common language runtime está hospedado, por exemplo, serviços de informações da Internet (IIS) ou SQL Server, o host pode limitar ou impedir alterações para o tamanho do pool de thread.</span><span class="sxs-lookup"><span data-stu-id="58ec4-401">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="58ec4-402">Tenha cuidado ao alterar o número máximo de threads no pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-402">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="58ec4-403">Enquanto seu código pode se beneficiar, as alterações podem ter um efeito adverso em bibliotecas de código que você usar.</span><span class="sxs-lookup"><span data-stu-id="58ec4-403">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="58ec4-404">Definir o tamanho do pool de thread muito grande pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-404">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="58ec4-405">Se muitos threads estão em execução ao mesmo tempo, a alternância de tarefas sobrecarga se torna um fator significativo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-405">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="58ec4-406">para a capacidade de controlar os threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-406">for the ability to control threads.</span></span> <span data-ttu-id="58ec4-407">Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="58ec4-407">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="58ec4-408">O número mínimo de threads de trabalho que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="58ec4-408">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="58ec4-409">O número mínimo de threads de E/S assíncronos que o pool de threads cria sob demanda.</span><span class="sxs-lookup"><span data-stu-id="58ec4-409">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="58ec4-410">Define o número mínimo de threads que o pool de threads cria sob demanda à medida que novas solicitações são feitas, antes de mudar para um algoritmo a fim de gerenciar a criação e a destruição de thread.</span><span class="sxs-lookup"><span data-stu-id="58ec4-410">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="58ec4-411"><see langword="true" /> se a alteração for bem-sucedida; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-411"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-412">O pool de threads fornece novos threads de trabalho ou threads de conclusão de e/s sob demanda até atingir o mínimo para cada categoria.</span><span class="sxs-lookup"><span data-stu-id="58ec4-412">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="58ec4-413">Quando o mínimo é atingido, o pool de threads pode criar threads adicionais nessa categoria ou aguarde a conclusão de algumas tarefas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-413">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="58ec4-414">Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o pool de threads cria e destrói threads para otimizar a taxa de transferência, que é definida como o número de tarefas concluídas por unidade de tempo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-414">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="58ec4-415">Pouquíssimos threads podem não fazer um uso ideal dos recursos disponíveis, enquanto muitos threads podem aumentar a contenção de recursos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-415">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="58ec4-416">Quando a demanda é baixa, o número real de threads do pool de threads pode ficar abaixo dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-416">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="58ec4-417">Se você especificar um número negativo ou um número maior que o número máximo de threads de pool de thread ativo (obtidos usando o <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> retorna `false` e não altera qualquer um dos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-417">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-418">Por padrão, o número mínimo de threads é definido como o número de processadores em um sistema.</span><span class="sxs-lookup"><span data-stu-id="58ec4-418">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="58ec4-419">Você pode usar o <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar o ofthreads número mínimo.</span><span class="sxs-lookup"><span data-stu-id="58ec4-419">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="58ec4-420">No entanto, o aumento desnecessário desses valores pode causar problemas de desempenho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-420">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="58ec4-421">Se muitas tarefas começarem ao mesmo tempo, todas elas podem parecer lentas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-421">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="58ec4-422">Na maioria dos casos, o pool de threads terá um desempenho melhor com seu próprio algoritmo de alocação de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-422">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="58ec4-423">Reduzindo o mínimo menor do que o número de processadores também pode prejudicar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-423">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58ec4-424">O exemplo a seguir define o número mínimo de threads de trabalho para quatro e preserva o valor original para o número mínimo de threads de conclusão de e/s assíncronas.</span><span class="sxs-lookup"><span data-stu-id="58ec4-424">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="58ec4-425">para a capacidade de controlar os threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-425">for the ability to control threads.</span></span> <span data-ttu-id="58ec4-426">Valor de permissão: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="58ec4-426">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="58ec4-427">A estrutura <see cref="T:System.Threading.NativeOverlapped" /> a ser colocada em fila.</span><span class="sxs-lookup"><span data-stu-id="58ec4-427">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="58ec4-428">Enfileira uma operação de E/S sobreposta para a execução.</span><span class="sxs-lookup"><span data-stu-id="58ec4-428">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="58ec4-429"><see langword="true" /> se a operação foi enfileirada com êxito para uma porta de conclusão de E/S; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-429"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-430">Para obter informações sobre como usar o Win32 nativo e/s sobreposta, consulte o <xref:System.Threading.Overlapped> classe, o <xref:System.Threading.NativeOverlapped> estrutura e o `OVERLAPPED` estrutura no SDK da plataforma do Win32.</span><span class="sxs-lookup"><span data-stu-id="58ec4-430">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-431">Usando o <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> método pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-431">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="58ec4-432">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="58ec4-432">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="58ec4-433">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, a pilha do thread do pool não tem o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="58ec4-433">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="58ec4-434">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-434">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="58ec4-435">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58ec4-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="58ec4-436">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58ec4-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="58ec4-437">Um <see cref="T:System.Threading.WaitCallback" /> que retrata o delegado a ser invocado quando um thread no pool de threads coleta o item de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-437">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-438">O objeto que é passado para o representante quando este recebe manutenção do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-438">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="58ec4-439">Enfileira o delegado especificado no pool de threads, mas não propagar a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-439">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="58ec4-440"><see langword="true" /> se o método tiver êxito; <see cref="T:System.OutOfMemoryException" /> será gerado se não for possível colocar o item de trabalho na fila.</span><span class="sxs-lookup"><span data-stu-id="58ec4-440"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-441">Ao contrário do <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-441">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="58ec4-442">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-442">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-443">Usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-443">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="58ec4-444">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="58ec4-444">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="58ec4-445">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="58ec4-445">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="58ec4-446">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-446">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58ec4-447">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="58ec4-447">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="58ec4-448">Uma condição de memória insuficiente foi encontrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-448">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="58ec4-449">Não foi possível colocar o item de trabalho na fila.</span><span class="sxs-lookup"><span data-stu-id="58ec4-449">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58ec4-450"><paramref name="callBack" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-450"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="58ec4-451">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58ec4-451">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="58ec4-452">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58ec4-452">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-453">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-453">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58ec4-454">Registra um representante para aguardar um <see cref="T:System.Threading.WaitHandle" />, mas não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-455">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-455">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-456">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-456">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-457">O delegado a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-457">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-458">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-458">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="58ec4-459">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-459">The time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-460">Se o parâmetro <paramref name="millisecondsTimeOutInterval" /> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-460">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-461">Se <paramref name="millisecondsTimeOutInterval" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-461">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-462"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-462"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-463">Registra um representante para aguardar um <see cref="T:System.Threading.WaitHandle" />, usando um inteiro com sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-463">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-464">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-464">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="58ec4-465">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-465">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-466">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-466">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="58ec4-467">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-467">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-468">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-468">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="58ec4-469">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="58ec4-469">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="58ec4-470">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="58ec4-470">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="58ec4-471">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-471">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="58ec4-472">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-472">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="58ec4-473">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-473">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-474">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-474">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-475">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-475">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-476">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-476">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58ec4-477">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="58ec4-477">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="58ec4-478">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58ec4-478">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="58ec4-479">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58ec4-479">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-480">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-480">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-481">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-481">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-482">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-482">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-483">O delegado a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-483">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-484">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-484">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="58ec4-485">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-485">The time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-486">Se o parâmetro <paramref name="millisecondsTimeOutInterval" /> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-486">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-487">Se <paramref name="millisecondsTimeOutInterval" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-487">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-488"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-488"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-489">Registra um delegado para esperar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro com sinal de 64 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-489">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-490">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-490">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="58ec4-491">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-491">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-492">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-492">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="58ec4-493">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-493">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-494">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-494">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="58ec4-495">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="58ec4-495">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="58ec4-496">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="58ec4-496">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="58ec4-497">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-497">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="58ec4-498">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-498">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="58ec4-499">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-499">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-500">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-500">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-501">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-501">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-502">O parâmetro <paramref name="millisecondsTimeOutInterval" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-502">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58ec4-503">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="58ec4-503">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="58ec4-504">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58ec4-504">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="58ec4-505">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58ec4-505">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-506">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-506">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-507">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-507">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-508">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-508">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-509">O delegado a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-509">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-510">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-510">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="58ec4-511">O tempo limite representado por um <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-511">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="58ec4-512">Se <paramref name="timeout" /> for 0 (zero), a função testará o estado do objeto e será retornada imediatamente.</span><span class="sxs-lookup"><span data-stu-id="58ec4-512">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-513">Se <paramref name="timeout" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-513">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-514"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-514"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-515">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um valor <see cref="T:System.TimeSpan" /> para o tempo limite. Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-515">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="58ec4-516">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-516">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-517">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-517">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="58ec4-518">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-518">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-519">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-519">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="58ec4-520">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="58ec4-520">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="58ec4-521">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="58ec4-521">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="58ec4-522">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-522">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="58ec4-523">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-523">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="58ec4-524">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-524">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-525">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-525">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-526">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-526">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58ec4-527">O parâmetro <paramref name="timeout" /> é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="58ec4-527">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58ec4-528">O parâmetro <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-528">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58ec4-529">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="58ec4-529">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="58ec4-530">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58ec4-530">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="58ec4-531">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58ec4-531">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-532">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-532">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="58ec4-533">O <see cref="T:System.Threading.WaitHandle" /> a ser registrado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-533">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="58ec4-534">Use um <see cref="T:System.Threading.WaitHandle" /> diferente do <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="58ec4-534">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="58ec4-535">O delegado a ser chamado quando o parâmetro <paramref name="waitObject" /> é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-535">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="58ec4-536">O objeto que é passado para o delegado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-536">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="58ec4-537">O tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-537">The time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-538">Se o parâmetro <paramref name="millisecondsTimeOutInterval" /> for 0 (zero), a função testará o estado do objeto e será imediatamente retornada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-538">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="58ec4-539">Se <paramref name="millisecondsTimeOutInterval" /> for -1, o intervalo de tempo limite da função nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="58ec4-539">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="58ec4-540"><see langword="true" /> para indicar que o thread não esperará o parâmetro <paramref name="waitObject" /> depois que o delegado for chamado; <see langword="false" /> para indicar que o temporizador será reiniciado sempre que a operação de espera for concluída até que o registro da espera seja cancelado.</span><span class="sxs-lookup"><span data-stu-id="58ec4-540"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="58ec4-541">Registra um delegado para aguardar um <see cref="T:System.Threading.WaitHandle" />, especificando um inteiro sem sinal de 32 bits para o tempo limite em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="58ec4-541">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="58ec4-542">Esse método não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-542">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="58ec4-543">O objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que pode ser usado para cancelar a operação de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-543">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58ec4-544">Ao contrário do <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> não propaga a pilha de chamadas para o thread de trabalho.</span><span class="sxs-lookup"><span data-stu-id="58ec4-544">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="58ec4-545">Isso permite que o código a perder a pilha de chamadas e, portanto, para elevar seus privilégios de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-545">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58ec4-546">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> pode abrir inadvertidamente uma brecha de segurança.</span><span class="sxs-lookup"><span data-stu-id="58ec4-546">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="58ec4-547">Segurança de acesso do código baseia suas verificações de permissão sobre as permissões de todos os chamadores na pilha.</span><span class="sxs-lookup"><span data-stu-id="58ec4-547">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="58ec4-548">Quando o trabalho está na fila em um thread de pool de thread usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, a pilha do thread do pool não terá o contexto dos chamadores reais.</span><span class="sxs-lookup"><span data-stu-id="58ec4-548">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="58ec4-549">Código mal-intencionado pode ser capaz de explorar isso para evitar verificações de permissão.</span><span class="sxs-lookup"><span data-stu-id="58ec4-549">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="58ec4-550">Usando um <xref:System.Threading.Mutex> para `waitObject` não oferece a exclusão mútua para os retornos de chamada, pois a API do Win32 subjacente usa o padrão `WT_EXECUTEDEFAULT` sinalizar, portanto, cada retorno de chamada é enviado em um thread separado do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="58ec4-550">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="58ec4-551">Quando tiver concluído usando o <xref:System.Threading.RegisteredWaitHandle> que é retornado por esse método, chame seu <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar referências para o identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="58ec4-551">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="58ec4-552">É recomendável que você sempre chame o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, mesmo se você especificar `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="58ec4-552">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="58ec4-553">Coleta de lixo funciona mais ou com eficiência se você chamar o <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método em vez de dependendo do finalizador do identificador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="58ec4-553">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58ec4-554">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="58ec4-554">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="58ec4-555">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58ec4-555">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="58ec4-556">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58ec4-556">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="58ec4-557">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="58ec4-557">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>