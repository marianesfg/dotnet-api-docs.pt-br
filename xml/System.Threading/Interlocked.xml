<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fa9facc092ece8bd12ffdc7cb45884caa9f995c6" />
    <Meta Name="ms.sourcegitcommit" Value="6b37f0465def6e8fa497984567df2a7cc3f75874" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/13/2018" />
    <Meta Name="ms.locfileid" Value="51598142" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="8b8db-101">Fornece operações atômicas para variáveis que são compartilhadas por vários threads.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b8db-101">Provides atomic operations for variables that are shared by multiple threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-102">Os métodos dessa classe ajudam a proteger contra erros que podem ocorrer quando o Agendador alterna contextos, enquanto um thread está atualizando uma variável que pode ser acessada por outros threads, ou quando dois threads estão em execução simultaneamente em processadores separados.</span><span class="sxs-lookup"><span data-stu-id="8b8db-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="8b8db-103">Os membros dessa classe não geram exceções.</span><span class="sxs-lookup"><span data-stu-id="8b8db-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="8b8db-104">O <xref:System.Threading.Interlocked.Increment%2A> e <xref:System.Threading.Interlocked.Decrement%2A> métodos incrementar ou decrementar a uma variável e armazenar o valor resultante em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="8b8db-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="8b8db-105">Na maioria dos computadores, incrementar uma variável não é uma operação atômica, que exigem as seguintes etapas:</span><span class="sxs-lookup"><span data-stu-id="8b8db-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="8b8db-106">Carregar um valor de uma variável de instância em um registro.</span><span class="sxs-lookup"><span data-stu-id="8b8db-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="8b8db-107">Incrementar ou decrementar o valor.</span><span class="sxs-lookup"><span data-stu-id="8b8db-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="8b8db-108">Store o valor na variável de instância.</span><span class="sxs-lookup"><span data-stu-id="8b8db-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="8b8db-109">Se você não usar <xref:System.Threading.Interlocked.Increment%2A> e <xref:System.Threading.Interlocked.Decrement%2A>, um thread pode ser impedido depois de executar as duas primeiras etapas.</span><span class="sxs-lookup"><span data-stu-id="8b8db-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="8b8db-110">Outro thread, em seguida, pode executar todas as três etapas.</span><span class="sxs-lookup"><span data-stu-id="8b8db-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="8b8db-111">Quando o primeiro thread retoma a execução, ele substitui o valor da variável de instância e o efeito de incremento ou decremento executada pelo thread de segundo é perdido.</span><span class="sxs-lookup"><span data-stu-id="8b8db-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="8b8db-112">O <xref:System.Threading.Interlocked.Add%2A> método atomicamente adiciona um valor inteiro para uma variável de inteiro e retorna o novo valor da variável.</span><span class="sxs-lookup"><span data-stu-id="8b8db-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="8b8db-113">O <xref:System.Threading.Interlocked.Exchange%2A> método atomicamente troca os valores das variáveis especificados.</span><span class="sxs-lookup"><span data-stu-id="8b8db-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="8b8db-114">O <xref:System.Threading.Interlocked.CompareExchange%2A> método combina duas operações: comparando dois valores e armazenar um terceiro valor em uma das variáveis, com base no resultado da comparação.</span><span class="sxs-lookup"><span data-stu-id="8b8db-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="8b8db-115">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="8b8db-116">Certifique-se de que qualquer gravação ou acesso de leitura a uma variável compartilhada seja atômico.</span><span class="sxs-lookup"><span data-stu-id="8b8db-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="8b8db-117">Caso contrário, os dados podem estar corrompidos ou o valor carregado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="8b8db-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="8b8db-118">O exemplo de código a seguir mostra um mecanismo de bloqueio de recurso de thread-safe.</span><span class="sxs-lookup"><span data-stu-id="8b8db-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="8b8db-119">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b8db-119">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="8b8db-120">Threading gerenciado</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b8db-120">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
      <span data-ttu-id="8b8db-121">Visão geral dos primitivos de sincronização</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b8db-121">Overview of synchronization primitives</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b8db-122">Adiciona dois números inteiros e substitui o primeiro inteiro com a soma, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-123">Uma variável que contém o primeiro valor a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-123">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="8b8db-124">A soma dos dois valores é armazenada em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-124">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-125">O valor a ser adicionado ao inteiro em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-125">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-126">Adiciona dois números inteiros de 32 bits e substitui o primeiro inteiro com a soma, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-127">O novo valor armazenado em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-127">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-128">Este método trata uma condição de estouro, encapsulando: se o valor no `location1` está <xref:System.Int32.MaxValue?displayProperty=nameWithType> e `value` for 1, o resultado é <xref:System.Int32.MinValue?displayProperty=nameWithType>; se `value` for 2, o resultado é (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="8b8db-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="8b8db-129">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-130">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-130">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-131">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-131">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-132">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-132">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-133">Uma variável que contém o primeiro valor a ser adicionado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-133">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="8b8db-134">A soma dos dois valores é armazenada em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-134">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-135">O valor a ser adicionado ao inteiro em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-135">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-136">Adiciona dois números inteiros de 64 bits e substitui o primeiro inteiro com a soma, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-137">O novo valor armazenado em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-137">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-138">Este método trata uma condição de estouro, encapsulando: se o valor no `location1` está <xref:System.Int64.MaxValue?displayProperty=nameWithType> e `value` for 1, o resultado é <xref:System.Int64.MinValue?displayProperty=nameWithType>; se `value` for 2, o resultado é (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="8b8db-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="8b8db-139">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-140">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-140">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-141">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-141">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-142">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-142">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b8db-143">Compara dois valores para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-143">Compares two values for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-144">O destino, cujo valor é comparado com <c>termo de comparação</c> e possivelmente substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-144">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-145">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-145">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-146">O valor comparado com o valor em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-146">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-147">Compara se dois pontos flutuantes de precisão dupla são iguais e, se eles forem, substitui o primeiro valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-148">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-148">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-149">Se `comparand` e o valor na `location1` forem iguais, então `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-150">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-151">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-152">O valor de retorno <xref:System.Threading.Interlocked.CompareExchange%2A> é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b8db-153">O exemplo de código a seguir demonstra um método de thread-safe que acumula total de execução de <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="8b8db-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="8b8db-154">Dois threads some uma série de <xref:System.Double> valores usando o método de thread-safe e adição comum, e quando os threads conclui os totais são comparados.</span><span class="sxs-lookup"><span data-stu-id="8b8db-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="8b8db-155">Em um computador com processador duplo, há uma diferença significativa nos totais.</span><span class="sxs-lookup"><span data-stu-id="8b8db-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="8b8db-156">O método de thread-safe, o valor inicial de execução total é salvo e, em seguida, o <xref:System.Threading.Interlocked.CompareExchange%2A> método é usado para trocar o total computado recentemente com o total de antigo.</span><span class="sxs-lookup"><span data-stu-id="8b8db-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="8b8db-157">Se o valor de retorno não for igual ao valor salvo do total em execução, em seguida, outro thread atualizou o total nesse meio tempo.</span><span class="sxs-lookup"><span data-stu-id="8b8db-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="8b8db-158">Nesse caso, a tentativa de atualizar o total acumulado deve ser repetida.</span><span class="sxs-lookup"><span data-stu-id="8b8db-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-159">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-159">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-160">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-160">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-161">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-161">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-162">O destino, cujo valor é comparado com <c>termo de comparação</c> e possivelmente substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-162">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-163">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-163">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-164">O valor comparado com o valor em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-164">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-165">Compara dois inteiros com sinal de 32 bits para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-166">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-166">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-167">Se `comparand` e o valor na `location1` forem iguais, então `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-168">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-169">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-170">O valor de retorno <xref:System.Threading.Interlocked.CompareExchange%2A> é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b8db-171">O exemplo de código a seguir demonstra um método de thread-safe que acumula total de execução.</span><span class="sxs-lookup"><span data-stu-id="8b8db-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="8b8db-172">O valor inicial de execução total é salvo e, em seguida, o <xref:System.Threading.Interlocked.CompareExchange%2A> método é usado para trocar o total computado recentemente com o total de antigo.</span><span class="sxs-lookup"><span data-stu-id="8b8db-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="8b8db-173">Se o valor de retorno não for igual ao valor salvo do total em execução, em seguida, outro thread atualizou o total nesse meio tempo.</span><span class="sxs-lookup"><span data-stu-id="8b8db-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="8b8db-174">Nesse caso, a tentativa de atualizar o total acumulado deve ser repetida.</span><span class="sxs-lookup"><span data-stu-id="8b8db-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b8db-175">O <xref:System.Threading.Interlocked.Add%2A> método, introduzido na versão 2.0 do .NET Framework, fornece uma maneira mais conveniente para acumular os totais de execução de thread-safe para números inteiros.</span><span class="sxs-lookup"><span data-stu-id="8b8db-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-176">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-176">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-177">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-177">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-178">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-178">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-179">O destino, cujo valor é comparado com <c>termo de comparação</c> e possivelmente substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-179">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-180">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-180">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-181">O valor comparado com o valor em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-181">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-182">Compara dois inteiros com sinal de 64 bits para verificar se são iguais e, em caso de igualdade, substitui o primeiro valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-183">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-183">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-184">Se `comparand` e o valor na `location1` forem iguais, então `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-185">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-186">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-187">O valor de retorno <xref:System.Threading.Interlocked.CompareExchange%2A> é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-188">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-188">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-189">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-189">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-190">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-190">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-191">O <see cref="T:System.IntPtr" /> de destino, cujo valor é comparado com o valor de <c>comparand</c> e possivelmente substituído por <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <c>comparand</c> and possibly replaced by <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-192">O <see cref="T:System.IntPtr" /> que substitui o valor de destino quando a comparação resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-193">O <see cref="T:System.IntPtr" /> comparado com o valor em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-194">Compara dois ponteiros ou identificadores específicos da plataforma quanto à igualdade e, se eles são iguais, substitui o primeiro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-195">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-195">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-196">Se `comparand` e o valor na `location1` forem iguais, então `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-197">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-198">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-199">O valor de retorno desse método é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b8db-200"><xref:System.IntPtr> é um tipo específico da plataforma.</span><span class="sxs-lookup"><span data-stu-id="8b8db-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-201">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-201">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-202">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-202">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-203">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-203">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-204">O objeto de destino que é comparado pela referência com <c>comparand</c> e possivelmente substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-204">The destination object that is compared by reference with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-205">O objeto que substitui o objeto de destino quando a comparação de referência resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-205">The object that replaces the destination object if the reference comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-206">O objeto que é comparado pela referência ao objeto em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-206">The object that is compared by reference to the object at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-207">Compara dois objetos quanto à igualdade de referência e, se eles forem iguais, substitui o primeiro objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-208">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-208">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="8b8db-209">Começando com o .NET Framework 2.0, o <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%29> sobrecarga do método fornece uma alternativa de tipo seguro para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="8b8db-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="8b8db-210">É recomendável que você chamá-lo em vez dessa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="8b8db-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="8b8db-211">Se `comparand` e o objeto na `location1` são iguais por referência, em seguida, `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-212">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-213">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-214">O valor de retorno <xref:System.Threading.Interlocked.CompareExchange%2A> é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="8b8db-215">Os objetos são comparados para igualdade de referência em vez de igualdade de valor.</span><span class="sxs-lookup"><span data-stu-id="8b8db-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="8b8db-216">Como resultado, duas instâncias demarcadas do mesmo tipo de valor (por exemplo, o valor inteiro 3) sempre parecem ser diferentes e nenhuma operação é executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="8b8db-217">Não use essa sobrecarga com tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="8b8db-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b8db-218">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-218">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-219">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-219">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-220">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-220">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-221">O destino, cujo valor é comparado com <c>termo de comparação</c> e possivelmente substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-221">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-222">O valor que substitui o valor de destino quando a comparação resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-222">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-223">O valor comparado com o valor em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-223">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-224">Compara se dois números de ponto flutuante de precisão simples são iguais e, se eles são, substitui o primeiro valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-225">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-225">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-226">Se `comparand` e o valor na `location1` forem iguais, então `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-227">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-228">As operações de comparação e troca são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-229">O valor de retorno <xref:System.Threading.Interlocked.CompareExchange%2A> é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b8db-230">O exemplo de código a seguir demonstra um método de thread-safe que acumula total de execução de <xref:System.Single> valores.</span><span class="sxs-lookup"><span data-stu-id="8b8db-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="8b8db-231">Dois threads some uma série de <xref:System.Single> valores usando o método de thread-safe e adição comum, e quando os threads conclui os totais são comparados.</span><span class="sxs-lookup"><span data-stu-id="8b8db-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="8b8db-232">Em um computador com processador duplo, há uma diferença significativa nos totais.</span><span class="sxs-lookup"><span data-stu-id="8b8db-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="8b8db-233">O método de thread-safe, o valor inicial de execução total é salvo e, em seguida, o <xref:System.Threading.Interlocked.CompareExchange%2A> método é usado para trocar o total computado recentemente com o total de antigo.</span><span class="sxs-lookup"><span data-stu-id="8b8db-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="8b8db-234">Se o valor de retorno não for igual ao valor salvo do total em execução, em seguida, outro thread atualizou o total nesse meio tempo.</span><span class="sxs-lookup"><span data-stu-id="8b8db-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="8b8db-235">Nesse caso, a tentativa de atualizar o total acumulado deve ser repetida.</span><span class="sxs-lookup"><span data-stu-id="8b8db-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-236">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-236">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-237">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-237">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-238">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-238">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b8db-239">O tipo a ser usado para <c>location1</c>, <c>valor</c>, e <c>comparand</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-239">The type to be used for <c>location1</c>, <c>value</c>, and <c>comparand</c>.</span>
          </span>
          <span data-ttu-id="8b8db-240">Esse tipo deve ser um tipo de referência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-240">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="8b8db-241">O destino, cujo valor é comparado pela referência com <c>comparand</c> e possivelmente substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-241">The destination, whose value is compared by reference with <c>comparand</c> and possibly replaced.</span>
          </span>
          <span data-ttu-id="8b8db-242">Esse é um parâmetro de referência (<see langword="ref" /> no C# e <see langword="ByRef" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-243">O valor que substitui o valor de destino quando a comparação pela referência resulta em igualdade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-243">The value that replaces the destination value if the comparison by reference results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="8b8db-244">O valor que é comparado pela referência com o valor em <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-244">The value that is compared by reference to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-245">Compara duas instâncias do tipo de referência <paramref name="T" /> especificado em relação à igualdade e, se elas forem iguais, substitui a primeira.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-246">O valor original em <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-246">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-247">Se `comparand` e o valor na `location1` são iguais por referência, em seguida, `value` são armazenados em `location1`.</span><span class="sxs-lookup"><span data-stu-id="8b8db-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="8b8db-248">Caso contrário, nenhuma operação será executada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="8b8db-249">A comparação e o exchange são executadas como uma operação atômica.</span><span class="sxs-lookup"><span data-stu-id="8b8db-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="8b8db-250">O valor de retorno desse método é o valor original no `location1`, esteja ou não a troca.</span><span class="sxs-lookup"><span data-stu-id="8b8db-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="8b8db-251">Esse método só dá suporte a tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="8b8db-251">This method only supports reference types.</span></span> <span data-ttu-id="8b8db-252">Há sobrecargas do <xref:System.Threading.Interlocked.CompareExchange%2A> método para os tipos de valor <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, e <xref:System.Double>, mas não há suporte para outros tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="8b8db-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b8db-253">Essa sobrecarga de método é preferível a <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> sobrecarga do método, porque a segunda opção requer o objeto de destino a ser acessado de associação tardia.</span><span class="sxs-lookup"><span data-stu-id="8b8db-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-254">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-254">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b8db-255">Decrementa uma variável especificada e armazena o resultado, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-255">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="8b8db-256">A variável cujo valor deve ser decrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-256">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-257">Decrementa uma variável especificada e armazena o resultado, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-257">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-258">O valor decrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-258">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-259">Este método trata uma condição de estouro, encapsulando: se `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8db-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8db-260">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b8db-261">O exemplo a seguir determina quantos números aleatórios que variam de 0 a 1.000 são necessárias para gerar números aleatórios 1.000 com um valor de ponto médio.</span><span class="sxs-lookup"><span data-stu-id="8b8db-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="8b8db-262">Para controlar o número de valores de ponto médio, uma variável, `midpointCount`, é definido igual a 1.000 e é decrementado sempre que o gerador de número aleatório retorna um valor de ponto médio.</span><span class="sxs-lookup"><span data-stu-id="8b8db-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="8b8db-263">Como três threads geram números aleatórios, o <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> método é chamado para garantir que vários threads não atualizam `midpointCount` simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="8b8db-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="8b8db-264">Observe que um bloqueio também é usado para proteger o gerador de número aleatório e que um <xref:System.Threading.CountdownEvent> objeto é usado para garantir que o `Main` método não concluir a execução antes de três threads.</span><span class="sxs-lookup"><span data-stu-id="8b8db-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="8b8db-265">O exemplo a seguir é semelhante ao anterior, exceto que ele usa o <xref:System.Threading.Tasks.Task> classe em vez de um procedimento de thread para gerar números inteiros de ponto médio aleatório 50.000.</span><span class="sxs-lookup"><span data-stu-id="8b8db-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="8b8db-266">Neste exemplo, uma expressão lambda substitui o `GenerateNumbers` procedimento do thread e a chamada para o <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método elimina a necessidade do <xref:System.Threading.CountdownEvent> objeto.</span><span class="sxs-lookup"><span data-stu-id="8b8db-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b8db-267">O endereço de <paramref name="location" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-267">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-268">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-268">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-269">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-269">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="8b8db-270">A variável cujo valor deve ser decrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-270">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-271">Diminui uma variável especificada e armazena o resultado como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-271">Decrements the specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-272">O valor decrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-272">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-273">Este método trata uma condição de estouro, encapsulando: se `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8db-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8db-274">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b8db-275">O endereço de <paramref name="location" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-275">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-276">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-276">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-277">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-277">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b8db-278">Define uma variável com um valor especificado como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-278">Sets a variable to a specified value as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-279">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-279">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-280">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-280">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-281">Define um número de ponto flutuante de precisão dupla para um valor especificado e retorna o valor original, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-282">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-282">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-283">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-283">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-284">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-284">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-285">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-285">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-286">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-286">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-287">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-287">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-288">Define um inteiro com sinal de 32 bits com um valor especificado e retorna o valor original, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-289">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-289">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b8db-290">O exemplo de código a seguir mostra um mecanismo de bloqueio de recurso de thread-safe.</span><span class="sxs-lookup"><span data-stu-id="8b8db-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b8db-291">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-291">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-292">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-292">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-293">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-293">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-294">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-294">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-295">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-295">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-296">Define um inteiro com sinal de 64 bits com um valor especificado e retorna o valor original, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-297">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-297">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-298">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-298">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-299">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-299">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-300">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-300">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-301">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-301">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-302">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-302">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-303">Define um identificador específico de plataforma ou um ponteiro para um valor especificado e retorna o valor original como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-304">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-304">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-305">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-305">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-306">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-306">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-307">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-307">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-308">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-308">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-309">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-309">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-310">Define um objeto com um valor especificado e retorna uma referência ao objeto original, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-311">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-311">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="8b8db-312">Começando com o .NET Framework 2.0, o <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> sobrecarga do método fornece uma alternativa de tipo seguro para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="8b8db-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="8b8db-313">É recomendável que você chamá-lo em vez dessa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="8b8db-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b8db-314">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-314">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-315">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-315">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-316">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-316">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="8b8db-317">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-317">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-318">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-318">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-319">Define um número de ponto flutuante de precisão simples para um valor especificado e retorna o valor original como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-320">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-320">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-321">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-321">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-322">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-322">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-323">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-323">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="8b8db-324">O tipo a ser usado para <c>location1</c> e <c>valor</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-324">The type to be used for <c>location1</c> and <c>value</c>.</span>
          </span>
          <span data-ttu-id="8b8db-325">Esse tipo deve ser um tipo de referência.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-325">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="8b8db-326">A variável a ser definida com o valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-326">The variable to set to the specified value.</span>
          </span>
          <span data-ttu-id="8b8db-327">Esse é um parâmetro de referência (<see langword="ref" /> no C# e <see langword="ByRef" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="8b8db-328">O valor para o qual o parâmetro <c>location1</c> é definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-328">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-329">Define uma variável do tipo <paramref name="T" /> especificado como um valor especificado e retorna o valor original como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-330">O valor original de <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-330">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-331">Esse método só dá suporte a tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="8b8db-331">This method only supports reference types.</span></span> <span data-ttu-id="8b8db-332">Há sobrecargas do <xref:System.Threading.Interlocked.Exchange%2A> método para o <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, e <xref:System.Double> tipos de valor, mas não há suporte para outros tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="8b8db-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b8db-333">Essa sobrecarga de método é preferível a <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> sobrecarga do método, porque a segunda opção requer acesso ao objeto de destino de associação tardia.</span><span class="sxs-lookup"><span data-stu-id="8b8db-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-334">O endereço de <paramref name="location1" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-334">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b8db-335">Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-335">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="8b8db-336">A variável cujo valor deve ser incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-336">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-337">Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-337">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-338">O valor incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-338">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-339">Este método trata uma condição de estouro, encapsulando: se `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8db-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8db-340">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b8db-341">O exemplo a seguir determina quantos números aleatórios que variam de 0 a 1.000 são necessárias para gerar números aleatórios 1.000 com um valor de ponto médio.</span><span class="sxs-lookup"><span data-stu-id="8b8db-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="8b8db-342">Para controlar o número de valores de ponto médio, uma variável, `midpointCount`, é definido como 0 e incrementado toda vez que o gerador de número aleatório retorna um valor de ponto médio até atingir a 10.000.</span><span class="sxs-lookup"><span data-stu-id="8b8db-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="8b8db-343">Como três threads geram números aleatórios, o <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> método é chamado para garantir que vários threads não atualizam `midpointCount` simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="8b8db-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="8b8db-344">Observe que um bloqueio também é usado para proteger o gerador de número aleatório e que um <xref:System.Threading.CountdownEvent> objeto é usado para garantir que o `Main` método não concluir a execução antes de três threads.</span><span class="sxs-lookup"><span data-stu-id="8b8db-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="8b8db-345">O exemplo a seguir é semelhante ao anterior, exceto que ele usa o <xref:System.Threading.Tasks.Task> classe em vez de um procedimento de thread para gerar números inteiros de ponto médio aleatório 50.000.</span><span class="sxs-lookup"><span data-stu-id="8b8db-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="8b8db-346">Neste exemplo, uma expressão lambda substitui o `GenerateNumbers` procedimento do thread e a chamada para o <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método elimina a necessidade do <xref:System.Threading.CountdownEvent> objeto.</span><span class="sxs-lookup"><span data-stu-id="8b8db-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-347">O endereço de <paramref name="location" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-347">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-348">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-348">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-349">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-349">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="8b8db-350">A variável cujo valor deve ser incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-350">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-351">Incrementa uma variável especificada e armazena o resultado, como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-351">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-352">O valor incrementado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-352">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-353">Este método trata uma condição de estouro, encapsulando: se `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8db-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8db-354">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="8b8db-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="8b8db-355">O endereço de <paramref name="location" /> é um ponteiro nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-355">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-356">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-356">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-357">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-357">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b8db-358">Sincroniza o acesso à memória da seguinte maneira: o processador que executa o thread atual não pode reorganizar as instruções de forma que os acessos à memória anteriores à chamada para <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> sejam executados depois dos acessos à memória posteriores à chamada para <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-359">Esse método foi adicionado para o <xref:System.Threading.Interlocked> classe a [!INCLUDE[net_v45](~/includes/net-v45-md.md)] como uma conveniência; ele é um wrapper para o <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="8b8db-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8b8db-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> é necessário apenas em sistemas multiprocessadores que tenha memória fraca ordem (por exemplo, um sistema que utiliza vários processadores Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="8b8db-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="8b8db-361">Para a maioria das finalidades, o c# `lock` instrução, o Visual Basic `SyncLock` instrução, ou o <xref:System.Threading.Monitor> classe fornecem maneiras mais fáceis para sincronizar os dados.</span><span class="sxs-lookup"><span data-stu-id="8b8db-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="8b8db-362">O valor de 64 bits a ser carregado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-362">The 64-bit value to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b8db-363">Retorna um valor de 64 bits, carregado como uma operação atômica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-363">Returns a 64-bit value, loaded as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b8db-364">O valor carregado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-364">The loaded value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b8db-365">O <xref:System.Threading.Interlocked.Read%2A> método é desnecessário em sistemas de 64 bits, pois as operações de leitura de 64 bits já são atômicas.</span><span class="sxs-lookup"><span data-stu-id="8b8db-365">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="8b8db-366">Em sistemas de 32 bits, as operações de leitura de 64 bits não são atômicas, a menos que executada usando <xref:System.Threading.Interlocked.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8db-366">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="8b8db-367">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-367">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md">
          <span data-ttu-id="8b8db-368">Visão geral dos primitivos de sincronização</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b8db-368">Overview of synchronization primitives</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>