<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7aae04c039e4c598f2f78c1131b5525f9c9e9654" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407689" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Cria e controla um thread, define sua prioridade e obtém seu status.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um processo é iniciado, o common language runtime cria automaticamente um thread único em primeiro plano para executar o código do aplicativo. Junto com este thread principal do primeiro plano, um processo pode criar um ou mais threads para executar uma parte do código do programa associado ao processo. Esses threads podem executar em primeiro plano ou no plano de fundo. Além disso, você pode usar o <xref:System.Threading.ThreadPool> classe para executar código em threads de trabalho que são gerenciados pelo common language runtime.  
  
 Nesta seção  
  
 [Iniciar um thread](#Starting)   
 [Recuperando objetos de Thread](#Retrieving)   
 [Threads de primeiro plano e plano de fundo](#Foreground)   
 [Cultura e threads](#Culture)   
 [Obtendo informações sobre e controlando threads](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Iniciar um thread  
 Iniciar um thread, fornecendo um delegado que representa o método que o thread é executar o construtor de classe. Em seguida, chamar o <xref:System.Threading.Thread.Start%2A> método para começar a execução.  
  
 O <xref:System.Threading.Thread> construtores podem ter um delegado de dois tipos, dependendo se você pode passar um argumento para o método a ser executado:  
  
-   Se o método não possui argumentos, você passar um <xref:System.Threading.ThreadStart> delegar para o construtor. Ele tem a assinatura:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     O exemplo a seguir cria e inicia um thread que executa o `ExecuteInForeground` método. O método exibe informações sobre algumas propriedades de thread e, em seguida, executa um loop no qual ele pausa por meio segundo e exibe o número decorrido de segundos. Quando o thread de execução pelo menos cinco segundos, o loop é encerrado e o thread finaliza a execução.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Se o método tem um argumento, você passar um <xref:System.Threading.ParameterizedThreadStart> delegar para o construtor. Ele tem a assinatura:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     O método executado pelo delegado pode, em seguida, cast (em c#) ou converter o parâmetro (no Visual Basic) para o tipo apropriado.  
  
     O exemplo a seguir é idêntico ao anterior, exceto que ele chama o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> construtor. Esta versão do `ExecuteInForeground` método tem um único parâmetro que representa o número aproximado de milissegundos que o loop é executado.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Não é necessário manter uma referência a um <xref:System.Threading.Thread> depois de iniciar o thread do objeto. O thread continua a executar até concluir o procedimento de thread.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Recuperando objetos de Thread  
 Você pode usar o static (`Shared` no Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> propriedade para recuperar uma referência para o thread em execução no momento do código que o thread está em execução. O exemplo a seguir usa o <xref:System.Threading.Thread.CurrentThread%2A> propriedade para exibir informações sobre o thread principal do aplicativo, outro thread de primeiro plano, um thread em segundo plano e um pool de threads.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Threads de primeiro plano e plano de fundo  
 Instâncias de <xref:System.Threading.Thread> classe representam os segmentos de primeiro plano ou threads em segundo plano. Threads em segundo plano são idênticos aos threads de primeiro plano com uma exceção: um thread em segundo plano não manter um processo em execução se todos os threads de primeiro plano tem sido encerrado. Depois que todos os threads de primeiro plano foram interrompidos, o tempo de execução interrompe todos os threads em segundo plano e desligado.  
  
 Por padrão, os seguintes threads executam em primeiro plano:  
  
-   O thread principal do aplicativo.  
  
-   Todos os threads criados chamando um <xref:System.Threading.Thread> construtor de classe.  
  
 Executem os seguintes threads em segundo plano por padrão:  
  
-   Thread do pool de threads, que são um pool de threads de trabalho mantida pelo tempo de execução.  Você pode configurar o trabalho de threads de pool e agenda em threads de pool usando o <xref:System.Threading.ThreadPool> classe.  
  
    > [!NOTE]
    >  Baseado em tarefas de operações assíncronas são executados automaticamente em threads de pool. Usam operações assíncronas baseado em tarefas de <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> classes para implementar o [padrão assíncrono baseado em tarefa](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Todos os threads que insira o ambiente de execução gerenciado de código não gerenciado.  
  
 Você pode alterar um segmento a ser executado em segundo plano, definindo a <xref:System.Threading.Thread.IsBackground%2A> propriedade a qualquer momento.  Threads em segundo plano são úteis para qualquer operação que deve continuar enquanto um aplicativo está em execução, mas não deve impedir que o aplicativo finalizando, como monitoramento de alterações do sistema de arquivos ou conexões de soquete de entrada.  
  
 O exemplo a seguir ilustra a diferença entre os threads de primeiro plano e plano de fundo. É como o primeiro exemplo de [iniciar um thread](#Starting) seção, exceto que ele define o thread seja executado em segundo plano antes de iniciá-lo. Como mostra a saída, o loop é interrompido antes de ele ser executado por cinco segundos.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Cultura e threads  
 Cada thread tem uma cultura, representada pelo <xref:System.Threading.Thread.CurrentCulture%2A> propriedade e uma cultura de interface do usuário, representado pelo <xref:System.Threading.Thread.CurrentUICulture%2A> propriedade.  A cultura atual oferece suporte a operações sensíveis à cultura como analisar e formatação, cadeia de caracteres de comparação e ordenação e também controla o sistema de escrita e o calendário usado por um thread. Fornece a cultura de interface do usuário atual para a recuperação sensíveis à cultura de recursos em arquivos de recurso.  
  
 Quando um novo segmento é instanciado, sua cultura e cultura da interface do usuário são definidos pela cultura do sistema atual e cultura da interface do usuário e não pela cultura e cultura da interface do usuário do thread do qual o novo thread é criado. Isso significa que, por exemplo, que se a cultura atual do sistema for inglês (Estados Unidos) e a cultura atual do thread principal do aplicativo é francês (França), a cultura de um novo thread criado chamando o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> construtor do thread principal é o inglês (Estados Unidos) e francês (França). Para obter mais informações, consulte a seção "Cultura e threads" do <xref:System.Globalization.CultureInfo> tópico sobre a classe.  
  
> [!IMPORTANT]
>  Isso não é possível de threads que executam operações assíncronas para aplicativos que têm como destino o [!INCLUDE[net_v46](~/includes/net-v46-md.md)] e versões posteriores, no caso, a cultura e cultura da interface do usuário é parte de uma assíncrona contexto das operações; o thread em que uma operação assíncrona executa por padrão herda a cultura e cultura da interface do usuário do thread do qual a operação assíncrona foi iniciada. Para saber mais, confira a seção "Cultura e operações assíncronas baseadas em tarefas" do tópico da classe <xref:System.Globalization.CultureInfo>.  
  
 Você pode fazer o seguinte para garantir que todos os threads de execução em um aplicativo compartilham a mesma cultura e cultura da interface do usuário:  
  
-   Você pode passar um <xref:System.Globalization.CultureInfo> objeto que representa essa cultura para o <xref:System.Threading.ParameterizedThreadStart> delegar ou <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> método.  
  
-   Para aplicativos em execução no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versões posteriores, você pode definir a cultura e cultura da interface do usuário que deve ser atribuído a todos os threads criados em um domínio de aplicativo, definindo o valor da <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propriedades. Observe que essa é uma configuração de domínio de aplicativo.  
  
 Para obter mais informações e exemplos, consulte a seção "Cultura e threads" do <xref:System.Globalization.CultureInfo> tópico sobre a classe.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Obtendo informações sobre e controlando threads  
 Você pode recuperar um número de valores de propriedade que fornecem informações sobre um segmento. Em alguns casos, você também pode definir esses valores de propriedade para controlar a operação do thread. Essas propriedades de thread incluem:  
  
-   Um nome. <xref:System.Threading.Thread.Name%2A> é uma gravação-uma vez a propriedade que você pode usar para identificar um thread.  O valor padrão é `null`.  
  
-   Um código de hash, que você pode recuperar chamando o <xref:System.Threading.Thread.GetHashCode%2A> método. O código hash pode ser usado para identificar exclusivamente um thread; para o tempo de vida do seu thread, seu código de hash não coincidirá com o valor de qualquer outro thread, independentemente do domínio de aplicativo do qual você pode obter o valor.  
  
-   Uma ID de thread. O valor de somente leitura <xref:System.Threading.Thread.ManagedThreadId%2A> propriedade é atribuída pelo tempo de execução e identifica exclusivamente um thread dentro de seu processo.  
  
    > [!NOTE]
    >  Um [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) do sistema operacional não tem relação fixa com um thread gerenciado porque hosts não gerenciados podem controlar a relação entre threads gerenciados e não gerenciados. Especificamente, um host sofisticado pode usar o [API de hospedagem de CLR](https://msdn.microsoft.com/library/ms404385.aspx) para agendar muitos threads gerenciados no mesmo thread do sistema operacional, ou para mover um thread gerenciado entre threads diferentes do sistema operacional.  
  
-   Estado atual do thread. Durante sua existência, um thread é sempre em uma ou mais os estados definidos pelo <xref:System.Threading.ThreadState> propriedade.  
  
-   Um nível de prioridade do agendamento, que é definido como o <xref:System.Threading.ThreadPriority> propriedade. Embora você possa definir esse valor para solicitar a prioridade do thread, não é garantido que ele ser respeitado pelo sistema operacional.  
  
-   Somente leitura <xref:System.Threading.Thread.IsThreadPoolThread%2A> propriedade, que indica se um thread é um pool de threads.  
  
-   A propriedade de <xref:System.Threading.Thread.IsBackground%2A> . Para obter mais informações, consulte o [threads de primeiro plano e plano de fundo](#Foreground) seção.  
  
## Examples  
 O exemplo a seguir demonstra a funcionalidade de encadeamento simple.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Esse código produz saída semelhante à seguinte:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Um delegado que representa os métodos a serem invocados quando esse thread começar a ser executado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />, especificando um delegado que permite que um objeto seja passado para o thread quando o thread for iniciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread não começar a execução quando ele é criado. Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A> método. Para passar um objeto de dados para o thread, use o <xref:System.Threading.Thread.Start%28System.Object%29> sobrecarga do método.  
  
> [!NOTE]
>  Usuários do Visual Basic podem omitir o <xref:System.Threading.ThreadStart> construtor ao criar um thread. Use o `AddressOf` operador ao passar o método, por exemplo `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic chama automaticamente o <xref:System.Threading.ThreadStart> construtor.  
  
   
  
## Examples  
 O exemplo a seguir mostra a sintaxe para criar e usar um <xref:System.Threading.ParameterizedThreadStart> representante com um método estático e um método de instância.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Um delegado <see cref="T:System.Threading.ThreadStart" /> que representa os métodos a serem invocados quando esse thread começar a ser executado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread não começar a execução quando ele é criado. Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A> método.  
  
> [!NOTE]
>  Usuários do Visual Basic podem omitir o <xref:System.Threading.ThreadStart> construtor ao criar um thread. Use o `AddressOf` operador ao passar o método como `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic chama automaticamente o <xref:System.Threading.ThreadStart> construtor.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar um thread que executa um método estático.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 O exemplo de código a seguir mostra como criar um thread que executa um método de instância.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="start" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Um delegado <see cref="T:System.Threading.ParameterizedThreadStart" /> que representa os métodos a serem invocados quando esse thread começar a ser executado.</param>
        <param name="maxStackSize">O tamanho máximo da pilha, em bytes, a ser usado pelo thread ou 0 para usar o tamanho de pilha máximo padrão especificado no cabeçalho do executável.  Importante   Para um código parcialmente confiável, <c>maxStackSize</c> será ignorado se ele for maior que o tamanho da pilha padrão. Nenhuma exceção é lançada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />, especificando um delegado que permite que um objeto seja passado para o thread quando o thread é iniciado e especificando o tamanho máximo da pilha para o thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evite usar essa sobrecarga de construtor. O tamanho da pilha padrão usado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> sobrecarga de construtor é o tamanho da pilha recomendados para threads. Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.  
  
> [!IMPORTANT]
>  Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]somente totalmente confiáveis código pode definir `maxStackSize` para um valor maior que o tamanho da pilha padrão (1 megabyte). Se for especificado um valor maior para `maxStackSize` quando o código está sendo executado com confiança parcial, `maxStackSize` será ignorado e o tamanho da pilha padrão é usado. Nenhuma exceção é lançada. Código em qualquer nível de confiança pode definir `maxStackSize` para um valor menor que o tamanho da pilha padrão.  
  
> [!NOTE]
>  Se você estiver desenvolvendo uma biblioteca totalmente confiável que será usada por código parcialmente confiável, e você precisa iniciar um thread que requer uma pilha de grande, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado. Não faça isso, a menos que você controlar totalmente o código que é executado no thread.  
  
 Se `maxStackSize` é menor que o tamanho mínimo de pilha, o tamanho da pilha mínimo é usado. Se `maxStackSize` não é um múltiplo do tamanho da página, ele será arredondado para o múltiplo mais próximo do tamanho da página. Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha de mínimo e o tamanho da página é 64KB (65.536 bytes).  
  
> [!NOTE]
>  Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, `maxStackSize` é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.  
  
 Se você especificar um tamanho de pilha muito pequeno, talvez seja necessário desabilitar a sondagem de estouro de pilha. Quando a pilha severos é restrito, a sondagem pode próprio causar um estouro de pilha. Para desabilitar a sondagem de estouro de pilha, adicione o seguinte arquivo de configuração de aplicativo.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Um delegado <see cref="T:System.Threading.ThreadStart" /> que representa os métodos a serem invocados quando esse thread começar a ser executado.</param>
        <param name="maxStackSize">O tamanho máximo da pilha, em bytes, a ser usado pelo thread ou 0 para usar o tamanho de pilha máximo padrão especificado no cabeçalho do executável.  Importante   Para um código parcialmente confiável, <c>maxStackSize</c> será ignorado se ele for maior que o tamanho da pilha padrão. Nenhuma exceção é lançada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />, especificando o tamanho máximo da pilha do thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evite usar essa sobrecarga de construtor. O tamanho da pilha padrão usado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> sobrecarga de construtor é o tamanho da pilha recomendados para threads. Se um thread tem problemas de memória, a causa mais provável é programação erro, como recursão infinita.  
  
> [!IMPORTANT]
>  Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]somente totalmente confiáveis código pode definir `maxStackSize` para um valor maior que o tamanho da pilha padrão (1 megabyte). Se for especificado um valor maior para `maxStackSize` quando o código está sendo executado com confiança parcial, `maxStackSize` será ignorado e o tamanho da pilha padrão é usado. Nenhuma exceção é lançada. Código em qualquer nível de confiança pode definir `maxStackSize` para um valor menor que o tamanho da pilha padrão.  
  
> [!NOTE]
>  Se você estiver desenvolvendo uma biblioteca totalmente confiável que será usada por código parcialmente confiável, e você precisa iniciar um thread que requer uma pilha de grande, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado. Não faça isso, a menos que você controlar totalmente o código que é executado no thread.  
  
 Se `maxStackSize` é menor que o tamanho mínimo de pilha, o tamanho da pilha mínimo é usado. Se `maxStackSize` não é um múltiplo do tamanho da página, ele será arredondado para o múltiplo mais próximo do tamanho da página. Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho da pilha de mínimo e o tamanho da página é 64KB (65.536 bytes).  
  
> [!NOTE]
>  Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, `maxStackSize` é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.  
  
 Se você especificar um tamanho de pilha muito pequeno, talvez seja necessário desabilitar a sondagem de estouro de pilha. Quando a pilha severos é restrito, a sondagem pode próprio causar um estouro de pilha. Para desabilitar a sondagem de estouro de pilha, adicione o seguinte arquivo de configuração de aplicativo.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gera um <see cref="T:System.Threading.ThreadAbortException" /> no thread no qual ele é invocado, para iniciar o processo de encerramento do thread. Geralmente, a chamada a esse método termina o thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gera um <see cref="T:System.Threading.ThreadAbortException" /> no thread no qual ele é invocado, para iniciar o processo de encerramento do thread. Geralmente, a chamada a esse método termina o thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando esse método é chamado em um thread, o sistema gera um <xref:System.Threading.ThreadAbortException> no thread para anular a ele. `ThreadAbortException` é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do `catch` impedir a menos que <xref:System.Threading.Thread.ResetAbort%2A> é chamado. `ResetAbort` Cancelar a solicitação para anular e impede que o `ThreadAbortException` de finalizar o thread. Não executadas `finally` blocos são executados antes do thread foi anulado.  
  
> [!NOTE]
>  Quando um thread chama `Abort` em si mesmo, o efeito é semelhante ao lançar uma exceção; o <xref:System.Threading.ThreadAbortException> acontece imediatamente, e o resultado é previsível. No entanto, se um thread chama `Abort` em outro thread, a anulação interrupções de qualquer código está sendo executado. Também há uma possibilidade de que um construtor estático pode ser anulado. Em casos raros, isso pode impedir instâncias dessa classe que está sendo criado no domínio de aplicativo. Nas versões do .NET Framework 1.0 e 1.1, há uma possibilidade pode anular o thread enquanto um `finally` bloco está em execução, caso em que o `finally` bloco será anulado.  
  
 O thread não é garantido para anular imediatamente ou em todos os. Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no `finally` blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação. Para aguardar até que um thread foi anulada, você pode chamar o <xref:System.Threading.Thread.Join%2A> método no thread depois de chamar o <xref:System.Threading.Thread.Abort%2A> método, mas não há nenhuma garantia que a espera terminará.  
  
> [!NOTE]
>  O thread que chama <xref:System.Threading.Thread.Abort%2A> podem bloquear se o thread que está sendo anulado estiver em uma área protegida do código, como um `catch` bloco, `finally` bloco ou região de execução restrita. Se o thread que chama <xref:System.Threading.Thread.Abort%2A> mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.  
  
 Se `Abort` é chamado em um thread que não tenha sido iniciado, o thread será anulada quando <xref:System.Threading.Thread.Start%2A> é chamado. Se `Abort` é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, anulado.  
  
 Se `Abort` é chamado em um thread que foi suspenso, um <xref:System.Threading.ThreadStateException> é gerada no thread de chamada <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> é adicionada para o <xref:System.Threading.Thread.ThreadState%2A> propriedade do thread que está sendo anulada. Um <xref:System.Threading.ThreadAbortException> não é gerada no thread suspenso até <xref:System.Threading.Thread.Resume%2A> é chamado.  
  
 Se `Abort` é chamado em um thread gerenciado durante a execução de código não gerenciado, um `ThreadAbortException` não é lançada até que o thread retorna para código gerenciado.  
  
 Se duas chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e outra chamada para executar o `Abort`. No entanto, um aplicativo não pode detectar essa situação.  
  
 Depois de `Abort` é invocado em um thread, o estado do thread inclui <xref:System.Threading.ThreadState.AbortRequested>. Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState.Stopped>. Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a anulação usando o `ResetAbort` método. Para obter um exemplo que demonstra a chamada a `ResetAbort` método, consulte o `ThreadAbortException` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: esse membro não é compatível.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread que está sendo anulado está suspenso no momento.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">operações avançadas em threads. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Um objeto que contém informações específicas do aplicativo, como estado, que podem ser usadas pelo thread que está sendo anulado.</param>
        <summary>Gera um <see cref="T:System.Threading.ThreadAbortException" /> no thread no qual ele é invocado, para iniciar o processo de término do thread e ao mesmo tempo fornecer informações de exceção sobre o término do thread. Geralmente, a chamada a esse método termina o thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando esse método é chamado em um thread, o sistema gera um <xref:System.Threading.ThreadAbortException> no thread para anular a ele. `ThreadAbortException` é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do `catch` impedir a menos que <xref:System.Threading.Thread.ResetAbort%2A> é chamado. `ResetAbort` Cancelar a solicitação para anular e impede que o `ThreadAbortException` de finalizar o thread. Não executadas `finally` blocos são executados antes do thread foi anulado.  
  
> [!NOTE]
>  Quando um thread chama `Abort` em si mesmo, o efeito é semelhante ao lançar uma exceção; o <xref:System.Threading.ThreadAbortException> acontece imediatamente, e o resultado é previsível. No entanto, se um thread chama `Abort` em outro thread, a anulação interrupções de qualquer código está sendo executado. Há uma possibilidade de que um construtor estático pode ser anulado. Em casos raros, isso pode impedir instâncias dessa classe que está sendo criado no domínio de aplicativo. Nas versões do .NET Framework 1.0 e 1.1, há uma possibilidade pode anular o thread enquanto um `finally` bloco está em execução, caso em que o `finally` bloco será anulado.  
  
 O thread não é garantido para anular imediatamente ou em todos os. Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no `finally` blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação. Para aguardar até que um thread foi anulada, você pode chamar o <xref:System.Threading.Thread.Join%2A> método no thread depois de chamar o <xref:System.Threading.Thread.Abort%2A> método, mas não há nenhuma garantia de que a espera terminará.  
  
> [!NOTE]
>  O thread que chama <xref:System.Threading.Thread.Abort%2A> podem bloquear se o thread que está sendo anulado estiver em uma área protegida do código, como um `catch` bloco, `finally` bloco ou região de execução restrita. Se o thread que chama <xref:System.Threading.Thread.Abort%2A> mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.  
  
 Se `Abort` é chamado em um thread que não tenha sido iniciado, o thread será anulada quando <xref:System.Threading.Thread.Start%2A> é chamado. Se `Abort` é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, anulado.  
  
 Se `Abort` é chamado em um thread que foi suspenso, um <xref:System.Threading.ThreadStateException> é gerada no thread de chamada <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> é adicionada para o <xref:System.Threading.Thread.ThreadState%2A> propriedade do thread que está sendo anulada. Um <xref:System.Threading.ThreadAbortException> não é gerada no thread suspenso até <xref:System.Threading.Thread.Resume%2A> é chamado.  
  
 Se `Abort` é chamado em um thread gerenciado durante a execução de código não gerenciado, um `ThreadAbortException` não é lançada até que o thread retorna para código gerenciado.  
  
 Se duas chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e outra chamada para executar o `Abort`. No entanto, um aplicativo não pode detectar essa situação.  
  
 Depois de `Abort` é invocado em um thread, o estado do thread inclui <xref:System.Threading.ThreadState.AbortRequested>. Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState.Stopped>. Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a anulação usando o `ResetAbort` método. Para obter um exemplo que demonstra a chamada a `ResetAbort` método, consulte o `ThreadAbortException` classe.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como passar informações para um thread que está sendo anulado.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: esse membro não é compatível.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread que está sendo anulado está suspenso no momento.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">operações avançadas em threads. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aloca um slot de dados sem nome em todos os threads. Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>O slot de dados nomeado alocado em todos os threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados. Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 O slot é alocado em todos os threads.  
  
 Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como usar um campo que está marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread. O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.  
  
 **Primeiro exemplo**  
  
 O exemplo a seguir mostra como usar um campo que está marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread. Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo exemplo**  
  
 O exemplo de código a seguir demonstra como usar um slot de dados para armazenar informações específicas de thread.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do slot de dados a ser alocado.</param>
        <summary>Aloca um slot de dados nomeado em todos os threads. Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>O slot de dados nomeado alocado em todos os threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados. Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.  
  
 Não é necessário usar o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método para alocar um slot de dados nomeada, porque o <xref:System.Threading.Thread.GetNamedDataSlot%2A> método aloca o slot se ele já não foi alocado.  
  
> [!NOTE]
>  Se o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método é usado, ele deve ser chamado no thread principal na inicialização do programa, porque ele lança uma exceção se um slot com o nome especificado já foi alocado. Não há nenhuma maneira de testar se um slot já foi alocado.  
  
 Slots alocados com esse método devem ser liberados com <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como usar um campo que está marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread. O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.  
  
 **Primeiro exemplo**  
  
 O exemplo a seguir mostra como usar um campo que está marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread. Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo exemplo**  
  
 O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.  
  
> [!NOTE]
>  O código de exemplo não usa o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método, porque o <xref:System.Threading.Thread.GetNamedDataSlot%2A> método aloca o slot se ele já não foi alocado. Se o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método é usado, ele deve ser chamado no thread principal na inicialização do programa.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Já existe um slot de dados nomeado com o nome especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o estado de apartment desse thread.</summary>
        <value>Um dos valores de <see cref="T:System.Threading.ApartmentState" />. O valor inicial é <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **O <xref:System.Threading.Thread.ApartmentState%2A> propriedade está obsoleta.**  As alternativas não obsoleto são o <xref:System.Threading.Thread.GetApartmentState%2A> método para recuperar o estado de apartment e <xref:System.Threading.Thread.SetApartmentState%2A> método para definir o estado de apartment.  
  
 Nas versões do .NET Framework 1.0 e 1.1, o `ApartmentState` propriedade marca um thread para indicar que ela será executada em um apartment do thread único ou vários. Essa propriedade pode ser definida quando o thread está no `Unstarted` ou `Running` thread estado; no entanto, ela pode ser definida apenas uma vez por um thread. Se a propriedade não foi definida, retornará `Unknown`.  
  
 Uma tentativa de usar o <xref:System.Threading.Thread.ApartmentState%2A> propriedade para definir o estado de apartment de thread cujo estado apartment já foi definido será ignorada. No entanto, o <xref:System.Threading.Thread.SetApartmentState%2A> método lança um <xref:System.InvalidOperationException> nesse caso.  
  
> [!IMPORTANT]
>  No .NET Framework versão 2.0, os novos segmentos são inicializados como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se seu estado de apartment não foi definido antes que eles são iniciados. O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> por padrão. Não é possível definir o thread principal do aplicativo para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> definindo o <xref:System.Threading.ApartmentState?displayProperty=nameWithType> propriedade na primeira linha de código. Use o <xref:System.STAThreadAttribute> em vez disso.  
  
 No .NET Framework versão 2.0, você pode especificar o threading de modelo para um aplicativo C++ usando COM o [/CLRTHREADATTRIBUTE (Definir Thread atributo CLR)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) opção de vinculador.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir o estado de apartment de thread.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">É feita uma tentativa de definir esta propriedade para um estado que não é um estado de apartment válido (um estado diferente de <see langword="STA" /> (single-threaded apartment) ou <see langword="MTA" /> (multithreaded apartment)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica um host que a execução está prestes a entrar em uma região de código em que os efeitos de uma exceção sem tratamento ou anulação de thread podem comprometer outras tarefas no domínio do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em não-críticas e regiões de código. Uma região crítica é um em que os efeitos de uma anulação de thread ou uma exceção sem tratamento não podem ser limitados à tarefa atual. Por outro lado, uma falha em uma região não críticos do código ou anular afeta apenas a tarefa na qual o erro ocorrer.  
  
 Por exemplo, considere uma tarefa que tenta alocar memória mantendo um bloqueio. Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, pois pode haver outras tarefas no domínio aguardando o bloqueio mesmo. Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.  
  
 Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o <xref:System.AppDomain> em vez de correr o risco de continuando a execução em um estado instável. Para informar o host que seu código está inserindo uma região crítica, chame <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Chamar <xref:System.Threading.Thread.EndCriticalRegion%2A> quando a execução retorna para uma região não críticos do código.  
  
 Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir um bloco de código em não-críticas e regiões.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica um host de que o código gerenciado está prestes a executar instruções que dependem da identidade do thread atual do sistema operacional físico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns dos hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads. Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento. A maioria das tarefas não são afetados por essa alternância. No entanto, algumas tarefas têm afinidade de thread - ou seja, eles dependem da identidade de um thread de sistema operacional físico. Essas tarefas devem informar o host quando eles executar código que não deve ser ativado.  
  
 Por exemplo, se seu aplicativo chama uma API de sistema para adquirir um sistema operacional de bloqueio com afinidade de thread, como CRITICAL_SECTION Win32, você deve chamar <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir o bloqueio e <xref:System.Threading.Thread.EndThreadAffinity%2A> depois de liberar o bloqueio.  
  
 Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar um host que um bloco de código depende da identidade de um thread de sistema operacional físico.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o contexto atual no qual o thread está em execução.</summary>
        <value>Um <see cref="T:System.Runtime.Remoting.Contexts.Context" /> que representa o contexto do thread atual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cultura do thread atual.</summary>
        <value>Um objeto que representa a cultura do thread atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Globalization.CultureInfo> objeto retornado por essa propriedade, junto com seus objetos associados, determinar o formato padrão para datas, horas, números, valores de moeda, a ordenação de texto, convenções de maiusculas e minúsculas e comparações de cadeia de caracteres. Consulte o <xref:System.Globalization.CultureInfo> de classe para saber mais sobre nomes de cultura e identificadores, as diferenças entre culturas invariáveis, neutras e específicas, e as informações de cultura de maneira afetam threads e domínios de aplicativo. Consulte o <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedade para saber como a cultura padrão de um thread é determinada, e como os usuários definir informações de cultura para seus computadores.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], você pode definir o <xref:System.Threading.Thread.CurrentCulture%2A> propriedade para uma cultura neutra. Isso ocorre porque o comportamento do <xref:System.Globalization.CultureInfo> classe mudou: quando ele representa uma cultura neutra, seus valores de propriedade (em particular, o <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, e <xref:System.Globalization.CultureInfo.TextInfo%2A> propriedades) agora reflete a cultura específica que está associada com a cultura neutra. Em versões anteriores do .NET Framework, o <xref:System.Threading.Thread.CurrentCulture%2A> propriedade gerou um <xref:System.NotSupportedException> exceção quando uma cultura neutra foi atribuída.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra a instrução de threading que permite que a interface de usuário de um Windows Forms para exibir a cultura que é definido no painel de controle. Código adicional é necessária.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A propriedade é definida como <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para definir a propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a entidade de segurança atual do thread (para segurança baseada em função).</summary>
        <value>Um <see cref="T:System.Security.Principal.IPrincipal" /> valor que representa o contexto de segurança.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como definir e recuperar a entidade de segurança de thread.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária para definir a entidade de segurança.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para manipular o objeto principal. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o thread em execução no momento.</summary>
        <value>Um <see cref="T:System.Threading.Thread" /> que é a representação do thread em execução no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria uma tarefa que por sua vez cria 20 tarefas de filho. O aplicativo em si, bem como cada tarefa, chama o `ShowThreadInformation` método, que usa o <xref:System.Threading.Thread.CurrentThread%2A> propriedade para exibir informações sobre o thread no qual ele está sendo executado.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Cada tarefa filho 1 milhão de números aleatórios entre 1 e 1 milhão de gera e retorna sua média. As chamadas da tarefa pai de <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método para garantir que as tarefas filho sejam concluídas antes de exibir a média retornada por cada tarefa e calcular a média do meio.  
  
 Observe que, enquanto o aplicativo é executado em um thread de primeiro plano, cada tarefa é executada em um pool de threads.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cultura atual usada pelo Gerenciador de Recursos para procurar recursos específicos da cultura em tempo de execução.</summary>
        <value>Um objeto que representa a cultura atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cultura de interface do usuário Especifica os recursos de um aplicativo precisa oferecer suporte à entrada do usuário e a saída e por padrão é o mesmo que a cultura do sistema operacional. Consulte o <xref:System.Globalization.CultureInfo> de classe para saber mais sobre nomes de cultura e identificadores, as diferenças entre culturas invariáveis, neutras e específicas, e as informações de cultura de maneira afetam threads e domínios de aplicativo. Consulte o <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriedade para saber como a cultura de interface do usuário padrão do segmento é determinada.  
  
 O <xref:System.Globalization.CultureInfo> retornado por essa propriedade pode ser uma cultura neutra. Culturas neutras não devem ser usadas com métodos de formatação, como <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, e <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Use o <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método para uma cultura específica, ou use o <xref:System.Threading.Thread.CurrentCulture%2A> propriedade.  
  
> [!NOTE]
>  O <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método lança <xref:System.ArgumentException> para culturas neutras "zh-Hant" ("zh-CHT") e "zh-Hans" ("zh-CHS").  
  
   
  
## Examples  
 O exemplo a seguir determina se o idioma da cultura da interface do thread atual é francês. Se não estiver, ele define a cultura de interface do usuário do thread atual para inglês (Estados Unidos).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 O exemplo de código a seguir mostra a instrução de threading que permite que a interface de usuário de um Windows Forms para exibir a cultura que é definido no painel de controle. Código adicional é necessária.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A propriedade é definida como <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade é definida como um nome de cultura não pode ser usado para localizar um arquivo de recurso. Nomes de arquivos de recursos devem incluir somente letras, números, hifens ou sublinhados.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desativa a limpeza automática de RCWs (Runtime Callable Wrappers) para o thread atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o common language runtime (CLR) limpa callable wrappers do tempo de execução automaticamente. As mensagens de bombas CLR durante a limpeza, o que pode causar problemas de reentrada para alguns aplicativos que atendem aos seguintes critérios comuns:  
  
-   O aplicativo faz sua própria bombeamento de mensagens.  
  
-   O aplicativo precisa controlar com precisão ao bombeamento de mensagens ocorre.  
  
 Esses aplicativos podem usar o <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> método para impedir que o CLR fazendo recuperação automática do runtime callable wrappers.  
  
 Quando esse método for chamado em um thread, a limpeza automática não pode ser habilitada novamente para esse thread. Quando seu aplicativo está pronto para limpar callable wrappers do tempo de execução, use o <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> método para instruir o tempo de execução para limpar todos os runtime callable wrappers no contexto atual. Bombeamento de mensagens ocorre durante a execução do método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica um host de que a execução está prestes a entrar em uma região de código na qual os efeitos de uma exceção sem tratamento ou anulação de thread estão limitados à tarefa atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em não-críticas e regiões de código. Uma região crítica é um em que os efeitos de uma anulação de thread ou uma exceção sem tratamento não podem ser limitados à tarefa atual. Por outro lado, uma falha em uma região não críticos do código ou anular afeta apenas a tarefa na qual o erro ocorrer.  
  
 Por exemplo, considere uma tarefa que tenta alocar memória mantendo um bloqueio. Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, pois pode haver outras tarefas no domínio aguardando o bloqueio mesmo. Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.  
  
 Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o <xref:System.AppDomain> em vez de correr o risco de continuando a execução em um estado instável. Para informar o host que seu código está inserindo uma região crítica, chame <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Chamar <xref:System.Threading.Thread.EndCriticalRegion%2A> quando a execução retorna para uma região não críticos do código.  
  
 Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir um bloco de código em não-críticas e regiões.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica um host que o código gerenciado terminou de executar as instruções que dependem da identidade do thread do sistema operacional físico atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns dos hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads. Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento. A maioria das tarefas não são afetados por essa alternância. No entanto, algumas tarefas têm afinidade de thread - ou seja, eles dependem da identidade de um thread de sistema operacional físico. Essas tarefas devem informar o host quando eles executar código que não deve ser ativado.  
  
 Por exemplo, se seu aplicativo chama uma API de sistema para adquirir um sistema operacional de bloqueio com afinidade de thread, como CRITICAL_SECTION Win32, você deve chamar <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir o bloqueio e <xref:System.Threading.Thread.EndThreadAffinity%2A> depois de liberar o bloqueio.  
  
 Usando esse método no código que é executado no SQL Server 2005 requer que o código a ser executado no mais alto nível de proteção de host.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar um host que um bloco de código depende da identidade de um thread de sistema operacional físico.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Threading.ExecutionContext" /> que contém informações sobre os diversos contextos do thread atual.</summary>
        <value>Um objeto <see cref="T:System.Threading.ExecutionContext" /> que consolida as informações de contexto para o thread atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.ExecutionContext> classe fornece um único contêiner para todas as informações relevantes para um segmento lógico de execução. Isso inclui o contexto de segurança, o contexto de chamada, contexto de sincronização, o contexto de localização e o contexto de transação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O coletor de lixo chama <xref:System.Threading.Thread.Finalize%2A> quando o objeto atual está pronto para ser finalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do slot de dados a ser liberado.</param>
        <summary>Elimina a associação entre um nome e um slot em todos os threads do processo. Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados. Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Depois de qualquer thread chamadas `FreeNamedDataSlot`, outro thread que chama <xref:System.Threading.Thread.GetNamedDataSlot%2A> com o mesmo nome alocará um novo slot associado ao nome. As chamadas subsequentes para `GetNamedDataSlot` por qualquer thread retornará o novo slot. No entanto, qualquer thread que ainda tem um <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> retornado por uma chamada anterior para `GetNamedDataSlot` pode continuar a usar o slot antigo.  
  
 Um slot que tenha sido associado um nome é liberado apenas quando cada `LocalDataStoreSlot` que foi obtido antes da chamada para `FreeNamedDataSlot` foi liberado e coleta de lixo.  
  
 Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como usar um campo que está marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread. O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.  
  
 **Primeiro exemplo**  
  
 O exemplo a seguir mostra como usar um campo que está marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread. Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo exemplo**  
  
 O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor <see cref="T:System.Threading.ApartmentState" /> que indica o estado do apartment.</summary>
        <returns>Um dos valores <see cref="T:System.Threading.ApartmentState" /> que indica o estado do apartment do thread gerenciado. O padrão é <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método, juntamente com o <xref:System.Threading.Thread.SetApartmentState%2A> método e o <xref:System.Threading.Thread.TrySetApartmentState%2A> substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A>. O exemplo de código cria um thread. Antes do thread é iniciado, <xref:System.Threading.Thread.GetApartmentState%2A> exibe inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado e <xref:System.Threading.Thread.SetApartmentState%2A> altera o estado para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. O <xref:System.Threading.Thread.TrySetApartmentState%2A> método retorna `false` durante a tentativa de alterar o estado para <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque o estado de apartment já está definido. Se a mesma operação tivesse sido tentada com <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> será lançada.  
  
 Depois que o thread é iniciado, o <xref:System.Threading.Thread.TrySetApartmentState%2A> método é usado novamente. Dessa vez lança <xref:System.Threading.ThreadStateException> porque o thread já foi iniciado.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Threading.CompressedStack" /> que pode ser usado para capturar a pilha do thread atual.</summary>
        <returns>nenhuma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há suporte para esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Em todos os casos.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">O <see cref="T:System.LocalDataStoreSlot" /> do qual o valor deve ser obtido.</param>
        <summary>Recupera o valor do slot especificado no thread atual, no domínio atual do thread atual. Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>O valor recuperado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados. Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> é um `Shared` método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread. Para evitar confusão, use o nome de classe ao chamar `Shared` métodos: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como usar um campo que está marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread. O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.  
  
 **Primeiro exemplo**  
  
 O exemplo a seguir mostra como usar um campo que está marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread. Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo exemplo**  
  
 O exemplo a seguir demonstra como usar um slot de dados para armazenar informações específicas de thread.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o domínio atual no qual o thread atual está em execução.</summary>
        <returns>Um <see cref="T:System.AppDomain" /> que representa o domínio de aplicativo atual do thread em execução.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como recuperar o nome e ID de `AppDomain` em que o thread está em execução.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um identificador de domínio do aplicativo exclusivo.</summary>
        <returns>Um inteiro com sinal de 32 bits que identifica exclusivamente o domínio do aplicativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra como recuperar o nome e ID de `AppDomain` em que o thread está em execução.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um código hash para o thread atual.</summary>
        <returns>Um valor inteiro de código hash.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O código de hash não é garantido como sendo exclusivo. Use o <xref:System.Threading.Thread.ManagedThreadId%2A> propriedade se precisar de um identificador exclusivo para um thread gerenciado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do slot de dados local.</param>
        <summary>Pesquisa um slot de dados nomeado. Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Um <see cref="T:System.LocalDataStoreSlot" /> alocado para este thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados. Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização depois que o thread de expira. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.  
  
 Se o slot nomeado não existir, um novo slot é alocado. Slots de dados nomeada são públicos e podem ser manipulados por qualquer pessoa.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como usar um campo que está marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread. O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.  
  
 **Primeiro exemplo**  
  
 O exemplo a seguir mostra como usar um campo que está marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread. Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo exemplo**  
  
 O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe um thread que está no estado de thread <see langword="WaitSleepJoin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse thread não está bloqueado no momento em um estado de junção, de modo de suspensão ou de espera, ele será interrompido quando ele lado começa a bloquear.  
  
 <xref:System.Threading.ThreadInterruptedException> será lançada no thread interrompido, mas não até que os blocos de thread. Se o thread nunca bloqueado, a exceção nunca é gerada e, portanto, o thread pode ser concluída sem nunca sejam interrompidos.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o comportamento de um thread em execução quando ela for interrompida e subsequentemente for bloqueada.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem o <see cref="T:System.Security.Permissions.SecurityPermission" /> apropriado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">operações avançadas em threads. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o status de execução do thread atual.</summary>
        <value>
          <see langword="true" /> se esse thread foi iniciado e não foi terminado normalmente ou foi anulado; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se um thread é ou não um thread de segundo plano.</summary>
        <value>
          <see langword="true" /> se esse thread for um thread de segundo plano ou for se tornar um; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread é um thread em segundo plano ou em um thread de primeiro plano. Threads em segundo plano são idênticos aos threads de primeiro plano, exceto que os threads em segundo plano não impedem que um processo de encerramento. Depois de tem terminado e todos os threads de primeiro plano que pertencem a um processo, o common language runtime finaliza o processo. Qualquer threads em segundo plano restantes são interrompidos e não são concluídos.  
  
 Por padrão, os seguintes threads executam em primeiro plano (ou seja, seus <xref:System.Threading.Thread.IsBackground%2A> propriedade retorna `false`):  
  
-   O thread principal (ou thread principal do aplicativo).  
  
-   Todos os threads criados chamando um <xref:System.Threading.Thread> construtor de classe.  
  
 Por padrão, os seguintes threads executam em segundo plano (isto é, seus <xref:System.Threading.Thread.IsBackground%2A> propriedade retorna `true`):  
  
-   Thread do pool de threads, que são um pool de threads de trabalho mantida pelo tempo de execução. Você pode configurar o trabalho de threads de pool e agenda em threads de pool usando o <xref:System.Threading.ThreadPool> classe.  
  
    > [!NOTE]
    >  Baseado em tarefas de operações assíncronas são executados automaticamente em threads de pool.  
  
-   Todos os threads que insira o ambiente de execução gerenciado de código não gerenciado.  
  
   
  
## Examples  
 O exemplo a seguir compara o comportamento de threads de primeiro plano e plano de fundo. Cria um thread de primeiro plano e um thread em segundo plano. O thread de primeiro plano mantém o processo em execução até conclui sua `for` loop e será encerrado. No entanto, como mostra a saída do exemplo, porque o thread de primeiro plano concluiu a execução, o processo foi finalizado antes do thread em segundo plano concluiu a execução.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">O thread está inativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um thread pertence ao pool de threads gerenciados ou não.</summary>
        <value>
          <see langword="true" /> se esse thread pertence ao pool de threads gerenciados; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [o Thread Pool gerenciado](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar se um thread do pool de threads.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloqueia o thread de chamada até que o thread representado por esta instância seja encerrado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloqueia o thread de chamada até que o thread representado por essa instância termine, enquanto continua a executar COM padrão e o bombeamento de <see langword="SendMessage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo <xref:System.Threading.Thread.Join%2A> é chamado de método foi concluída. Use esse método para garantir que um thread foi encerrado. O chamador bloqueará indefinidamente, se o thread não terminar. No exemplo a seguir, o `Thread1` chamadas de threads a <xref:System.Threading.Thread.Join> método `Thread2`, que faz com que `Thread1` para bloquear até `Thread2` foi concluída.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Se o thread já foi encerrado quando <xref:System.Threading.Thread.Join%2A> é chamado, o método retorna imediatamente.  
  
> [!WARNING]
>  Você nunca deve chamar o <xref:System.Threading.Thread.Join%2A> método o <xref:System.Threading.Thread> objeto que representa o thread atual do thread atual. Isso faz com que seu aplicativo travar porque o thread atual espera indefinidamente, em si mesmo  
  
 Esse método altera o estado do thread de chamada para incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Não é possível invocar `Join` em um thread que está no <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">O chamador tentou ingressar em um thread que está no estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">O thread é interrompido enquanto espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para espera pelo encerramento do thread.</param>
        <summary>Bloqueia o thread de chamada até que o thread representado por essa instância termine ou até que o tempo especificado tenha decorrido, enquanto continua executando o COM padrão e o bombeamento de SendMessage.</summary>
        <returns>
          <see langword="true" /> se o thread tiver sido encerrado; <see langword="false" /> se o thread não tiver sido encerrado depois que o tempo especificado pelo parâmetro <paramref name="millisecondsTimeout" /> tiver decorrido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo <xref:System.Threading.Thread.Join%2A> é chamado de método foi concluída ou o intervalo de tempo limite. No exemplo a seguir, o `Thread1` chamadas de threads a <xref:System.Threading.Thread.Join> método `Thread2`, que faz com que `Thread1` para bloquear até que `Thread2` foi concluída ou 2 segundos.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> é especificado para o `millisecondsTimeout` parâmetro, que esse método se comporta de forma idêntica ao <xref:System.Threading.Thread.Join> sobrecarga do método, exceto para o valor de retorno.  
  
 Se o thread já foi encerrado quando <xref:System.Threading.Thread.Join%2A> é chamado, o método retorna imediatamente.  
  
 Esse método altera o estado do thread de chamada para incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Não é possível invocar `Join` em um thread que está no <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> será negativo e não será igual a <see cref="F:System.Threading.Timeout.Infinite" /> em milissegundos.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread não foi iniciado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> definido como a quantidade de tempo de espera até a conclusão do thread.</param>
        <summary>Bloqueia o thread de chamada até que o thread representado por essa instância termine ou até que o tempo especificado tenha decorrido, enquanto continua executando o COM padrão e o bombeamento de SendMessage.</summary>
        <returns>
          <see langword="true" /> se o thread tiver sido encerrado; <see langword="false" /> se o thread não tiver sido encerrado depois que o período especificado pelo parâmetro <paramref name="timeout" /> tiver decorrido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo <xref:System.Threading.Thread.Join%2A> é chamado de método foi concluída ou o intervalo de tempo limite. No exemplo a seguir, o `Thread1` chamadas de threads a <xref:System.Threading.Thread.Join> método `Thread2`, que faz com que `Thread1` para bloquear até que `Thread2` foi concluída ou 2 segundos.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> é especificado para `timeout`, esse método se comporta de forma idêntica ao <xref:System.Threading.Thread.Join> sobrecarga do método, exceto para o valor de retorno.  
  
 Se o thread já foi encerrado quando <xref:System.Threading.Thread.Join%2A> é chamado, o método retorna imediatamente.  
  
 Esse método altera o estado do thread atual para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>. Não é possível invocar `Join` em um thread que está no <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar um `TimeSpan` valor com o `Join` método.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> será negativo e não será igual a <see cref="F:System.Threading.Timeout.Infinite" /> em milissegundos, ou será maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O chamador tentou ingressar em um thread que está no estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um identificador exclusivo para o thread gerenciado atual.</summary>
        <value>Um inteiro que representa um identificador exclusivo para esse thread gerenciado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread <xref:System.Threading.Thread.ManagedThreadId%2A> valor da propriedade serve para identificar exclusivamente o thread dentro de seu processo.  
  
 O valor de <xref:System.Threading.Thread.ManagedThreadId%2A> propriedade varia ao longo do tempo, mesmo se o código não gerenciado que hospeda o common language runtime implementa o thread como uma fibra.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sincroniza o acesso à memória da seguinte maneira: o processador que executa o thread atual não pode reorganizar as instruções de forma que os acessos à memória antes da chamada a <see cref="M:System.Threading.Thread.MemoryBarrier" /> sejam executados após os acessos de memória que seguem a chamada a <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> é necessária somente em sistemas de multiprocessador com memória fraca ordenação (por exemplo, um sistema utilizar vários processadores Intel Itanium).  
  
 Para a maioria das finalidades, c# `lock` instrução, o Visual Basic `SyncLock` instrução, ou o <xref:System.Threading.Monitor> classe fornecem maneiras mais fáceis para sincronizar os dados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do thread.</summary>
        <value>Uma cadeia de caracteres que contém o nome do thread, ou <see langword="null" />, se nenhum nome foi definido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é gravação-depois. Como o valor padrão de um thread <xref:System.Threading.Thread.Name%2A> é de propriedade `null`, você pode determinar se um nome tem já foram explicitamente atribuído para o thread, comparando-o com `null`.  
  
 A cadeia de caracteres atribuída para o <xref:System.Threading.Thread.Name%2A> propriedade pode incluir qualquer caractere Unicode.  
  
   
  
## Examples  
 O exemplo a seguir mostra como nomear um thread.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi solicitada uma operação de conjuntos, mas a propriedade <see langword="Name" /> já foi definida.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica a prioridade de agendamento de um thread.</summary>
        <value>Um dos valores de <see cref="T:System.Threading.ThreadPriority" />. O valor padrão é <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread pode ser atribuído a qualquer um dos seguinte prioridade <xref:System.Threading.ThreadPriority> valores:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Sistemas operacionais não são necessárias para cumprir a prioridade de thread.  
  
   
  
## Examples  
 O exemplo a seguir mostra o resultado da alteração da prioridade de thread. Três threads são criados, a prioridade de um thread é definida como <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, e a prioridade de segundo é definida como <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Cada thread incrementa uma variável em um `while` loop e é executado por um período definido.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">O thread atingiu um estado final, como <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para uma operação definida não é um valor <see cref="T:System.Threading.ThreadPriority" /> válido.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela um <see cref="M:System.Threading.Thread.Abort(System.Object)" /> solicitado para o thread atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método só pode ser chamado por código com as permissões adequadas.  
  
 Quando é feita uma chamada para `Abort` para encerrar um thread, o sistema gera um <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final do bloco catch, a menos que `ResetAbort` é chamado. `ResetAbort` Cancelar a solicitação para anular e impede que o `ThreadAbortException` de finalizar o thread.  
  
 Consulte <xref:System.Threading.ThreadAbortException> para obter um exemplo que demonstra a chamar o `ResetAbort` método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: esse membro não é compatível.</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> não foi invocado no thread atual.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão de segurança necessária para o thread atual.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">operações avançadas em threads. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retoma um thread que foi suspenso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Não use o <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar as atividades de threads. Você não tem como saber qual código de um thread está em execução quando você suspende a ele. Se você suspender um thread enquanto ele mantém o bloqueio durante a avaliação de permissão de segurança, outros threads de <xref:System.AppDomain> podem ser bloqueadas. Se você suspender um thread enquanto ele está em execução em um construtor de classe, outros threads de <xref:System.AppDomain> que tentar usar que classe estão bloqueadas. Os deadlocks podem ocorrer facilmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: esse membro não é compatível.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread não foi iniciado, está inativo ou não está no estado suspenso.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem o <see cref="T:System.Security.Permissions.SecurityPermission" /> apropriado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">operações avançadas em threads. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">O novo estado de apartment.</param>
        <summary>Define o estado do apartment de um thread antes que ele seja iniciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Novos threads são inicializados como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se seu estado de apartment não foi definido antes que eles são iniciados. Estado de apartment deve ser definido antes que um thread é iniciado.  
  
> [!NOTE]
>  O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> por padrão. A única maneira de definir o estado apartment do thread principal do aplicativo para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> é aplicar o <xref:System.STAThreadAttribute> atributo ao método de ponto de entrada.  
  
 O <xref:System.Threading.Thread.SetApartmentState%2A> método, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A> método e o <xref:System.Threading.Thread.TrySetApartmentState%2A> substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A>. O exemplo de código cria um thread. Antes do thread é iniciado, <xref:System.Threading.Thread.GetApartmentState%2A> exibe inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado e <xref:System.Threading.Thread.SetApartmentState%2A> altera o estado para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. O <xref:System.Threading.Thread.TrySetApartmentState%2A> método retorna `false` durante a tentativa de alterar o estado para <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque o estado de apartment já está definido. Se a mesma operação tivesse sido tentada com <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> será lançada.  
  
 Depois que o thread é iniciado, o <xref:System.Threading.Thread.TrySetApartmentState%2A> método é usado novamente. Dessa vez lança <xref:System.Threading.ThreadStateException> porque o thread já foi iniciado.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: esse membro não é compatível com as plataformas macOS e Linux.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> não é um estado de apartment válido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread já foi iniciado.</exception>
        <exception cref="T:System.InvalidOperationException">O estado de apartment já foi inicializado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">O objeto <see cref="T:System.Threading.CompressedStack" /> a ser aplicado ao thread atual.</param>
        <summary>Aplica uma <see cref="T:System.Threading.CompressedStack" /> capturada ao thread atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há suporte para esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Em todos os casos.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">O <see cref="T:System.LocalDataStoreSlot" /> no qual definir o valor.</param>
        <param name="data">O valor a ser configurado.</param>
        <summary>Define os dados no slot especificado no thread em execução no momento, para o domínio atual do thread. Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados. Campos estáticos relativos a thread fornecem melhor desempenho que slots de dados e habilitar a verificação de tipo de tempo de compilação. Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Os threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento. O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado. O thread pode alocar um slot de dados no repositório de dados, armazenar e recuperar dados de um valor no slot e liberar o slot para reutilização após a conclusão do procedimento de thread e o <xref:System.Threading.Thread> objeto tiver sido recuperado pela coleta de lixo. Slots de dados são exclusivos por thread. Nenhum outro thread (nem mesmo um thread de filho) pode obter dados.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> é um `Shared` método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread. Para evitar confusão, use o nome de classe ao chamar `Shared` métodos: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como usar um campo que está marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread. O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.  
  
 **Primeiro exemplo**  
  
 O exemplo a seguir mostra como usar um campo que está marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread. Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo exemplo**  
  
 O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Suspende o thread atual para o período de tempo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos durante o qual o thread ficará suspenso. Se o valor do argumento <c>millisecondsTimeout</c> for zero, o thread entregará o restante de sua fração de tempo para qualquer thread de prioridade igual que está pronto para execução. Se não houver nenhum outro thread de prioridade igual pronto para execução, a execução do thread atual não será suspensa.</param>
        <summary>Suspende o thread atual no número especificado de milissegundos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O thread não será agendado para execução pelo sistema operacional para a quantidade de tempo especificado. Esse método altera o estado do thread para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Você pode especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o `millisecondsTimeout` parâmetro para suspender o thread indefinidamente. No entanto, recomendamos que você use outro <xref:System.Threading?displayProperty=nameWithType> classes como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> em vez disso, para sincronizar threads ou gerenciar recursos.  
  
 Os pulsos de relógio do sistema em uma taxa específica chamada a resolução do relógio. O tempo limite real pode não ser exatamente o tempo limite especificado, porque o tempo limite especificado será ajustado para coincidir com tiques do relógio. Para obter mais informações sobre resolução de relógio e o tempo de espera, consulte o [suspensão função](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tópico. Este método chama o [suspensão função](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) de APIs do sistema do Windows.  
  
 Este método não executa SendMessage bombeamento e COM padrão.  
  
> [!NOTE]
>  Se você precisa de suspensão em um thread que tenha <xref:System.STAThreadAttribute>, mas você deseja executar COM e SendMessage bombeamento padrão, considere usar uma das sobrecargas do <xref:System.Threading.Thread.Join%2A> método que especifica um intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Thread.Sleep%2A> método para bloquear o thread principal do aplicativo.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de tempo limite é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A quantidade de tempo para a qual o thread é suspenso. Se o valor do argumento <c>millisecondsTimeout</c> for <see cref="F:System.TimeSpan.Zero" />, o thread entregará o restante de sua fatia de tempo para qualquer thread de prioridade igual que está pronto para execução. Se não houver nenhum outro thread de prioridade igual pronto para execução, a execução do thread atual não será suspensa.</param>
        <summary>Suspende o thread atual para o período de tempo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O thread não será agendado para execução pelo sistema operacional para a quantidade de tempo especificado. Esse método altera o estado do thread para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Você pode especificar <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> para o `timeout` parâmetro para suspender o thread indefinidamente. No entanto, recomendamos que você use outro <xref:System.Threading?displayProperty=nameWithType> classes como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> em vez disso, para sincronizar threads ou gerenciar recursos.  
  
 Esta sobrecarga do <xref:System.Threading.Thread.Sleep%2A> usa o número total de milissegundos em `timeout`. Milissegundos fracionários são descartados.  
  
 Este método não executa SendMessage bombeamento e COM padrão.  
  
> [!NOTE]
>  Se você precisa de suspensão em um thread que tenha <xref:System.STAThreadAttribute>, mas você deseja executar COM e SendMessage bombeamento padrão, considere usar uma das sobrecargas do <xref:System.Threading.Thread.Join%2A> método que especifica um intervalo de tempo limite.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> sobrecarga do método para bloquear o thread principal do aplicativo cinco vezes, para cada hora de dois segundos.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> será negativo e não será igual a <see cref="F:System.Threading.Timeout.Infinite" /> em milissegundos, ou será maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">Um inteiro com sinal de 32 bits que define quanto tempo um thread deverá aguardar.</param>
        <summary>Faz com que um thread aguarde o número de vezes definido pelo parâmetro <paramref name="iterations" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Thread.SpinWait%2A> método é útil para a implementação de bloqueios. Classes do .NET Framework, como <xref:System.Threading.Monitor> e <xref:System.Threading.ReaderWriterLock>, use esse método internamente. <xref:System.Threading.Thread.SpinWait%2A> basicamente coloca o processador em um loop estreito muito, com a contagem de loop especificada pelo `iterations` parâmetro. A duração da espera, portanto, depende da velocidade do processador.  
  
 Compare isso com o <xref:System.Threading.Thread.Sleep%2A> método. Um thread que chama <xref:System.Threading.Thread.Sleep%2A> produz o restante do seu fatia atual de tempo do processador, mesmo se o intervalo especificado é zero. Especificar um intervalo diferente de zero para <xref:System.Threading.Thread.Sleep%2A> remove o thread de consideração pelo Agendador de thread até que o intervalo de tempo decorrido.  
  
 <xref:System.Threading.Thread.SpinWait%2A> não é geralmente é útil para aplicativos comuns. Na maioria dos casos, você deve usar as classes de sincronização fornecidas pelo .NET Framework. Por exemplo, chamar <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ou uma instrução que encapsula <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` em c# ou `SyncLock` no Visual Basic).  
  
> [!CAUTION]
>  Em casos raros em que é vantajoso para evitar uma alternância de contexto, como quando você sabe que uma alteração de estado é iminente, fazer uma chamada para o <xref:System.Threading.Thread.SpinWait%2A> método em seu loop. O código <xref:System.Threading.Thread.SpinWait%2A> executa é projetado para evitar problemas que podem ocorrer em computadores com vários processadores. Por exemplo, em computadores com vários processadores Intel utilizar a tecnologia Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> impede a privação de processador em determinadas situações.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Faz com que um thread seja agendado para execução.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Faz com que o sistema operacional altere o estado da instância atual para <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread estiver no <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, o sistema operacional pode agendá-lo para execução. O thread de início da execução na primeira linha do método representado pelo <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> delegado fornecido para o construtor de thread. Observe que a chamada para <xref:System.Threading.Thread.Start%2A> não bloqueia o thread de chamada.  
  
> [!NOTE]
>  Se essa sobrecarga é usada com um thread criado usando um <xref:System.Threading.ParameterizedThreadStart> delegado, `null` é passado para o método executado pelo thread.  
  
 Depois que o thread termina, ele não pode ser reiniciado com outra chamada para `Start`.  
  
   
  
## Examples  
 O exemplo a seguir cria e inicia um thread.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">O thread já foi iniciado.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível para iniciar esse thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Um objeto que contém dados a serem usados pelo método executado pelo thread.</param>
        <summary>Faz com que o sistema operacional altere o estado da instância atual para <see cref="F:System.Threading.ThreadState.Running" /> e, opcionalmente, fornece um objeto que contém dados a serem usados pelo método executado pelo thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread estiver no <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, o sistema operacional pode agendá-lo para execução. O thread de início da execução na primeira linha do método representado pelo <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> delegado fornecido para o construtor de thread. Observe que a chamada para <xref:System.Threading.Thread.Start%2A> não bloqueia o thread de chamada.  
  
 Depois que o thread termina, ele não pode ser reiniciado com outra chamada para `Start`.  
  
 Essa sobrecarga e a <xref:System.Threading.ParameterizedThreadStart> delegado facilitam passar dados para um procedimento de thread, mas a técnica não é tipo seguro porque qualquer objeto pode ser passado para essa sobrecarga. Uma maneira mais robusta para passar dados para um procedimento de thread é colocar o procedimento de thread e os campos de dados em um objeto de trabalho. Para obter mais informações, consulte [criando Threads e passando dados na hora de início](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Threading.ParameterizedThreadStart> representante com um método estático e um método de instância.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">O thread já foi iniciado.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível para iniciar esse thread.</exception>
        <exception cref="T:System.InvalidOperationException">Esse thread foi criado usando um delegado <see cref="T:System.Threading.ThreadStart" /> em vez de um delegado <see cref="T:System.Threading.ParameterizedThreadStart" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspende o thread ou, se o thread já está suspenso, não tem efeito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o thread já está suspenso, esse método não terá efeito.  
  
> [!CAUTION]
>  Não use o <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar as atividades de threads. Você não tem como saber qual código de um thread está em execução quando você suspende a ele. Se você suspender um thread enquanto ele mantém o bloqueio durante a avaliação de permissão de segurança, outros threads de <xref:System.AppDomain> podem ser bloqueadas. Se você suspender um thread enquanto ele está em execução em um construtor de classe, outros threads de <xref:System.AppDomain> que tentar usar que classe estão bloqueadas. Os deadlocks podem ocorrer facilmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Somente .NET Core: esse membro não é compatível.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread não foi iniciado ou está inativo.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem o <see cref="T:System.Security.Permissions.SecurityPermission" /> apropriado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">operações avançadas em threads. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Recebe um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que contém os estados do thread atual.</summary>
        <value>Um dos valores de <see cref="T:System.Threading.ThreadState" /> que indica o estado do thread atual. O valor inicial é <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Thread.ThreadState%2A> propriedade fornece informações mais específicas do que o <xref:System.Threading.Thread.IsAlive%2A> propriedade.  
  
> [!IMPORTANT]
>  Estado do segmento é somente de interesse em cenários de depuração. O código nunca deve usar o estado do thread para sincronizar as atividades de threads.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o acesso a `ThreadState` de thread.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">O novo estado de apartment.</param>
        <summary>Define o estado do apartment de um thread antes que ele seja iniciado.</summary>
        <returns>
          <see langword="true" /> se o estado de apartment for definido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Novos threads são inicializados como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se seu estado de apartment não foi definido antes que eles são iniciados. Estado de apartment deve ser definido antes que um thread é iniciado.  
  
> [!NOTE]
>  O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> por padrão. A única maneira de definir o estado apartment do thread principal do aplicativo para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> é aplicar o <xref:System.STAThreadAttribute> atributo ao método de ponto de entrada.  
  
 O <xref:System.Threading.Thread.TrySetApartmentState%2A> método, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A> método e o <xref:System.Threading.Thread.SetApartmentState%2A> substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A>. O exemplo de código cria um thread. Antes do thread é iniciado, <xref:System.Threading.Thread.GetApartmentState%2A> exibe inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado e <xref:System.Threading.Thread.SetApartmentState%2A> altera o estado para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. O <xref:System.Threading.Thread.TrySetApartmentState%2A> método retorna `false` durante a tentativa de alterar o estado para <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque o estado de apartment já está definido. Se a mesma operação tivesse sido tentada com <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> será lançada.  
  
 Depois que o thread é iniciado, o <xref:System.Threading.Thread.TrySetApartmentState%2A> método é usado novamente. Dessa vez lança <xref:System.Threading.ThreadStateException> porque o thread já foi iniciado.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> não é um estado de apartment válido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">O thread já foi iniciado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">O campo a ser lido.</param>
        <summary>Lê o valor de um campo. O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</summary>
        <returns>O último valor gravado no campo por qualquer processador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">O campo no qual o valor deve ser gravado.</param>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são casos especiais de sincronização. Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.  
  
 Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória fica imediatamente visível para todos os processadores. Isso pode exigir a liberação de caches de processador.  
  
 Mesmo em um sistema de processador único, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenadas em cache (por exemplo, em um registro do processador). Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.  
  
 Chamar esse método afeta apenas um acesso de memória único. Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Faz com que o thread de chamada conceda a execução para outro thread que está pronto para ser executado no processador atual. O sistema operacional seleciona o thread de recebimento.</summary>
        <returns>
          <see langword="true" /> se o sistema operacional execução mudou a execução para outro thread; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método for bem-sucedido, o restante da fração de tempo atual do thread é produzido. O sistema operacional agenda o thread de chamada para outro intervalo de tempo, de acordo com sua prioridade e o status de outros threads que estão disponíveis para executar.  
  
 Gerando é limitado para o processador que está executando o thread de chamada. O sistema operacional não mudará execução a outro processador, mesmo se que o processador está ocioso ou estiver executando um thread de prioridade mais baixa. Se não houver nenhum outro thread está pronto para executar o processador atual, o sistema operacional não gera a execução e esse método retorna `false`.  
  
 Esse método é equivalente a usando invocação de plataforma para chamar o Win32 nativo `SwitchToThread` função. Você deve chamar o <xref:System.Threading.Thread.Yield%2A> invoca o método em vez de usar a plataforma, porque ignora qualquer comportamento de threading personalizado host solicitou de invocação de plataforma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>