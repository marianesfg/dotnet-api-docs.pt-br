<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fd2bf7c62b10f302d95d138e19563c498a74ec5a" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52219338" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="04b65-101">Cria e controla um thread, define sua prioridade e obtém seu status.</span><span class="sxs-lookup"><span data-stu-id="04b65-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-102">Quando um processo é iniciado, o common language runtime cria automaticamente um thread de primeiro plano único para executar o código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="04b65-103">Junto com esse thread principal em primeiro plano, um processo pode criar um ou mais threads para executar uma parte do código do programa associado ao processo.</span><span class="sxs-lookup"><span data-stu-id="04b65-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="04b65-104">Esses threads podem executar em primeiro plano ou em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="04b65-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="04b65-105">Além disso, você pode usar o <xref:System.Threading.ThreadPool> classe para executar código em threads de trabalho que são gerenciados pelo common language runtime.</span><span class="sxs-lookup"><span data-stu-id="04b65-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="04b65-106">Nesta seção</span><span class="sxs-lookup"><span data-stu-id="04b65-106">In this section</span></span>  
  
 <span data-ttu-id="04b65-107">[Iniciar um thread](#Starting) </span><span class="sxs-lookup"><span data-stu-id="04b65-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="04b65-108">[Recuperando objetos de Thread](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="04b65-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="04b65-109">[Threads de primeiro plano e plano de fundo](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="04b65-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="04b65-110">[Cultura e threads](#Culture) </span><span class="sxs-lookup"><span data-stu-id="04b65-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="04b65-111">Obtendo informações e controlando threads</span><span class="sxs-lookup"><span data-stu-id="04b65-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="04b65-112">Iniciar um thread</span><span class="sxs-lookup"><span data-stu-id="04b65-112">Starting a thread</span></span>  
 <span data-ttu-id="04b65-113">Iniciar um thread, fornecendo um delegado que representa o método que o thread é executar em seu construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="04b65-114">Você, em seguida, chamar o <xref:System.Threading.Thread.Start%2A> método para iniciar a execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="04b65-115">O <xref:System.Threading.Thread> os construtores podem usar qualquer um dos tipos de delegado dois, dependendo se você pode passar um argumento para o método a ser executado:</span><span class="sxs-lookup"><span data-stu-id="04b65-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="04b65-116">Se o método não tiver nenhum argumento, você passa um <xref:System.Threading.ThreadStart> delegar para o construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="04b65-117">Ele tem a assinatura:</span><span class="sxs-lookup"><span data-stu-id="04b65-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="04b65-118">O exemplo a seguir cria e inicia um thread que executa o `ExecuteInForeground` método.</span><span class="sxs-lookup"><span data-stu-id="04b65-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="04b65-119">O método exibe informações sobre algumas propriedades do thread e, em seguida, executa um loop no qual ele pausa por meio de um segundo e exibe o número decorrido de segundos.</span><span class="sxs-lookup"><span data-stu-id="04b65-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="04b65-120">Quando o thread tenha executado pelo menos cinco segundos, o loop é encerrado e o thread termina a execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="04b65-121">Se o método tem um argumento, você passa um <xref:System.Threading.ParameterizedThreadStart> delegar para o construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="04b65-122">Ele tem a assinatura:</span><span class="sxs-lookup"><span data-stu-id="04b65-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="04b65-123">O método executado pelo delegado pode, em seguida, cast (em c#) ou converta (no Visual Basic) o parâmetro para o tipo apropriado.</span><span class="sxs-lookup"><span data-stu-id="04b65-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="04b65-124">O exemplo a seguir é idêntico ao anterior, exceto que ele chama o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="04b65-125">Esta versão do `ExecuteInForeground` método tem um único parâmetro que representa o número aproximado de milissegundos que o loop é executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="04b65-126">Não é necessário manter uma referência a um <xref:System.Threading.Thread> depois de iniciar o thread do objeto.</span><span class="sxs-lookup"><span data-stu-id="04b65-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="04b65-127">O thread continua a executar até concluir o procedimento de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="04b65-128">Recuperando objetos de Thread</span><span class="sxs-lookup"><span data-stu-id="04b65-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="04b65-129">Você pode usar o estático (`Shared` no Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> propriedade para recuperar uma referência para o thread em execução no momento do código que o thread está em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="04b65-130">O exemplo a seguir usa o <xref:System.Threading.Thread.CurrentThread%2A> propriedade para exibir informações sobre o thread principal do aplicativo, outro thread de primeiro plano, um thread em segundo plano e um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="04b65-131">Threads de primeiro plano e plano de fundo</span><span class="sxs-lookup"><span data-stu-id="04b65-131">Foreground and background threads</span></span>  
 <span data-ttu-id="04b65-132">Instâncias do <xref:System.Threading.Thread> classe representam os threads de primeiro plano ou threads em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="04b65-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="04b65-133">Threads em segundo plano são idênticos aos threads de primeiro plano com uma exceção: um thread em segundo plano não mantém um processo em execução se todos os threads de primeiro plano tiverem terminado.</span><span class="sxs-lookup"><span data-stu-id="04b65-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="04b65-134">Depois que todos os threads de primeiro plano foram interrompidos, o tempo de execução interrompe todos os threads em segundo plano e desliga.</span><span class="sxs-lookup"><span data-stu-id="04b65-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="04b65-135">Por padrão, os seguintes threads executam em primeiro plano:</span><span class="sxs-lookup"><span data-stu-id="04b65-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="04b65-136">O thread principal do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="04b65-137">Todos os threads criados chamando uma <xref:System.Threading.Thread> construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="04b65-138">Executem os seguintes threads em segundo plano por padrão:</span><span class="sxs-lookup"><span data-stu-id="04b65-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="04b65-139">Thread do pool de threads, que são um pool de threads de trabalho mantido pelo tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="04b65-140">Você pode configurar o trabalho de threads de pool e o agendamento em threads do pool usando o <xref:System.Threading.ThreadPool> classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="04b65-141">Operações assíncronas baseadas em tarefa executar automaticamente em threads do pool.</span><span class="sxs-lookup"><span data-stu-id="04b65-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="04b65-142">Usam operações assíncronas baseadas em tarefas do <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> classes para implementar a [padrão assíncrono baseado em tarefa](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="04b65-143">Todos os threads que entram no ambiente de execução gerenciado do código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="04b65-144">Você pode alterar um thread para executar em segundo plano, definindo o <xref:System.Threading.Thread.IsBackground%2A> propriedade a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="04b65-145">Threads em segundo plano são úteis para qualquer operação que deve continuar desde que um aplicativo está em execução, mas não deve impedir que o aplicativo termine, como o monitoramento de alterações no sistema de arquivos ou conexões de soquete de entrada.</span><span class="sxs-lookup"><span data-stu-id="04b65-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="04b65-146">O exemplo a seguir ilustra a diferença entre os threads de primeiro plano e plano de fundo.</span><span class="sxs-lookup"><span data-stu-id="04b65-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="04b65-147">Como o primeiro exemplo é o [iniciar um thread](#Starting) seção, exceto que ele define o thread seja executado em segundo plano antes de iniciá-lo.</span><span class="sxs-lookup"><span data-stu-id="04b65-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="04b65-148">Como mostra a saída, o loop é interrompido antes de ele ser executado por cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="04b65-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="04b65-149">Cultura e threads</span><span class="sxs-lookup"><span data-stu-id="04b65-149">Culture and threads</span></span>  
 <span data-ttu-id="04b65-150">Cada thread tem uma cultura, representada pela <xref:System.Threading.Thread.CurrentCulture%2A> propriedade e uma cultura de interface do usuário, representado pelo <xref:System.Threading.Thread.CurrentUICulture%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="04b65-151">A cultura atual dá suporte a operações sensíveis à cultura como análise e formatação, comparação de cadeia de caracteres e classificação e também controla o sistema de escrita e o calendário usado por um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="04b65-152">A cultura da interface do usuário atual fornece recuperação de cultura dos recursos em arquivos de recurso.</span><span class="sxs-lookup"><span data-stu-id="04b65-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="04b65-153">O <xref:System.Threading.Thread.CurrentCulture> e <xref:System.Threading.Thread.CurrentUICulture> propriedades não funcionam de forma confiável quando usado com qualquer thread diferente do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="04b65-154">No .NET Framework, essas propriedades de leitura é confiável, embora definir essas propriedades para um thread diferente do thread atual não é.</span><span class="sxs-lookup"><span data-stu-id="04b65-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="04b65-155">No .NET Core, um <xref:System.InvalidOperationException> será lançada se um thread tenta ler ou gravar essas propriedades em um thread diferente.</span><span class="sxs-lookup"><span data-stu-id="04b65-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="04b65-156">É recomendável que você use o <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propriedades para recuperar e definir a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="04b65-157">Quando um novo thread é instanciado, sua cultura e cultura da interface do usuário são definidas pela cultura atual do sistema e cultura da interface do usuário e não pela cultura e cultura da interface do usuário do thread do qual o novo thread é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="04b65-158">Isso significa, por exemplo, que se a cultura atual do sistema é inglês (Estados Unidos) e a cultura atual do thread principal do aplicativo é o francês (França), a cultura de um novo thread criado chamando o <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> construtor do thread principal é o inglês (Estados Unidos) e francês (França).</span><span class="sxs-lookup"><span data-stu-id="04b65-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="04b65-159">Para obter mais informações, consulte a seção "Cultura e threads" do <xref:System.Globalization.CultureInfo> tópico da classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-160">Isso não é verdadeiro de threads que executam operações assíncronas para aplicativos que se destinam a [!INCLUDE[net_v46](~/includes/net-v46-md.md)] e versões posteriores, nesse caso, a cultura e cultura da interface do usuário faz parte do assíncrona contexto das operações; o thread no qual uma operação assíncrona executa por padrão herda a cultura e cultura da interface do usuário do thread do qual a operação assíncrona foi iniciada.</span><span class="sxs-lookup"><span data-stu-id="04b65-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="04b65-161">Para saber mais, confira a seção "Cultura e operações assíncronas baseadas em tarefas" do tópico da classe <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="04b65-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="04b65-162">Você pode fazer o seguinte para garantir que todos os threads em execução em um aplicativo compartilham a mesma cultura e cultura de interface do usuário:</span><span class="sxs-lookup"><span data-stu-id="04b65-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="04b65-163">Você pode passar uma <xref:System.Globalization.CultureInfo> objeto que representa a cultura para o <xref:System.Threading.ParameterizedThreadStart> delegado ou a <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="04b65-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="04b65-164">Para aplicativos executados nos [!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versões posteriores, você pode definir a cultura e cultura da interface do usuário que deve ser atribuído a todos os threads criados em um domínio de aplicativo, definindo o valor da <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propriedades.</span><span class="sxs-lookup"><span data-stu-id="04b65-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="04b65-165">Observe que essa é uma configuração de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="04b65-166">Para obter mais informações e exemplos, consulte a seção "Cultura e threads" do <xref:System.Globalization.CultureInfo> tópico da classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="04b65-167">Obtendo informações e controlando threads</span><span class="sxs-lookup"><span data-stu-id="04b65-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="04b65-168">Você pode recuperar um número de valores de propriedade que fornecem informações sobre um segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="04b65-169">Em alguns casos, você também pode definir esses valores de propriedade para controlar a operação do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="04b65-170">Essas propriedades de segmento incluem:</span><span class="sxs-lookup"><span data-stu-id="04b65-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="04b65-171">Um nome.</span><span class="sxs-lookup"><span data-stu-id="04b65-171">A name.</span></span> <span data-ttu-id="04b65-172"><xref:System.Threading.Thread.Name%2A> é uma gravação-uma vez a propriedade que você pode usar para identificar um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="04b65-173">Seu valor padrão é `null`.</span><span class="sxs-lookup"><span data-stu-id="04b65-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="04b65-174">Um código de hash, que você pode recuperar chamando o <xref:System.Threading.Thread.GetHashCode%2A> método.</span><span class="sxs-lookup"><span data-stu-id="04b65-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="04b65-175">O código de hash pode ser usado para identificar exclusivamente um thread. o tempo de vida de seu thread, seu código de hash não coincidirá com o valor de outros threads, independentemente de onde você obter o valor de domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="04b65-176">Uma ID de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-176">A thread ID.</span></span> <span data-ttu-id="04b65-177">O valor de somente leitura <xref:System.Threading.Thread.ManagedThreadId%2A> propriedade é atribuída pelo tempo de execução e identifica exclusivamente um thread dentro de seu processo.</span><span class="sxs-lookup"><span data-stu-id="04b65-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="04b65-178">Um [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) do sistema operacional não tem relação fixa com um thread gerenciado porque hosts não gerenciados podem controlar a relação entre threads gerenciados e não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="04b65-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="04b65-179">Especificamente, hosts sofisticados podem usar o [API de hospedagem de CLR](https://msdn.microsoft.com/library/ms404385.aspx) para agendar muitos threads gerenciados no mesmo thread do sistema operacional, ou para mover um thread gerenciado entre os threads do sistema operacional diferente.</span><span class="sxs-lookup"><span data-stu-id="04b65-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="04b65-180">Estado atual do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-180">The thread's current state.</span></span> <span data-ttu-id="04b65-181">Durante o período de sua existência, um thread está sempre em um ou mais dos Estados definidos pelo <xref:System.Threading.ThreadState> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="04b65-182">Um nível de prioridade do agendamento, que é definido pelo <xref:System.Threading.ThreadPriority> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="04b65-183">Embora você possa definir esse valor para solicitar a prioridade do thread, não é garantido para ser respeitado pelo sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="04b65-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="04b65-184">Somente leitura <xref:System.Threading.Thread.IsThreadPoolThread%2A> propriedade, que indica se um thread é um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="04b65-185">A propriedade de <xref:System.Threading.Thread.IsBackground%2A> .</span><span class="sxs-lookup"><span data-stu-id="04b65-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="04b65-186">Para obter mais informações, consulte o [threads de primeiro plano e plano de fundo](#Foreground) seção.</span><span class="sxs-lookup"><span data-stu-id="04b65-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="04b65-187">O exemplo a seguir demonstra a funcionalidade de threading simple.</span><span class="sxs-lookup"><span data-stu-id="04b65-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="04b65-188">Esse código produz uma saída semelhante à seguinte:</span><span class="sxs-lookup"><span data-stu-id="04b65-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="04b65-189">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="04b65-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-190">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="04b65-191">Usando threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="04b65-192">Fonte de referência para a classe Thread</span><span class="sxs-lookup"><span data-stu-id="04b65-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-193">Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="04b65-194">Um delegado que representa os métodos a serem invocados quando esse thread começar a ser executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="04b65-195">Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />, especificando um delegado que permite que um objeto seja passado para o thread quando o thread for iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-196">Um thread não começa a executar quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="04b65-197">Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A> método.</span><span class="sxs-lookup"><span data-stu-id="04b65-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="04b65-198">Para passar um objeto de dados para o thread, use o <xref:System.Threading.Thread.Start%28System.Object%29> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="04b65-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-199">Usuários do Visual Basic podem omitir o <xref:System.Threading.ThreadStart> construtor durante a criação de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="04b65-200">Use o `AddressOf` operador ao passar o seu método, por exemplo `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="04b65-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="04b65-201">Visual Basic chama automaticamente o <xref:System.Threading.ThreadStart> construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-202">O exemplo a seguir mostra a sintaxe para criar e usar um <xref:System.Threading.ParameterizedThreadStart> delegado com um método estático e um método de instância.</span><span class="sxs-lookup"><span data-stu-id="04b65-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04b65-203"><paramref name="start" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="04b65-204">Criando Threads</span><span class="sxs-lookup"><span data-stu-id="04b65-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="04b65-205">Um delegado <see cref="T:System.Threading.ThreadStart" /> que representa os métodos a serem invocados quando esse thread começar a ser executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="04b65-206">Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-207">Um thread não começa a executar quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="04b65-208">Para agendar o thread de execução, chame o <xref:System.Threading.Thread.Start%2A> método.</span><span class="sxs-lookup"><span data-stu-id="04b65-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-209">Usuários do Visual Basic podem omitir o <xref:System.Threading.ThreadStart> construtor durante a criação de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="04b65-210">Use o `AddressOf` operador ao passar por exemplo o seu método `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="04b65-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="04b65-211">Visual Basic chama automaticamente o <xref:System.Threading.ThreadStart> construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-212">O exemplo de código a seguir mostra como criar um thread que executa um método estático.</span><span class="sxs-lookup"><span data-stu-id="04b65-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="04b65-213">O exemplo de código a seguir mostra como criar um thread que executa um método de instância.</span><span class="sxs-lookup"><span data-stu-id="04b65-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04b65-214">O parâmetro <paramref name="start" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="04b65-215">Criando Threads</span><span class="sxs-lookup"><span data-stu-id="04b65-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="04b65-216">Um delegado <see cref="T:System.Threading.ParameterizedThreadStart" /> que representa os métodos a serem invocados quando esse thread começar a ser executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="04b65-217">O tamanho máximo da pilha, em bytes, a ser usado pelo thread ou 0 para usar o tamanho de pilha máximo padrão especificado no cabeçalho do executável.</span><span class="sxs-lookup"><span data-stu-id="04b65-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="04b65-218">Importante   Para um código parcialmente confiável, <paramref name="maxStackSize" /> será ignorado se for maior que o tamanho da pilha padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="04b65-219">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="04b65-220">Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />, especificando um delegado que permite que um objeto seja passado para o thread quando o thread é iniciado e especificando o tamanho máximo da pilha para o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-221">Evite usar essa sobrecarga de construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="04b65-222">O tamanho da pilha padrão usado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> sobrecarga de construtor é o tamanho da pilha recomendada para threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="04b65-223">Se um thread tiver problemas de memória, a causa mais provável é programação de erro, como recursão infinita.</span><span class="sxs-lookup"><span data-stu-id="04b65-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-224">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], somente totalmente confiáveis, o código pode definir `maxStackSize` para um valor que é maior que o tamanho da pilha padrão (1 megabyte).</span><span class="sxs-lookup"><span data-stu-id="04b65-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="04b65-225">Se um valor maior for especificado para `maxStackSize` quando o código está em execução com confiança parcial, `maxStackSize` será ignorado e o tamanho da pilha padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="04b65-226">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-226">No exception is thrown.</span></span> <span data-ttu-id="04b65-227">O código em qualquer nível de confiança pode definir `maxStackSize` para um valor que é menor que o tamanho da pilha padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-228">Se você estiver desenvolvendo uma biblioteca de totalmente confiável que será usada pelo código parcialmente confiável, e você precisa iniciar um thread que exige uma grande pilha, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="04b65-229">Não faça isso, a menos que você controlar totalmente o código que é executado no thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="04b65-230">Se `maxStackSize` é menor que o tamanho mínimo de pilha, o tamanho mínimo da pilha é usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="04b65-231">Se `maxStackSize` não é um múltiplo do tamanho da página, ele será arredondado para o próximo maior múltiplo do tamanho da página.</span><span class="sxs-lookup"><span data-stu-id="04b65-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="04b65-232">Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho mínimo da pilha e o tamanho da página é 64KB (65.536 bytes).</span><span class="sxs-lookup"><span data-stu-id="04b65-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-233">Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, `maxStackSize` é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="04b65-234">Se você especificar um tamanho de pilha muito pequeno, talvez precise desabilitar a investigação de estouro de pilha.</span><span class="sxs-lookup"><span data-stu-id="04b65-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="04b65-235">Quando a pilha é restrições rígida, a investigação pode próprio causar um estouro de pilha.</span><span class="sxs-lookup"><span data-stu-id="04b65-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="04b65-236">Para desabilitar a investigação de estouro de pilha, adicione o seguinte ao arquivo de configuração de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04b65-237"><paramref name="start" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04b65-238"><paramref name="maxStackSize" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="04b65-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="04b65-239">Um delegado <see cref="T:System.Threading.ThreadStart" /> que representa os métodos a serem invocados quando esse thread começar a ser executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="04b65-240">O tamanho máximo da pilha, em bytes, a ser usado pelo thread ou 0 para usar o tamanho de pilha máximo padrão especificado no cabeçalho do executável.</span><span class="sxs-lookup"><span data-stu-id="04b65-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="04b65-241">Importante   Para um código parcialmente confiável, <paramref name="maxStackSize" /> será ignorado se for maior que o tamanho da pilha padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="04b65-242">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="04b65-243">Inicializa uma nova instância da classe <see cref="T:System.Threading.Thread" />, especificando o tamanho máximo da pilha do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-244">Evite usar essa sobrecarga de construtor.</span><span class="sxs-lookup"><span data-stu-id="04b65-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="04b65-245">O tamanho da pilha padrão usado pelo <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> sobrecarga de construtor é o tamanho da pilha recomendada para threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="04b65-246">Se um thread tiver problemas de memória, a causa mais provável é programação de erro, como recursão infinita.</span><span class="sxs-lookup"><span data-stu-id="04b65-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-247">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], somente totalmente confiáveis, o código pode definir `maxStackSize` para um valor que é maior que o tamanho da pilha padrão (1 megabyte).</span><span class="sxs-lookup"><span data-stu-id="04b65-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="04b65-248">Se um valor maior for especificado para `maxStackSize` quando o código está em execução com confiança parcial, `maxStackSize` será ignorado e o tamanho da pilha padrão é usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="04b65-249">Nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-249">No exception is thrown.</span></span> <span data-ttu-id="04b65-250">O código em qualquer nível de confiança pode definir `maxStackSize` para um valor que é menor que o tamanho da pilha padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-251">Se você estiver desenvolvendo uma biblioteca de totalmente confiável que será usada pelo código parcialmente confiável, e você precisa iniciar um thread que exige uma grande pilha, você deve declarar confiança total antes de criar o thread ou o tamanho da pilha padrão será usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="04b65-252">Não faça isso, a menos que você controlar totalmente o código que é executado no thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="04b65-253">Se `maxStackSize` é menor que o tamanho mínimo de pilha, o tamanho mínimo da pilha é usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="04b65-254">Se `maxStackSize` não é um múltiplo do tamanho da página, ele será arredondado para o próximo maior múltiplo do tamanho da página.</span><span class="sxs-lookup"><span data-stu-id="04b65-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="04b65-255">Por exemplo, se você estiver usando o .NET Framework versão 2.0 no Windows Vista, 256KB (262.144 bytes) é o tamanho mínimo da pilha e o tamanho da página é 64KB (65.536 bytes).</span><span class="sxs-lookup"><span data-stu-id="04b65-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-256">Em versões do Microsoft Windows anteriores ao Windows XP e Windows Server 2003, `maxStackSize` é ignorado, e o tamanho da pilha especificado no cabeçalho do executável é usado.</span><span class="sxs-lookup"><span data-stu-id="04b65-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="04b65-257">Se você especificar um tamanho de pilha muito pequeno, talvez precise desabilitar a investigação de estouro de pilha.</span><span class="sxs-lookup"><span data-stu-id="04b65-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="04b65-258">Quando a pilha é restrições rígida, a investigação pode próprio causar um estouro de pilha.</span><span class="sxs-lookup"><span data-stu-id="04b65-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="04b65-259">Para desabilitar a investigação de estouro de pilha, adicione o seguinte ao arquivo de configuração de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04b65-260"><paramref name="start" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04b65-261"><paramref name="maxStackSize" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="04b65-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-262">Gera um <see cref="T:System.Threading.ThreadAbortException" /> no thread no qual ele é invocado, para iniciar o processo de encerramento do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="04b65-263">Geralmente, a chamada a esse método termina o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="04b65-264">O `Thread.Abort` método deve ser usado com cuidado.</span><span class="sxs-lookup"><span data-stu-id="04b65-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="04b65-265">Especialmente quando você chamá-lo para anular um thread diferente do thread atual, você não souber qual código foi executado ou falhou ser executado quando o <xref:System.Threading.ThreadAbortException> é lançada, nem pode ser determinado do estado do seu aplicativo ou qualquer aplicativo de estado do usuário e que é responsável pela preservação.</span><span class="sxs-lookup"><span data-stu-id="04b65-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="04b65-266">Por exemplo, chamar `Thread.Abort` pode impedir a execução de construtores estáticos ou impedir a liberação de recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="04b65-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources.</span></span> 
>
> <span data-ttu-id="04b65-267">Observe que o `Thread.Abort` método não é suportado no .NET Core.</span><span class="sxs-lookup"><span data-stu-id="04b65-267">Note that the `Thread.Abort` method is not supported on .NET Core.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-268">Gera um <see cref="T:System.Threading.ThreadAbortException" /> no thread no qual ele é invocado, para iniciar o processo de encerramento do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-268">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="04b65-269">Geralmente, a chamada a esse método termina o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-269">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-270">Quando esse método é invocado em um thread, o sistema gera um <xref:System.Threading.ThreadAbortException> no thread de anulá-la.</span><span class="sxs-lookup"><span data-stu-id="04b65-270">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="04b65-271">`ThreadAbortException` é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final de `catch` bloquear a menos que <xref:System.Threading.Thread.ResetAbort%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-271">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="04b65-272">`ResetAbort` Cancela a solicitação ser anulada e impede que o `ThreadAbortException` de finalizar o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-272">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="04b65-273">Não executadas `finally` blocos são executados antes do thread é anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-273">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-274">Quando um thread chama `Abort` em si, o efeito é semelhante ao lançar uma exceção; a <xref:System.Threading.ThreadAbortException> acontece imediatamente, e o resultado é previsível.</span><span class="sxs-lookup"><span data-stu-id="04b65-274">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="04b65-275">No entanto, se um thread chama `Abort` em outro thread, a anulação interrompe qualquer código está em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-275">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="04b65-276">Também há uma chance de que um construtor estático pode ser anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-276">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="04b65-277">Em casos raros, isso pode impedir que instâncias dessa classe que está sendo criado no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-277">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="04b65-278">Nas versões do .NET Framework 1.0 e 1.1, é provável que o thread poderia ser anulada enquanto um `finally` bloco estiver em execução, caso em que o `finally` bloco será anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-278">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="04b65-279">O thread não é garantido para anular imediatamente ou em todos os.</span><span class="sxs-lookup"><span data-stu-id="04b65-279">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="04b65-280">Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no `finally` blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação.</span><span class="sxs-lookup"><span data-stu-id="04b65-280">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="04b65-281">Para esperar até que um thread foi anulada, você pode chamar o <xref:System.Threading.Thread.Join%2A> método no thread depois de chamar o <xref:System.Threading.Thread.Abort%2A> método, mas não há nenhuma garantia de tempo de espera será encerrada.</span><span class="sxs-lookup"><span data-stu-id="04b65-281">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-282">O thread que chama <xref:System.Threading.Thread.Abort%2A> podem bloquear se o thread que está sendo anulado está em uma região protegida de código, como uma `catch` bloco, `finally` bloco ou região de execução restrita.</span><span class="sxs-lookup"><span data-stu-id="04b65-282">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="04b65-283">Se o thread que chama <xref:System.Threading.Thread.Abort%2A> mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.</span><span class="sxs-lookup"><span data-stu-id="04b65-283">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="04b65-284">Se `Abort` é chamado em um thread que não foi iniciado, o thread será anulado quando <xref:System.Threading.Thread.Start%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-284">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="04b65-285">Se `Abort` é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, cancelado.</span><span class="sxs-lookup"><span data-stu-id="04b65-285">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="04b65-286">Se `Abort` é chamado em um thread que foi suspenso, um <xref:System.Threading.ThreadStateException> é gerada no thread que chamou <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> é adicionado ao <xref:System.Threading.Thread.ThreadState%2A> propriedade do thread que está sendo anulada.</span><span class="sxs-lookup"><span data-stu-id="04b65-286">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="04b65-287">Um <xref:System.Threading.ThreadAbortException> não é lançada no thread suspenso até <xref:System.Threading.Thread.Resume%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-287">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="04b65-288">Se `Abort` é chamado em um thread gerenciado durante a execução de código não gerenciado, um `ThreadAbortException` não é lançada até que o thread retorna para código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-288">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="04b65-289">Se duas chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e a outra chamada para executar o `Abort`.</span><span class="sxs-lookup"><span data-stu-id="04b65-289">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="04b65-290">No entanto, um aplicativo não é possível detectar essa situação.</span><span class="sxs-lookup"><span data-stu-id="04b65-290">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="04b65-291">Após `Abort` é invocado em um thread, o estado do thread inclui <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="04b65-291">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="04b65-292">Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="04b65-292">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="04b65-293">Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a anulação usando o `ResetAbort` método.</span><span class="sxs-lookup"><span data-stu-id="04b65-293">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="04b65-294">Para obter um exemplo que demonstra a chamada a `ResetAbort` método, consulte o `ThreadAbortException` classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-294">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="04b65-295">Somente .NET Core: esse membro não é compatível.</span><span class="sxs-lookup"><span data-stu-id="04b65-295">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-296">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-296">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-297">O thread que está sendo anulado está suspenso no momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-297">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-298">operações avançadas em threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-298">for advanced operations on threads.</span></span> <span data-ttu-id="04b65-299">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-299">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-300">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-300">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="04b65-301">Usando threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-301">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="04b65-302">Destruindo threads</span><span class="sxs-lookup"><span data-stu-id="04b65-302">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="04b65-303">Um objeto que contém informações específicas do aplicativo, como estado, que podem ser usadas pelo thread que está sendo anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-303">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="04b65-304">Gera um <see cref="T:System.Threading.ThreadAbortException" /> no thread no qual ele é invocado, para iniciar o processo de término do thread e ao mesmo tempo fornecer informações de exceção sobre o término do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-304">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="04b65-305">Geralmente, a chamada a esse método termina o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-305">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-306">Quando esse método é invocado em um thread, o sistema gera um <xref:System.Threading.ThreadAbortException> no thread de anulá-la.</span><span class="sxs-lookup"><span data-stu-id="04b65-306">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="04b65-307">`ThreadAbortException` é uma exceção especial que pode ser capturada pelo código do aplicativo, mas é lançada novamente no final de `catch` bloquear a menos que <xref:System.Threading.Thread.ResetAbort%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-307">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="04b65-308">`ResetAbort` Cancela a solicitação ser anulada e impede que o `ThreadAbortException` de finalizar o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-308">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="04b65-309">Não executadas `finally` blocos são executados antes do thread é anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-309">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-310">Quando um thread chama `Abort` em si, o efeito é semelhante ao lançar uma exceção; a <xref:System.Threading.ThreadAbortException> acontece imediatamente, e o resultado é previsível.</span><span class="sxs-lookup"><span data-stu-id="04b65-310">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="04b65-311">No entanto, se um thread chama `Abort` em outro thread, a anulação interrompe qualquer código está em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-311">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="04b65-312">Há uma chance de que um construtor estático pode ser anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-312">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="04b65-313">Em casos raros, isso pode impedir que instâncias dessa classe que está sendo criado no domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-313">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="04b65-314">Nas versões do .NET Framework 1.0 e 1.1, é provável que o thread poderia ser anulada enquanto um `finally` bloco estiver em execução, caso em que o `finally` bloco será anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-314">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="04b65-315">O thread não é garantido para anular imediatamente ou em todos os.</span><span class="sxs-lookup"><span data-stu-id="04b65-315">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="04b65-316">Essa situação pode ocorrer se um thread faz uma quantidade ilimitada de computação no `finally` blocos que são chamados como parte do procedimento de anulação, atrasando indefinidamente, assim, a anulação.</span><span class="sxs-lookup"><span data-stu-id="04b65-316">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="04b65-317">Para esperar até que um thread foi anulada, você pode chamar o <xref:System.Threading.Thread.Join%2A> método no thread depois de chamar o <xref:System.Threading.Thread.Abort%2A> método, mas não há nenhuma garantia de que a espera terminará.</span><span class="sxs-lookup"><span data-stu-id="04b65-317">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-318">O thread que chama <xref:System.Threading.Thread.Abort%2A> podem bloquear se o thread que está sendo anulado está em uma região protegida de código, como uma `catch` bloco, `finally` bloco ou região de execução restrita.</span><span class="sxs-lookup"><span data-stu-id="04b65-318">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="04b65-319">Se o thread que chama <xref:System.Threading.Thread.Abort%2A> mantém um bloqueio que exige que o thread anulado, pode ocorrer um deadlock.</span><span class="sxs-lookup"><span data-stu-id="04b65-319">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="04b65-320">Se `Abort` é chamado em um thread que não foi iniciado, o thread será anulado quando <xref:System.Threading.Thread.Start%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-320">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="04b65-321">Se `Abort` é chamado em um thread que está bloqueado ou está em suspensão, o thread é interrompido e, em seguida, cancelado.</span><span class="sxs-lookup"><span data-stu-id="04b65-321">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="04b65-322">Se `Abort` é chamado em um thread que foi suspenso, um <xref:System.Threading.ThreadStateException> é gerada no thread que chamou <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> é adicionado ao <xref:System.Threading.Thread.ThreadState%2A> propriedade do thread que está sendo anulada.</span><span class="sxs-lookup"><span data-stu-id="04b65-322">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="04b65-323">Um <xref:System.Threading.ThreadAbortException> não é lançada no thread suspenso até <xref:System.Threading.Thread.Resume%2A> é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-323">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="04b65-324">Se `Abort` é chamado em um thread gerenciado durante a execução de código não gerenciado, um `ThreadAbortException` não é lançada até que o thread retorna para código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-324">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="04b65-325">Se duas chamadas para `Abort` vêm ao mesmo tempo, é possível que uma chamada definir as informações de estado e a outra chamada para executar o `Abort`.</span><span class="sxs-lookup"><span data-stu-id="04b65-325">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="04b65-326">No entanto, um aplicativo não é possível detectar essa situação.</span><span class="sxs-lookup"><span data-stu-id="04b65-326">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="04b65-327">Após `Abort` é invocado em um thread, o estado do thread inclui <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="04b65-327">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="04b65-328">Depois que o thread foi encerrado como resultado de uma chamada bem-sucedida para `Abort`, o estado do thread é alterado para <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="04b65-328">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="04b65-329">Com permissões suficientes, um thread que é o destino de uma `Abort` pode cancelar a anulação usando o `ResetAbort` método.</span><span class="sxs-lookup"><span data-stu-id="04b65-329">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="04b65-330">Para obter um exemplo que demonstra a chamada a `ResetAbort` método, consulte o `ThreadAbortException` classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-330">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-331">O exemplo de código a seguir mostra como passar informações para um thread que está sendo anulado.</span><span class="sxs-lookup"><span data-stu-id="04b65-331">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="04b65-332">Somente .NET Core: esse membro não é compatível.</span><span class="sxs-lookup"><span data-stu-id="04b65-332">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-333">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-333">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-334">O thread que está sendo anulado está suspenso no momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-334">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-335">operações avançadas em threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-335">for advanced operations on threads.</span></span> <span data-ttu-id="04b65-336">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-336">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-337">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-337">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="04b65-338">Usando threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-338">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="04b65-339">Destruindo threads</span><span class="sxs-lookup"><span data-stu-id="04b65-339">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-340">Aloca um slot de dados sem nome em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-340">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="04b65-341">Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-341">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="04b65-342">O slot de dados nomeado alocado em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-342">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-343">O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-343">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="04b65-344">Campos estáticos relativos a thread fornecem melhor desempenho que os slots de dados e habilitar a verificação de tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="04b65-344">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="04b65-345">Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-345">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="04b65-346">O slot é alocado em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-346">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="04b65-347">Threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-347">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="04b65-348">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-348">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="04b65-349">O thread pode alocar um slot de dados no armazenamento de dados, armazene e recupere dados de um valor no slot e liberar o slot para reutilização depois que o thread expira.</span><span class="sxs-lookup"><span data-stu-id="04b65-349">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="04b65-350">Slots de dados são exclusivos por thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-350">Data slots are unique per thread.</span></span> <span data-ttu-id="04b65-351">Nenhum outro thread (nem mesmo um thread filho) pode obter esses dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-351">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-352">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-352">This section contains two code examples.</span></span> <span data-ttu-id="04b65-353">O primeiro exemplo mostra como usar um campo que é marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-353">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="04b65-354">O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="04b65-354">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="04b65-355">**Primeiro exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-355">**First Example**</span></span>  
  
 <span data-ttu-id="04b65-356">O exemplo a seguir mostra como usar um campo que é marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-356">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="04b65-357">Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.</span><span class="sxs-lookup"><span data-stu-id="04b65-357">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="04b65-358">**Segundo exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-358">**Second Example**</span></span>  
  
 <span data-ttu-id="04b65-359">O exemplo de código a seguir demonstra como usar um slot de dados para armazenar informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-359">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-360">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-360">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="04b65-361">Armazenamento local de thread: campos estáticos relativos a thread e slots de dados</span><span class="sxs-lookup"><span data-stu-id="04b65-361">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04b65-362">O nome do slot de dados a ser alocado.</span><span class="sxs-lookup"><span data-stu-id="04b65-362">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="04b65-363">Aloca um slot de dados nomeado em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-363">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="04b65-364">Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-364">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="04b65-365">O slot de dados nomeado alocado em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-365">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-366">O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-366">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="04b65-367">Campos estáticos relativos a thread fornecem melhor desempenho que os slots de dados e habilitar a verificação de tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="04b65-367">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="04b65-368">Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-368">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="04b65-369">Threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-369">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="04b65-370">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-370">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="04b65-371">O thread pode alocar um slot de dados no armazenamento de dados, armazene e recupere dados de um valor no slot e liberar o slot para reutilização depois que o thread expira.</span><span class="sxs-lookup"><span data-stu-id="04b65-371">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="04b65-372">Slots de dados são exclusivos por thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-372">Data slots are unique per thread.</span></span> <span data-ttu-id="04b65-373">Nenhum outro thread (nem mesmo um thread filho) pode obter esses dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-373">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="04b65-374">Não é necessário usar o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método para alocar um slot de dados nomeados, porque o <xref:System.Threading.Thread.GetNamedDataSlot%2A> método aloca o slot se ele já não foi alocado.</span><span class="sxs-lookup"><span data-stu-id="04b65-374">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-375">Se o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método é usado, ele deve ser chamado no thread principal na inicialização do programa, pois ele gera uma exceção se um slot com o nome especificado já foi alocado.</span><span class="sxs-lookup"><span data-stu-id="04b65-375">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="04b65-376">Não há nenhuma maneira de testar se um slot já foi alocado.</span><span class="sxs-lookup"><span data-stu-id="04b65-376">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="04b65-377">Slots alocados com esse método devem ser liberados com <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-377">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-378">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-378">This section contains two code examples.</span></span> <span data-ttu-id="04b65-379">O primeiro exemplo mostra como usar um campo que é marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-379">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="04b65-380">O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="04b65-380">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="04b65-381">**Primeiro exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-381">**First Example**</span></span>  
  
 <span data-ttu-id="04b65-382">O exemplo a seguir mostra como usar um campo que é marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-382">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="04b65-383">Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.</span><span class="sxs-lookup"><span data-stu-id="04b65-383">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="04b65-384">**Segundo exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-384">**Second Example**</span></span>  
  
 <span data-ttu-id="04b65-385">O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-385">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-386">O código de exemplo não usa o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método, porque o <xref:System.Threading.Thread.GetNamedDataSlot%2A> método aloca o slot se ele já não foi alocado.</span><span class="sxs-lookup"><span data-stu-id="04b65-386">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="04b65-387">Se o <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método é usado, ele deve ser chamado no thread principal na inicialização do programa.</span><span class="sxs-lookup"><span data-stu-id="04b65-387">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04b65-388">Já existe um slot de dados nomeado com o nome especificado.</span><span class="sxs-lookup"><span data-stu-id="04b65-388">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-389">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-389">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="04b65-390">Armazenamento local de thread: campos estáticos relativos a thread e slots de dados</span><span class="sxs-lookup"><span data-stu-id="04b65-390">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-391">Obtém ou define o estado de apartment desse thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-391">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="04b65-392">Um dos valores de <see cref="T:System.Threading.ApartmentState" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-392">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="04b65-393">O valor inicial é <see langword="Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-393">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-394">**O <xref:System.Threading.Thread.ApartmentState%2A> propriedade está obsoleta.**</span><span class="sxs-lookup"><span data-stu-id="04b65-394">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="04b65-395">As alternativas não obsoleto são as <xref:System.Threading.Thread.GetApartmentState%2A> método para recuperar o estado de apartment e o <xref:System.Threading.Thread.SetApartmentState%2A> método para definir o estado de apartment.</span><span class="sxs-lookup"><span data-stu-id="04b65-395">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="04b65-396">Nas versões do .NET Framework 1.0 e 1.1, o `ApartmentState` propriedade marca um thread para indicar que ela será executada em um apartment de thread único ou vários threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-396">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="04b65-397">Essa propriedade pode ser definida quando o thread está no `Unstarted` ou `Running` thread estado; no entanto, ela pode ser definida apenas uma vez para um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-397">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="04b65-398">Se a propriedade não foi definida, retornará `Unknown`.</span><span class="sxs-lookup"><span data-stu-id="04b65-398">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="04b65-399">Uma tentativa de usar o <xref:System.Threading.Thread.ApartmentState%2A> propriedade para definir o estado de apartment de um thread cujo estado de apartment já foi definido será ignorada.</span><span class="sxs-lookup"><span data-stu-id="04b65-399">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="04b65-400">No entanto, o <xref:System.Threading.Thread.SetApartmentState%2A> método lança um <xref:System.InvalidOperationException> nesse caso.</span><span class="sxs-lookup"><span data-stu-id="04b65-400">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-401">No .NET Framework versão 2.0, novos threads são inicializados como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se seu estado de apartment não tiver sido definido antes que eles são iniciados.</span><span class="sxs-lookup"><span data-stu-id="04b65-401">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="04b65-402">O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> por padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-402">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="04b65-403">Não é possível definir o thread principal do aplicativo como <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> definindo o <xref:System.Threading.ApartmentState?displayProperty=nameWithType> propriedade na primeira linha de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-403">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="04b65-404">Use o <xref:System.STAThreadAttribute> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="04b65-404">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="04b65-405">No .NET Framework versão 2.0, você pode especificar o modelo para um aplicativo C++ usando de threading COM o [/CLRTHREADATTRIBUTE (definir atributo de Thread CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) a opção de vinculador.</span><span class="sxs-lookup"><span data-stu-id="04b65-405">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-406">O exemplo de código a seguir demonstra como definir o estado de apartment de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-406">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04b65-407">É feita uma tentativa de definir esta propriedade para um estado que não é um estado de apartment válido (um estado diferente de <see langword="STA" /> (single-threaded apartment) ou <see langword="MTA" /> (multithreaded apartment)).</span><span class="sxs-lookup"><span data-stu-id="04b65-407">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-408">Notifica um host que a execução está prestes a entrar em uma região de código em que os efeitos de uma exceção sem tratamento ou anulação de thread podem comprometer outras tarefas no domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-408">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-409">Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em regiões críticas e não-críticas do código.</span><span class="sxs-lookup"><span data-stu-id="04b65-409">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="04b65-410">Uma região crítica é um no qual os efeitos de uma anulação de thread ou uma exceção não tratada não podem ser limitados à tarefa atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-410">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="04b65-411">Por outro lado, uma anulação ou uma falha em uma região não-críticas do código afeta apenas a tarefa na qual o erro ocorre.</span><span class="sxs-lookup"><span data-stu-id="04b65-411">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="04b65-412">Por exemplo, considere uma tarefa que tenta alocar memória enquanto mantém um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="04b65-412">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="04b65-413">Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, pois pode haver outras tarefas no domínio aguardando o mesmo bloqueio.</span><span class="sxs-lookup"><span data-stu-id="04b65-413">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="04b65-414">Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.</span><span class="sxs-lookup"><span data-stu-id="04b65-414">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="04b65-415">Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o <xref:System.AppDomain> em vez de correr o risco de continuar a execução em um estado instável.</span><span class="sxs-lookup"><span data-stu-id="04b65-415">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="04b65-416">Para informar o host que seu código está inserindo uma região crítica, chame <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-416">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="04b65-417">Chamar <xref:System.Threading.Thread.EndCriticalRegion%2A> quando a execução retorna para uma região não-críticas do código.</span><span class="sxs-lookup"><span data-stu-id="04b65-417">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="04b65-418">Usando esse método no código que executa o SQL Server 2005 requer o código para ser executado no nível de proteção mais alto do host.</span><span class="sxs-lookup"><span data-stu-id="04b65-418">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-419">O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir um bloco de código em regiões críticas e não críticas.</span><span class="sxs-lookup"><span data-stu-id="04b65-419">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-420">Notifica um host de que o código gerenciado está prestes a executar instruções que dependem da identidade do thread atual do sistema operacional físico.</span><span class="sxs-lookup"><span data-stu-id="04b65-420">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-421">Alguns hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-421">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="04b65-422">Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-422">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="04b65-423">A maioria das tarefas não são afetados por essa alternância.</span><span class="sxs-lookup"><span data-stu-id="04b65-423">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="04b65-424">No entanto, algumas tarefas têm afinidade de thread – ou seja, eles dependem da identidade de um thread de sistema operacional físico.</span><span class="sxs-lookup"><span data-stu-id="04b65-424">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="04b65-425">Essas tarefas devem informar o host quando ele executam o código que não deve ser alternado.</span><span class="sxs-lookup"><span data-stu-id="04b65-425">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="04b65-426">Por exemplo, se seu aplicativo chama uma API de sistema para adquirir um sistema operacional de bloqueio que tem afinidade de thread, como um CRITICAL_SECTION Win32, você deve chamar <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir o bloqueio e <xref:System.Threading.Thread.EndThreadAffinity%2A> após a liberação do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="04b65-426">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="04b65-427">Usando esse método no código que executa o SQL Server 2005 requer o código para ser executado no nível de proteção mais alto do host.</span><span class="sxs-lookup"><span data-stu-id="04b65-427">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-428">O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar um host que um bloco de código depende da identidade de um thread de sistema operacional físico.</span><span class="sxs-lookup"><span data-stu-id="04b65-428">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-429">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-429">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04b65-430">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="04b65-430">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04b65-431">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="04b65-431">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-432">Obtém o contexto atual no qual o thread está em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-432">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="04b65-433">Um <see cref="T:System.Runtime.Remoting.Contexts.Context" /> que representa o contexto do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-433">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-434">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-434">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04b65-435">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="04b65-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04b65-436">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="04b65-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-437">Obtém ou define a cultura do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-437">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="04b65-438">Um objeto que representa a cultura do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-438">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-439">O <xref:System.Globalization.CultureInfo> objeto que é retornado por essa propriedade, junto com seus objetos associados, determinar o formato padrão para datas, horas, números, valores de moeda, a ordenação de texto, convenções de maiusculas e minúsculas e comparações de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="04b65-439">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="04b65-440">Consulte o <xref:System.Globalization.CultureInfo> de classe para saber mais sobre nomes de cultura e identificadores, as diferenças entre culturas invariáveis, neutras e específicas, e as informações de cultura de maneira afetam threads e domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-440">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="04b65-441">Consulte o <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedade para saber como a cultura padrão de um thread é determinada, e como os usuários definir informações de cultura para seus computadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-441">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="04b65-442">O <xref:System.Threading.Thread.CurrentCulture> propriedade não funciona de forma confiável quando usado com qualquer thread diferente do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-442">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="04b65-443">No .NET Framework, a propriedade de leitura é confiável, embora defini-lo em um thread diferente do thread atual não é.</span><span class="sxs-lookup"><span data-stu-id="04b65-443">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="04b65-444">No .NET Core, uma <xref:System.InvalidOperationException> será lançada se um thread tenta ler ou gravar o <xref:System.Threading.Thread.CurrentCulture> propriedade em um thread diferente.</span><span class="sxs-lookup"><span data-stu-id="04b65-444">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="04b65-445">É recomendável que você use o <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> propriedade para recuperar e definir a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-445">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="04b65-446">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], você pode definir o <xref:System.Threading.Thread.CurrentCulture%2A> propriedade para uma cultura neutra.</span><span class="sxs-lookup"><span data-stu-id="04b65-446">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="04b65-447">Isso ocorre porque o comportamento do <xref:System.Globalization.CultureInfo> classe foi alterado: quando ele representa uma cultura neutra, seus valores de propriedade (em particular, o <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, e <xref:System.Globalization.CultureInfo.TextInfo%2A> propriedades) agora reflete a cultura específica que está associada com a cultura neutra.</span><span class="sxs-lookup"><span data-stu-id="04b65-447">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="04b65-448">Em versões anteriores do .NET Framework, o <xref:System.Threading.Thread.CurrentCulture%2A> propriedade gerou um <xref:System.NotSupportedException> exceção quando foi atribuída a uma cultura neutra.</span><span class="sxs-lookup"><span data-stu-id="04b65-448">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="04b65-449">O exemplo a seguir mostra a instrução de threading que permite que a interface do usuário de um aplicativo de formulários do Windows para exibir na cultura que é definida no painel de controle.</span><span class="sxs-lookup"><span data-stu-id="04b65-449">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="04b65-450">Um código adicional é necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-450">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04b65-451">A propriedade é definida como <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-451">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-452">Somente .NET Core: não há suporte para leitura ou gravação da cultura de um thread a partir de outro thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-452">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-453">Para definir a propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-453">for setting the property.</span></span> <span data-ttu-id="04b65-454">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="04b65-454">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-455">Obtém ou define a entidade de segurança atual do thread (para segurança baseada em função).</span><span class="sxs-lookup"><span data-stu-id="04b65-455">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="04b65-456">Um <see cref="T:System.Security.Principal.IPrincipal" /> valor que representa o contexto de segurança.</span><span class="sxs-lookup"><span data-stu-id="04b65-456">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04b65-457">O exemplo de código a seguir mostra como definir e recuperar a entidade de segurança de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-457">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-458">O chamador não tem a permissão necessária para definir a entidade de segurança.</span><span class="sxs-lookup"><span data-stu-id="04b65-458">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-459">para manipular o objeto principal.</span><span class="sxs-lookup"><span data-stu-id="04b65-459">to manipulate the principal object.</span></span> <span data-ttu-id="04b65-460">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-460">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-461">Obtém o thread em execução no momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-461">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="04b65-462">Um <see cref="T:System.Threading.Thread" /> que é a representação do thread em execução no momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-462">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04b65-463">O exemplo a seguir cria uma tarefa que por sua vez cria 20 tarefas de filho.</span><span class="sxs-lookup"><span data-stu-id="04b65-463">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="04b65-464">O aplicativo em si, como bem como cada tarefa, chama o `ShowThreadInformation` método, que usa o <xref:System.Threading.Thread.CurrentThread%2A> propriedade para exibir informações sobre o thread no qual ele está em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-464">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="04b65-465">Cada tarefa filho gera números aleatórios entre 1 e 1 milhão de 1 milhão e retorna sua média.</span><span class="sxs-lookup"><span data-stu-id="04b65-465">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="04b65-466">As chamadas da tarefa pai o <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método para garantir que as tarefas filho tem concluído antes de exibir a média retornada por cada tarefa e calcular a média de significa.</span><span class="sxs-lookup"><span data-stu-id="04b65-466">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="04b65-467">Observe que, enquanto o aplicativo é executado em um thread de primeiro plano, cada tarefa é executada em um pool de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-467">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-468">Obtém ou define a cultura atual usada pelo Gerenciador de Recursos para procurar recursos específicos da cultura em tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-468">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="04b65-469">Um objeto que representa a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-469">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-470">A cultura de interface do usuário Especifica os recursos de um aplicativo precisa para dar suporte à entrada do usuário e a saída e, por padrão é o mesmo que a cultura do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="04b65-470">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="04b65-471">Consulte o <xref:System.Globalization.CultureInfo> de classe para saber mais sobre nomes de cultura e identificadores, as diferenças entre culturas invariáveis, neutras e específicas, e as informações de cultura de maneira afetam threads e domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-471">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="04b65-472">Consulte o <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propriedade para saber como a cultura de interface do usuário do thread padrão é determinada.</span><span class="sxs-lookup"><span data-stu-id="04b65-472">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="04b65-473">O <xref:System.Threading.Thread.CurrentUICulture> propriedade não funciona de forma confiável quando usado com qualquer thread diferente do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-473">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="04b65-474">No .NET Framework, a propriedade de leitura é confiável, embora defini-lo em um thread diferente do thread atual não é.</span><span class="sxs-lookup"><span data-stu-id="04b65-474">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="04b65-475">No .NET Core, uma <xref:System.InvalidOperationException> será lançada se um thread tenta ler ou gravar o <xref:System.Threading.Thread.CurrentUICulture> propriedade em um thread diferente.</span><span class="sxs-lookup"><span data-stu-id="04b65-475">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="04b65-476">É recomendável que você use o <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propriedade para recuperar e definir a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-476">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="04b65-477">O <xref:System.Globalization.CultureInfo> retornado por essa propriedade pode ser uma cultura neutra.</span><span class="sxs-lookup"><span data-stu-id="04b65-477">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="04b65-478">Culturas neutras não devem ser usadas com métodos de formatação, como <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, e <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-478">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-479">Use o <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método para obter uma cultura específica, ou use o <xref:System.Threading.Thread.CurrentCulture%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-479">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-480">O <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método lança <xref:System.ArgumentException> para as culturas neutras "zh-Hant" ("zh-CHT") e "zh-Hans" ("zh-CHS").</span><span class="sxs-lookup"><span data-stu-id="04b65-480">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-481">O exemplo a seguir determina se o idioma da cultura de interface do usuário do thread atual for o francês.</span><span class="sxs-lookup"><span data-stu-id="04b65-481">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="04b65-482">Se não estiver, ele define a cultura de interface do usuário do thread atual para o inglês (Estados Unidos).</span><span class="sxs-lookup"><span data-stu-id="04b65-482">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="04b65-483">O exemplo de código a seguir mostra a instrução de threading que permite que a interface do usuário de um Windows Forms para exibir na cultura que é definida no painel de controle.</span><span class="sxs-lookup"><span data-stu-id="04b65-483">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="04b65-484">Um código adicional é necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-484">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04b65-485">A propriedade é definida como <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-485">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04b65-486">A propriedade é definida como um nome de cultura não pode ser usado para localizar um arquivo de recurso.</span><span class="sxs-lookup"><span data-stu-id="04b65-486">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="04b65-487">Nomes de arquivos de recursos devem incluir somente letras, números, hifens ou sublinhados.</span><span class="sxs-lookup"><span data-stu-id="04b65-487">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-488">Somente .NET Core: não há suporte para leitura ou gravação da cultura de um thread a partir de outro thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-488">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-489">Desativa a limpeza automática de RCWs (Runtime Callable Wrappers) para o thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-489">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-490">Por padrão, o common language runtime (CLR) limpa callable wrappers do tempo de execução automaticamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-490">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="04b65-491">As mensagens de bombas CLR durante a limpeza, o que pode causar problemas de reentrada para alguns aplicativos que atendem aos seguintes critérios incomuns:</span><span class="sxs-lookup"><span data-stu-id="04b65-491">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="04b65-492">O aplicativo faz sua própria bombeamento de mensagens.</span><span class="sxs-lookup"><span data-stu-id="04b65-492">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="04b65-493">O aplicativo precisa controlar precisamente quando o bombeamento de mensagens ocorre.</span><span class="sxs-lookup"><span data-stu-id="04b65-493">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="04b65-494">Esses aplicativos podem usar o <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> método para impedir que o CLR fazendo a recuperação automática do runtime callable wrappers do.</span><span class="sxs-lookup"><span data-stu-id="04b65-494">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="04b65-495">Quando esse método foi chamado em um thread, a limpeza automática não pode ser habilitada novamente para esse thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-495">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="04b65-496">Quando seu aplicativo está pronto para limpar callable wrappers do tempo de execução, use o <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> método para instruir o tempo de execução para limpar todos os invólucros de tempo de execução que pode ser chamado no contexto atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-496">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="04b65-497">Bombeamento de mensagens ocorre enquanto o método é executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-497">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04b65-498">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="04b65-498">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04b65-499">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="04b65-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-500">Notifica um host de que a execução está prestes a entrar em uma região de código na qual os efeitos de uma exceção sem tratamento ou anulação de thread estão limitados à tarefa atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-500">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-501">Hosts do common language runtime (CLR), como o Microsoft SQL Server 2005, podem estabelecer políticas diferentes para falhas em regiões críticas e não-críticas do código.</span><span class="sxs-lookup"><span data-stu-id="04b65-501">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="04b65-502">Uma região crítica é um no qual os efeitos de uma anulação de thread ou uma exceção não tratada não podem ser limitados à tarefa atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-502">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="04b65-503">Por outro lado, uma anulação ou uma falha em uma região não-críticas do código afeta apenas a tarefa na qual o erro ocorre.</span><span class="sxs-lookup"><span data-stu-id="04b65-503">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="04b65-504">Por exemplo, considere uma tarefa que tenta alocar memória enquanto mantém um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="04b65-504">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="04b65-505">Se a alocação de memória falhar, anulando a tarefa atual não é suficiente para garantir a estabilidade do <xref:System.AppDomain>, pois pode haver outras tarefas no domínio aguardando o mesmo bloqueio.</span><span class="sxs-lookup"><span data-stu-id="04b65-505">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="04b65-506">Se a tarefa atual for encerrada, outras tarefas podem ser bloqueadas.</span><span class="sxs-lookup"><span data-stu-id="04b65-506">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="04b65-507">Quando ocorre uma falha em uma região crítica, o host pode decidir descarregar todo o <xref:System.AppDomain> em vez de correr o risco de continuar a execução em um estado instável.</span><span class="sxs-lookup"><span data-stu-id="04b65-507">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="04b65-508">Para informar o host que seu código está inserindo uma região crítica, chame <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-508">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="04b65-509">Chamar <xref:System.Threading.Thread.EndCriticalRegion%2A> quando a execução retorna para uma região não-críticas do código.</span><span class="sxs-lookup"><span data-stu-id="04b65-509">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="04b65-510">Usando esse método no código que executa o SQL Server 2005 requer o código para ser executado no nível de proteção mais alto do host.</span><span class="sxs-lookup"><span data-stu-id="04b65-510">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-511">O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir um bloco de código em regiões críticas e não críticas.</span><span class="sxs-lookup"><span data-stu-id="04b65-511">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-512">Notifica um host que o código gerenciado terminou de executar as instruções que dependem da identidade do thread do sistema operacional físico atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-512">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-513">Alguns hosts do common language runtime, como o Microsoft SQL Server 2005, fornecem seu próprio gerenciamento de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-513">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="04b65-514">Um host que fornece seu próprio gerenciamento de threads pode mover uma tarefa de execução de um thread de sistema operacional físico para outro a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="04b65-514">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="04b65-515">A maioria das tarefas não são afetados por essa alternância.</span><span class="sxs-lookup"><span data-stu-id="04b65-515">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="04b65-516">No entanto, algumas tarefas têm afinidade de thread – ou seja, eles dependem da identidade de um thread de sistema operacional físico.</span><span class="sxs-lookup"><span data-stu-id="04b65-516">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="04b65-517">Essas tarefas devem informar o host quando ele executam o código que não deve ser alternado.</span><span class="sxs-lookup"><span data-stu-id="04b65-517">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="04b65-518">Por exemplo, se seu aplicativo chama uma API de sistema para adquirir um sistema operacional de bloqueio que tem afinidade de thread, como um CRITICAL_SECTION Win32, você deve chamar <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir o bloqueio e <xref:System.Threading.Thread.EndThreadAffinity%2A> após a liberação do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="04b65-518">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="04b65-519">Usando esse método no código que executa o SQL Server 2005 requer o código para ser executado no nível de proteção mais alto do host.</span><span class="sxs-lookup"><span data-stu-id="04b65-519">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-520">O exemplo a seguir demonstra o uso do <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar um host que um bloco de código depende da identidade de um thread de sistema operacional físico.</span><span class="sxs-lookup"><span data-stu-id="04b65-520">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-521">O chamador não tem a permissão necessária.</span><span class="sxs-lookup"><span data-stu-id="04b65-521">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04b65-522">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="04b65-522">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04b65-523">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="04b65-523">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-524">Obtém um objeto <see cref="T:System.Threading.ExecutionContext" /> que contém informações sobre os diversos contextos do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-524">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="04b65-525">Um objeto <see cref="T:System.Threading.ExecutionContext" /> que consolida as informações de contexto para o thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-525">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-526">O <xref:System.Threading.ExecutionContext> classe fornece um único contêiner para todas as informações relevantes para um segmento lógico de execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-526">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="04b65-527">Isso inclui o contexto de segurança, chamada de contexto, contexto de sincronização, contexto de localização e o contexto de transação.</span><span class="sxs-lookup"><span data-stu-id="04b65-527">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-528">Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-528">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-529">O coletor de lixo chama <xref:System.Threading.Thread.Finalize%2A> quando o objeto atual está pronto para ser finalizado.</span><span class="sxs-lookup"><span data-stu-id="04b65-529">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04b65-530">O nome do slot de dados a ser liberado.</span><span class="sxs-lookup"><span data-stu-id="04b65-530">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="04b65-531">Elimina a associação entre um nome e um slot em todos os threads do processo.</span><span class="sxs-lookup"><span data-stu-id="04b65-531">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="04b65-532">Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-532">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-533">O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-533">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="04b65-534">Campos estáticos relativos a thread fornecem melhor desempenho que os slots de dados e habilitar a verificação de tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="04b65-534">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="04b65-535">Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-535">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="04b65-536">Depois que o thread chamar `FreeNamedDataSlot`, outro thread que chama <xref:System.Threading.Thread.GetNamedDataSlot%2A> com o mesmo nome será alocar um novo slot associado ao nome.</span><span class="sxs-lookup"><span data-stu-id="04b65-536">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="04b65-537">As chamadas subsequentes para `GetNamedDataSlot` por qualquer thread retornará o novo slot.</span><span class="sxs-lookup"><span data-stu-id="04b65-537">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="04b65-538">No entanto, qualquer thread que ainda tem um <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> retornado por uma chamada anterior para `GetNamedDataSlot` pode continuar a usar o slot antigo.</span><span class="sxs-lookup"><span data-stu-id="04b65-538">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="04b65-539">Um slot que tenha sido associado um nome é liberado apenas quando cada `LocalDataStoreSlot` que foi obtida antes da chamada a `FreeNamedDataSlot` foi lançado e coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="04b65-539">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="04b65-540">Threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-540">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="04b65-541">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-541">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="04b65-542">O thread pode alocar um slot de dados no armazenamento de dados, armazene e recupere dados de um valor no slot e liberar o slot para reutilização depois que o thread expira.</span><span class="sxs-lookup"><span data-stu-id="04b65-542">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="04b65-543">Slots de dados são exclusivos por thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-543">Data slots are unique per thread.</span></span> <span data-ttu-id="04b65-544">Nenhum outro thread (nem mesmo um thread filho) pode obter esses dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-544">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-545">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-545">This section contains two code examples.</span></span> <span data-ttu-id="04b65-546">O primeiro exemplo mostra como usar um campo que é marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-546">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="04b65-547">O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="04b65-547">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="04b65-548">**Primeiro exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-548">**First Example**</span></span>  
  
 <span data-ttu-id="04b65-549">O exemplo a seguir mostra como usar um campo que é marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-549">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="04b65-550">Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.</span><span class="sxs-lookup"><span data-stu-id="04b65-550">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="04b65-551">**Segundo exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-551">**Second Example**</span></span>  
  
 <span data-ttu-id="04b65-552">O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-552">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-553">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-553">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="04b65-554">Armazenamento local de thread: campos estáticos relativos a thread e slots de dados</span><span class="sxs-lookup"><span data-stu-id="04b65-554">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-555">Retorna um valor <see cref="T:System.Threading.ApartmentState" /> que indica o estado do apartment.</span><span class="sxs-lookup"><span data-stu-id="04b65-555">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="04b65-556">Um dos valores <see cref="T:System.Threading.ApartmentState" /> que indica o estado do apartment do thread gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-556">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="04b65-557">O padrão é <see cref="F:System.Threading.ApartmentState.Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-557">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-558">Esse método, juntamente com o <xref:System.Threading.Thread.SetApartmentState%2A> método e o <xref:System.Threading.Thread.TrySetApartmentState%2A> substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-558">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-559">O exemplo de código a seguir demonstra os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-559">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="04b65-560">O exemplo de código cria um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-560">The code example creates a thread.</span></span> <span data-ttu-id="04b65-561">Antes do thread é iniciado, <xref:System.Threading.Thread.GetApartmentState%2A> exibe a inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado e <xref:System.Threading.Thread.SetApartmentState%2A> altera o estado para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-561">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-562">O <xref:System.Threading.Thread.TrySetApartmentState%2A> , em seguida, o método retornará `false` durante a tentativa de alterar o estado para <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque o estado de apartment já está definido.</span><span class="sxs-lookup"><span data-stu-id="04b65-562">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="04b65-563">Se a mesma operação tivesse sido tentada com <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> seria ter sido lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-563">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="04b65-564">Depois que o thread é iniciado, o <xref:System.Threading.Thread.TrySetApartmentState%2A> método é usado novamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-564">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="04b65-565">Desta vez, ele gera <xref:System.Threading.ThreadStateException> porque o thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-565">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-566">Retorna um objeto <see cref="T:System.Threading.CompressedStack" /> que pode ser usado para capturar a pilha do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-566">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="04b65-567">nenhuma.</span><span class="sxs-lookup"><span data-stu-id="04b65-567">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-568">Esse método não é mais suportado.</span><span class="sxs-lookup"><span data-stu-id="04b65-568">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-569">Em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="04b65-569">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04b65-570">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="04b65-570">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04b65-571">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="04b65-571">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="04b65-572">O <see cref="T:System.LocalDataStoreSlot" /> do qual o valor deve ser obtido.</span><span class="sxs-lookup"><span data-stu-id="04b65-572">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="04b65-573">Recupera o valor do slot especificado no thread atual, no domínio atual do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-573">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="04b65-574">Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-574">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="04b65-575">O valor recuperado.</span><span class="sxs-lookup"><span data-stu-id="04b65-575">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-576">O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-576">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="04b65-577">Campos estáticos relativos a thread fornecem melhor desempenho que os slots de dados e habilitar a verificação de tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="04b65-577">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="04b65-578">Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-578">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="04b65-579">Threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-579">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="04b65-580">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-580">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="04b65-581">O thread pode alocar um slot de dados no armazenamento de dados, armazene e recupere dados de um valor no slot e liberar o slot para reutilização depois que o thread expira.</span><span class="sxs-lookup"><span data-stu-id="04b65-581">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="04b65-582">Slots de dados são exclusivos por thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-582">Data slots are unique per thread.</span></span> <span data-ttu-id="04b65-583">Nenhum outro thread (nem mesmo um thread filho) pode obter esses dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-583">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-584"><xref:System.Threading.Thread.GetData%2A> é um `Shared` método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-584"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="04b65-585">Para evitar confusão, use o nome de classe ao chamar `Shared` métodos: `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="04b65-585">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-586">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-586">This section contains two code examples.</span></span> <span data-ttu-id="04b65-587">O primeiro exemplo mostra como usar um campo que é marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-587">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="04b65-588">O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="04b65-588">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="04b65-589">**Primeiro exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-589">**First Example**</span></span>  
  
 <span data-ttu-id="04b65-590">O exemplo a seguir mostra como usar um campo que é marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-590">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="04b65-591">Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.</span><span class="sxs-lookup"><span data-stu-id="04b65-591">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="04b65-592">**Segundo exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-592">**Second Example**</span></span>  
  
 <span data-ttu-id="04b65-593">O exemplo a seguir demonstra como usar um slot de dados para armazenar informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-593">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-594">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-594">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="04b65-595">Armazenamento local de thread: campos estáticos relativos a thread e slots de dados</span><span class="sxs-lookup"><span data-stu-id="04b65-595">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-596">Retorna o domínio atual no qual o thread atual está em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-596">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="04b65-597">Um <see cref="T:System.AppDomain" /> que representa o domínio de aplicativo atual do thread em execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-597">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04b65-598">O exemplo de código a seguir mostra como recuperar o nome e ID do `AppDomain` no qual o thread está sendo executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-598">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-599">Retorna um identificador de domínio do aplicativo exclusivo.</span><span class="sxs-lookup"><span data-stu-id="04b65-599">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="04b65-600">Um inteiro com sinal de 32 bits que identifica exclusivamente o domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-600">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04b65-601">O exemplo de código a seguir mostra como recuperar o nome e ID do `AppDomain` no qual o thread está sendo executado.</span><span class="sxs-lookup"><span data-stu-id="04b65-601">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-602">Retorna um código hash para o thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-602">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="04b65-603">Um valor inteiro de código hash.</span><span class="sxs-lookup"><span data-stu-id="04b65-603">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-604">O código de hash não é garantido para ser exclusivo.</span><span class="sxs-lookup"><span data-stu-id="04b65-604">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="04b65-605">Use o <xref:System.Threading.Thread.ManagedThreadId%2A> propriedade se precisar de um identificador exclusivo para um thread gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-605">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04b65-606">O nome do slot de dados local.</span><span class="sxs-lookup"><span data-stu-id="04b65-606">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="04b65-607">Pesquisa um slot de dados nomeado.</span><span class="sxs-lookup"><span data-stu-id="04b65-607">Looks up a named data slot.</span></span> <span data-ttu-id="04b65-608">Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-608">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="04b65-609">Um <see cref="T:System.LocalDataStoreSlot" /> alocado para este thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-609">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-610">O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-610">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="04b65-611">Campos estáticos relativos a thread fornecem melhor desempenho que os slots de dados e habilitar a verificação de tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="04b65-611">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="04b65-612">Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-612">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="04b65-613">Threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-613">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="04b65-614">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-614">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="04b65-615">O thread pode alocar um slot de dados no armazenamento de dados, armazene e recupere dados de um valor no slot e liberar o slot para reutilização depois que o thread expira.</span><span class="sxs-lookup"><span data-stu-id="04b65-615">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="04b65-616">Slots de dados são exclusivos por thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-616">Data slots are unique per thread.</span></span> <span data-ttu-id="04b65-617">Nenhum outro thread (nem mesmo um thread filho) pode obter esses dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-617">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="04b65-618">Se o slot nomeado não existir, um novo slot é alocado.</span><span class="sxs-lookup"><span data-stu-id="04b65-618">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="04b65-619">Slots de dados nomeados são públicos e podem ser manipulados por qualquer pessoa.</span><span class="sxs-lookup"><span data-stu-id="04b65-619">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-620">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-620">This section contains two code examples.</span></span> <span data-ttu-id="04b65-621">O primeiro exemplo mostra como usar um campo que é marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-621">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="04b65-622">O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="04b65-622">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="04b65-623">**Primeiro exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-623">**First Example**</span></span>  
  
 <span data-ttu-id="04b65-624">O exemplo a seguir mostra como usar um campo que é marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-624">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="04b65-625">Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.</span><span class="sxs-lookup"><span data-stu-id="04b65-625">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="04b65-626">**Segundo exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-626">**Second Example**</span></span>  
  
 <span data-ttu-id="04b65-627">O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-627">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-628">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-628">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="04b65-629">Armazenamento local de thread: campos estáticos relativos a thread e slots de dados</span><span class="sxs-lookup"><span data-stu-id="04b65-629">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-630">Interrompe um thread que está no estado de thread <see langword="WaitSleepJoin" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-630">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-631">Se esse thread não está bloqueado no momento em um estado de junção, de suspensão ou de espera, ele será interrompido quando, em seguida, ele começa a bloquear a.</span><span class="sxs-lookup"><span data-stu-id="04b65-631">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="04b65-632"><xref:System.Threading.ThreadInterruptedException> é lançada no thread interrompido, mas não até os blocos de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-632"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="04b65-633">Se o thread nunca for bloqueado, a exceção nunca seja gerada e, portanto, o thread pode ser concluída sem nunca ser interrompido.</span><span class="sxs-lookup"><span data-stu-id="04b65-633">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-634">O exemplo de código a seguir mostra o comportamento de um thread em execução quando ele é interrompido e, posteriormente, for bloqueado.</span><span class="sxs-lookup"><span data-stu-id="04b65-634">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-635">O chamador não tem o <see cref="T:System.Security.Permissions.SecurityPermission" /> apropriado.</span><span class="sxs-lookup"><span data-stu-id="04b65-635">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-636">operações avançadas em threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-636">for advanced operations on threads.</span></span> <span data-ttu-id="04b65-637">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-637">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="04b65-638">Pausando e interrompendo threads</span><span class="sxs-lookup"><span data-stu-id="04b65-638">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-639">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-639">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-640">Obtém um valor que indica o status de execução do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-640">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="04b65-641"><see langword="true" /> se esse thread foi iniciado e não foi terminado normalmente ou foi anulado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-641"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-642">Obtém ou define um valor que indica se um thread é ou não um thread de segundo plano.</span><span class="sxs-lookup"><span data-stu-id="04b65-642">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="04b65-643"><see langword="true" /> se esse thread for um thread de segundo plano ou for se tornar um; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-643"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-644">Um thread é um thread em segundo plano ou um thread de primeiro plano.</span><span class="sxs-lookup"><span data-stu-id="04b65-644">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="04b65-645">Threads em segundo plano são idênticos aos threads de primeiro plano, exceto que os threads em segundo plano não impedem que um processo de encerramento.</span><span class="sxs-lookup"><span data-stu-id="04b65-645">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="04b65-646">Após tem terminado e todos os threads de primeiro plano que pertencem a um processo, o common language runtime finaliza o processo.</span><span class="sxs-lookup"><span data-stu-id="04b65-646">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="04b65-647">Os threads em segundo plano restantes são interrompidos e não forem concluídas.</span><span class="sxs-lookup"><span data-stu-id="04b65-647">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="04b65-648">Por padrão, os seguintes threads executam em primeiro plano (ou seja, seus <xref:System.Threading.Thread.IsBackground%2A> propriedade retorna `false`):</span><span class="sxs-lookup"><span data-stu-id="04b65-648">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="04b65-649">O thread primário (ou thread principal do aplicativo).</span><span class="sxs-lookup"><span data-stu-id="04b65-649">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="04b65-650">Todos os threads criados chamando uma <xref:System.Threading.Thread> construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-650">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="04b65-651">Por padrão, os seguintes threads são executados em segundo plano (ou seja, seus <xref:System.Threading.Thread.IsBackground%2A> propriedade retorna `true`):</span><span class="sxs-lookup"><span data-stu-id="04b65-651">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="04b65-652">Thread do pool de threads, que são um pool de threads de trabalho mantido pelo tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-652">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="04b65-653">Você pode configurar o trabalho de threads de pool e o agendamento em threads do pool usando o <xref:System.Threading.ThreadPool> classe.</span><span class="sxs-lookup"><span data-stu-id="04b65-653">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="04b65-654">Operações assíncronas baseadas em tarefa executar automaticamente em threads do pool.</span><span class="sxs-lookup"><span data-stu-id="04b65-654">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="04b65-655">Todos os threads que entram no ambiente de execução gerenciado do código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-655">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-656">O exemplo a seguir compara o comportamento de threads de primeiro plano e plano de fundo.</span><span class="sxs-lookup"><span data-stu-id="04b65-656">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="04b65-657">Ele cria um thread de primeiro plano e um thread em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="04b65-657">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="04b65-658">O thread de primeiro plano mantém o processo em execução até conclui seu `for` loop e será encerrado.</span><span class="sxs-lookup"><span data-stu-id="04b65-658">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="04b65-659">No entanto, como mostra a saída do exemplo, porque o thread de primeiro plano terminou de execução, o processo será encerrado antes da execução do thread de segundo plano foi concluída.</span><span class="sxs-lookup"><span data-stu-id="04b65-659">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-660">O thread está inativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-660">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="04b65-661">Threads em primeiro plano e em segundo plano</span><span class="sxs-lookup"><span data-stu-id="04b65-661">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-662">Obtém um valor que indica se um thread pertence ao pool de threads gerenciados ou não.</span><span class="sxs-lookup"><span data-stu-id="04b65-662">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="04b65-663"><see langword="true" /> se esse thread pertence ao pool de threads gerenciados; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-663"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-664">Para obter mais informações, consulte [pool de threads gerenciados](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-664">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-665">O exemplo de código a seguir mostra como determinar se um thread é do pool de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-665">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="04b65-666">O pool de threads gerenciados</span><span class="sxs-lookup"><span data-stu-id="04b65-666">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-667">Bloqueia o thread de chamada até que o thread representado por esta instância seja encerrado.</span><span class="sxs-lookup"><span data-stu-id="04b65-667">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-668">Bloqueia o thread de chamada até que o thread representado por essa instância termine, enquanto continua a executar COM padrão e o bombeamento de <see langword="SendMessage" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-668">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-669"><xref:System.Threading.Thread.Join%2A> é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até que o thread cujo <xref:System.Threading.Thread.Join%2A> método é chamado foi concluída.</span><span class="sxs-lookup"><span data-stu-id="04b65-669"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="04b65-670">Use esse método para garantir que um thread foi encerrado.</span><span class="sxs-lookup"><span data-stu-id="04b65-670">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="04b65-671">O chamador será bloqueado indefinidamente se o thread não terminar.</span><span class="sxs-lookup"><span data-stu-id="04b65-671">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="04b65-672">No exemplo a seguir, o `Thread1` thread chamar o <xref:System.Threading.Thread.Join> método de `Thread2`, que faz com que `Thread1` para bloquear até `Thread2` foi concluída.</span><span class="sxs-lookup"><span data-stu-id="04b65-672">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="04b65-673">Se o thread já tiver sido encerrado quando <xref:System.Threading.Thread.Join%2A> é chamado, o método retornará imediatamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-673">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="04b65-674">Você nunca deve chamar o <xref:System.Threading.Thread.Join%2A> método da <xref:System.Threading.Thread> objeto que representa o thread atual do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-674">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="04b65-675">Isso faz com que seu aplicativo parar de responder porque o thread atual espera indefinidamente, em si mesmo</span><span class="sxs-lookup"><span data-stu-id="04b65-675">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="04b65-676">Esse método altera o estado do thread de chamada para incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-676">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-677">Você não pode invocar `Join` em um thread que está no <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.</span><span class="sxs-lookup"><span data-stu-id="04b65-677">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-678">O chamador tentou ingressar em um thread que está no estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-678">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="04b65-679">O thread é interrompido enquanto espera.</span><span class="sxs-lookup"><span data-stu-id="04b65-679">The thread is interrupted while waiting.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-680">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-680">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="04b65-681">O número de milissegundos para espera pelo encerramento do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-681">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="04b65-682">Bloqueia o thread de chamada até que o thread representado por essa instância termine ou até que o tempo especificado tenha decorrido, enquanto continua executando o COM padrão e o bombeamento de SendMessage.</span><span class="sxs-lookup"><span data-stu-id="04b65-682">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="04b65-683"><see langword="true" /> se o thread tiver sido encerrado; <see langword="false" /> se o thread não tiver sido encerrado depois que o tempo especificado pelo parâmetro <paramref name="millisecondsTimeout" /> tiver decorrido.</span><span class="sxs-lookup"><span data-stu-id="04b65-683"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-684"><xref:System.Threading.Thread.Join%28System.Int32%29> é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até qualquer thread cujo <xref:System.Threading.Thread.Join%2A> método é chamado foi concluído ou o intervalo de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="04b65-684"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="04b65-685">No exemplo a seguir, o `Thread1` thread chamar o <xref:System.Threading.Thread.Join> método `Thread2`, que faz com que `Thread1` para bloquear até que `Thread2` foi concluída ou 2 segundos decorridos.</span><span class="sxs-lookup"><span data-stu-id="04b65-685">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="04b65-686">Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for especificado para o `millisecondsTimeout` parâmetro, que esse método se comporta de forma idêntica ao <xref:System.Threading.Thread.Join> sobrecarga de método, exceto para o valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="04b65-686">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="04b65-687">Se o thread já tiver sido encerrado quando <xref:System.Threading.Thread.Join%2A> é chamado, o método retornará imediatamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-687">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="04b65-688">Esse método altera o estado do thread de chamada para incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-688">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-689">Você não pode invocar `Join` em um thread que está no <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.</span><span class="sxs-lookup"><span data-stu-id="04b65-689">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04b65-690">O valor de <paramref name="millisecondsTimeout" /> será negativo e não será igual a <see cref="F:System.Threading.Timeout.Infinite" /> em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="04b65-690">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-691">O thread não foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-691">The thread has not been started.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-692">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-692">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="04b65-693">Um <see cref="T:System.TimeSpan" /> definido como a quantidade de tempo de espera até a conclusão do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-693">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="04b65-694">Bloqueia o thread de chamada até que o thread representado por essa instância termine ou até que o tempo especificado tenha decorrido, enquanto continua executando o COM padrão e o bombeamento de SendMessage.</span><span class="sxs-lookup"><span data-stu-id="04b65-694">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="04b65-695"><see langword="true" /> se o thread tiver sido encerrado; <see langword="false" /> se o thread não tiver sido encerrado depois que o período especificado pelo parâmetro <paramref name="timeout" /> tiver decorrido.</span><span class="sxs-lookup"><span data-stu-id="04b65-695"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-696"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> é um método de sincronização que bloqueia o thread de chamada (ou seja, o thread que chama o método) até qualquer thread cujo <xref:System.Threading.Thread.Join%2A> método é chamado foi concluído ou o intervalo de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="04b65-696"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="04b65-697">No exemplo a seguir, o `Thread1` thread chamar o <xref:System.Threading.Thread.Join> método `Thread2`, que faz com que `Thread1` para bloquear até que `Thread2` foi concluída ou 2 segundos decorridos.</span><span class="sxs-lookup"><span data-stu-id="04b65-697">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="04b65-698">Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for especificado para `timeout`, esse método se comporta de forma idêntica ao <xref:System.Threading.Thread.Join> sobrecarga de método, exceto para o valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="04b65-698">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="04b65-699">Se o thread já tiver sido encerrado quando <xref:System.Threading.Thread.Join%2A> é chamado, o método retornará imediatamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-699">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="04b65-700">Esse método altera o estado do thread atual para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="04b65-700">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="04b65-701">Você não pode invocar `Join` em um thread que está no <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.</span><span class="sxs-lookup"><span data-stu-id="04b65-701">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-702">O exemplo de código a seguir demonstra como usar um `TimeSpan` valor com o `Join` método.</span><span class="sxs-lookup"><span data-stu-id="04b65-702">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04b65-703">O valor de <paramref name="timeout" /> será negativo e não será igual a <see cref="F:System.Threading.Timeout.Infinite" /> em milissegundos, ou será maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</span><span class="sxs-lookup"><span data-stu-id="04b65-703">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-704">O chamador tentou ingressar em um thread que está no estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-704">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-705">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-705">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-706">Obtém um identificador exclusivo para o thread gerenciado atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-706">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="04b65-707">Um inteiro que representa um identificador exclusivo para esse thread gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-707">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-708">Um thread <xref:System.Threading.Thread.ManagedThreadId%2A> valor da propriedade serve para identificar exclusivamente esse thread dentro de seu processo.</span><span class="sxs-lookup"><span data-stu-id="04b65-708">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="04b65-709">O valor da <xref:System.Threading.Thread.ManagedThreadId%2A> propriedade varia ao longo do tempo, mesmo se o código não gerenciado que hospeda o common language runtime implementa o thread como uma fibra.</span><span class="sxs-lookup"><span data-stu-id="04b65-709">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-710">Sincroniza o acesso à memória da seguinte maneira: o processador que executa o thread atual não pode reorganizar as instruções de forma que os acessos à memória antes da chamada a <see cref="M:System.Threading.Thread.MemoryBarrier" /> sejam executados após os acessos de memória que seguem a chamada a <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-710">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-711"><xref:System.Threading.Thread.MemoryBarrier%2A> é necessária somente em sistemas multiprocessadores com memória fraca ordenação (por exemplo, um sistema empregando vários processadores Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="04b65-711"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="04b65-712">Para a maioria das finalidades, o c# `lock` instrução, o Visual Basic `SyncLock` instrução, ou o <xref:System.Threading.Monitor> classe fornecem maneiras mais fáceis para sincronizar os dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-712">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-713">Obtém ou define o nome do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-713">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="04b65-714">Uma cadeia de caracteres que contém o nome do thread, ou <see langword="null" />, se nenhum nome foi definido.</span><span class="sxs-lookup"><span data-stu-id="04b65-714">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-715">Esta propriedade é gravação-depois.</span><span class="sxs-lookup"><span data-stu-id="04b65-715">This property is write-once.</span></span> <span data-ttu-id="04b65-716">Porque o valor padrão de um thread <xref:System.Threading.Thread.Name%2A> é de propriedade `null`, você pode determinar se um nome já foi explicitamente atribuído ao thread, comparando-o com `null`.</span><span class="sxs-lookup"><span data-stu-id="04b65-716">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="04b65-717">A cadeia de caracteres atribuída para o <xref:System.Threading.Thread.Name%2A> propriedade pode incluir qualquer caractere Unicode.</span><span class="sxs-lookup"><span data-stu-id="04b65-717">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-718">O exemplo a seguir mostra como nomear um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-718">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-719">Foi solicitada uma operação de conjuntos, mas a propriedade <see langword="Name" /> já foi definida.</span><span class="sxs-lookup"><span data-stu-id="04b65-719">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-720">Obtém ou define um valor que indica a prioridade de agendamento de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-720">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="04b65-721">Um dos valores de <see cref="T:System.Threading.ThreadPriority" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-721">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="04b65-722">O valor padrão é <see cref="F:System.Threading.ThreadPriority.Normal" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-722">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-723">Um thread pode ser atribuído a qualquer um dos seguinte prioridade <xref:System.Threading.ThreadPriority> valores:</span><span class="sxs-lookup"><span data-stu-id="04b65-723">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="04b65-724">Sistemas operacionais não devem honrar a prioridade de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-724">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-725">O exemplo a seguir mostra o resultado da alteração da prioridade de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-725">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="04b65-726">Três threads são criados, a prioridade de um thread é definida como <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, e a prioridade de segundo é definida como <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-726">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-727">Cada thread incrementa uma variável em um `while` loop e é executada por um período de tempo.</span><span class="sxs-lookup"><span data-stu-id="04b65-727">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-728">O thread atingiu um estado final, como <see cref="F:System.Threading.ThreadState.Aborted" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-728">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04b65-729">O valor especificado para uma operação definida não é um valor <see cref="T:System.Threading.ThreadPriority" /> válido.</span><span class="sxs-lookup"><span data-stu-id="04b65-729">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="04b65-730">Agendando threads</span><span class="sxs-lookup"><span data-stu-id="04b65-730">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-731">Cancela um <see cref="M:System.Threading.Thread.Abort(System.Object)" /> solicitado para o thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-731">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-732">Esse método só pode ser chamado por código com as permissões adequadas.</span><span class="sxs-lookup"><span data-stu-id="04b65-732">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="04b65-733">Quando é feita uma chamada para `Abort` para encerrar um thread, o sistema gera um <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="04b65-733">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="04b65-734">`ThreadAbortException` é uma exceção especial que pode ser capturada pelo código do aplicativo, mas será gerada novamente no final do bloco catch, a menos que `ResetAbort` é chamado.</span><span class="sxs-lookup"><span data-stu-id="04b65-734">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="04b65-735">`ResetAbort` Cancela a solicitação ser anulada e impede que o `ThreadAbortException` de finalizar o thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-735">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="04b65-736">Ver <xref:System.Threading.ThreadAbortException> para obter um exemplo que demonstra a chamada a `ResetAbort` método.</span><span class="sxs-lookup"><span data-stu-id="04b65-736">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="04b65-737">Somente .NET Core: esse membro não é compatível.</span><span class="sxs-lookup"><span data-stu-id="04b65-737">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-738"><see langword="Abort" /> não foi invocado no thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-738"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-739">O chamador não tem a permissão de segurança necessária para o thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-739">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-740">operações avançadas em threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-740">for advanced operations on threads.</span></span> <span data-ttu-id="04b65-741">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-741">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="04b65-742">Destruindo threads</span><span class="sxs-lookup"><span data-stu-id="04b65-742">Destroying threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-743">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-743">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-744">Retoma um thread que foi suspenso.</span><span class="sxs-lookup"><span data-stu-id="04b65-744">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="04b65-745">Não use o <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar as atividades de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-745">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="04b65-746">Você não tem como saber qual código de um thread está em execução quando você suspendê-lo.</span><span class="sxs-lookup"><span data-stu-id="04b65-746">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="04b65-747">Se você suspender um thread enquanto mantém o bloqueio durante uma avaliação da permissão de segurança, outros threads no <xref:System.AppDomain> poderá ser bloqueado.</span><span class="sxs-lookup"><span data-stu-id="04b65-747">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="04b65-748">Se você suspender um thread enquanto ele está em execução em um construtor de classe, outros threads no <xref:System.AppDomain> que tentar usar que a classe estão bloqueadas.</span><span class="sxs-lookup"><span data-stu-id="04b65-748">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="04b65-749">Os deadlocks podem ocorrer com muita facilidade.</span><span class="sxs-lookup"><span data-stu-id="04b65-749">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="04b65-750">Somente .NET Core: esse membro não é compatível.</span><span class="sxs-lookup"><span data-stu-id="04b65-750">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-751">O thread não foi iniciado, está inativo ou não está no estado suspenso.</span><span class="sxs-lookup"><span data-stu-id="04b65-751">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-752">O chamador não tem o <see cref="T:System.Security.Permissions.SecurityPermission" /> apropriado.</span><span class="sxs-lookup"><span data-stu-id="04b65-752">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-753">operações avançadas em threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-753">for advanced operations on threads.</span></span> <span data-ttu-id="04b65-754">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="04b65-754">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="04b65-755">Pausando e interrompendo threads</span><span class="sxs-lookup"><span data-stu-id="04b65-755">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-756">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-756">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="04b65-757">O novo estado de apartment.</span><span class="sxs-lookup"><span data-stu-id="04b65-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="04b65-758">Define o estado do apartment de um thread antes que ele seja iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-759">Novos threads são inicializados como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se seu estado de apartment não tiver sido definido antes que eles são iniciados.</span><span class="sxs-lookup"><span data-stu-id="04b65-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="04b65-760">Estado de apartment deve ser definido antes que um thread é iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-761">O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> por padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="04b65-762">A única maneira de definir o estado de apartment do thread principal do aplicativo para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> é aplicar o <xref:System.STAThreadAttribute> atributo ao método de ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="04b65-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="04b65-763">O <xref:System.Threading.Thread.SetApartmentState%2A> método, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A> método e o <xref:System.Threading.Thread.TrySetApartmentState%2A> substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-764">O exemplo de código a seguir demonstra os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="04b65-765">O exemplo de código cria um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-765">The code example creates a thread.</span></span> <span data-ttu-id="04b65-766">Antes do thread é iniciado, <xref:System.Threading.Thread.GetApartmentState%2A> exibe a inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado e <xref:System.Threading.Thread.SetApartmentState%2A> altera o estado para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-767">O <xref:System.Threading.Thread.TrySetApartmentState%2A> , em seguida, o método retornará `false` durante a tentativa de alterar o estado para <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque o estado de apartment já está definido.</span><span class="sxs-lookup"><span data-stu-id="04b65-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="04b65-768">Se a mesma operação tivesse sido tentada com <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> seria ter sido lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="04b65-769">Depois que o thread é iniciado, o <xref:System.Threading.Thread.TrySetApartmentState%2A> método é usado novamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="04b65-770">Desta vez, ele gera <xref:System.Threading.ThreadStateException> porque o thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="04b65-771">Somente .NET Core: esse membro não é compatível com as plataformas macOS e Linux.</span><span class="sxs-lookup"><span data-stu-id="04b65-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04b65-772"><paramref name="state" /> não é um estado de apartment válido.</span><span class="sxs-lookup"><span data-stu-id="04b65-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-773">O thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-774">O estado de apartment já foi inicializado.</span><span class="sxs-lookup"><span data-stu-id="04b65-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="04b65-775">O objeto <see cref="T:System.Threading.CompressedStack" /> a ser aplicado ao thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="04b65-776">Aplica uma <see cref="T:System.Threading.CompressedStack" /> capturada ao thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-777">Esse método não é mais suportado.</span><span class="sxs-lookup"><span data-stu-id="04b65-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-778">Em todos os casos.</span><span class="sxs-lookup"><span data-stu-id="04b65-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04b65-779">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="04b65-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04b65-780">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="04b65-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="04b65-781">O <see cref="T:System.LocalDataStoreSlot" /> no qual definir o valor.</span><span class="sxs-lookup"><span data-stu-id="04b65-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="04b65-782">O valor a ser configurado.</span><span class="sxs-lookup"><span data-stu-id="04b65-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="04b65-783">Define os dados no slot especificado no thread em execução no momento, para o domínio atual do thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="04b65-784">Para melhorar o desempenho, use os campos marcados com o atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-785">O .NET Framework fornece dois mecanismos para usar o armazenamento local de thread (TLS): campos estáticos relativos a thread (ou seja, os campos que são marcados com o <xref:System.ThreadStaticAttribute> atributo) e slots de dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="04b65-786">Campos estáticos relativos a thread fornecem melhor desempenho que os slots de dados e habilitar a verificação de tipo de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="04b65-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="04b65-787">Para obter mais informações sobre como usar o TLS, consulte [armazenamento Local de Thread: campos estáticos relativos a Thread e Slots de dados](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="04b65-788">Threads usam um mecanismo de armazenamento local de memória para armazenar dados específicos de segmento.</span><span class="sxs-lookup"><span data-stu-id="04b65-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="04b65-789">O common language runtime aloca uma matriz de armazenamento de dados de vários slots para cada processo quando ele é criado.</span><span class="sxs-lookup"><span data-stu-id="04b65-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="04b65-790">O thread pode alocar um slot de dados no armazenamento de dados, armazene e recupere dados de um valor no slot e liberar o slot para ser reutilizado após a conclusão do procedimento de thread e o <xref:System.Threading.Thread> objeto foi recuperado pela coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="04b65-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="04b65-791">Slots de dados são exclusivos por thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-791">Data slots are unique per thread.</span></span> <span data-ttu-id="04b65-792">Nenhum outro thread (nem mesmo um thread filho) pode obter esses dados.</span><span class="sxs-lookup"><span data-stu-id="04b65-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-793"><xref:System.Threading.Thread.SetData%2A> é um `Shared` método que sempre se aplica ao thread em execução no momento, mesmo se você chamá-lo usando uma variável que faz referência a outro thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="04b65-794">Para evitar confusão, use o nome de classe ao chamar `Shared` métodos: `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="04b65-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-795">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="04b65-795">This section contains two code examples.</span></span> <span data-ttu-id="04b65-796">O primeiro exemplo mostra como usar um campo que é marcado com o <xref:System.ThreadStaticAttribute> atributo para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="04b65-797">O segundo exemplo mostra como usar um slot de dados para fazer a mesma coisa.</span><span class="sxs-lookup"><span data-stu-id="04b65-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="04b65-798">**Primeiro exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-798">**First Example**</span></span>  
  
 <span data-ttu-id="04b65-799">O exemplo a seguir mostra como usar um campo que é marcado com <xref:System.ThreadStaticAttribute> para manter informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="04b65-800">Essa técnica fornece desempenho melhor do que a técnica que é mostrado no segundo exemplo.</span><span class="sxs-lookup"><span data-stu-id="04b65-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="04b65-801">**Segundo exemplo**</span><span class="sxs-lookup"><span data-stu-id="04b65-801">**Second Example**</span></span>  
  
 <span data-ttu-id="04b65-802">O exemplo a seguir demonstra como usar um slot de dados nomeado para armazenar informações específicas de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-803">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="04b65-804">Armazenamento local de thread: campos estáticos relativos a thread e slots de dados</span><span class="sxs-lookup"><span data-stu-id="04b65-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-805">Suspende o thread atual para o período de tempo especificado.</span><span class="sxs-lookup"><span data-stu-id="04b65-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="04b65-806">O número de milissegundos durante o qual o thread ficará suspenso.</span><span class="sxs-lookup"><span data-stu-id="04b65-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="04b65-807">Se o valor do argumento <paramref name="millisecondsTimeout" /> for zero, o thread entregará o restante da fração de tempo para qualquer thread de prioridade igual que está pronto para execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="04b65-808">Se não houver nenhum outro thread de prioridade igual pronto para execução, a execução do thread atual não será suspensa.</span><span class="sxs-lookup"><span data-stu-id="04b65-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="04b65-809">Suspende o thread atual no número especificado de milissegundos.</span><span class="sxs-lookup"><span data-stu-id="04b65-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-810">O thread não será agendado para execução pelo sistema operacional durante o período especificado.</span><span class="sxs-lookup"><span data-stu-id="04b65-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="04b65-811">Esse método altera o estado do thread para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="04b65-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="04b65-812">Você pode especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o `millisecondsTimeout` parâmetro para suspender o thread indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="04b65-813">No entanto, recomendamos que você use outro <xref:System.Threading?displayProperty=nameWithType> classes como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> em vez disso, para sincronizar threads ou gerenciar recursos.</span><span class="sxs-lookup"><span data-stu-id="04b65-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="04b65-814">Os tiques do relógio do sistema em uma taxa específica chamada a resolução do relógio.</span><span class="sxs-lookup"><span data-stu-id="04b65-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="04b65-815">O tempo limite real pode não ser exatamente o tempo limite especificado, porque o tempo limite especificado será ajustado para coincidir com tiques do relógio.</span><span class="sxs-lookup"><span data-stu-id="04b65-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="04b65-816">Para obter mais informações sobre a resolução do relógio e o tempo de espera, consulte a [suspensão função](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tópico.</span><span class="sxs-lookup"><span data-stu-id="04b65-816">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="04b65-817">Este método chama o [suspensão função](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) das APIs do sistema Windows.</span><span class="sxs-lookup"><span data-stu-id="04b65-817">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="04b65-818">Esse método não executa padrão COM e o bombeamento de SendMessage.</span><span class="sxs-lookup"><span data-stu-id="04b65-818">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-819">Se você precisa no modo de suspensão em um thread que tenha <xref:System.STAThreadAttribute>, mas você deseja executar o bombeamento de SendMessage e COM padrão, considere usar uma das sobrecargas do <xref:System.Threading.Thread.Join%2A> método que especifica um intervalo de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="04b65-819">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-820">O exemplo a seguir usa o <xref:System.Threading.Thread.Sleep%2A> para bloquear o thread principal do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-820">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04b65-821">O valor de tempo limite é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-821">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="04b65-822">A quantidade de tempo para a qual o thread é suspenso.</span><span class="sxs-lookup"><span data-stu-id="04b65-822">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="04b65-823">Se o valor do argumento <paramref name="millisecondsTimeout" /> for <see cref="F:System.TimeSpan.Zero" />, o thread entregará o restante de sua fração de tempo a qualquer thread de prioridade igual que esteja pronto para execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-823">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="04b65-824">Se não houver nenhum outro thread de prioridade igual pronto para execução, a execução do thread atual não será suspensa.</span><span class="sxs-lookup"><span data-stu-id="04b65-824">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="04b65-825">Suspende o thread atual para o período de tempo especificado.</span><span class="sxs-lookup"><span data-stu-id="04b65-825">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-826">O thread não será agendado para execução pelo sistema operacional durante o período especificado.</span><span class="sxs-lookup"><span data-stu-id="04b65-826">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="04b65-827">Esse método altera o estado do thread para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="04b65-827">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="04b65-828">Você pode especificar <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> para o `timeout` parâmetro para suspender o thread indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-828">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="04b65-829">No entanto, recomendamos que você use outro <xref:System.Threading?displayProperty=nameWithType> classes como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, ou <xref:System.Threading.Semaphore> em vez disso, para sincronizar threads ou gerenciar recursos.</span><span class="sxs-lookup"><span data-stu-id="04b65-829">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="04b65-830">Essa sobrecarga de <xref:System.Threading.Thread.Sleep%2A> usa o número total de milissegundos inteiros em `timeout`.</span><span class="sxs-lookup"><span data-stu-id="04b65-830">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="04b65-831">Milissegundos fracionários são descartados.</span><span class="sxs-lookup"><span data-stu-id="04b65-831">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="04b65-832">Esse método não executa padrão COM e o bombeamento de SendMessage.</span><span class="sxs-lookup"><span data-stu-id="04b65-832">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-833">Se você precisa no modo de suspensão em um thread que tenha <xref:System.STAThreadAttribute>, mas você deseja executar o bombeamento de SendMessage e COM padrão, considere usar uma das sobrecargas do <xref:System.Threading.Thread.Join%2A> método que especifica um intervalo de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="04b65-833">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-834">O exemplo a seguir usa o <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> sobrecarga de método para bloquear o thread principal do aplicativo cinco vezes, por dois segundos cada vez.</span><span class="sxs-lookup"><span data-stu-id="04b65-834">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04b65-835">O valor de <paramref name="timeout" /> será negativo e não será igual a <see cref="F:System.Threading.Timeout.Infinite" /> em milissegundos, ou será maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</span><span class="sxs-lookup"><span data-stu-id="04b65-835">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="04b65-836">Um inteiro com sinal de 32 bits que define quanto tempo um thread deverá aguardar.</span><span class="sxs-lookup"><span data-stu-id="04b65-836">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="04b65-837">Faz com que um thread aguarde o número de vezes definido pelo parâmetro <paramref name="iterations" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-837">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-838">O <xref:System.Threading.Thread.SpinWait%2A> método é útil para implementar bloqueios.</span><span class="sxs-lookup"><span data-stu-id="04b65-838">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="04b65-839">Classes no .NET Framework, como <xref:System.Threading.Monitor> e <xref:System.Threading.ReaderWriterLock>, use esse método internamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-839">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="04b65-840"><xref:System.Threading.Thread.SpinWait%2A> basicamente coloca o processador em um loop muito estreito, com a contagem do loop especificada pelo `iterations` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="04b65-840"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="04b65-841">A duração da espera, portanto, depende da velocidade do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-841">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="04b65-842">Compare isso com o <xref:System.Threading.Thread.Sleep%2A> método.</span><span class="sxs-lookup"><span data-stu-id="04b65-842">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="04b65-843">Um thread que chama <xref:System.Threading.Thread.Sleep%2A> produz o restante da fração de atual de tempo do processador, mesmo se o intervalo especificado é zero.</span><span class="sxs-lookup"><span data-stu-id="04b65-843">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="04b65-844">Especificando um intervalo diferente de zero para <xref:System.Threading.Thread.Sleep%2A> remove o thread de consideração pelo Agendador de thread até que o intervalo de tempo tenha decorrido.</span><span class="sxs-lookup"><span data-stu-id="04b65-844">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="04b65-845"><xref:System.Threading.Thread.SpinWait%2A> não é geralmente útil para aplicativos comuns.</span><span class="sxs-lookup"><span data-stu-id="04b65-845"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="04b65-846">Na maioria dos casos, você deve usar as classes de sincronização fornecidas pelo .NET Framework; Por exemplo, chamar <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> ou uma instrução que encapsula <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` em c# ou `SyncLock` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04b65-846">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="04b65-847">No caso raro em que é vantajoso para evitar uma alternância de contexto, como quando você sabe que uma alteração de estado é iminente, fazer uma chamada para o <xref:System.Threading.Thread.SpinWait%2A> método em seu loop.</span><span class="sxs-lookup"><span data-stu-id="04b65-847">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="04b65-848">O código <xref:System.Threading.Thread.SpinWait%2A> executa é projetado para evitar problemas que podem ocorrer em computadores com vários processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-848">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="04b65-849">Por exemplo, em computadores com vários processadores Intel, empregando a tecnologia Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> impede a privação de processador em determinadas situações.</span><span class="sxs-lookup"><span data-stu-id="04b65-849">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-850">Faz com que um thread seja agendado para execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-850">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-851">Faz com que o sistema operacional altere o estado da instância atual para <see cref="F:System.Threading.ThreadState.Running" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-851">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-852">Depois que um thread está no <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, o sistema operacional pode programá-lo para execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-852">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="04b65-853">O thread começa a ser executado na primeira linha do método representado pela <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> delegado fornecido para o construtor de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-853">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="04b65-854">Observe que a chamada para <xref:System.Threading.Thread.Start%2A> não bloqueia o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="04b65-854">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-855">Se essa sobrecarga é usada com um thread criado usando um <xref:System.Threading.ParameterizedThreadStart> delegar, `null` é passado para o método executado pelo thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-855">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="04b65-856">Depois que o thread é encerrado, ele não pode ser reiniciado com outra chamada para `Start`.</span><span class="sxs-lookup"><span data-stu-id="04b65-856">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-857">O exemplo a seguir cria e inicia um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-857">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-858">O thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-858">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="04b65-859">Não há memória suficiente disponível para iniciar esse thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-859">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="04b65-860">Threads e threading</span><span class="sxs-lookup"><span data-stu-id="04b65-860">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="04b65-861">Criando threads e passando dados na hora de início</span><span class="sxs-lookup"><span data-stu-id="04b65-861">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="04b65-862">Um objeto que contém dados a serem usados pelo método executado pelo thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-862">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="04b65-863">Faz com que o sistema operacional altere o estado da instância atual para <see cref="F:System.Threading.ThreadState.Running" /> e, opcionalmente, fornece um objeto que contém dados a serem usados pelo método executado pelo thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-863">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-864">Depois que um thread está no <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, o sistema operacional pode programá-lo para execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-864">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="04b65-865">O thread começa a ser executado na primeira linha do método representado pela <xref:System.Threading.ThreadStart> ou <xref:System.Threading.ParameterizedThreadStart> delegado fornecido para o construtor de thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-865">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="04b65-866">Observe que a chamada para <xref:System.Threading.Thread.Start%2A> não bloqueia o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="04b65-866">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="04b65-867">Depois que o thread é encerrado, ele não pode ser reiniciado com outra chamada para `Start`.</span><span class="sxs-lookup"><span data-stu-id="04b65-867">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="04b65-868">Essa sobrecarga e a <xref:System.Threading.ParameterizedThreadStart> delegado tornam mais fácil passar dados para um procedimento de thread, mas a técnica não é fortemente tipado, porque qualquer objeto pode ser passado para essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="04b65-868">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="04b65-869">Uma maneira mais robusta para passar dados para um procedimento de thread é colocar o procedimento de thread e os campos de dados em um objeto de trabalho.</span><span class="sxs-lookup"><span data-stu-id="04b65-869">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="04b65-870">Para obter mais informações, consulte [criando Threads e passando dados na hora de início](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="04b65-870">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-871">O exemplo a seguir cria um <xref:System.Threading.ParameterizedThreadStart> delegado com um método estático e um método de instância.</span><span class="sxs-lookup"><span data-stu-id="04b65-871">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-872">O thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-872">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="04b65-873">Não há memória suficiente disponível para iniciar esse thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-873">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04b65-874">Esse thread foi criado usando um delegado <see cref="T:System.Threading.ThreadStart" /> em vez de um delegado <see cref="T:System.Threading.ParameterizedThreadStart" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-874">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="04b65-875">Criando Threads</span><span class="sxs-lookup"><span data-stu-id="04b65-875">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-876">Suspende o thread ou, se o thread já está suspenso, não tem efeito.</span><span class="sxs-lookup"><span data-stu-id="04b65-876">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-877">Se o thread já está suspenso, esse método não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="04b65-877">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="04b65-878">Não use o <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar as atividades de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-878">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="04b65-879">Você não tem como saber qual código de um thread está em execução quando você suspendê-lo.</span><span class="sxs-lookup"><span data-stu-id="04b65-879">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="04b65-880">Se você suspender um thread enquanto mantém o bloqueio durante uma avaliação da permissão de segurança, outros threads no <xref:System.AppDomain> poderá ser bloqueado.</span><span class="sxs-lookup"><span data-stu-id="04b65-880">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="04b65-881">Se você suspender um thread enquanto ele está em execução em um construtor de classe, outros threads no <xref:System.AppDomain> que tentar usar que a classe estão bloqueadas.</span><span class="sxs-lookup"><span data-stu-id="04b65-881">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="04b65-882">Os deadlocks podem ocorrer com muita facilidade.</span><span class="sxs-lookup"><span data-stu-id="04b65-882">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="04b65-883">Somente .NET Core: esse membro não é compatível.</span><span class="sxs-lookup"><span data-stu-id="04b65-883">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-884">O thread não foi iniciado ou está inativo.</span><span class="sxs-lookup"><span data-stu-id="04b65-884">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04b65-885">O chamador não tem o <see cref="T:System.Security.Permissions.SecurityPermission" /> apropriado.</span><span class="sxs-lookup"><span data-stu-id="04b65-885">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="04b65-886">operações avançadas em threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-886">for advanced operations on threads.</span></span> <span data-ttu-id="04b65-887">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-887">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="04b65-888">Pausando e interrompendo threads</span><span class="sxs-lookup"><span data-stu-id="04b65-888">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-889">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-889">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="04b65-890">Reservado para uso futuro.</span><span class="sxs-lookup"><span data-stu-id="04b65-890">Reserved for future use.</span></span> <span data-ttu-id="04b65-891">Deve ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="04b65-891">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="04b65-892">Matriz passada de nomes a serem mapeados.</span><span class="sxs-lookup"><span data-stu-id="04b65-892">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="04b65-893">Contagem dos nomes a serem mapeados.</span><span class="sxs-lookup"><span data-stu-id="04b65-893">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="04b65-894">O contexto de localidade no qual interpretar os nomes.</span><span class="sxs-lookup"><span data-stu-id="04b65-894">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="04b65-895">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</span><span class="sxs-lookup"><span data-stu-id="04b65-895">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="04b65-896">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</span><span class="sxs-lookup"><span data-stu-id="04b65-896">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-897">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-897">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04b65-898">Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="04b65-898">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04b65-899">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="04b65-899">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="04b65-900">As informações de tipo a serem retornadas.</span><span class="sxs-lookup"><span data-stu-id="04b65-900">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="04b65-901">O identificador de localidade das informações do tipo.</span><span class="sxs-lookup"><span data-stu-id="04b65-901">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="04b65-902">Recebe um ponteiro para o objeto de informações de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="04b65-902">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="04b65-903">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</span><span class="sxs-lookup"><span data-stu-id="04b65-903">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-904">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-904">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04b65-905">Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="04b65-905">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04b65-906">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="04b65-906">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="04b65-907">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</span><span class="sxs-lookup"><span data-stu-id="04b65-907">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="04b65-908">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</span><span class="sxs-lookup"><span data-stu-id="04b65-908">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-909">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-909">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04b65-910">Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="04b65-910">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04b65-911">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="04b65-911">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="04b65-912">Identifica o membro.</span><span class="sxs-lookup"><span data-stu-id="04b65-912">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="04b65-913">Reservado para uso futuro.</span><span class="sxs-lookup"><span data-stu-id="04b65-913">Reserved for future use.</span></span> <span data-ttu-id="04b65-914">Deve ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="04b65-914">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="04b65-915">O contexto de localidade no qual interpretar argumentos.</span><span class="sxs-lookup"><span data-stu-id="04b65-915">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="04b65-916">Sinalizadores que descrevem o contexto da chamada.</span><span class="sxs-lookup"><span data-stu-id="04b65-916">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="04b65-917">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</span><span class="sxs-lookup"><span data-stu-id="04b65-917">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="04b65-918">Ponteiro para o local onde o resultado deve ser armazenado.</span><span class="sxs-lookup"><span data-stu-id="04b65-918">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="04b65-919">Ponteiro para uma estrutura que contém informações de exceção.</span><span class="sxs-lookup"><span data-stu-id="04b65-919">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="04b65-920">O índice do primeiro argumento que tem um erro.</span><span class="sxs-lookup"><span data-stu-id="04b65-920">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="04b65-921">Fornece acesso a propriedades e métodos expostos por um objeto.</span><span class="sxs-lookup"><span data-stu-id="04b65-921">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-922">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-922">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04b65-923">Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="04b65-923">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04b65-924">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span><span class="sxs-lookup"><span data-stu-id="04b65-924">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04b65-925">Obtém um valor que contém os estados do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-925">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="04b65-926">Um dos valores de <see cref="T:System.Threading.ThreadState" /> que indica o estado do thread atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-926">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="04b65-927">O valor inicial é <see langword="Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-927">The initial value is <see langword="Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-928">O <xref:System.Threading.Thread.ThreadState%2A> propriedade fornece informações mais específicas que o <xref:System.Threading.Thread.IsAlive%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-928">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04b65-929">Estado do thread só é importante em cenários de depuração.</span><span class="sxs-lookup"><span data-stu-id="04b65-929">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="04b65-930">O código nunca deve usar o estado do thread para sincronizar as atividades de threads.</span><span class="sxs-lookup"><span data-stu-id="04b65-930">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-931">O exemplo de código a seguir demonstra como acessar o `ThreadState` de um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-931">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="04b65-932">Estados de thread gerenciado</span><span class="sxs-lookup"><span data-stu-id="04b65-932">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="04b65-933">O novo estado de apartment.</span><span class="sxs-lookup"><span data-stu-id="04b65-933">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="04b65-934">Define o estado do apartment de um thread antes que ele seja iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-934">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="04b65-935"><see langword="true" /> se o estado de apartment for definido; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-935"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-936">Novos threads são inicializados como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se seu estado de apartment não tiver sido definido antes que eles são iniciados.</span><span class="sxs-lookup"><span data-stu-id="04b65-936">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="04b65-937">Estado de apartment deve ser definido antes que um thread é iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-937">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-938">O thread principal do aplicativo é inicializado como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> por padrão.</span><span class="sxs-lookup"><span data-stu-id="04b65-938">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="04b65-939">A única maneira de definir o estado de apartment do thread principal do aplicativo para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> é aplicar o <xref:System.STAThreadAttribute> atributo ao método de ponto de entrada.</span><span class="sxs-lookup"><span data-stu-id="04b65-939">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="04b65-940">O <xref:System.Threading.Thread.TrySetApartmentState%2A> método, juntamente com o <xref:System.Threading.Thread.GetApartmentState%2A> método e o <xref:System.Threading.Thread.SetApartmentState%2A> substitui o método, o <xref:System.Threading.Thread.ApartmentState%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="04b65-940">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04b65-941">O exemplo de código a seguir demonstra os métodos <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> e <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-941">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="04b65-942">O exemplo de código cria um thread.</span><span class="sxs-lookup"><span data-stu-id="04b65-942">The code example creates a thread.</span></span> <span data-ttu-id="04b65-943">Antes do thread é iniciado, <xref:System.Threading.Thread.GetApartmentState%2A> exibe a inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado e <xref:System.Threading.Thread.SetApartmentState%2A> altera o estado para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04b65-943">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04b65-944">O <xref:System.Threading.Thread.TrySetApartmentState%2A> , em seguida, o método retornará `false` durante a tentativa de alterar o estado para <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque o estado de apartment já está definido.</span><span class="sxs-lookup"><span data-stu-id="04b65-944">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="04b65-945">Se a mesma operação tivesse sido tentada com <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> seria ter sido lançada.</span><span class="sxs-lookup"><span data-stu-id="04b65-945">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="04b65-946">Depois que o thread é iniciado, o <xref:System.Threading.Thread.TrySetApartmentState%2A> método é usado novamente.</span><span class="sxs-lookup"><span data-stu-id="04b65-946">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="04b65-947">Desta vez, ele gera <xref:System.Threading.ThreadStateException> porque o thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-947">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04b65-948"><paramref name="state" /> não é um estado de apartment válido.</span><span class="sxs-lookup"><span data-stu-id="04b65-948"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="04b65-949">O thread já foi iniciado.</span><span class="sxs-lookup"><span data-stu-id="04b65-949">The thread has already been started.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-950">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-950">Reads the value of a field.</span></span> <span data-ttu-id="04b65-951">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-951">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-952">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-952">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-953">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-953">Reads the value of a field.</span></span> <span data-ttu-id="04b65-954">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-954">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-955">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-955">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-956"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-956"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-957">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-957">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-958">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-958">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-959">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-959">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-960">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-960">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-961">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-961">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-962">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-962">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-963">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-963">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-964">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-964">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-965">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-965">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-966">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-966">Reads the value of a field.</span></span> <span data-ttu-id="04b65-967">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-967">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-968">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-968">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-969"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-969"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-970">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-970">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-971">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-971">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-972">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-972">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-973">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-973">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-974">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-974">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-975">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-975">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-976">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-976">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-977">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-977">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-978">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-978">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-979">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-979">Reads the value of a field.</span></span> <span data-ttu-id="04b65-980">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-980">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-981">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-981">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-982"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-982"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-983">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-983">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-984">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-984">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-985">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-985">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-986">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-986">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-987">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-987">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-988">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-988">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-989">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-989">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-990">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-990">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-991">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-991">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-992">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-992">Reads the value of a field.</span></span> <span data-ttu-id="04b65-993">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-993">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-994">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-994">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-995"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-995"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-996">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-996">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-997">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-997">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-998">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-998">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-999">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-999">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1000">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1000">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1001">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1001">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1002">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1002">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1003">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1003">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1004">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1004">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1005">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1005">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1006">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1006">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1007">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1007">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1008"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1008"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1009">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1009">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1010">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1010">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1011">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1011">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1012">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1012">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1013">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1013">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1014">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1014">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1015">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1015">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1016">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1016">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1017">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1017">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1018">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1018">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1019">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1019">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1020">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1020">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1021"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1021"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1022">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1022">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1023">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1023">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1024">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1024">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1025">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1025">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1026">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1026">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1027">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1027">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1028">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1028">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1029">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1029">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1030">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1030">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1031">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1031">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1032">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1032">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1033">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1033">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1034"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1034"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1035">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1035">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1036">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1036">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1037">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1037">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1038">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1038">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1039">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1039">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1040">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1040">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1041">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1041">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1042">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1042">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1043">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1043">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1044">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1044">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1045">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1045">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1046">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1046">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1047"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1047"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1048">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1048">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1049">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1049">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1050">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1050">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1051">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1051">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1052">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1052">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1053">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1053">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1054">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1054">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1055">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1055">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1056">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1056">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1057">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1057">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1058">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1058">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1059">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1059">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1060"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1060"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1061">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1061">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1062">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1062">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1063">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1063">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1064">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1064">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1065">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1065">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1066">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1066">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1067">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1067">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1068">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1068">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1069">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1069">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1070">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1070">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1071">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1071">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1072">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1072">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1073"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1073"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1074">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1074">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1075">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1075">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1076">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1076">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1077">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1077">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1078">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1078">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1079">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1079">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1080">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1080">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1081">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1081">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1082">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1082">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1083">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1083">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1084">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1084">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1085">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1085">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1086"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1086"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1087">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1087">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1088">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1088">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1089">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1089">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1090">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1090">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1091">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1091">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1092">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1092">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1093">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1093">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1094">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1094">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1095">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1095">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1096">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1096">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1097">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1097">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1098">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1098">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1099"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1099"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1100">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1100">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1101">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1101">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1102">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1102">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1103">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1103">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1104">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1104">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1105">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1105">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1106">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1106">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1107">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1107">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1108">O campo a ser lido.</span><span class="sxs-lookup"><span data-stu-id="04b65-1108">The field to be read.</span></span></param>
        <summary><span data-ttu-id="04b65-1109">Lê o valor de um campo.</span><span class="sxs-lookup"><span data-stu-id="04b65-1109">Reads the value of a field.</span></span> <span data-ttu-id="04b65-1110">O valor é o último gravado por qualquer processador em um computador, independentemente do número de processadores ou do estado do cache do processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1110">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="04b65-1111">O último valor gravado no campo por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1111">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1112"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1112"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1113">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1113">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1114">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileRead%2A> obtém o valor mais recente gravado em um local de memória por qualquer processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1114">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="04b65-1115">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1115">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1116">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1116">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1117">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1117">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1118">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1118">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1119">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1119">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1120">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1120">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04b65-1121">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1121">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1122">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1122">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1123">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1123">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1124">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1124">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1125"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1125"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1126">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1126">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1127">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1127">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1128">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1128">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1129">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1129">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1130">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1130">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1131">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1131">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1132">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1132">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1133">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1133">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1134">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1134">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1135">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1135">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1136">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1136">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1137"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1137"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1138">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1138">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1139">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1139">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1140">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1140">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1141">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1141">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1142">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1142">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1143">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1143">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1144">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1144">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1145">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1145">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1146">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1146">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1147">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1147">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1148">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1148">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1149"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1149"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1150">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1150">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1151">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1151">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1152">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1152">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1153">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1153">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1154">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1154">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1155">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1155">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1156">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1156">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1157">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1157">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1158">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1158">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1159">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1159">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1160">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1160">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1161"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1161"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1162">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1162">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1163">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1163">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1164">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1164">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1165">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1165">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1166">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1166">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1167">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1167">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1168">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1168">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1169">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1169">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1170">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1170">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1171">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1171">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1172">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1172">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1173"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1173"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1174">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1174">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1175">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1175">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1176">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1176">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1177">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1177">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1178">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1178">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1179">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1179">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1180">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1180">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1181">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1181">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1182">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1182">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1183">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1183">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1184">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1184">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1185"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1185"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1186">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1186">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1187">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1187">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1188">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1188">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1189">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1189">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1190">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1190">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1191">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1191">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1192">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1192">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1193">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1193">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1194">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1194">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1195">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1195">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1196">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1196">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1197"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1197"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1198">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1198">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1199">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1199">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1200">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1200">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1201">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1201">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1202">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1202">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1203">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1203">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1204">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1204">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1205">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1205">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1206">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1206">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1207">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1207">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1208">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1208">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1209"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1209"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1210">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1210">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1211">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1211">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1212">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1212">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1213">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1213">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1214">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1214">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1215">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1215">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1216">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1216">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1217">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1217">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1218">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1218">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1219">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1219">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1220">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1220">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1221"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1221"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1222">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1222">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1223">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1223">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1224">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1224">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1225">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1225">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1226">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1226">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1227">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1227">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1228">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1228">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1229">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1229">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1230">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1230">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1231">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1231">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1232">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1232">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1233"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1233"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1234">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1234">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1235">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1235">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1236">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1236">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1237">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1237">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1238">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1238">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1239">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1239">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1240">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1240">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1241">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1241">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1242">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1242">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1243">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1243">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1244">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1244">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1245"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1245"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1246">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1246">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1247">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1247">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1248">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1248">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1249">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1249">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1250">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1250">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1251">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1251">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1252">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1252">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1253">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1253">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1254">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1254">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1255">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1255">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1256">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1256">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1257"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1257"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1258">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1258">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1259">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1259">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1260">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1260">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1261">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1261">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1262">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1262">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1263">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1263">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1264">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1264">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1265">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1265">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="04b65-1266">O campo no qual o valor deve ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1266">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="04b65-1267">O valor a ser gravado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1267">The value to be written.</span></span></param>
        <summary><span data-ttu-id="04b65-1268">Grava um valor em um campo imediatamente, para que o valor esteja visível para todos os processadores no computador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1268">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1269"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> são para casos especiais de sincronização.</span><span class="sxs-lookup"><span data-stu-id="04b65-1269"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="04b65-1270">Em circunstâncias normais, o c# `lock` instrução, o Visual Basic `SyncLock` instrução e o <xref:System.Threading.Monitor> classe fornecem alternativas mais fácil.</span><span class="sxs-lookup"><span data-stu-id="04b65-1270">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="04b65-1271">Em um sistema multiprocessador, <xref:System.Threading.Thread.VolatileWrite%2A> garante que um valor gravado em um local de memória seja imediatamente visível para todos os processadores.</span><span class="sxs-lookup"><span data-stu-id="04b65-1271">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="04b65-1272">Isso pode exigir a liberação de caches de processador.</span><span class="sxs-lookup"><span data-stu-id="04b65-1272">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="04b65-1273">Mesmo em um sistema uniprocessador, <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> Certifique-se de que um valor é lido ou gravado na memória e não armazenado em cache (por exemplo, em um registro do processador).</span><span class="sxs-lookup"><span data-stu-id="04b65-1273">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="04b65-1274">Assim, você pode usá-los para sincronizar o acesso a um campo que pode ser atualizado por outro thread ou pelo hardware.</span><span class="sxs-lookup"><span data-stu-id="04b65-1274">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="04b65-1275">Chamar esse método afeta apenas um acesso de memória único.</span><span class="sxs-lookup"><span data-stu-id="04b65-1275">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="04b65-1276">Para fornecer sincronização efetiva para um campo, todo o acesso ao campo deve usar <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1276">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04b65-1277">No c#, usando o `volatile` modificador em um campo garante que todo o acesso a esse campo usa <xref:System.Threading.Thread.VolatileRead%2A> ou <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="04b65-1277">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04b65-1278">Faz com que o thread de chamada conceda a execução para outro thread que está pronto para ser executado no processador atual.</span><span class="sxs-lookup"><span data-stu-id="04b65-1278">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="04b65-1279">O sistema operacional seleciona o thread de recebimento.</span><span class="sxs-lookup"><span data-stu-id="04b65-1279">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="04b65-1280"><see langword="true" /> se o sistema operacional execução mudou a execução para outro thread; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04b65-1280"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04b65-1281">Se esse método for bem-sucedido, o restante da fração de tempo do thread atual é gerado.</span><span class="sxs-lookup"><span data-stu-id="04b65-1281">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="04b65-1282">O sistema operacional agenda o thread de chamada para outra fatia de tempo, acordo com sua prioridade e o status de outros threads que estão disponíveis para execução.</span><span class="sxs-lookup"><span data-stu-id="04b65-1282">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="04b65-1283">Produzindo é limitado para o processador que está executando o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="04b65-1283">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="04b65-1284">O sistema operacional não mudará execução para outro processador, mesmo que o processador está ocioso ou estiver executando um thread de prioridade mais baixa.</span><span class="sxs-lookup"><span data-stu-id="04b65-1284">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="04b65-1285">Se não houver nenhum outro thread está pronto para executar no processador atual, o sistema operacional não conceda a execução e esse método retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="04b65-1285">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="04b65-1286">Esse método é equivalente a usando invocação de plataforma para chamar o Win32 nativo `SwitchToThread` função.</span><span class="sxs-lookup"><span data-stu-id="04b65-1286">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="04b65-1287">Você deve chamar o <xref:System.Threading.Thread.Yield%2A> de invocação de método em vez de usar a plataforma, porque ignora qualquer comportamento personalizado threading host solicitou a invocação de plataforma.</span><span class="sxs-lookup"><span data-stu-id="04b65-1287">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>