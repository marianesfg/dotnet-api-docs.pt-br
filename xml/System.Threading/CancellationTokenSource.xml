<Type Name="CancellationTokenSource" FullName="System.Threading.CancellationTokenSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9d80567a25e1e4dab118367b1bf054b90d195acd" /><Meta Name="ms.sourcegitcommit" Value="9802d4c6745a8ae514b26f144fb3969265b224ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/22/2018" /><Meta Name="ms.locfileid" Value="53751694" /></Metadata><TypeSignature Language="C#" Value="public class CancellationTokenSource : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CancellationTokenSource extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationTokenSource" />
  <TypeSignature Language="VB.NET" Value="Public Class CancellationTokenSource&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CancellationTokenSource : IDisposable" />
  <TypeSignature Language="F#" Value="type CancellationTokenSource = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Sinaliza para um <see cref="T:System.Threading.CancellationToken" /> que ele deve ser cancelado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o .NET Framework usa um modelo unificado para cancelamento cooperativo de operações síncronas de longa execução ou assíncronas, o que envolve dois objetos:  
  
-   Um <xref:System.Threading.CancellationTokenSource> objeto, que fornece um token de cancelamento por meio de seu <xref:System.Threading.CancellationTokenSource.Token%2A> propriedade e envia um cancelamento de mensagem chamando seu <xref:System.Threading.CancellationTokenSource.Cancel%2A> ou <xref:System.Threading.CancellationTokenSource.CancelAfter%2A> método.  
  
-   Um <xref:System.Threading.CancellationToken> objeto, que indica se o cancelamento é solicitado.  
  
 O padrão geral para implementar o modelo de cancelamento cooperativo é:  
  
-   Instancie um objeto <xref:System.Threading.CancellationTokenSource>, que gerencia e envia uma notificação de cancelamento para os tokens de cancelamento individuais.  
  
-   Passe o token retornado pela propriedade <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> para cada tarefa ou thread que responde ao cancelamento.  
  
-   Chamar o <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> método das operações que recebe o token de cancelamento. Fornece um mecanismo para cada tarefa ou thread responder a uma solicitação de cancelamento. Se você optar por cancelar uma operação e exatamente como você faz isso, depende da lógica do aplicativo.  
  
-   Chame o método <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> para fornecer uma notificação de cancelamento. Isso define a <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> propriedade em todas as cópias do token de cancelamento para `true`.  
  
-   Chame o <xref:System.Threading.CancellationTokenSource.Dispose%2A> método quando tiver terminado com o <xref:System.Threading.CancellationTokenSource> objeto.  
  
 Para saber mais, confira [Cancelamento em threads gerenciados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar uma instância do tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
   
  
## Examples  
 O exemplo a seguir usa um gerador de número aleatório para emular um aplicativo de coleta de dados que lê os 10 valores de integrais de onze instrumentos diferentes. Um valor de zero indica que a medição falhou para um instrumento, caso em que a operação deve ser cancelada e nenhum média geral devem ser calculados.  
  
 Para lidar com possíveis cancelamento da operação, o exemplo cria uma instância de um <xref:System.Threading.CancellationTokenSource> objeto que gera um token de cancelamento que é passado para um <xref:System.Threading.Tasks.TaskFactory> objeto. O <xref:System.Threading.Tasks.TaskFactory> objeto por sua vez passa o token de cancelamento para cada uma das tarefas responsável por coletar leituras para um determinado instrumento. O <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método é chamado para garantir que a média é computada somente depois que todas as leituras foram compiladas com êxito. Se uma tarefa tiver não porque ele foi cancelado, a chamada para o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> método lançará uma exceção.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros públicos e protegidos da <see cref="T:System.Threading.CancellationTokenSource" /> são thread-safe e podem ser usados simultaneamente de vários threads, com exceção de <see cref="M:System.Threading.CancellationTokenSource.Dispose" />, que deve ser usado somente quando todas as outras operações no <see cref="T:System.Threading.CancellationTokenSource" /> objeto concluiu.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa o <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationTokenSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationTokenSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationTokenSource (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (millisecondsDelay As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationTokenSource(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationTokenSource : int -&gt; System.Threading.CancellationTokenSource" Usage="new System.Threading.CancellationTokenSource millisecondsDelay" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">O intervalo de tempo em milissegundos para aguardar antes de cancelar essa <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.CancellationTokenSource" /> que será cancelada depois do atraso especificado em milissegundos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A contagem regressiva para o `millisecondsDelay` inicia durante a chamada para o construtor.  Quando o `millisecondsDelay` expirar, construído <xref:System.Threading.CancellationTokenSource> é cancelado (se ele não tiver sido cancelado já).  
  
 As chamadas subsequentes para <xref:System.Threading.CancellationTokenSource.CancelAfter%2A> redefinirá o `millisecondsDelay` para construído <xref:System.Threading.CancellationTokenSource>, se não tiver sido cancelado já.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsDelay" /> é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationTokenSource (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.#ctor(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (delay As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationTokenSource(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationTokenSource : TimeSpan -&gt; System.Threading.CancellationTokenSource" Usage="new System.Threading.CancellationTokenSource delay" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">O intervalo de tempo de espera antes de cancelar essa <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.CancellationTokenSource" /> que será cancelada depois do intervalo de tempo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicia a contagem regressiva para o atraso durante a chamada para o construtor. Quando o atraso expira, construído <xref:System.Threading.CancellationTokenSource> for cancelada, se não tiver sido cancelado já.  
  
 As chamadas subsequentes para <xref:System.Threading.CancellationTokenSource.CancelAfter%2A> redefinirá o atraso de construído <xref:System.Threading.CancellationTokenSource>, se não tiver sido cancelado já.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" />.<see cref="P:System.TimeSpan.TotalMilliseconds" /> é menor que -1 ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Cancel">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comunica uma solicitação de cancelamento.</summary>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; unit" Usage="cancellationTokenSource.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comunica uma solicitação de cancelamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associado <xref:System.Threading.CancellationToken> serão notificados do cancelamento e fará a transição para um estado onde <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> retorna true.  
  
 Qualquer operação cancelável ou retornos de chamada registrado com o <xref:System.Threading.CancellationToken> será executado.  
  
 É recomendável que as operações canceláveis e retornos de chamada registrado com <xref:System.Threading.CancellationToken> não lançam exceções. 
 
 Essa sobrecarga de cancelamento irá agregar todas as exceções geradas em um <xref:System.AggregateException>, de modo que um retorno de chamada, gerando uma exceção não impedirá outros retornos de chamada registrados que está sendo executado. 
   
  
## Examples  
 O exemplo a seguir usa um gerador de número aleatório para emular um aplicativo de coleta de dados que lê os 10 valores de integrais de onze instrumentos diferentes. Um valor de zero indica que a medição falhou para um instrumento, caso em que a operação deve ser cancelada e nenhum média geral devem ser calculados.  
  
 Para lidar com possíveis cancelamento da operação, o exemplo cria uma instância de um <xref:System.Threading.CancellationTokenSource> objeto que gera um token de cancelamento que é passado para um <xref:System.Threading.Tasks.TaskFactory> objeto. O <xref:System.Threading.Tasks.TaskFactory> objeto por sua vez passa o token de cancelamento para cada uma das tarefas responsável por coletar leituras para um determinado instrumento. O <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método é chamado para garantir que a média é computada somente depois que todas as leituras foram compiladas com êxito. Se uma tarefa tiver não porque ele foi cancelado, a chamada para o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> método lançará uma exceção.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">Uma exceção de agregação que contém todas as exceções geradas pelos retornos de chamada registrados no <see cref="T:System.Threading.CancellationToken" /> associado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel (bool throwOnFirstException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel(bool throwOnFirstException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel (throwOnFirstException As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel(bool throwOnFirstException);" />
      <MemberSignature Language="F#" Value="member this.Cancel : bool -&gt; unit" Usage="cancellationTokenSource.Cancel throwOnFirstException" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="throwOnFirstException" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="throwOnFirstException"><see langword="true" /> se exceções devem propagar imediatamente; caso contrário, <see langword="false" />.</param>
        <summary>Comunica uma solicitação de cancelamento e especifica se as operações canceláveis e os retornos de chamada restantes deverão ser processados se ocorrer uma exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associado <xref:System.Threading.CancellationToken> serão notificados do cancelamento e fará a transição para um estado em que <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> retorna `true`.  
  
 Qualquer operação cancelável ou retornos de chamada registrado com o <xref:System.Threading.CancellationToken> será executado. Retornos de chamada serão ser executados de forma síncrona na ordem UEPS. 
  
 É recomendável que as operações canceláveis e retornos de chamada registrado com <xref:System.Threading.CancellationToken> não lançam exceções. 
  
 Se `throwOnFirstException` está `true`, uma exceção será propagado imediatamente sem a chamada para <xref:System.Threading.CancellationTokenSource.Cancel%2A>, impedindo que os retornos de chamada restantes e operações canceláveis que não sejam processadas.  
  
 Se `throwOnFirstException` está `false`, essa sobrecarga agregará todas as exceções geradas em um <xref:System.AggregateException>, de modo que um retorno de chamada, gerando uma exceção não impedirá outros retornos de chamada registrados que está sendo executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">Uma exceção de agregação que contém todas as exceções geradas pelos retornos de chamada registrados no <see cref="T:System.Threading.CancellationToken" /> associado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CancelAfter">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agenda uma operação de cancelamento neste <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CancelAfter">
      <MemberSignature Language="C#" Value="public void CancelAfter (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAfter(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CancelAfter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAfter (millisecondsDelay As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAfter(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="member this.CancelAfter : int -&gt; unit" Usage="cancellationTokenSource.CancelAfter millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">O período de tempo de espera antes de cancelar este <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Agenda uma operação de cancelamento neste <see cref="T:System.Threading.CancellationTokenSource" /> após o número especificado de milissegundos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A contagem regressiva para o `millisecondsDelay` inicia durante esta chamada. Quando o `millisecondsDelay` expirar, isso <xref:System.Threading.CancellationTokenSource> for cancelada, se não tiver sido cancelado já.  
  
 As chamadas subsequentes para CancelAfter redefinirá o `millisecondsDelay` para este <xref:System.Threading.CancellationTokenSource>, se não tiver sido cancelado já.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção lançada quando este <see cref="T:System.Threading.CancellationTokenSource" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando <paramref name="millisecondsDelay" /> é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelAfter">
      <MemberSignature Language="C#" Value="public void CancelAfter (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAfter(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CancelAfter(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAfter (delay As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAfter(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="member this.CancelAfter : TimeSpan -&gt; unit" Usage="cancellationTokenSource.CancelAfter delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">O período de tempo de espera antes de cancelar este <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Agenda uma operação de cancelamento neste <see cref="T:System.Threading.CancellationTokenSource" /> após o período de tempo especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção lançada quando este <see cref="T:System.Threading.CancellationTokenSource" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção que é lançada quando <paramref name="delay" /> é menor que -1 ou maior que Int32.MaxValue.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLinkedTokenSource">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um <see cref="T:System.Threading.CancellationTokenSource" /> que estará em estado cancelado quando qualquer um dos tokens de origem estiverem no estado cancelado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLinkedTokenSource">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationTokenSource CreateLinkedTokenSource (params System.Threading.CancellationToken[] tokens);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.CancellationTokenSource CreateLinkedTokenSource(valuetype System.Threading.CancellationToken[] tokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateLinkedTokenSource (ParamArray tokens As CancellationToken()) As CancellationTokenSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::CancellationTokenSource ^ CreateLinkedTokenSource(... cli::array &lt;System::Threading::CancellationToken&gt; ^ tokens);" />
      <MemberSignature Language="F#" Value="static member CreateLinkedTokenSource : System.Threading.CancellationToken[] -&gt; System.Threading.CancellationTokenSource" Usage="System.Threading.CancellationTokenSource.CreateLinkedTokenSource tokens" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokens" Type="System.Threading.CancellationToken[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tokens">Uma matriz que contém as instâncias de token de cancelamento a serem observadas.</param>
        <summary>Cria uma <see cref="T:System.Threading.CancellationTokenSource" /> que estará em estado cancelado quando qualquer um dos tokens de origem na matriz especificada estiverem no estado cancelado.</summary>
        <returns>Um <see cref="T:System.Threading.CancellationTokenSource" /> vinculado aos tokens de origem.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um <see cref="T:System.Threading.CancellationTokenSource" /> associado a um dos tokens de origem foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tokens" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tokens" /> está vazio.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6f4f3804-2ed7-41b4-a97a-6e32b93f6e05">Como ouvir várias solicitações de cancelamento</related>
      </Docs>
    </Member>
    <Member MemberName="CreateLinkedTokenSource">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationTokenSource CreateLinkedTokenSource (System.Threading.CancellationToken token1, System.Threading.CancellationToken token2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.CancellationTokenSource CreateLinkedTokenSource(valuetype System.Threading.CancellationToken token1, valuetype System.Threading.CancellationToken token2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateLinkedTokenSource (token1 As CancellationToken, token2 As CancellationToken) As CancellationTokenSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::CancellationTokenSource ^ CreateLinkedTokenSource(System::Threading::CancellationToken token1, System::Threading::CancellationToken token2);" />
      <MemberSignature Language="F#" Value="static member CreateLinkedTokenSource : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; System.Threading.CancellationTokenSource" Usage="System.Threading.CancellationTokenSource.CreateLinkedTokenSource (token1, token2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token1" Type="System.Threading.CancellationToken" />
        <Parameter Name="token2" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="token1">O primeiro token de cancelamento a ser observado.</param>
        <param name="token2">O segundo token de cancelamento a ser observado.</param>
        <summary>Cria um <see cref="T:System.Threading.CancellationTokenSource" /> que estará em estado cancelado quando qualquer um dos tokens de origem estiverem no estado cancelado.</summary>
        <returns>Um <see cref="T:System.Threading.CancellationTokenSource" /> vinculado aos tokens de origem.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um <see cref="T:System.Threading.CancellationTokenSource" /> associado a um dos tokens de origem foi descartado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6f4f3804-2ed7-41b4-a97a-6e32b93f6e05">Como ouvir várias solicitações de cancelamento</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cancellationTokenSource.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame `Dispose` quando tiver terminado de usar o <xref:System.Threading.CancellationTokenSource>. O `Dispose` método deixa o <xref:System.Threading.CancellationTokenSource> em um estado inutilizável. Depois de chamar `Dispose`, você deve liberar todas as referências para o <xref:System.Threading.CancellationTokenSource> para que o coletor de lixo possa recuperar a memória que o <xref:System.Threading.CancellationTokenSource> estava ocupando.  
  
 Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Sempre chamar `Dispose` antes de liberar sua última referência para o <xref:System.Threading.CancellationTokenSource>. Caso contrário, os recursos que ele está usando não serão liberados até que o coletor de lixo chame o <xref:System.Threading.CancellationTokenSource> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="cancellationTokenSource.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pela classe <see cref="T:System.Threading.CancellationTokenSource" /> e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationTokenSource.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCancellationRequested : bool" Usage="System.Threading.CancellationTokenSource.IsCancellationRequested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica se foi solicitado cancelamento para essa <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <value><see langword="true" /> se foi solicitado cancelamento para essa <see cref="T:System.Threading.CancellationTokenSource" />, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade indica se foi solicitado cancelamento para esta fonte de token, por exemplo, devido a uma chamada para seu <xref:System.Threading.CancellationTokenSource.Cancel%2A> método.  
  
 Se essa propriedade retornará `true`, apenas garante que o cancelamento foi solicitado. Ele não garante que cada manipulador registrado com o token correspondente finalizou a execução, nem que as solicitações de cancelamento tiveram terminado de propagar para todos os manipuladores registrados. Sincronização adicional pode ser necessária, especialmente em situações em que os objetos relacionados estão sendo cancelados simultaneamente.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
      </Docs>
    </Member>
    <Member MemberName="Token">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken Token { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken Token" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationTokenSource.Token" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Token As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken Token { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.Token : System.Threading.CancellationToken" Usage="System.Threading.CancellationTokenSource.Token" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Threading.CancellationToken" /> associado a este <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <value>O <see cref="T:System.Threading.CancellationToken" /> associado a este <see cref="T:System.Threading.CancellationTokenSource" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A fonte de token foi descartada.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelamento</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelamento da tarefa</related>
      </Docs>
    </Member>
  </Members>
</Type>