<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="62025fbb7d1925db8ef69f15ef025bce4e0db9c2" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39929306" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define um bloqueio que dá suporte a autores únicos e múltiplos leitores.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] tem dois bloqueios de leitor-gravador, <xref:System.Threading.ReaderWriterLockSlim> e <xref:System.Threading.ReaderWriterLock>. O <xref:System.Threading.ReaderWriterLockSlim> é recomendado para todos os novos desenvolvimentos. O <xref:System.Threading.ReaderWriterLockSlim> é semelhante ao <xref:System.Threading.ReaderWriterLock>, mas tem regras simplificadas para recursão e para atualização e downgrade de estado de bloqueio. <xref:System.Threading.ReaderWriterLockSlim> evita muitos casos potenciais de deadlock. Além disso, o desempenho de <xref:System.Threading.ReaderWriterLockSlim> é significativamente melhor que o de <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock> é usado para sincronizar o acesso a um recurso. A qualquer momento determinado, ele permite que o acesso simultâneo de leitura para vários threads, ou acesso de gravação para um único thread. Em uma situação em que um recurso é alterado com frequência, uma `ReaderWriterLock` fornece a melhor taxa de transferência que um bloqueio de um em vez de simple, como <xref:System.Threading.Monitor>.  
  
 `ReaderWriterLock` funciona melhor em que a maioria dos acessos são leituras, enquanto as gravações são frequentes e de curta duração. Vários leitores alternam com autores únicos, para que nem leitores nem gravadores estão bloqueados por longos períodos.  
  
> [!NOTE]
>  Mantendo bloqueios de leitor ou bloqueios de gravação por longos períodos será enfraquecer outros threads. Para obter melhor desempenho, considere a reestruturação do seu aplicativo para minimizar a duração de gravações.  
  
 Um thread pode conter um leitor de bloqueio ou um bloqueio de gravador, mas não ambos ao mesmo tempo. Em vez de liberar um bloqueio de leitor para adquirir o bloqueio de gravador, você pode usar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> e <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  
  
 Solicitações de bloqueio recursiva aumentam a contagem de bloqueio em um bloqueio.  
  
 Os leitores e gravadores são enfileirados separadamente. Quando um thread libera o bloqueio de gravador, todos os threads aguardando na fila leitor nesse momento são concedidos os bloqueios de leitor; Quando todos os bloqueios de leitor foram lançados, a próxima espera de thread no gravador de fila, se houver, é concedido o bloqueio de gravador e assim por diante. Em outras palavras, `ReaderWriterLock` alterna entre uma coleção de leitores e um gravador.  
  
 Enquanto um thread na fila de gravador está aguardando os bloqueios de leitor ativo a ser liberado, threads solicitando novos bloqueios de leitor se acumulam na fila de leitor. Suas solicitações não são concedidas, mesmo que eles podem compartilhar o acesso simultâneo com detentores de bloqueio de leitor existente; Isso ajuda a proteger gravadores em bloqueio indefinido pelos leitores.  
  
 A maioria dos métodos para adquirir bloqueios em um `ReaderWriterLock` aceitar valores de tempo limite. Use tempos limite para evitar deadlocks em seu aplicativo. Por exemplo, um thread pode adquirir o bloqueio de gravador em um recurso e, em seguida, solicitar um bloqueio de leitor em um segundo recurso; Enquanto isso, outro thread pode adquirir o bloqueio de gravador em segundo recurso e solicitar um bloqueio de leitor no primeiro. A menos que os tempos limite são usados, o segmentos apresentam um deadlock.  
  
 Se o intervalo de tempo limite expirar, e a solicitação de bloqueio não foi concedida, o método retorna o controle para o thread de chamada, lançando uma <xref:System.ApplicationException>. Um thread pode capturar essa exceção e determinar qual ação será tomada próxima.  
  
 Tempos limite são expressos em milissegundos. Se você usar um <xref:System.TimeSpan?displayProperty=nameWithType> para especificar o tempo limite, o valor usado é o número total de milissegundos inteiros representado pelo <xref:System.TimeSpan>. A tabela a seguir mostra os valores de tempo limite válido em milissegundos.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|-1|O thread aguarda até que o bloqueio é adquirido, independentemente de quanto tempo demora. Para métodos que especificam tempos limite de número inteiro, a constante <xref:System.Threading.Timeout.Infinite> pode ser usado.|  
|0|O thread não espera para adquirir o bloqueio. Se o bloqueio não pode ser adquirido imediatamente, o método retorna.|  
|>0|O número de milissegundos de espera.|  
  
 Com exceção de -1, não são permitidos valores de tempo limite negativo. Se você especificar um inteiro negativo diferente de -1, um valor de tempo limite de zero será usado. (Ou seja, o método retorna sem esperar, se o bloqueio não pode ser adquirido imediatamente.) Se você especificar uma <xref:System.TimeSpan> que representa um número negativo de milissegundos diferente de -1, <xref:System.ArgumentOutOfRangeException> é lançada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar um <xref:System.Threading.ReaderWriterLock> para proteger um recurso compartilhado, um valor inteiro chamado `resource`, que é ler simultaneamente e escritos exclusivamente por vários threads. Observe que o <xref:System.Threading.ReaderWriterLock> é declarado no nível de classe para que ele fique visível a todos os threads.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como criar uma nova instância do <xref:System.Threading.ReaderWriterLock> classe.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquire um bloqueio de leitor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
        <summary>Adquire um bloqueio de leitor, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> bloqueia um thread diferente tem o bloqueio de gravador, ou se pelo menos um thread está aguardando o bloqueio de gravador.  
  
> [!NOTE]
>  Se o thread atual já tiver o bloqueio de gravador, nenhum bloqueio de leitor é adquirido. Em vez disso, a contagem de bloqueio no bloqueio de gravador é incrementada. Isso impede que um segmento de bloqueio em seu próprio bloqueio de gravador. O resultado é exatamente o mesmo que chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>e uma chamada adicional para <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> é necessária ao liberar o bloqueio de gravador.  
  
 `AcquireReaderLock` dá suporte a solicitações de bloqueio de leitor de recursiva. Ou seja, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueio de cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> uma vez para cada vez que você chamar `AcquireReaderLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursivas sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila de leitor. Use bloqueios de recursiva com cuidado, para evitar o bloqueio de solicitações de bloqueio de gravador por longos períodos.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de leitor e como tratar a exceção gerada quando uma solicitação expira.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
        <summary>Adquire um bloqueio de leitor, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> bloqueia um thread diferente tem o bloqueio de gravador, ou se pelo menos um thread está aguardando o bloqueio de gravador.  
  
> [!NOTE]
>  Se o thread atual já tiver o bloqueio de gravador, nenhum bloqueio de leitor é adquirido. Em vez disso, a contagem de bloqueio no bloqueio de gravador é incrementada. Isso impede que um segmento de bloqueio em seu próprio bloqueio de gravador. O resultado é exatamente o mesmo que chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>e uma chamada adicional para <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> é necessária ao liberar o bloqueio de gravador.  
  
 `AcquireReaderLock` dá suporte a solicitações de bloqueio de leitor de recursiva. Ou seja, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueio de cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> uma vez para cada vez que você chamar `AcquireReaderLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursivas sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila de leitor. Use bloqueios de recursiva com cuidado, para evitar o bloqueio de solicitações de bloqueio de gravador por longos períodos.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquire o bloqueio de gravador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
        <summary>Adquire um bloqueio de gravador, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia se outro thread tiver um bloqueio de leitor ou gravador. Para obter uma descrição da maneira como o bloqueio de gravador é alternada com vários bloqueios de leitor simultâneo, consulte o <xref:System.Threading.ReaderWriterLock> classe.  
  
 Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de gravador em uma das duas maneiras: liberando o bloqueio de leitor antes de chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Se um thread chama `AcquireWriterLock` enquanto ele ainda tem um bloqueio de leitor, ele será bloqueado em seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, o thread enfrentarão deadlock. Para evitar esses deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar se o thread atual já tem um bloqueio de leitor.  
  
 `AcquireWriterLock` dá suporte a solicitações de bloqueio de gravador recursiva. Ou seja, um thread pode chamar `AcquireWriterLock` várias vezes, que incrementa a contagem de bloqueio de cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> uma vez para cada vez que você chamar `AcquireWriterLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursivas sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila do gravador.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de gravador e como tratar a exceção gerada quando uma solicitação expira.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
        <summary>Adquire um bloqueio de gravador, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método bloqueia se outro thread tiver um bloqueio de leitor ou gravador. Para obter uma descrição da maneira como o bloqueio de gravador é alternada com vários bloqueios de leitor simultâneo, consulte o <xref:System.Threading.ReaderWriterLock> classe.  
  
 Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de gravador em uma das duas maneiras: liberando o bloqueio de leitor antes de chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Se um thread chama `AcquireWriterLock` enquanto ele ainda tem um bloqueio de leitor, ele será bloqueado em seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, o thread enfrentarão deadlock. Para evitar esses deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar se o thread atual já tem um bloqueio de leitor.  
  
 `AcquireWriterLock` dá suporte a solicitações de bloqueio de gravador recursiva. Ou seja, um thread pode chamar `AcquireWriterLock` várias vezes, que incrementa a contagem de bloqueio de cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> uma vez para cada vez que você chamar `AcquireWriterLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursivas sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila do gravador.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">O número de sequência.</param>
        <summary>Indica se o bloqueio de gravador foi concedido a qualquer thread desde que o número de sequência foi obtido.</summary>
        <returns>
          <see langword="true" /> se o bloqueio de gravador tiver sido concedido a qualquer thread desde que o número de sequência foi obtido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> e `AnyWritersSince` para melhorar o desempenho do aplicativo. Por exemplo, um thread pode armazenar em cache as informações que ele obtém mantendo um bloqueio de leitor. Após a liberação e mais tarde readquirir o bloqueio, o thread pode usar `AnyWritersSince` para determinar se outros threads têm escrito para o recurso durante o processo; caso contrário, as informações em cache podem ser usadas. Essa técnica é útil onde as informações protegidas pelo bloqueio de leitura é caro; Por exemplo, executando uma consulta de banco de dados.  
  
 O chamador deve ser mantendo um bloqueio de leitor ou um bloqueio de gravador para que o número de sequência para serem úteis.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> método e o <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> pela última vez, propriedade para determinar se outro thread adquiriu o bloqueio de gravador de recurso protegido desde o thread atual mantém o bloqueio de gravador.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock :  -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Restaura o status de bloqueio do thread para o status prévio antes de <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> ser chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> libera o bloqueio de gravador, independentemente da contagem de bloqueio recursivos e restaura o bloqueio de leitor foi mantido pelo thread antes de atualizar para o bloqueio de gravador. A contagem de bloqueio no bloqueio de leitor é restaurada.  
  
> [!NOTE]
>  `DowngradeFromWriterLock` aceita uma <xref:System.Threading.LockCookie> obtido chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. Não use uma `LockCookie` retornado por <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  
  
 Um thread não bloqueia ao fazer downgrade de bloqueio de gravador, mesmo se outros threads estão aguardando o bloqueio de gravador, porque todas as solicitações de bloqueio de leitor são concedidas quando o bloqueio de gravador é liberado.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como solicitar um bloqueio de leitor, atualize o bloqueio de leitor para um bloqueio de gravador e fazer o downgrade para um bloqueio de leitor novamente.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread não tem o bloqueio de gravador.</exception>
        <exception cref="T:System.NullReferenceException">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O coletor de lixo chama <xref:System.Threading.ReaderWriterLock.Finalize%2A> quando atual <xref:System.Threading.ReaderWriterLock> objeto está pronto para ser finalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual mantém um bloqueio de leitor.</summary>
        <value>
          <see langword="true" /> Se o thread atual mantém um bloqueio de leitor; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar `IsReaderLockHeld` para evitar deadlocks.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual mantém um bloqueio de gravador.</summary>
        <value>
          <see langword="true" /> Se o thread atual mantiver o bloqueio de gravador; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra que, quando é feita uma tentativa para adquirir um bloqueio de leitor em um thread que tem um bloqueio de gravador, `ReaderWriterLock` não concede o bloqueio de leitor, mas em vez disso, incrementa a contagem de bloqueio no bloqueio de gravador.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera o bloqueio, independentemente do número de vezes que o thread adquiriu o bloqueio.</summary>
        <returns>Um valor <see cref="T:System.Threading.LockCookie" /> que representa o bloqueio liberado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> libera o bloqueio de leitor ou gravador, independentemente da contagem de bloqueio recursiva. Para restaurar o estado do bloqueio, incluindo a contagem de bloqueio, passe o <xref:System.Threading.LockCookie> para <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar o bloqueio, independentemente de quantas vezes ele foi adquirido por thread e como restaurar o estado do bloqueio mais tarde.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diminui a contagem de bloqueio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> Diminui a contagem de bloqueio. Quando a contagem chega a zero, o bloqueio é liberado.  
  
> [!NOTE]
>  Se um thread possui o bloqueio de gravador, chamando `ReleaseReaderLock` tem o mesmo efeito de chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. Se um thread não tem nenhum bloqueio, chamando `ReleaseReaderLock` lança um <xref:System.ApplicationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de leitor e como tratar a exceção gerada quando uma solicitação expira.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread não tem nenhum bloqueio de leitor ou de gravador.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diminui a contagem de bloqueio no bloqueio de gravador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> diminui o bloqueio de gravador contagem. Quando a contagem chega a zero, o bloqueio de gravador é liberado.  
  
> [!NOTE]
>  Se um thread tem um bloqueio de leitor, ou nenhum bloqueio, chamando `ReleaseWriterLock` lança um <xref:System.ApplicationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de gravador e como tratar a exceção gerada quando uma solicitação expira.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread não tem o bloqueio de gravador.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock :  -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Restaura o status de bloqueio do thread para o que era antes de chamar <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O estado restaurado por `RestoreLock` inclui a contagem de bloqueio recursiva.  
  
 Um thread seja bloqueado se tentar restaurar um bloqueio de leitor depois de outro thread adquiriu o bloqueio de gravador, ou se ele tentar restaurar o bloqueio de gravador após o outro thread adquiriu um bloqueio de leitor ou gravador. Porque `RestoreLock` não aceita um tempo limite, você deve ter cuidado para evitar possíveis deadlocks.  
  
> [!CAUTION]
>  Antes de chamar `RestoreLock`, verifique se você lançou uma todos os bloqueios adquiridos desde a chamada para <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. Por exemplo, um thread deadlocks se adquire um bloqueio de leitor e, em seguida, tenta restaurar um bloqueio de gravador anterior. Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> e <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> para detectar esses bloqueios adicionais.  
  
 Não use uma <xref:System.Threading.LockCookie> retornado de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar o bloqueio, independentemente de quantas vezes ele foi adquirido por thread e como restaurar o estado do bloqueio mais tarde.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Faz o upgrade de um bloqueio de leitor para o bloqueio de gravador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
        <summary>Atualiza um bloqueio de leitor para o bloqueio de gravador, usando um valor <see langword="Int32" /> para o tempo limite.</summary>
        <returns>Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread chama `UpgradeToWriterLock` o bloqueio de leitor é liberado, independentemente da contagem de bloqueio, e o thread vai para o final da fila de bloqueio de gravador. Assim, outros threads podem gravar o recurso antes que o thread que solicitou que a atualização é concedida o bloqueio de gravador.  
  
> [!IMPORTANT]
>  A exceção de tempo limite não é lançada até que o thread que chamou o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método pode readquirir o bloqueio de leitor. Se houver outros segmentos aguardando o bloqueio de gravador, isso acontece imediatamente. No entanto, se outro thread está na fila de bloqueio de gravador, o thread que chamado o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método não é possível readquirir o bloqueio de leitor até que todos os leitores atuais lançaram seus bloqueios e um thread tenha adquirido e liberado o bloqueio de gravador. Isso é verdadeiro mesmo se o outro thread que solicitou o bloqueio de gravador solicitou que ela depois que o thread atual é chamado de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.  
  
 Para restaurar o estado de bloqueio, chame <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> usando o <xref:System.Threading.LockCookie> retornado pela `UpgradeToWriterLock`. Não use isso `LockCookie` com <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Quando um thread não tem nenhum bloqueio de leitor, não use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> em seu lugar.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como solicitar um bloqueio de leitor, atualize o bloqueio de leitor para um bloqueio de gravador e fazer o downgrade para um bloqueio de leitor novamente.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
        <summary>Faz o upgrade de um bloqueio de leitor para o bloqueio de gravador usando um valor <see langword="TimeSpan" /> para o tempo limite.</summary>
        <returns>Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread chama `UpgradeToWriterLock` o bloqueio de leitor é liberado, independentemente da contagem de bloqueio, e o thread vai para o final da fila de bloqueio de gravador. Assim, outros threads podem gravar o recurso antes que o thread que solicitou que a atualização é concedida o bloqueio de gravador.  
  
> [!IMPORTANT]
>  A exceção de tempo limite não é lançada até que o thread que chamou o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método pode readquirir o bloqueio de leitor. Se houver outros segmentos aguardando o bloqueio de gravador, isso acontece imediatamente. No entanto, se outro thread está na fila de bloqueio de gravador, o thread que chamado o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método não é possível readquirir o bloqueio de leitor até que todos os leitores atuais lançaram seus bloqueios e um thread tenha adquirido e liberado o bloqueio de gravador. Isso é verdadeiro mesmo se o outro thread que solicitou o bloqueio de gravador solicitou que ela depois que o thread atual é chamado de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.  
  
 Para restaurar o estado de bloqueio, chame <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> usando o <xref:System.Threading.LockCookie> retornado pela `UpgradeToWriterLock`. Não use isso `LockCookie` com <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Quando um thread não tem nenhum bloqueio de leitor, não use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> em seu lugar.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de sequência atual.</summary>
        <value>O número de sequência atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência número aumenta sempre que um thread adquire o bloqueio de gravador. Você pode salvar o número de sequência e passá-lo para <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> em um momento posterior, se você quiser determinar se outros threads tiveram adquirido o bloqueio de gravador nesse meio tempo.  
  
 Você pode usar `WriterSeqNum` para melhorar o desempenho do aplicativo. Por exemplo, um thread pode armazenar em cache as informações que ele obtém mantendo um bloqueio de leitor. Após a liberação e mais tarde readquirir o bloqueio, o thread pode determinar se outros threads têm escrito para o recurso chamando `AnyWritersSince`; se não, as informações em cache podem ser usadas. Essa técnica é útil quando as informações protegidas pelo bloqueio de leitura é caro; Por exemplo, executando uma consulta de banco de dados.  
  
 O chamador deve ser mantendo um bloqueio de leitor ou um bloqueio de gravador para que o número de sequência para serem úteis.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriedade e o <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> pela última vez, método para determinar se outro thread adquiriu o bloqueio de gravador de recurso protegido desde o thread atual mantém o bloqueio de gravador.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>