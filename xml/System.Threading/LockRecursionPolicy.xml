<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LockRecursionPolicy.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52aaae222fcf2f023007bf6b87e2bf7c7bb83adaa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2aaae222fcf2f023007bf6b87e2bf7c7bb83adaa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.LockRecursionPolicy">
          <source>Specifies whether a lock can be entered multiple times by the same thread.</source>
          <target state="translated">Especifica se um bloqueio pode ser inserido várias vezes pelo mesmo thread.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The default recursion policy depends on the type of lock.</source>
          <target state="translated">A política de recursão padrão depende do tipo de bloqueio.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</source>
          <target state="translated">Para a política padrão e o comportamento preciso de recursão de bloqueio para qualquer tipo de bloqueio, consulte a documentação para o tipo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For example, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</source>
          <target state="translated">Por exemplo, a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe não permite que um thread inserir o bloqueio no modo de gravação, se ele já inseriu o bloqueio em modo de leitura, independentemente da configuração de política de bloqueio, para reduzir a chance de deadlocks.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>Currently only one lock uses this enumeration:</source>
          <target state="translated">No momento, somente um bloqueio usa esta enumeração:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property.</source>
          <target state="translated">Para obter mais informações, consulte a propriedade <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">O exemplo a seguir mostra dois cenários de exceção, que depende de <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> configuração e outra que não.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</source>
          <target state="translated">No primeiro cenário, o thread insere o bloqueio em modo de leitura e, em seguida, tenta inserir o modo de leitura recursivamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> é criado usando o construtor padrão, que define a política de recursão para NoRecursion, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If SupportsRecursion is used to create the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Se SupportsRecursion é usado para criar o <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, nenhuma exceção é lançada.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</source>
          <target state="translated">O segundo cenário, o thread insere o bloqueio em modo de leitura e, em seguida, tenta digitar o bloqueio no modo de gravação.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> será lançada, independentemente da política de recursão de bloqueio.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>If a thread tries to enter a lock recursively, an exception is thrown.</source>
          <target state="translated">Se um thread tentar inserir um bloqueio recursivamente, uma exceção será lançada.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>Some classes may allow certain recursions when this setting is in effect.</source>
          <target state="translated">Algumas classes podem permitir determinadas recursões quando essa configuração está em vigor.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>A thread can enter a lock recursively.</source>
          <target state="translated">Um thread pode inserir um bloqueio recursivamente.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>Some classes may restrict this capability.</source>
          <target state="translated">Algumas classes podem restringir essa funcionalidade.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>