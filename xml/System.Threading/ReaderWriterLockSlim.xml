<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3464038fcf06fcd6ab722a9c4b6f82b812141c99" />
    <Meta Name="ms.sourcegitcommit" Value="84c54c0c7d64827a5637d1f05e74e1f0598606a1" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/27/2018" />
    <Meta Name="ms.locfileid" Value="42942847" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um bloqueio que é usado para gerenciar o acesso a um recurso, permitindo vários threads para leitura ou acesso exclusivo para gravação.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Threading.ReaderWriterLockSlim> para proteger um recurso que é lida por vários threads e gravado por um thread por vez. <xref:System.Threading.ReaderWriterLockSlim> permite que vários threads estar no modo de leitura, permite que um thread esteja no modo de gravação com a propriedade exclusiva do bloqueio e permite que um thread que tem acesso de leitura para estar no modo de leitura pode ser atualizado, do qual o thread pode atualizar para o modo de gravação sem precisar liberar ele s o acesso de leitura para o recurso.  
  
> [!NOTE]
>  O <xref:System.Threading.ReaderWriterLockSlim> é semelhante ao <xref:System.Threading.ReaderWriterLock>, mas tem regras simplificadas para recursão e para atualização e downgrade de estado de bloqueio. <xref:System.Threading.ReaderWriterLockSlim> evita muitos casos potenciais de deadlock. Além disso, o desempenho de <xref:System.Threading.ReaderWriterLockSlim> é significativamente melhor que o de <xref:System.Threading.ReaderWriterLock>. O <xref:System.Threading.ReaderWriterLockSlim> é recomendado para todos os novos desenvolvimentos.  
  
 Por padrão, novas instâncias de <xref:System.Threading.ReaderWriterLockSlim> são criados com o <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> sinalizador e não permitir a recursão. Essa política padrão é recomendada para todos os novos desenvolvimentos, como recursão introduz complicações desnecessárias e torna seu código mais propensa a deadlocks. Para simplificar a migração de existente projetos que usam <xref:System.Threading.Monitor> ou <xref:System.Threading.ReaderWriterLock>, você pode usar o <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> sinalizador para criar instâncias de <xref:System.Threading.ReaderWriterLockSlim> que permitem a recursão.  
  
 Um thread pode inserir o bloqueio em três modos: modo, o modo de gravação e o modo de leitura pode ser atualizado de leitura. (No restante deste tópico, "modo de leitura pode ser atualizado" é chamado de "modo de upgrade" e a frase "Insira `x` modo de" é usado em preferência a frase mais longa "entrar no bloqueio no `x` modo".)  
  
 Independentemente da política de recursão, apenas um thread pode ser no modo de gravação a qualquer momento. Quando um thread está no modo de gravação, nenhum outro thread pode inserir o bloqueio em qualquer modo. Apenas um thread pode estar no modo pode ser atualizado a qualquer momento. Qualquer número de threads pode estar no modo de leitura e pode haver um thread no modo de upgrade, enquanto outro thread está no modo de leitura.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 <xref:System.Threading.ReaderWriterLockSlim> gerencia afinidade de thread; ou seja, cada <xref:System.Threading.Thread> objeto deve fazer suas próprias chamadas de método para entrar e sair de modos de bloqueio. Nenhum thread pode alterar o modo de outro thread.  
  
 Se um <xref:System.Threading.ReaderWriterLockSlim> não permite a recursão, um thread que tenta entrar no bloqueio pode bloquear por vários motivos:  
  
-   Um thread que tenta inserir blocos de modo de leitura se não houver threads esperando para inserir o modo de gravação ou se há um único thread no modo de gravação.  
  
    > [!NOTE]
    >  Novos leitores de bloqueio quando gravadores estão na fila é uma política de integridade de bloqueio que favoreça gravadores. A política de integridade atual saldos de igualdade para os leitores e gravadores, para promover a taxa de transferência em cenários mais comuns. Versões futuras do [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] pode introduzir novas políticas de integridade.  
  
-   Um thread que tenta inserir blocos de modo de upgrade se já houver um thread no modo de upgrade, se não houver threads aguardando para entrar no modo de gravação, ou se não houver um único thread no modo de gravação.  
  
-   Um thread que tenta inserir blocos de modo de gravação se não houver um thread em qualquer um dos três modos.  
  
## <a name="upgrading-and-downgrading-locks"></a>Bloqueios de atualização e downgrade  
 Modo de upgrade destina-se a casos em que um thread lê geralmente do recurso protegido, mas talvez seja necessário gravar nele se alguma condição for atendida. Um thread que entrou em um <xref:System.Threading.ReaderWriterLockSlim> no modo de upgrade, tem acesso de leitura para o recurso protegido e pode atualizar para o modo de gravação por meio da chamada a <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> ou <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> métodos. Como pode haver apenas um thread no modo de upgrade por vez, atualizando para o modo de gravação não é possível deadlock quando recursão não é permitido, que é a política padrão.  
  
> [!IMPORTANT]
>  Independentemente da política de recursão, um thread que inseriu inicialmente ler modo não é permitido atualizar para o modo de upgrade ou modo de gravação, porque esse padrão cria uma grande probabilidade de deadlocks. Por exemplo, se dois threads no modo de leitura que ambos tentam inserir o modo de gravação, elas enfrentarão deadlock. Modo de upgrade foi projetado para evitar esses deadlocks.  
  
 Se houver outros threads no modo de leitura, o thread que está atualizando os blocos. Enquanto o thread estiver bloqueado, outros threads que tentarem entrar no modo de leitura são bloqueados. Quando todos os threads tenham saído do modo de leitura, o thread pode ser atualizado bloqueado entra no modo de gravação. Se houver outros threads esperando para inserir o modo de gravação, eles permanecem bloqueados, pois o único thread que está no modo de upgrade impede que eles obtenham acesso exclusivo ao recurso.  
  
 Quando o thread no modo de upgrade sai do modo de gravação, outros threads que estão esperando para inserir o modo de leitura podem fazer isso, a menos que haja threads esperando para inserir modo de gravação. O thread no modo de upgrade pode atualizar e fazer o downgrade indefinidamente, desde que ele é o único thread que grava no recurso protegido.  
  
> [!IMPORTANT]
>  Se você permitir que vários threads inserir gravação modo ou modo de upgrade, você não deve permitir que um thread monopolize o modo de upgrade. Caso contrário, os threads que tentam inserir gravar modo diretamente será bloqueado indefinidamente, e enquanto eles estiverem bloqueados, outros threads poderão entrar no modo de leitura.  
  
 Um thread no modo de upgrade pode fazer o downgrade para o modo de leitura pelo primeiro chamar o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método e, em seguida, chamar o <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método. Esse padrão de downgrade é permitida para todas as políticas de recursão de bloqueio, até mesmo <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 Depois de fazer o downgrade para o modo de leitura, um thread não é possível reinserir o modo de upgrade até que ele saiu do modo de leitura.  
  
## <a name="entering-the-lock-recursively"></a>Inserir o bloqueio recursivamente  
 Você pode criar uma <xref:System.Threading.ReaderWriterLockSlim> que dá suporte à entrada de bloqueio recursiva usando o <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> construtor que especifica a política de bloqueio e a especificação <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  O uso de recursão não é recomendado para novos desenvolvimentos, porque ela introduz complicações desnecessárias e torna seu código mais propensa a deadlocks.  
  
 Para um <xref:System.Threading.ReaderWriterLockSlim> que permite que a recursão, o seguinte pode ser dito sobre os modos de um thread pode inserir:  
  
-   Um thread no modo de leitura pode inserir o modo de leitura recursivamente, mas não é possível inserir o modo de gravação ou pode ser atualizado. Se tentar fazer isso, um <xref:System.Threading.LockRecursionException> é gerada. Inserir ler modo e, em seguida, inserindo o modo de gravação ou modo de upgrade é um padrão com uma grande probabilidade de deadlocks, portanto, não é permitido. Conforme discutido anteriormente, o modo de upgrade é fornecido para casos em que é necessário atualizar um bloqueio.  
  
-   Um thread no modo de upgrade pode inserir o modo de gravação de e/ou modo de leitura e pode inserir qualquer um de três modos recursivamente. No entanto, uma tentativa de inserir gravar blocos de modo a se há outros threads no modo de leitura.  
  
-   Um thread no modo de gravação pode inserir o modo de leitura e/ou modo de upgrade e pode inserir qualquer um de três modos recursivamente.  
  
-   Um thread que não entrou no bloqueio pode inserir qualquer modo. Essa tentativa pode bloquear pelos mesmos motivos como uma tentativa de inserir um bloqueio de não-recursivo.  
  
 Um thread pode sair os modos em que ele entrou em qualquer ordem, desde que ele sai do modo de cada exatamente como quantas vezes ele entrou em que o modo. Se um thread tentar sair de um modo de muitas vezes, ou para sair do modo de não entrou, um <xref:System.Threading.SynchronizationLockException> é gerada.  
  
## <a name="lock-states"></a>Estados de bloqueio  
 Você talvez ache útil considerar o bloqueio em termos de seus estados. Um <xref:System.Threading.ReaderWriterLockSlim> pode estar em um dos quatro estados: não inserida, ler, atualizar e gravar.  
  
-   Não digitado: nesse estado, nenhum thread inseriu o bloqueio (ou todos os threads tenham saído do bloqueio).  
  
-   Leitura: Nesse estado, um ou mais threads inseriu o bloqueio de acesso de leitura ao recurso protegido.  
  
    > [!NOTE]
    >  Um thread pode inserir o bloqueio no modo de leitura usando o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> ou <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> métodos, ou fazer downgrade do modo de upgrade.  
  
-   Atualização: Nesse estado, um thread entrou no bloqueio de acesso de leitura com a opção de atualização para acesso de gravação (ou seja, no modo de upgrade), e zero ou mais threads inseriu o bloqueio de acesso de leitura. Não mais do que um thread por vez pode entrar no bloqueio com a opção para atualizar; threads adicionais que tenta entrar no modo atualizável são bloqueadas.  
  
-   Gravação: Nesse estado, um thread entrou no bloqueio para acesso de gravação ao recurso protegido. Esse thread tiver posse exclusivo do bloqueio. Qualquer outro thread que tenta entrar no bloqueio por qualquer motivo é bloqueado.  
  
 A tabela a seguir descreve as transições entre estados de bloqueio, para os bloqueios que não permitem a recursão, quando um thread `t` executa a ação descrita na coluna mais à esquerda. No momento, ele executa a ação, `t` não tem nenhum modo. (Caso especial em que `t` está no modo de upgrade é descrito nas notas de rodapé de tabela.) A linha superior descreve o estado inicial do bloqueio. As células descrevem o que acontece com o thread e mostram as alterações para o estado de bloqueio entre parênteses.  
  
||Não é inserido (N)|Read (R)|Atualização (U)|Gravação (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` entra no modo de leitura|`t` Insere (R).|`t` blocos se segmentos estão aguardando para modo de gravação; Caso contrário, `t` entra.|`t` blocos se segmentos estão aguardando para modo de gravação; Caso contrário, `t` entra.<sup> 1</sup>|`t` blocos.|  
|`t` entra em modo de upgrade|`t` Insere (U).|`t` blocos se segmentos estão aguardando para gravar o modo ou modo de atualização; Caso contrário, `t` entra (U).|`t` blocos.|`t` blocos.|  
|`t` entra no modo de gravação|`t` Insere (W).|`t` blocos.|`t` blocos. <sup>2</sup>|`t` blocos.|  
  
 <sup>1</sup> se `t` inicia out no modo de upgrade, ele entra em modo de leitura. Essa ação nunca bloqueia. Não altera o estado de bloqueio. (O thread pode, em seguida, concluir um downgrade para o modo de leitura ao sair do modo de upgrade.)  
  
 <sup>2</sup> se `t` é iniciado no modo de upgrade, ele bloqueia se não houver threads no modo de leitura. Caso contrário, ele atualiza para o modo de gravação. As alterações de estado de bloqueio para gravação (W). Se `t` bloqueia porque há threads no modo de leitura, ele entra no modo de gravação, assim que o último thread sai do modo de leitura, mesmo se não houver threads esperando para inserir modo de gravação.  
  
 Quando uma alteração de estado ocorre porque um thread é encerrado o bloqueio, o próximo segmento a ser despertado é selecionado da seguinte maneira:  
  
-   Primeiro, um thread que está aguardando modo de gravação e já está no modo de upgrade (pode haver no máximo um thread desse tipo).  
  
-   Caso de falha, um thread que está aguardando o modo de gravação.  
  
-   Caso de falha, um thread que está aguardando o modo de upgrade.  
  
-   Caso de falha, todos os threads que estão aguardando o modo de leitura.  
  
 O estado subsequente do bloqueio é sempre gravar (W) na primeira atualização (U) e dois casos no caso de terceiro, independentemente do estado do bloqueio quando o thread existente disparado a alteração de estado. No último caso, o estado do bloqueio é de atualização (U) se não houver um thread no modo de upgrade após a alteração de estado e Read (R) caso contrário, independentemente do estado anterior.  
  
   
  
## Examples  
 O exemplo a seguir mostra um cache sincronizado simple que contém cadeias de caracteres com chaves de inteiro. Uma instância do <xref:System.Threading.ReaderWriterLockSlim> é usado para sincronizar o acesso para o <xref:System.Collections.Generic.Dictionary%602> que serve como o cache interno.  
  
 O exemplo inclui métodos simples para adicionar ao cache, excluir do cache e lidos do cache. Para demonstrar os tempos limite, o exemplo inclui um método que adiciona ao cache somente se ele pode fazer isso dentro de um tempo limite especificado.  
  
 Para demonstrar o modo de upgrade, o exemplo inclui um método que recupera o valor associado com uma chave e o compara com um novo valor. Se o valor não é alterado, o método retorna um status que indica nenhuma alteração. Se nenhum valor for encontrado para a chave, o par chave/valor é inserido. Se o valor for alterado, ele será atualizado. Modo de upgrade permite que o thread atualizar do acesso de leitura para acesso de gravação, conforme necessário, sem o risco de deadlocks.  
  
 O exemplo inclui uma enumeração aninhada que especifica os valores de retorno para o método que demonstra o modo de upgrade.  
  
 O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão. Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 O código a seguir usa o `SynchronizedCache` objeto para armazenar um dicionário de nomes de legumes. Ele cria três tarefas. O primeiro grava os nomes de legumes armazenados em uma matriz para um `SynchronizedCache` instância. A tarefa de segunda e terceira exibem os nomes de legumes, o primeiro em ordem crescente (da baixo índice de índice alto), o segundo em ordem decrescente. A tarefa final procura a cadeia de caracteres "cucumber" e, quando ele encontra, chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para substituir a cadeia de caracteres "verde bean".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> com os valores da propriedade padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Threading.ReaderWriterLockSlim> que é inicializada com esse construtor não permite a recursão. Ou seja, a propriedade <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> do método retorna <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre a política de recursão e seus efeitos, consulte o <xref:System.Threading.LockRecursionPolicy> enumeração e a <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra um cache sincronizado simple que contém cadeias de caracteres com chaves de inteiro. Uma instância do <xref:System.Threading.ReaderWriterLockSlim> é usado para sincronizar o acesso para o <xref:System.Collections.Generic.Dictionary%602> que serve como o cache interno. O construtor sem parâmetros é usado para criar o bloqueio.  
  
 O exemplo inclui métodos simples para adicionar ao cache, excluir do cache e lidos do cache. Para demonstrar os tempos limite, o exemplo inclui um método que adiciona ao cache somente se ele pode fazer isso dentro de um tempo limite especificado.  
  
 Para demonstrar o modo de upgrade, o exemplo inclui um método que recupera o valor associado com uma chave e o compara com um novo valor. Se o valor não é alterado, o método retorna um status que indica nenhuma alteração. Ela nenhum valor for encontrado para a chave, o par chave/valor é inserido. Se o valor for alterado, ele será atualizado. Modo de upgrade permite que o thread atualizar do acesso de leitura para acesso de gravação, conforme necessário, sem o risco de deadlocks.  
  
 O exemplo inclui uma enumeração aninhada que especifica os valores de retorno para o método que demonstra o modo de upgrade.  
  
 O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão. Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 O código a seguir usa o `SynchronizedCache` objeto para armazenar um dicionário de nomes de legumes. Ele cria três tarefas. O primeiro grava os nomes de legumes armazenados em uma matriz para um `SynchronizedCache` instância. A tarefa de segunda e terceira exibem os nomes de legumes, o primeiro em ordem crescente (da baixo índice de índice alto), o segundo em ordem decrescente. A tarefa final procura a cadeia de caracteres "cucumber" e, quando ele encontra, chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para substituir a cadeia de caracteres "verde bean".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Um dos valores de enumeração que especifica a política de recursão de bloqueio.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, especificando a política de recursão de bloqueio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Política de recursão determina as restrições em threads que entrar no bloqueio de mais de uma vez. Por exemplo, se um bloqueio foi criado com <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e um thread entrou no bloqueio no modo de leitura, <xref:System.Threading.LockRecursionException> será gerada se o thread tenta reintroduzir o bloqueio no modo de leitura. Da mesma forma, se um thread entrou no bloqueio no modo de gravação, <xref:System.Threading.LockRecursionException> será gerada se o thread tenta reintroduzir o bloqueio em qualquer modo.  
  
> [!NOTE]
>  Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para modo independentemente da configuração de política de recursão de bloqueio de leitura.  
  
 Independentemente da política de recursão, um thread que inseriu inicialmente ler modo não é permitido atualizar para o modo de upgrade ou modo de gravação, porque esse padrão cria uma grande probabilidade de deadlocks.  
  
 Para obter mais informações sobre a política de recursão e seus efeitos, consulte o <xref:System.Threading.LockRecursionPolicy> enumeração e a <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra dois cenários de exceção, que depende do <xref:System.Threading.LockRecursionPolicy> configuração e que não faz isso.  
  
 No primeiro cenário, o thread entra no modo de leitura e, em seguida, tenta inserir recursivamente do modo de leitura. Se o <xref:System.Threading.ReaderWriterLockSlim> é criado usando o construtor padrão, que define a política de recursão <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, uma exceção será lançada. Se <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> é usado para criar o <xref:System.Threading.ReaderWriterLockSlim>, nenhuma exceção é lançada.  
  
 No segundo cenário, o thread entra no modo de leitura e, em seguida, tenta inserir modo de gravação. <xref:System.Threading.LockRecursionException> é lançada independentemente da política de recursão de bloqueio.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 O código a seguir usa o `SynchronizedCache` objeto para armazenar um dicionário de nomes de legumes. Ele cria três tarefas. O primeiro grava os nomes de legumes armazenados em uma matriz para um `SynchronizedCache` instância. A tarefa de segunda e terceira exibem os nomes de legumes, o primeiro em ordem crescente (da baixo índice de índice alto), o segundo em ordem decrescente. A tarefa final procura a cadeia de caracteres "cucumber" e, quando ele encontra, chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para substituir a cadeia de caracteres "verde bean".  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número total de threads exclusivos que inseriram o bloqueio no modo de leitura.</summary>
        <value>O número de threads exclusivos que inseriram o bloqueio no modo de leitura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread é contado apenas uma vez, mesmo se o bloqueio permite que o thread e recursão entrou em modo de leitura várias vezes.  
  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads no modo de leitura exceder um limite.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> quando tiver terminado de usar o <xref:System.Threading.ReaderWriterLockSlim>. O <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> método deixa o <xref:System.Threading.ReaderWriterLockSlim> em um estado inutilizável. Depois de chamar <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, você deve liberar todas as referências para o <xref:System.Threading.ReaderWriterLockSlim> para que o coletor de lixo possa recuperar a memória que o <xref:System.Threading.ReaderWriterLockSlim> estava ocupando. Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> antes de liberar sua última referência para o <xref:System.Threading.ReaderWriterLockSlim> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> é maior que zero.  
  
- ou - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> é maior que zero.  
  
- ou - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> é maior que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tenta entrar no bloqueio em modo de leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este blocos de método até que o thread de chamada entra no bloqueio e, portanto, talvez nunca retornam. Use o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloquear para um intervalo especificado, e, em seguida, retornar se o thread de chamada não entrou em modo de leitura durante esse intervalo.  
  
 Vários threads podem entrar no modo de leitura ao mesmo tempo.  
  
 Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> blocos de método até que esses threads tenham atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de leitura pode inserir repetidamente do modo de leitura, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
 No máximo um thread pode estar em modo de upgrade, enquanto outro thread está no modo de leitura. Se os threads adicionais estão esperando para inserir o modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, threads que chamam o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método entrar imediatamente no modo de leitura e não bloquear.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método para inserir o bloqueio no modo de leitura. O método mostrado no exemplo recupera o valor associado com uma chave. Se a chave não for encontrada, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate. Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> método, garantindo que o chamador sai do modo de leitura.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de leitura.  
  
- ou - 
A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de gravação.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca devem encontrar essa exceção.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tenta entrar no bloqueio no modo atualizável.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este blocos de método até que o thread de chamada entra no bloqueio e, portanto, talvez nunca retornam. Use o <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloquear para um intervalo especificado, e, em seguida, retornar se o thread de chamada não entrou em modo de upgrade durante esse intervalo.  
  
 Use o modo pode ser atualizado quando um thread normalmente acessa o recurso protegido pelo <xref:System.Threading.ReaderWriterLockSlim> no modo de leitura, mas talvez seja necessário inserir o modo de gravação se determinadas condições forem atendidas. Um thread no modo de upgrade pode fazer o downgrade para o modo de leitura ou atualização para o modo de gravação.  
  
 Apenas um thread pode inserir o modo de upgrade em um determinado momento. Se um thread está em modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, qualquer número de outros threads pode entrar no modo de leitura, mesmo se não houver segmentos aguardando para entrar no modo atualizável.  
  
 Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> blocos de método até que esses threads tenham atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de upgrade pode inserir repetidamente do modo de upgrade, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para inserir o bloqueio no modo de upgrade. Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método, garantindo que o chamador sai do modo de upgrade.  
  
 O método mostrado no exemplo recupera o valor associado com uma chave e o compara com um novo valor. Se o valor não é alterado, o método retorna um status que indica nenhuma alteração. Ela nenhum valor for encontrado para a chave, o par chave/valor é inserido. Se o valor for alterado, ele será atualizado. Modo de upgrade permite que o thread atualizar o bloqueio de leitura, conforme necessário, sem o risco de deadlocks.  
  
 O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão. Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.  
  
- ou - 
O thread atual entrou no modo de leitura, portanto, tentar entrar no modo atualizável criará a possibilidade de um deadlock.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tenta entrar no bloqueio em modo de gravação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este blocos de método até que o thread de chamada entra no bloqueio e, portanto, talvez nunca retornam. Use o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloquear para um intervalo especificado, e, em seguida, retornar se o thread de chamada não entrou em modo de gravação durante esse intervalo.  
  
 Se outros threads inseriu o bloqueio no modo de leitura, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> modo de leitura de blocos de método até que esses threads tenham saído. Quando há threads aguardando para entrar no modo de gravação, threads adicionais que tentam inserir o modo de leitura ou bloco de modo de upgrade até que todos os threads estão aguardando para entrar no modo de gravação tenham atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de gravação pode inserir repetidamente do modo de gravação, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método para inserir o bloqueio no modo de gravação. O método mostrado no exemplo adiciona um novo par chave/valor para o cache sincronizado. Se a chave já está no cache, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate. Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, garantindo que o chamador sai do modo de gravação.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.  
  
- ou - 
O thread atual entrou no modo de leitura e ainda não tem um bloqueio de gravação. Portanto, tentar entrar no bloqueio em modo de gravação criará a possibilidade de um deadlock.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduz a contagem de recursão para o modo de leitura e sai do modo de leitura se a contagem resultante é 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não é sensível à ordem de recursão. Por exemplo, se um thread entra em um bloqueio no modo de upgrade e, em seguida, entra no bloqueio no modo de leitura, a ordem na qual o thread seja encerrado os dois modos não importa. Se um bloqueio permite recursão, um thread pode inserir o bloqueio no modo de gravação e, em seguida, insira-recursivamente no modo de leitura; a ordem na qual o thread seja encerrado modo de leitura e gravação modo não importa.  
  
 Sair do bloqueio pode sinalizar outros threads em espera.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar um `finally` bloco para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> método, garantindo que o chamador sai do modo de leitura. O método mostrado no exemplo recupera o valor associado com uma chave. Se a chave não for encontrada, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate. O <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método é usado para entrar no modo de leitura.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não entrou no bloqueio no modo de leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduz a contagem de recursão para o modo de upgrade e sai do modo de upgrade se a contagem resultante é 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não é sensível à ordem de recursão. Por exemplo, se um thread entra em um bloqueio no modo de upgrade e, em seguida, entra no bloqueio no modo de gravação, a ordem na qual o thread seja encerrado os dois modos não importa. Se um bloqueio permite recursão, um thread pode inserir o bloqueio no modo de gravação e, em seguida, insira-recursivamente no modo de upgrade; não importa a ordem na qual o thread sai do modo de gravação e de modo pode ser atualizado.  
  
 Sair do bloqueio pode sinalizar outros threads em espera.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar um `finally` bloco para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método, garantindo que o chamador sai do modo de upgrade.  
  
 O método mostrado no exemplo recupera o valor associado com uma chave e o compara com um novo valor. Se o valor não é alterado, o método retorna um status que indica nenhuma alteração. Ela nenhum valor for encontrado para a chave, o par chave/valor é inserido. Se o valor for alterado, ele será atualizado. Modo de upgrade permite que o thread atualizar o bloqueio de leitura, conforme necessário, sem o risco de deadlocks.  
  
 O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão. Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não entrou no bloqueio em modo de upgrade.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduz a contagem de recursão para o modo de gravação e sai do modo de gravação se a contagem resultante é 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não é sensível à ordem de recursão. Por exemplo, se um thread entra em um bloqueio no modo de upgrade e, em seguida, entra no bloqueio no modo de gravação, a ordem na qual o thread seja encerrado os dois modos não importa. Se um bloqueio permite recursão, um thread pode inserir o bloqueio no modo de gravação e, em seguida, insira-recursivamente no modo de leitura; a ordem na qual o thread seja encerrado modo de leitura e gravação modo não importa.  
  
 Sair do bloqueio pode sinalizar outros threads em espera.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar um `finally` bloco para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, garantindo que o chamador sai do modo de gravação. O método mostrado no exemplo adiciona um novo par chave/valor para o cache sincronizado. Se a chave já está no cache, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate. O <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método é usado para inserir o bloqueio no modo de gravação.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">O thread atual não entrou no bloqueio em modo de gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de leitura.</summary>
        <value>
          <see langword="true" /> Se o thread atual inseriu ler modo; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade destina para uso em declarações ou para outros fins de depuração. Não usá-lo para controlar o fluxo de execução do programa.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> propriedade para gerar uma declaração, se o thread atual entrou no modo de leitura inesperadamente.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de upgrade.</summary>
        <value>
          <see langword="true" /> Se o thread atual entrou no modo atualizável; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade destina para uso em declarações ou para outros fins de depuração. Não usá-lo para controlar o fluxo de execução do programa.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> propriedade para gerar uma declaração, se o thread atual entrou no modo atualizável inesperadamente.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de gravação.</summary>
        <value>
          <see langword="true" /> Se o thread atual entrou no modo de gravação; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade destina para uso em declarações ou para outros fins de depuração. Não usá-lo para controlar o fluxo de execução do programa.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> propriedade para gerar uma declaração, se o thread atual entrou no modo de gravação inesperadamente.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica a política de recursão do objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> atual.</summary>
        <value>Um dos valores de enumeração que especifica a política de recursão de bloqueio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Política de recursão determina as restrições em threads que entrar no bloqueio de mais de uma vez. Por exemplo, se um bloqueio foi criado com <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e um thread entrou no bloqueio no modo de leitura, <xref:System.Threading.LockRecursionException> será gerada se o thread tenta reintroduzir o bloqueio no modo de leitura.  
  
> [!NOTE]
>  Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para modo independentemente da configuração de política de recursão de bloqueio de leitura.  
  
 Independentemente da política de recursão, um thread que inseriu inicialmente ler modo não é permitido atualizar para o modo de upgrade ou modo de gravação, porque esse padrão cria uma grande probabilidade de deadlocks.  
  
 Para obter mais informações sobre a política de recursão e seus efeitos, consulte o <xref:System.Threading.LockRecursionPolicy> enumeração e a <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de leitura, como uma indicação de recursão.</summary>
        <value>0 (zero) se o thread atual não entrou modo de leitura, 1 se o thread entrou no modo de leitura, mas não foi inserido, ele recursivamente, ou *n* se o thread inseriu o bloqueio recursivamente *n* – 1 vezes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de upgrade, como uma indicação de recursão.</summary>
        <value>0 se o thread atual não entrou em modo de upgrade, 1 se o thread entrou em modo de upgrade, mas não tiver inserido ele recursivamente, ou *n* se o thread entrou no modo de upgrade recursivamente *n* - 1 tempos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de gravação, como uma indicação de recursão.</summary>
        <value>0 se o thread atual não entrou gravar modo, 1 se o thread entrou no modo de gravação, mas não foi inserido, ele recursivamente, ou *n* se o thread tiver inserido recursivamente do modo de gravação *n* – 1 vezes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta entrar no bloqueio no modo de leitura, com um tempo limite opcional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
        <summary>Tenta inserir o bloqueio no modo de gravação com um tempo limite inteiro opcional.</summary>
        <returns>
          <see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.  
  
 Vários threads podem entrar no modo de leitura ao mesmo tempo.  
  
 Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de leitura pode inserir repetidamente do modo de leitura, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
 Um thread pode estar em modo de upgrade, enquanto outro thread está no modo de leitura. Se os threads adicionais estão esperando para inserir o modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, threads que chamam o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método entrar imediatamente no modo de leitura e não bloquear.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
        <summary>Tenta entrar no bloqueio no modo de leitura, com um tempo limite opcional.</summary>
        <returns>
          <see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.  
  
 Vários threads podem entrar no bloqueio no modo de leitura ao mesmo tempo.  
  
 Se um ou mais threads na fila para entrar no modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de leitura pode inserir repetidamente do modo de leitura, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
 Um thread pode estar em modo de upgrade, enquanto outro thread está no modo de leitura. Se os threads adicionais estão esperando para inserir o modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, threads que chamam o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método entrar imediatamente no modo de leitura e não bloquear.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.  
  
- ou - 
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
        <summary>Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
        <returns>
          <see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.  
  
 Use o modo pode ser atualizado quando um thread normalmente acessa o recurso protegido pelo <xref:System.Threading.ReaderWriterLockSlim> no modo de leitura, mas talvez seja necessário inserir o modo de gravação se determinadas condições forem atendidas. Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para o modo de leitura.  
  
 Apenas um thread pode inserir um bloqueio no modo de upgrade em um determinado momento. Se um thread está em modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, qualquer número de outros threads pode entrar no modo de leitura, mesmo se não houver segmentos aguardando para entrar no modo atualizável.  
  
 Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de upgrade pode inserir repetidamente do modo de upgrade, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.  
  
- ou - 
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
        <summary>Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</summary>
        <returns>
          <see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.  
  
 Use o modo pode ser atualizado quando um thread normalmente acessa o recurso protegido pela <xref:System.Threading.ReaderWriterLockSlim> no modo de leitura, mas talvez seja necessário inserir o modo de gravação se determinadas condições forem atendidas. Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para o modo de leitura.  
  
 Apenas um thread pode inserir um bloqueio no modo de upgrade em um determinado momento. Se um thread está em modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, qualquer número de outros threads pode entrar no modo de leitura, mesmo se não houver segmentos aguardando para entrar no modo atualizável.  
  
 Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de upgrade pode inserir repetidamente do modo de upgrade, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.  
  
- ou - 
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.  
  
- ou - 
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</param>
        <summary>Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
        <returns>
          <see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.  
  
 Se outros threads inseriu o bloqueio no modo de leitura, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloqueia até que esses threads tiveram saído do modo de leitura ou até que o intervalo de tempo limite tenha decorrido. Enquanto os threads são bloqueados, esperando para inserir o modo de gravação, threads adicionais que tentam inserir o modo de leitura ou modo de upgrade bloqueiam até que o modo de gravação de todos os threads esperando para inserir tiver qualquer um atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de gravação pode inserir repetidamente do modo de gravação, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método para inserir o bloqueio no modo de gravação, com um tempo limite. O método mostrado no exemplo adiciona um novo par chave/valor para o cache sincronizado. Se o intervalo de tempo limite especificado transcorrer antes que o thread entra no bloqueio, o método retorna `false`. O método retorna `true` se o par chave/valor é adicionado.  
  
 Se a chave já está no cache, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate. Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, garantindo que o chamador é encerrado o bloqueio.  
  
 Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.  
  
- ou - 
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</param>
        <summary>Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</summary>
        <returns>
          <see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.  
  
 Se outros threads inseriu o bloqueio no modo de leitura, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloqueia até que esses threads tiveram saído do modo de leitura ou até que o intervalo de tempo limite tenha decorrido. Enquanto os threads são bloqueados, esperando para inserir o modo de gravação, threads adicionais que tentam inserir o modo de leitura ou modo de upgrade bloqueiam até que o modo de gravação de todos os threads esperando para inserir tiver qualquer um atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.  
  
> [!NOTE]
>  Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de gravação pode inserir repetidamente do modo de gravação, mesmo se outros threads estão esperando para inserir o modo de gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.  
  
- ou - 
O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.  
  
- ou - 
O número de recursão excederia a capacidade do contador. O limite é tão grande que os aplicativos nunca o alcançariam.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.  
  
- ou - 
O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de leitura.</summary>
        <value>O número total de threads que estão esperando para inserir o modo de leitura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads que estão bloqueados, esperando para inserir o modo de leitura, exceder um limite.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de upgrade.</summary>
        <value>O número total de threads que estão esperando para inserir o modo de upgrade.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads que estão bloqueados, esperando para inserir o modo de upgrade, exceder um limite.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de gravação.</summary>
        <value>O número total de threads que estão esperando para inserir o modo de gravação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo. Os resultados podem ser alterados assim que eles foram calculados. Portanto, não é seguro tomar decisões com base nessa propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads que estão bloqueados, esperando para inserir o modo de gravação, exceder um limite.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>