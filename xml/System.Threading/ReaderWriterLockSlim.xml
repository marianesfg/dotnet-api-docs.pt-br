<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0fee7c4885e8d1b579011bb73bd7952ec0ae6dc1" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58696277" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="93906-101">Representa um bloqueio que é usado para gerenciar o acesso a um recurso, permitindo vários threads para leitura ou acesso exclusivo para gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-102">Use <xref:System.Threading.ReaderWriterLockSlim> para proteger um recurso que é lida por vários threads e gravado por um thread por vez.</span><span class="sxs-lookup"><span data-stu-id="93906-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="93906-103"><xref:System.Threading.ReaderWriterLockSlim> permite que vários threads estar no modo de leitura, permite que um thread esteja no modo de gravação com a propriedade exclusiva do bloqueio e permite que um thread que tem acesso de leitura para estar no modo de leitura pode ser atualizado, do qual o thread pode atualizar para o modo de gravação sem precisar liberar ele s o acesso de leitura para o recurso.</span><span class="sxs-lookup"><span data-stu-id="93906-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-104">O <xref:System.Threading.ReaderWriterLockSlim> é semelhante ao <xref:System.Threading.ReaderWriterLock>, mas tem regras simplificadas para recursão e para atualização e downgrade de estado de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="93906-105"><xref:System.Threading.ReaderWriterLockSlim> evita muitos casos potenciais de deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="93906-106">Além disso, o desempenho de <xref:System.Threading.ReaderWriterLockSlim> é significativamente melhor que o de <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="93906-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="93906-107">O <xref:System.Threading.ReaderWriterLockSlim> é recomendado para todos os novos desenvolvimentos.</span><span class="sxs-lookup"><span data-stu-id="93906-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="93906-108">Por padrão, novas instâncias de <xref:System.Threading.ReaderWriterLockSlim> são criados com o <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> sinalizador e não permitir a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="93906-109">Essa política padrão é recomendada para todos os novos desenvolvimentos, como recursão introduz complicações desnecessárias e torna seu código mais propensa a deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="93906-110">Para simplificar a migração de existente projetos que usam <xref:System.Threading.Monitor> ou <xref:System.Threading.ReaderWriterLock>, você pode usar o <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> sinalizador para criar instâncias de <xref:System.Threading.ReaderWriterLockSlim> que permitem a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="93906-111">Um thread pode inserir o bloqueio em três modos: modo, o modo de gravação e o modo de leitura pode ser atualizado de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="93906-112">(No restante deste tópico, "modo de leitura pode ser atualizado" é chamado de "modo de upgrade" e a frase "Insira `x` modo de" é usado em preferência a frase mais longa "entrar no bloqueio no `x` modo".)</span><span class="sxs-lookup"><span data-stu-id="93906-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="93906-113">Independentemente da política de recursão, apenas um thread pode ser no modo de gravação a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="93906-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="93906-114">Quando um thread está no modo de gravação, nenhum outro thread pode inserir o bloqueio em qualquer modo.</span><span class="sxs-lookup"><span data-stu-id="93906-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="93906-115">Apenas um thread pode estar no modo pode ser atualizado a qualquer momento.</span><span class="sxs-lookup"><span data-stu-id="93906-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="93906-116">Qualquer número de threads pode estar no modo de leitura e pode haver um thread no modo de upgrade, enquanto outro thread está no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="93906-117">Esse tipo implementa o <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="93906-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="93906-118">Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente.</span><span class="sxs-lookup"><span data-stu-id="93906-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="93906-119">Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco.</span><span class="sxs-lookup"><span data-stu-id="93906-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="93906-120">Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="93906-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="93906-121">Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.</span><span class="sxs-lookup"><span data-stu-id="93906-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="93906-122"><xref:System.Threading.ReaderWriterLockSlim> gerencia afinidade de thread; ou seja, cada <xref:System.Threading.Thread> objeto deve fazer suas próprias chamadas de método para entrar e sair de modos de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="93906-123">Nenhum thread pode alterar o modo de outro thread.</span><span class="sxs-lookup"><span data-stu-id="93906-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="93906-124">Se um <xref:System.Threading.ReaderWriterLockSlim> não permite a recursão, um thread que tenta entrar no bloqueio pode bloquear por vários motivos:</span><span class="sxs-lookup"><span data-stu-id="93906-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="93906-125">Um thread que tenta inserir blocos de modo de leitura se não houver threads esperando para inserir o modo de gravação ou se há um único thread no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="93906-126">Novos leitores de bloqueio quando gravadores estão na fila é uma política de integridade de bloqueio que favoreça gravadores.</span><span class="sxs-lookup"><span data-stu-id="93906-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="93906-127">A política de integridade atual saldos de igualdade para os leitores e gravadores, para promover a taxa de transferência em cenários mais comuns.</span><span class="sxs-lookup"><span data-stu-id="93906-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="93906-128">Versões futuras do [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] pode introduzir novas políticas de integridade.</span><span class="sxs-lookup"><span data-stu-id="93906-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="93906-129">Um thread que tenta inserir blocos de modo de upgrade se já houver um thread no modo de upgrade, se não houver threads aguardando para entrar no modo de gravação, ou se não houver um único thread no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="93906-130">Um thread que tenta inserir blocos de modo de gravação se não houver um thread em qualquer um dos três modos.</span><span class="sxs-lookup"><span data-stu-id="93906-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="93906-131">Bloqueios de atualização e downgrade</span><span class="sxs-lookup"><span data-stu-id="93906-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="93906-132">Modo de upgrade destina-se a casos em que um thread lê geralmente do recurso protegido, mas talvez seja necessário gravar nele se alguma condição for atendida.</span><span class="sxs-lookup"><span data-stu-id="93906-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="93906-133">Um thread que entrou em um <xref:System.Threading.ReaderWriterLockSlim> no modo de upgrade, tem acesso de leitura para o recurso protegido e pode atualizar para o modo de gravação por meio da chamada a <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> ou <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="93906-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="93906-134">Como pode haver apenas um thread no modo de upgrade por vez, atualizando para o modo de gravação não é possível deadlock quando recursão não é permitido, que é a política padrão.</span><span class="sxs-lookup"><span data-stu-id="93906-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="93906-135">Independentemente da política de recursão, um thread que inseriu inicialmente ler modo não é permitido atualizar para o modo de upgrade ou modo de gravação, porque esse padrão cria uma grande probabilidade de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="93906-136">Por exemplo, se dois threads no modo de leitura que ambos tentam inserir o modo de gravação, elas enfrentarão deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="93906-137">Modo de upgrade foi projetado para evitar esses deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="93906-138">Se houver outros threads no modo de leitura, o thread que está atualizando os blocos.</span><span class="sxs-lookup"><span data-stu-id="93906-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="93906-139">Enquanto o thread estiver bloqueado, outros threads que tentarem entrar no modo de leitura são bloqueados.</span><span class="sxs-lookup"><span data-stu-id="93906-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="93906-140">Quando todos os threads tenham saído do modo de leitura, o thread pode ser atualizado bloqueado entra no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="93906-141">Se houver outros threads esperando para inserir o modo de gravação, eles permanecem bloqueados, pois o único thread que está no modo de upgrade impede que eles obtenham acesso exclusivo ao recurso.</span><span class="sxs-lookup"><span data-stu-id="93906-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="93906-142">Quando o thread no modo de upgrade sai do modo de gravação, outros threads que estão esperando para inserir o modo de leitura podem fazer isso, a menos que haja threads esperando para inserir modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="93906-143">O thread no modo de upgrade pode atualizar e fazer o downgrade indefinidamente, desde que ele é o único thread que grava no recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="93906-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="93906-144">Se você permitir que vários threads inserir gravação modo ou modo de upgrade, você não deve permitir que um thread monopolize o modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="93906-145">Caso contrário, os threads que tentam inserir gravar modo diretamente será bloqueado indefinidamente, e enquanto eles estiverem bloqueados, outros threads poderão entrar no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="93906-146">Um thread no modo de upgrade pode fazer o downgrade para o modo de leitura pelo primeiro chamar o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método e, em seguida, chamar o <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método.</span><span class="sxs-lookup"><span data-stu-id="93906-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="93906-147">Esse padrão de downgrade é permitida para todas as políticas de recursão de bloqueio, até mesmo <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span><span class="sxs-lookup"><span data-stu-id="93906-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="93906-148">Depois de fazer o downgrade para o modo de leitura, um thread não é possível reinserir o modo de upgrade até que ele saiu do modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="93906-149">Inserir o bloqueio recursivamente</span><span class="sxs-lookup"><span data-stu-id="93906-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="93906-150">Você pode criar uma <xref:System.Threading.ReaderWriterLockSlim> que dá suporte à entrada de bloqueio recursiva usando o <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> construtor que especifica a política de bloqueio e a especificação <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="93906-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-151">O uso de recursão não é recomendado para novos desenvolvimentos, porque ela introduz complicações desnecessárias e torna seu código mais propensa a deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="93906-152">Para um <xref:System.Threading.ReaderWriterLockSlim> que permite que a recursão, o seguinte pode ser dito sobre os modos de um thread pode inserir:</span><span class="sxs-lookup"><span data-stu-id="93906-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="93906-153">Um thread no modo de leitura pode inserir o modo de leitura recursivamente, mas não é possível inserir o modo de gravação ou pode ser atualizado.</span><span class="sxs-lookup"><span data-stu-id="93906-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="93906-154">Se tentar fazer isso, um <xref:System.Threading.LockRecursionException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="93906-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="93906-155">Inserir ler modo e, em seguida, inserindo o modo de gravação ou modo de upgrade é um padrão com uma grande probabilidade de deadlocks, portanto, não é permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="93906-156">Conforme discutido anteriormente, o modo de upgrade é fornecido para casos em que é necessário atualizar um bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="93906-157">Um thread no modo de upgrade pode inserir o modo de gravação de e/ou modo de leitura e pode inserir qualquer um de três modos recursivamente.</span><span class="sxs-lookup"><span data-stu-id="93906-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="93906-158">No entanto, uma tentativa de inserir gravar blocos de modo a se há outros threads no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="93906-159">Um thread no modo de gravação pode inserir o modo de leitura e/ou modo de upgrade e pode inserir qualquer um de três modos recursivamente.</span><span class="sxs-lookup"><span data-stu-id="93906-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="93906-160">Um thread que não entrou no bloqueio pode inserir qualquer modo.</span><span class="sxs-lookup"><span data-stu-id="93906-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="93906-161">Essa tentativa pode bloquear pelos mesmos motivos como uma tentativa de inserir um bloqueio de não-recursivo.</span><span class="sxs-lookup"><span data-stu-id="93906-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="93906-162">Um thread pode sair os modos em que ele entrou em qualquer ordem, desde que ele sai do modo de cada exatamente como quantas vezes ele entrou em que o modo.</span><span class="sxs-lookup"><span data-stu-id="93906-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="93906-163">Se um thread tentar sair de um modo de muitas vezes, ou para sair do modo de não entrou, um <xref:System.Threading.SynchronizationLockException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="93906-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="93906-164">Estados de bloqueio</span><span class="sxs-lookup"><span data-stu-id="93906-164">Lock States</span></span>  
 <span data-ttu-id="93906-165">Você talvez ache útil considerar o bloqueio em termos de seus estados.</span><span class="sxs-lookup"><span data-stu-id="93906-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="93906-166">Um <xref:System.Threading.ReaderWriterLockSlim> pode estar em um dos quatro estados: não inserida, ler, atualizar e gravar.</span><span class="sxs-lookup"><span data-stu-id="93906-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="93906-167">Não é inserido: Nesse estado, nenhum thread inseriu o bloqueio (ou todos os threads tenham saído do bloqueio).</span><span class="sxs-lookup"><span data-stu-id="93906-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="93906-168">Leitura: Nesse estado, um ou mais threads inseriu o bloqueio de acesso de leitura para o recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="93906-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="93906-169">Um thread pode inserir o bloqueio no modo de leitura usando o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> ou <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> métodos, ou fazer downgrade do modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="93906-170">Atualização: Nesse estado, um thread entrou no bloqueio de acesso de leitura com a opção de atualização para acesso de gravação (ou seja, no modo de upgrade), e zero ou mais threads inseriu o bloqueio de acesso de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="93906-171">Não mais do que um thread por vez pode entrar no bloqueio com a opção para atualizar; threads adicionais que tenta entrar no modo atualizável são bloqueadas.</span><span class="sxs-lookup"><span data-stu-id="93906-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="93906-172">Gravação: Nesse estado, um thread entrou no bloqueio para acesso de gravação ao recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="93906-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="93906-173">Esse thread tiver posse exclusivo do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="93906-174">Qualquer outro thread que tenta entrar no bloqueio por qualquer motivo é bloqueado.</span><span class="sxs-lookup"><span data-stu-id="93906-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="93906-175">A tabela a seguir descreve as transições entre estados de bloqueio, para os bloqueios que não permitem a recursão, quando um thread `t` executa a ação descrita na coluna mais à esquerda.</span><span class="sxs-lookup"><span data-stu-id="93906-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="93906-176">No momento, ele executa a ação, `t` não tem nenhum modo.</span><span class="sxs-lookup"><span data-stu-id="93906-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="93906-177">(Caso especial em que `t` está no modo de upgrade é descrito nas notas de rodapé de tabela.) A linha superior descreve o estado inicial do bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="93906-178">As células descrevem o que acontece com o thread e mostram as alterações para o estado de bloqueio entre parênteses.</span><span class="sxs-lookup"><span data-stu-id="93906-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="93906-179">Não é inserido (N)</span><span class="sxs-lookup"><span data-stu-id="93906-179">Not entered (N)</span></span>|<span data-ttu-id="93906-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="93906-180">Read (R)</span></span>|<span data-ttu-id="93906-181">Atualização (U)</span><span class="sxs-lookup"><span data-stu-id="93906-181">Upgrade (U)</span></span>|<span data-ttu-id="93906-182">Gravação (W)</span><span class="sxs-lookup"><span data-stu-id="93906-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="93906-183">`t` entra no modo de leitura</span><span class="sxs-lookup"><span data-stu-id="93906-183">`t` enters read mode</span></span>|<span data-ttu-id="93906-184">`t` Insere (R).</span><span class="sxs-lookup"><span data-stu-id="93906-184">`t` enters (R).</span></span>|<span data-ttu-id="93906-185">`t` blocos se segmentos estão aguardando para modo de gravação; Caso contrário, `t` entra.</span><span class="sxs-lookup"><span data-stu-id="93906-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="93906-186">`t` blocos se segmentos estão aguardando para modo de gravação; Caso contrário, `t` entra.<sup> 1</sup></span><span class="sxs-lookup"><span data-stu-id="93906-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="93906-187">`t` blocos.</span><span class="sxs-lookup"><span data-stu-id="93906-187">`t` blocks.</span></span>|  
|<span data-ttu-id="93906-188">`t` entra em modo de upgrade</span><span class="sxs-lookup"><span data-stu-id="93906-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="93906-189">`t` Insere (U).</span><span class="sxs-lookup"><span data-stu-id="93906-189">`t` enters (U).</span></span>|<span data-ttu-id="93906-190">`t` blocos se segmentos estão aguardando para gravar o modo ou modo de atualização; Caso contrário, `t` entra (U).</span><span class="sxs-lookup"><span data-stu-id="93906-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="93906-191">`t` blocos.</span><span class="sxs-lookup"><span data-stu-id="93906-191">`t` blocks.</span></span>|<span data-ttu-id="93906-192">`t` blocos.</span><span class="sxs-lookup"><span data-stu-id="93906-192">`t` blocks.</span></span>|  
|<span data-ttu-id="93906-193">`t` entra no modo de gravação</span><span class="sxs-lookup"><span data-stu-id="93906-193">`t` enters write mode</span></span>|<span data-ttu-id="93906-194">`t` Insere (W).</span><span class="sxs-lookup"><span data-stu-id="93906-194">`t` enters (W).</span></span>|<span data-ttu-id="93906-195">`t` blocos.</span><span class="sxs-lookup"><span data-stu-id="93906-195">`t` blocks.</span></span>|<span data-ttu-id="93906-196">`t` blocos. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="93906-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="93906-197">`t` blocos.</span><span class="sxs-lookup"><span data-stu-id="93906-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="93906-198"><sup>1</sup> se `t` inicia out no modo de upgrade, ele entra em modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="93906-199">Essa ação nunca bloqueia.</span><span class="sxs-lookup"><span data-stu-id="93906-199">This action never blocks.</span></span> <span data-ttu-id="93906-200">Não altera o estado de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-200">The lock state does not change.</span></span> <span data-ttu-id="93906-201">(O thread pode, em seguida, concluir um downgrade para o modo de leitura ao sair do modo de upgrade.)</span><span class="sxs-lookup"><span data-stu-id="93906-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="93906-202"><sup>2</sup> se `t` é iniciado no modo de upgrade, ele bloqueia se não houver threads no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="93906-203">Caso contrário, ele atualiza para o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="93906-204">As alterações de estado de bloqueio para gravação (W).</span><span class="sxs-lookup"><span data-stu-id="93906-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="93906-205">Se `t` bloqueia porque há threads no modo de leitura, ele entra no modo de gravação, assim que o último thread sai do modo de leitura, mesmo se não houver threads esperando para inserir modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="93906-206">Quando uma alteração de estado ocorre porque um thread é encerrado o bloqueio, o próximo segmento a ser despertado é selecionado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="93906-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="93906-207">Primeiro, um thread que está aguardando modo de gravação e já está no modo de upgrade (pode haver no máximo um thread desse tipo).</span><span class="sxs-lookup"><span data-stu-id="93906-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="93906-208">Caso de falha, um thread que está aguardando o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="93906-209">Caso de falha, um thread que está aguardando o modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="93906-210">Caso de falha, todos os threads que estão aguardando o modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="93906-211">O estado subsequente do bloqueio é sempre gravar (W) na primeira atualização (U) e dois casos no caso de terceiro, independentemente do estado do bloqueio quando o thread existente disparado a alteração de estado.</span><span class="sxs-lookup"><span data-stu-id="93906-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="93906-212">No último caso, o estado do bloqueio é de atualização (U) se não houver um thread no modo de upgrade após a alteração de estado e Read (R) caso contrário, independentemente do estado anterior.</span><span class="sxs-lookup"><span data-stu-id="93906-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-213">O exemplo a seguir mostra um cache sincronizado simple que contém cadeias de caracteres com chaves de inteiro.</span><span class="sxs-lookup"><span data-stu-id="93906-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="93906-214">Uma instância do <xref:System.Threading.ReaderWriterLockSlim> é usado para sincronizar o acesso para o <xref:System.Collections.Generic.Dictionary%602> que serve como o cache interno.</span><span class="sxs-lookup"><span data-stu-id="93906-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="93906-215">O exemplo inclui métodos simples para adicionar ao cache, excluir do cache e lidos do cache.</span><span class="sxs-lookup"><span data-stu-id="93906-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="93906-216">Para demonstrar os tempos limite, o exemplo inclui um método que adiciona ao cache somente se ele pode fazer isso dentro de um tempo limite especificado.</span><span class="sxs-lookup"><span data-stu-id="93906-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="93906-217">Para demonstrar o modo de upgrade, o exemplo inclui um método que recupera o valor associado com uma chave e o compara com um novo valor.</span><span class="sxs-lookup"><span data-stu-id="93906-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="93906-218">Se o valor não é alterado, o método retorna um status que indica nenhuma alteração.</span><span class="sxs-lookup"><span data-stu-id="93906-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="93906-219">Se nenhum valor for encontrado para a chave, o par chave/valor é inserido.</span><span class="sxs-lookup"><span data-stu-id="93906-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="93906-220">Se o valor for alterado, ele será atualizado.</span><span class="sxs-lookup"><span data-stu-id="93906-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="93906-221">Modo de upgrade permite que o thread atualizar do acesso de leitura para acesso de gravação, conforme necessário, sem o risco de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="93906-222">O exemplo inclui uma enumeração aninhada que especifica os valores de retorno para o método que demonstra o modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-223">O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="93906-224">Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="93906-225">O código a seguir usa o `SynchronizedCache` objeto para armazenar um dicionário de nomes de legumes.</span><span class="sxs-lookup"><span data-stu-id="93906-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="93906-226">Ele cria três tarefas.</span><span class="sxs-lookup"><span data-stu-id="93906-226">It creates three tasks.</span></span> <span data-ttu-id="93906-227">O primeiro grava os nomes de legumes armazenados em uma matriz para um `SynchronizedCache` instância.</span><span class="sxs-lookup"><span data-stu-id="93906-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="93906-228">A tarefa de segunda e terceira exibem os nomes de legumes, o primeiro em ordem crescente (da baixo índice de índice alto), o segundo em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="93906-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="93906-229">A tarefa final procura a cadeia de caracteres "cucumber" e, quando ele encontra, chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para substituir a cadeia de caracteres "verde bean".</span><span class="sxs-lookup"><span data-stu-id="93906-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="93906-230">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="93906-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93906-231">Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span><span class="sxs-lookup"><span data-stu-id="93906-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-232">Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> com os valores da propriedade padrão.</span><span class="sxs-lookup"><span data-stu-id="93906-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-233">Um <xref:System.Threading.ReaderWriterLockSlim> que é inicializada com esse construtor não permite a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="93906-234">Ou seja, a propriedade <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> do método retorna <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="93906-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="93906-235">Para obter mais informações sobre a política de recursão e seus efeitos, consulte o <xref:System.Threading.LockRecursionPolicy> enumeração e a <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-236">O exemplo a seguir mostra um cache sincronizado simple que contém cadeias de caracteres com chaves de inteiro.</span><span class="sxs-lookup"><span data-stu-id="93906-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="93906-237">Uma instância do <xref:System.Threading.ReaderWriterLockSlim> é usado para sincronizar o acesso para o <xref:System.Collections.Generic.Dictionary%602> que serve como o cache interno.</span><span class="sxs-lookup"><span data-stu-id="93906-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="93906-238">O construtor sem parâmetros é usado para criar o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="93906-239">O exemplo inclui métodos simples para adicionar ao cache, excluir do cache e lidos do cache.</span><span class="sxs-lookup"><span data-stu-id="93906-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="93906-240">Para demonstrar os tempos limite, o exemplo inclui um método que adiciona ao cache somente se ele pode fazer isso dentro de um tempo limite especificado.</span><span class="sxs-lookup"><span data-stu-id="93906-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="93906-241">Para demonstrar o modo de upgrade, o exemplo inclui um método que recupera o valor associado com uma chave e o compara com um novo valor.</span><span class="sxs-lookup"><span data-stu-id="93906-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="93906-242">Se o valor não é alterado, o método retorna um status que indica nenhuma alteração.</span><span class="sxs-lookup"><span data-stu-id="93906-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="93906-243">Ela nenhum valor for encontrado para a chave, o par chave/valor é inserido.</span><span class="sxs-lookup"><span data-stu-id="93906-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="93906-244">Se o valor for alterado, ele será atualizado.</span><span class="sxs-lookup"><span data-stu-id="93906-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="93906-245">Modo de upgrade permite que o thread atualizar do acesso de leitura para acesso de gravação, conforme necessário, sem o risco de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="93906-246">O exemplo inclui uma enumeração aninhada que especifica os valores de retorno para o método que demonstra o modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-247">O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="93906-248">Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="93906-249">O código a seguir usa o `SynchronizedCache` objeto para armazenar um dicionário de nomes de legumes.</span><span class="sxs-lookup"><span data-stu-id="93906-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="93906-250">Ele cria três tarefas.</span><span class="sxs-lookup"><span data-stu-id="93906-250">It creates three tasks.</span></span> <span data-ttu-id="93906-251">O primeiro grava os nomes de legumes armazenados em uma matriz para um `SynchronizedCache` instância.</span><span class="sxs-lookup"><span data-stu-id="93906-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="93906-252">A tarefa de segunda e terceira exibem os nomes de legumes, o primeiro em ordem crescente (da baixo índice de índice alto), o segundo em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="93906-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="93906-253">A tarefa final procura a cadeia de caracteres "cucumber" e, quando ele encontra, chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para substituir a cadeia de caracteres "verde bean".</span><span class="sxs-lookup"><span data-stu-id="93906-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="93906-254">Um dos valores de enumeração que especifica a política de recursão de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="93906-255">Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, especificando a política de recursão de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-256">Política de recursão determina as restrições em threads que entrar no bloqueio de mais de uma vez.</span><span class="sxs-lookup"><span data-stu-id="93906-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="93906-257">Por exemplo, se um bloqueio foi criado com <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e um thread entrou no bloqueio no modo de leitura, <xref:System.Threading.LockRecursionException> será gerada se o thread tenta reintroduzir o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="93906-258">Da mesma forma, se um thread entrou no bloqueio no modo de gravação, <xref:System.Threading.LockRecursionException> será gerada se o thread tenta reintroduzir o bloqueio em qualquer modo.</span><span class="sxs-lookup"><span data-stu-id="93906-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-259">Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para modo independentemente da configuração de política de recursão de bloqueio de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="93906-260">Independentemente da política de recursão, um thread que inseriu inicialmente ler modo não é permitido atualizar para o modo de upgrade ou modo de gravação, porque esse padrão cria uma grande probabilidade de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="93906-261">Para obter mais informações sobre a política de recursão e seus efeitos, consulte o <xref:System.Threading.LockRecursionPolicy> enumeração e a <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-262">O exemplo a seguir mostra dois cenários de exceção, que depende do <xref:System.Threading.LockRecursionPolicy> configuração e que não faz isso.</span><span class="sxs-lookup"><span data-stu-id="93906-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="93906-263">No primeiro cenário, o thread entra no modo de leitura e, em seguida, tenta inserir recursivamente do modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="93906-264">Se o <xref:System.Threading.ReaderWriterLockSlim> é criado usando o construtor padrão, que define a política de recursão <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="93906-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="93906-265">Se <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> é usado para criar o <xref:System.Threading.ReaderWriterLockSlim>, nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="93906-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="93906-266">No segundo cenário, o thread entra no modo de leitura e, em seguida, tenta inserir modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="93906-267"><xref:System.Threading.LockRecursionException> é lançada independentemente da política de recursão de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="93906-268">O código a seguir usa o `SynchronizedCache` objeto para armazenar um dicionário de nomes de legumes.</span><span class="sxs-lookup"><span data-stu-id="93906-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="93906-269">Ele cria três tarefas.</span><span class="sxs-lookup"><span data-stu-id="93906-269">It creates three tasks.</span></span> <span data-ttu-id="93906-270">O primeiro grava os nomes de legumes armazenados em uma matriz para um `SynchronizedCache` instância.</span><span class="sxs-lookup"><span data-stu-id="93906-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="93906-271">A tarefa de segunda e terceira exibem os nomes de legumes, o primeiro em ordem crescente (da baixo índice de índice alto), o segundo em ordem decrescente.</span><span class="sxs-lookup"><span data-stu-id="93906-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="93906-272">A tarefa final procura a cadeia de caracteres "cucumber" e, quando ele encontra, chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para substituir a cadeia de caracteres "verde bean".</span><span class="sxs-lookup"><span data-stu-id="93906-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-273">Obtém o número total de threads exclusivos que inseriram o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="93906-274">O número de threads exclusivos que inseriram o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-275">Um thread é contado apenas uma vez, mesmo se o bloqueio permite que o thread e recursão entrou em modo de leitura várias vezes.</span><span class="sxs-lookup"><span data-stu-id="93906-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="93906-276">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-277">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-278">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-279">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads no modo de leitura exceder um limite.</span><span class="sxs-lookup"><span data-stu-id="93906-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-280">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span><span class="sxs-lookup"><span data-stu-id="93906-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-281">Chame <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> quando tiver terminado de usar o <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="93906-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="93906-282">O <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> método deixa o <xref:System.Threading.ReaderWriterLockSlim> em um estado inutilizável.</span><span class="sxs-lookup"><span data-stu-id="93906-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="93906-283">Depois de chamar <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, você deve liberar todas as referências para o <xref:System.Threading.ReaderWriterLockSlim> para que o coletor de lixo possa recuperar a memória que o <xref:System.Threading.ReaderWriterLockSlim> estava ocupando.</span><span class="sxs-lookup"><span data-stu-id="93906-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="93906-284">Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementando um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="93906-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-285">Sempre chamar <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> antes de liberar sua última referência para o <xref:System.Threading.ReaderWriterLockSlim> objeto.</span><span class="sxs-lookup"><span data-stu-id="93906-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="93906-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> é maior que zero.</span><span class="sxs-lookup"><span data-stu-id="93906-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="93906-287">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-287">-or-</span></span> 
 <span data-ttu-id="93906-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> é maior que zero.</span><span class="sxs-lookup"><span data-stu-id="93906-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="93906-289">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-289">-or-</span></span> 
 <span data-ttu-id="93906-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> é maior que zero.</span><span class="sxs-lookup"><span data-stu-id="93906-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-291">Tenta entrar no bloqueio em modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-292">Este blocos de método até que o thread de chamada entra no bloqueio e, portanto, talvez nunca retornam.</span><span class="sxs-lookup"><span data-stu-id="93906-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="93906-293">Use o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloquear para um intervalo especificado, e, em seguida, retornar se o thread de chamada não entrou em modo de leitura durante esse intervalo.</span><span class="sxs-lookup"><span data-stu-id="93906-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="93906-294">Vários threads podem entrar no modo de leitura ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="93906-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="93906-295">Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> blocos de método até que esses threads tenham atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.</span><span class="sxs-lookup"><span data-stu-id="93906-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-296">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de leitura pode inserir repetidamente do modo de leitura, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="93906-297">No máximo um thread pode estar em modo de upgrade, enquanto outro thread está no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="93906-298">Se os threads adicionais estão esperando para inserir o modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, threads que chamam o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método entrar imediatamente no modo de leitura e não bloquear.</span><span class="sxs-lookup"><span data-stu-id="93906-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-299">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método para inserir o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="93906-300">O método mostrado no exemplo recupera o valor associado com uma chave.</span><span class="sxs-lookup"><span data-stu-id="93906-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="93906-301">Se a chave não for encontrada, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate.</span><span class="sxs-lookup"><span data-stu-id="93906-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="93906-302">Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> método, garantindo que o chamador sai do modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="93906-303">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-304">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="93906-305">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-305">-or-</span></span> 
<span data-ttu-id="93906-306">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual tentou adquirir o bloqueio de leitura quando ele já retinha o bloqueio de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="93906-307">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-307">-or-</span></span> 
<span data-ttu-id="93906-308">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-309">O limite é tão grande que os aplicativos nunca devem encontrar essa exceção.</span><span class="sxs-lookup"><span data-stu-id="93906-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-310">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-311">Tenta entrar no bloqueio no modo atualizável.</span><span class="sxs-lookup"><span data-stu-id="93906-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-312">Este blocos de método até que o thread de chamada entra no bloqueio e, portanto, talvez nunca retornam.</span><span class="sxs-lookup"><span data-stu-id="93906-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="93906-313">Use o <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloquear para um intervalo especificado, e, em seguida, retornar se o thread de chamada não entrou em modo de upgrade durante esse intervalo.</span><span class="sxs-lookup"><span data-stu-id="93906-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="93906-314">Use o modo pode ser atualizado quando um thread normalmente acessa o recurso protegido pelo <xref:System.Threading.ReaderWriterLockSlim> no modo de leitura, mas talvez seja necessário inserir o modo de gravação se determinadas condições forem atendidas.</span><span class="sxs-lookup"><span data-stu-id="93906-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="93906-315">Um thread no modo de upgrade pode fazer o downgrade para o modo de leitura ou atualização para o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="93906-316">Apenas um thread pode inserir o modo de upgrade em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="93906-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="93906-317">Se um thread está em modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, qualquer número de outros threads pode entrar no modo de leitura, mesmo se não houver segmentos aguardando para entrar no modo atualizável.</span><span class="sxs-lookup"><span data-stu-id="93906-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-318">Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> blocos de método até que esses threads tenham atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.</span><span class="sxs-lookup"><span data-stu-id="93906-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-319">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de upgrade pode inserir repetidamente do modo de upgrade, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-320">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para inserir o bloqueio no modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="93906-321">Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método, garantindo que o chamador sai do modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-322">O método mostrado no exemplo recupera o valor associado com uma chave e o compara com um novo valor.</span><span class="sxs-lookup"><span data-stu-id="93906-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="93906-323">Se o valor não é alterado, o método retorna um status que indica nenhuma alteração.</span><span class="sxs-lookup"><span data-stu-id="93906-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="93906-324">Ela nenhum valor for encontrado para a chave, o par chave/valor é inserido.</span><span class="sxs-lookup"><span data-stu-id="93906-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="93906-325">Se o valor for alterado, ele será atualizado.</span><span class="sxs-lookup"><span data-stu-id="93906-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="93906-326">Modo de upgrade permite que o thread atualizar o bloqueio de leitura, conforme necessário, sem o risco de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="93906-327">O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-327">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="93906-328">Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="93906-329">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-330">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.</span><span class="sxs-lookup"><span data-stu-id="93906-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="93906-331">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-331">-or-</span></span> 
<span data-ttu-id="93906-332">O thread atual entrou no modo de leitura, portanto, tentar entrar no modo atualizável criará a possibilidade de um deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="93906-333">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-333">-or-</span></span> 
<span data-ttu-id="93906-334">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-335">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-336">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-337">Tenta entrar no bloqueio em modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-338">Este blocos de método até que o thread de chamada entra no bloqueio e, portanto, talvez nunca retornam.</span><span class="sxs-lookup"><span data-stu-id="93906-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="93906-339">Use o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloquear para um intervalo especificado, e, em seguida, retornar se o thread de chamada não entrou em modo de gravação durante esse intervalo.</span><span class="sxs-lookup"><span data-stu-id="93906-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="93906-340">Se outros threads inseriu o bloqueio no modo de leitura, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> modo de leitura de blocos de método até que esses threads tenham saído.</span><span class="sxs-lookup"><span data-stu-id="93906-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="93906-341">Quando há threads aguardando para entrar no modo de gravação, threads adicionais que tentam inserir o modo de leitura ou bloco de modo de upgrade até que todos os threads estão aguardando para entrar no modo de gravação tenham atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.</span><span class="sxs-lookup"><span data-stu-id="93906-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-342">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de gravação pode inserir repetidamente do modo de gravação, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-343">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método para inserir o bloqueio no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="93906-344">O método mostrado no exemplo adiciona um novo par chave/valor para o cache sincronizado.</span><span class="sxs-lookup"><span data-stu-id="93906-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="93906-345">Se a chave já está no cache, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate.</span><span class="sxs-lookup"><span data-stu-id="93906-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="93906-346">Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, garantindo que o chamador sai do modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="93906-347">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-348">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio em qualquer modo.</span><span class="sxs-lookup"><span data-stu-id="93906-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="93906-349">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-349">-or-</span></span> 
<span data-ttu-id="93906-350">O thread atual entrou no modo de leitura e ainda não tem um bloqueio de gravação. Portanto, tentar entrar no bloqueio em modo de gravação criará a possibilidade de um deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="93906-351">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-351">-or-</span></span> 
<span data-ttu-id="93906-352">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-353">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-354">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-355">Reduz a contagem de recursão para o modo de leitura e sai do modo de leitura se a contagem resultante é 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="93906-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-356">Esse método não é sensível à ordem de recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="93906-357">Por exemplo, se um thread entra em um bloqueio no modo de upgrade e, em seguida, entra no bloqueio no modo de leitura, a ordem na qual o thread seja encerrado os dois modos não importa.</span><span class="sxs-lookup"><span data-stu-id="93906-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="93906-358">Se um bloqueio permite recursão, um thread pode inserir o bloqueio no modo de gravação e, em seguida, insira-recursivamente no modo de leitura; a ordem na qual o thread seja encerrado modo de leitura e gravação modo não importa.</span><span class="sxs-lookup"><span data-stu-id="93906-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="93906-359">Sair do bloqueio pode sinalizar outros threads em espera.</span><span class="sxs-lookup"><span data-stu-id="93906-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-360">O exemplo a seguir mostra como usar um `finally` bloco para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> método, garantindo que o chamador sai do modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="93906-361">O método mostrado no exemplo recupera o valor associado com uma chave.</span><span class="sxs-lookup"><span data-stu-id="93906-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="93906-362">Se a chave não for encontrada, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate.</span><span class="sxs-lookup"><span data-stu-id="93906-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="93906-363">O <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método é usado para entrar no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="93906-364">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="93906-365">O thread atual não entrou no bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-366">Reduz a contagem de recursão para o modo de upgrade e sai do modo de upgrade se a contagem resultante é 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="93906-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-367">Esse método não é sensível à ordem de recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="93906-368">Por exemplo, se um thread entra em um bloqueio no modo de upgrade e, em seguida, entra no bloqueio no modo de gravação, a ordem na qual o thread seja encerrado os dois modos não importa.</span><span class="sxs-lookup"><span data-stu-id="93906-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="93906-369">Se um bloqueio permite recursão, um thread pode inserir o bloqueio no modo de gravação e, em seguida, insira-recursivamente no modo de upgrade; não importa a ordem na qual o thread sai do modo de gravação e de modo pode ser atualizado.</span><span class="sxs-lookup"><span data-stu-id="93906-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="93906-370">Sair do bloqueio pode sinalizar outros threads em espera.</span><span class="sxs-lookup"><span data-stu-id="93906-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-371">O exemplo a seguir mostra como usar um `finally` bloco para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método, garantindo que o chamador sai do modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-372">O método mostrado no exemplo recupera o valor associado com uma chave e o compara com um novo valor.</span><span class="sxs-lookup"><span data-stu-id="93906-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="93906-373">Se o valor não é alterado, o método retorna um status que indica nenhuma alteração.</span><span class="sxs-lookup"><span data-stu-id="93906-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="93906-374">Ela nenhum valor for encontrado para a chave, o par chave/valor é inserido.</span><span class="sxs-lookup"><span data-stu-id="93906-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="93906-375">Se o valor for alterado, ele será atualizado.</span><span class="sxs-lookup"><span data-stu-id="93906-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="93906-376">Modo de upgrade permite que o thread atualizar o bloqueio de leitura, conforme necessário, sem o risco de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="93906-377">O exemplo usa o construtor padrão para criar o bloqueio, portanto, não é permitida a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-377">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="93906-378">Programando o <xref:System.Threading.ReaderWriterLockSlim> é mais simples e menos propenso a erro quando o bloqueio não permite a recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="93906-379">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="93906-380">O thread atual não entrou no bloqueio em modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="93906-381">Reduz a contagem de recursão para o modo de gravação e sai do modo de gravação se a contagem resultante é 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="93906-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-382">Esse método não é sensível à ordem de recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="93906-383">Por exemplo, se um thread entra em um bloqueio no modo de upgrade e, em seguida, entra no bloqueio no modo de gravação, a ordem na qual o thread seja encerrado os dois modos não importa.</span><span class="sxs-lookup"><span data-stu-id="93906-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="93906-384">Se um bloqueio permite recursão, um thread pode inserir o bloqueio no modo de gravação e, em seguida, insira-recursivamente no modo de leitura; a ordem na qual o thread seja encerrado modo de leitura e gravação modo não importa.</span><span class="sxs-lookup"><span data-stu-id="93906-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="93906-385">Sair do bloqueio pode sinalizar outros threads em espera.</span><span class="sxs-lookup"><span data-stu-id="93906-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-386">O exemplo a seguir mostra como usar um `finally` bloco para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, garantindo que o chamador sai do modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="93906-387">O método mostrado no exemplo adiciona um novo par chave/valor para o cache sincronizado.</span><span class="sxs-lookup"><span data-stu-id="93906-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="93906-388">Se a chave já está no cache, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate.</span><span class="sxs-lookup"><span data-stu-id="93906-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="93906-389">O <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método é usado para inserir o bloqueio no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="93906-390">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="93906-391">O thread atual não entrou no bloqueio em modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-392">Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="93906-393"><see langword="true" /> Se o thread atual inseriu ler modo; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-394">Esta propriedade destina para uso em declarações ou para outros fins de depuração.</span><span class="sxs-lookup"><span data-stu-id="93906-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="93906-395">Não usá-lo para controlar o fluxo de execução do programa.</span><span class="sxs-lookup"><span data-stu-id="93906-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-396">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> propriedade para gerar uma declaração, se o thread atual entrou no modo de leitura inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="93906-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-397">Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="93906-398"><see langword="true" /> Se o thread atual entrou no modo atualizável; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-399">Esta propriedade destina para uso em declarações ou para outros fins de depuração.</span><span class="sxs-lookup"><span data-stu-id="93906-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="93906-400">Não usá-lo para controlar o fluxo de execução do programa.</span><span class="sxs-lookup"><span data-stu-id="93906-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-401">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> propriedade para gerar uma declaração, se o thread atual entrou no modo atualizável inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="93906-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-402">Obtém um valor que indica se o thread atual inseriu o bloqueio no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="93906-403"><see langword="true" /> Se o thread atual entrou no modo de gravação; Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-404">Esta propriedade destina para uso em declarações ou para outros fins de depuração.</span><span class="sxs-lookup"><span data-stu-id="93906-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="93906-405">Não usá-lo para controlar o fluxo de execução do programa.</span><span class="sxs-lookup"><span data-stu-id="93906-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-406">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> propriedade para gerar uma declaração, se o thread atual entrou no modo de gravação inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="93906-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-407">Obtém um valor que indica a política de recursão do objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> atual.</span><span class="sxs-lookup"><span data-stu-id="93906-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="93906-408">Um dos valores de enumeração que especifica a política de recursão de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-409">Política de recursão determina as restrições em threads que entrar no bloqueio de mais de uma vez.</span><span class="sxs-lookup"><span data-stu-id="93906-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="93906-410">Por exemplo, se um bloqueio foi criado com <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e um thread entrou no bloqueio no modo de leitura, <xref:System.Threading.LockRecursionException> será gerada se o thread tenta reintroduzir o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-411">Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para modo independentemente da configuração de política de recursão de bloqueio de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="93906-412">Independentemente da política de recursão, um thread que inseriu inicialmente ler modo não é permitido atualizar para o modo de upgrade ou modo de gravação, porque esse padrão cria uma grande probabilidade de deadlocks.</span><span class="sxs-lookup"><span data-stu-id="93906-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="93906-413">Para obter mais informações sobre a política de recursão e seus efeitos, consulte o <xref:System.Threading.LockRecursionPolicy> enumeração e a <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-414">Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de leitura, como uma indicação de recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="93906-415">0 (zero) se o thread atual não entrou modo de leitura, 1 se o thread entrou no modo de leitura, mas não foi inserido, ele recursivamente, ou *n* se o thread inseriu o bloqueio recursivamente *n* – 1 vezes.</span><span class="sxs-lookup"><span data-stu-id="93906-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-416">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-417">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-418">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-419">Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de upgrade, como uma indicação de recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="93906-420">0 se o thread atual não entrou em modo de upgrade, 1 se o thread entrou em modo de upgrade, mas não tiver inserido ele recursivamente, ou *n* se o thread entrou no modo de upgrade recursivamente *n* - 1 tempos.</span><span class="sxs-lookup"><span data-stu-id="93906-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-421">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-422">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-423">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-424">Obtém o número de vezes que o thread atual inseriu o bloqueio no modo de gravação, como uma indicação de recursão.</span><span class="sxs-lookup"><span data-stu-id="93906-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="93906-425">0 se o thread atual não entrou gravar modo, 1 se o thread entrou no modo de gravação, mas não foi inserido, ele recursivamente, ou *n* se o thread tiver inserido recursivamente do modo de gravação *n* – 1 vezes.</span><span class="sxs-lookup"><span data-stu-id="93906-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-426">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-427">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-428">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93906-429">Tenta entrar no bloqueio no modo de leitura, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="93906-430">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="93906-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="93906-431">Tenta inserir o bloqueio no modo de gravação com um tempo limite inteiro opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="93906-432"><see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-433">Se `millisecondsTimeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="93906-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="93906-434">Vários threads podem entrar no modo de leitura ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="93906-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="93906-435">Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.</span><span class="sxs-lookup"><span data-stu-id="93906-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-436">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de leitura pode inserir repetidamente do modo de leitura, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="93906-437">Um thread pode estar em modo de upgrade, enquanto outro thread está no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="93906-438">Se os threads adicionais estão esperando para inserir o modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, threads que chamam o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método entrar imediatamente no modo de leitura e não bloquear.</span><span class="sxs-lookup"><span data-stu-id="93906-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-439">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="93906-440">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-440">-or-</span></span> 
<span data-ttu-id="93906-441">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-442">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93906-443">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-444">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="93906-445">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="93906-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="93906-446">Tenta entrar no bloqueio no modo de leitura, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="93906-447"><see langword="true" /> se o thread de chamada tiver entrado no modo de leitura; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-448">Se `timeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="93906-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="93906-449">Vários threads podem entrar no bloqueio no modo de leitura ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="93906-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="93906-450">Se um ou mais threads na fila para entrar no modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.</span><span class="sxs-lookup"><span data-stu-id="93906-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-451">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de leitura pode inserir repetidamente do modo de leitura, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="93906-452">Um thread pode estar em modo de upgrade, enquanto outro thread está no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="93906-453">Se os threads adicionais estão esperando para inserir o modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, threads que chamam o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método entrar imediatamente no modo de leitura e não bloquear.</span><span class="sxs-lookup"><span data-stu-id="93906-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-454">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="93906-455">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-455">-or-</span></span> 
<span data-ttu-id="93906-456">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-457">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93906-458">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="93906-459">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-459">-or-</span></span> 
<span data-ttu-id="93906-460">O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</span><span class="sxs-lookup"><span data-stu-id="93906-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-461">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93906-462">Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="93906-463">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="93906-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="93906-464">Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="93906-465"><see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-466">Se `millisecondsTimeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="93906-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="93906-467">Use o modo pode ser atualizado quando um thread normalmente acessa o recurso protegido pelo <xref:System.Threading.ReaderWriterLockSlim> no modo de leitura, mas talvez seja necessário inserir o modo de gravação se determinadas condições forem atendidas.</span><span class="sxs-lookup"><span data-stu-id="93906-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="93906-468">Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para o modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="93906-469">Apenas um thread pode inserir um bloqueio no modo de upgrade em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="93906-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="93906-470">Se um thread está em modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, qualquer número de outros threads pode entrar no modo de leitura, mesmo se não houver segmentos aguardando para entrar no modo atualizável.</span><span class="sxs-lookup"><span data-stu-id="93906-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-471">Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.</span><span class="sxs-lookup"><span data-stu-id="93906-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-472">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de upgrade pode inserir repetidamente do modo de upgrade, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-473">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="93906-474">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-474">-or-</span></span> 
<span data-ttu-id="93906-475">O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="93906-476">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-476">-or-</span></span> 
<span data-ttu-id="93906-477">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-478">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93906-479">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-480">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="93906-481">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="93906-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="93906-482">Tenta inserir o bloqueio no modo de upgrade, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="93906-483"><see langword="true" /> se o thread de chamada tiver entrado no modo de upgrade, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-484">Se `timeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="93906-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="93906-485">Use o modo pode ser atualizado quando um thread normalmente acessa o recurso protegido pela <xref:System.Threading.ReaderWriterLockSlim> no modo de leitura, mas talvez seja necessário inserir o modo de gravação se determinadas condições forem atendidas.</span><span class="sxs-lookup"><span data-stu-id="93906-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="93906-486">Um thread no modo de upgrade pode atualizar para o modo de gravação ou fazer downgrade para o modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="93906-487">Apenas um thread pode inserir um bloqueio no modo de upgrade em um determinado momento.</span><span class="sxs-lookup"><span data-stu-id="93906-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="93906-488">Se um thread está em modo de upgrade e não há nenhum segmento esperando para entrar no modo de gravação, qualquer número de outros threads pode entrar no modo de leitura, mesmo se não houver segmentos aguardando para entrar no modo atualizável.</span><span class="sxs-lookup"><span data-stu-id="93906-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="93906-489">Se um ou mais threads estão esperando para inserir o modo de gravação, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloqueia até que esses threads tenham o atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele, ou até que o intervalo de tempo limite de thread de chamada próprio expire.</span><span class="sxs-lookup"><span data-stu-id="93906-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-490">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de upgrade pode inserir repetidamente do modo de upgrade, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-491">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="93906-492">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-492">-or-</span></span> 
<span data-ttu-id="93906-493">O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de upgrade geraria a possibilidade de um deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="93906-494">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-494">-or-</span></span> 
<span data-ttu-id="93906-495">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-496">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93906-497">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="93906-498">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-498">-or-</span></span> 
<span data-ttu-id="93906-499">O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</span><span class="sxs-lookup"><span data-stu-id="93906-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-500">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="93906-501">Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="93906-502">O número de milissegundos a aguardar ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="93906-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="93906-503">Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="93906-504"><see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-505">Se `millisecondsTimeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="93906-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="93906-506">Se outros threads inseriu o bloqueio no modo de leitura, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloqueia até que esses threads tiveram saído do modo de leitura ou até que o intervalo de tempo limite tenha decorrido.</span><span class="sxs-lookup"><span data-stu-id="93906-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="93906-507">Enquanto os threads são bloqueados, esperando para inserir o modo de gravação, threads adicionais que tentam inserir o modo de leitura ou modo de upgrade bloqueiam até que o modo de gravação de todos os threads esperando para inserir tiver qualquer um atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.</span><span class="sxs-lookup"><span data-stu-id="93906-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-508">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de gravação pode inserir repetidamente do modo de gravação, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-509">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método para inserir o bloqueio no modo de gravação, com um tempo limite. O método mostrado no exemplo adiciona um novo par chave/valor para o cache sincronizado.</span><span class="sxs-lookup"><span data-stu-id="93906-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="93906-510">Se o intervalo de tempo limite especificado transcorrer antes que o thread entra no bloqueio, o método retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="93906-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="93906-511">O método retorna `true` se o par chave/valor é adicionado.</span><span class="sxs-lookup"><span data-stu-id="93906-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="93906-512">Se a chave já está no cache, a exceção gerada pelo interno <xref:System.Collections.Generic.Dictionary%602> é permitido para o método terminate.</span><span class="sxs-lookup"><span data-stu-id="93906-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="93906-513">Um `finally` block é usado para executar o <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, garantindo que o chamador é encerrado o bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="93906-514">Esse código é parte de um exemplo maior fornecido para o <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="93906-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-515">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="93906-516">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-516">-or-</span></span> 
<span data-ttu-id="93906-517">O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="93906-518">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-518">-or-</span></span> 
<span data-ttu-id="93906-519">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-520">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93906-521">O valor de <paramref name="millisecondsTimeout" /> é negativo, mas não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que é o único valor negativo permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-522">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="93906-523">O intervalo para esperar ou -1 milissegundo para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="93906-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="93906-524">Tenta entrar no bloqueio no modo de gravação, com um tempo limite opcional.</span><span class="sxs-lookup"><span data-stu-id="93906-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="93906-525"><see langword="true" /> se o thread de chamada tiver entrado no modo de gravação, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="93906-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-526">Se `timeout` for 0 (zero), esse método verifica o estado de bloqueio e retorna `false` imediatamente se o estado desejado não estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="93906-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="93906-527">Se outros threads inseriu o bloqueio no modo de leitura, um thread que chama o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloqueia até que esses threads tiveram saído do modo de leitura ou até que o intervalo de tempo limite tenha decorrido.</span><span class="sxs-lookup"><span data-stu-id="93906-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="93906-528">Enquanto os threads são bloqueados, esperando para inserir o modo de gravação, threads adicionais que tentam inserir o modo de leitura ou modo de upgrade bloqueiam até que o modo de gravação de todos os threads esperando para inserir tiver qualquer um atingiu o tempo limite ou entrou no modo de gravação e, em seguida, encerrado dele.</span><span class="sxs-lookup"><span data-stu-id="93906-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="93906-529">Se um bloqueio permite recursão, um thread que entrou no bloqueio no modo de gravação pode inserir repetidamente do modo de gravação, mesmo se outros threads estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="93906-530">A propriedade <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> é <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e o thread atual já entrou no bloqueio.</span><span class="sxs-lookup"><span data-stu-id="93906-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="93906-531">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-531">-or-</span></span> 
<span data-ttu-id="93906-532">O thread atual inseriu inicialmente o bloqueio no modo de leitura, portanto, tentar entrar no modo de gravação criará a possibilidade de um deadlock.</span><span class="sxs-lookup"><span data-stu-id="93906-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="93906-533">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-533">-or-</span></span> 
<span data-ttu-id="93906-534">O número de recursão excederia a capacidade do contador.</span><span class="sxs-lookup"><span data-stu-id="93906-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="93906-535">O limite é tão grande que os aplicativos nunca o alcançariam.</span><span class="sxs-lookup"><span data-stu-id="93906-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="93906-536">O valor de <paramref name="timeout" /> é negativo, mas não é igual a -1 milissegundo, que é o único valor negativo permitido.</span><span class="sxs-lookup"><span data-stu-id="93906-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="93906-537">- ou -</span><span class="sxs-lookup"><span data-stu-id="93906-537">-or-</span></span> 
<span data-ttu-id="93906-538">O valor de <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" /> milissegundos.</span><span class="sxs-lookup"><span data-stu-id="93906-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="93906-539">O objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> foi descartado.</span><span class="sxs-lookup"><span data-stu-id="93906-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-540">Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="93906-541">O número total de threads que estão esperando para inserir o modo de leitura.</span><span class="sxs-lookup"><span data-stu-id="93906-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-542">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-543">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-544">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-545">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads que estão bloqueados, esperando para inserir o modo de leitura, exceder um limite.</span><span class="sxs-lookup"><span data-stu-id="93906-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-546">Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="93906-547">O número total de threads que estão esperando para inserir o modo de upgrade.</span><span class="sxs-lookup"><span data-stu-id="93906-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-548">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-549">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-550">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-551">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads que estão bloqueados, esperando para inserir o modo de upgrade, exceder um limite.</span><span class="sxs-lookup"><span data-stu-id="93906-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="93906-552">Obtém o número total de threads que estão esperando para inserir o bloqueio no modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="93906-553">O número total de threads que estão esperando para inserir o modo de gravação.</span><span class="sxs-lookup"><span data-stu-id="93906-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="93906-554">Use essa propriedade apenas para depuração, criação de perfil e registrar os objetivos e não para controlar o comportamento de um algoritmo.</span><span class="sxs-lookup"><span data-stu-id="93906-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="93906-555">Os resultados podem ser alterados assim que eles foram calculados.</span><span class="sxs-lookup"><span data-stu-id="93906-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="93906-556">Portanto, não é seguro tomar decisões com base nessa propriedade.</span><span class="sxs-lookup"><span data-stu-id="93906-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="93906-557">O exemplo a seguir mostra como usar o <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> propriedade para gerar uma entrada de log de eventos se o número de threads que estão bloqueados, esperando para inserir o modo de gravação, exceder um limite.</span><span class="sxs-lookup"><span data-stu-id="93906-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>