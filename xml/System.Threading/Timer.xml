<Type Name="Timer" FullName="System.Threading.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1eef97181838354ff4be8e0d34d51c4d79667eea" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406779" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Timer&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="0031a-101">Fornece um mecanismo para executar um método em um thread do pool de threads em intervalos especificados.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0031a-101">Provides a mechanism for executing a method on a thread pool thread at specified intervals.</span>
      </span>
      <span data-ttu-id="0031a-102">Essa classe não pode ser herdada.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0031a-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-103">Use um <xref:System.Threading.TimerCallback> delegado para especificar o método que você deseja o <xref:System.Threading.Timer> para executar.</span><span class="sxs-lookup"><span data-stu-id="0031a-103">Use a <xref:System.Threading.TimerCallback> delegate to specify the method you want the <xref:System.Threading.Timer> to execute.</span></span> <span data-ttu-id="0031a-104">A assinatura do <xref:System.Threading.TimerCallback> delegado é:</span><span class="sxs-lookup"><span data-stu-id="0031a-104">The signature of the <xref:System.Threading.TimerCallback> delegate is:</span></span>  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 <span data-ttu-id="0031a-105">O representante de timer é especificado quando o timer é construído e não pode ser alterado.</span><span class="sxs-lookup"><span data-stu-id="0031a-105">The timer delegate is specified when the timer is constructed, and cannot be changed.</span></span> <span data-ttu-id="0031a-106">O método não é executado no thread que criou o timer; ele é executado em um <xref:System.Threading.ThreadPool> thread fornecido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="0031a-106">The method does not execute on the thread that created the timer; it executes on a <xref:System.Threading.ThreadPool> thread supplied by the system.</span></span>  
  
> [!TIP]
> <span data-ttu-id="0031a-107">.NET inclui quatro classes chamadas `Timer`, cada um de que oferece funcionalidades diferentes:</span><span class="sxs-lookup"><span data-stu-id="0031a-107">.NET includes four classes named `Timer`, each of which offers different functionality:</span></span>  
>
> - <span data-ttu-id="0031a-108"><xref:System.Timers.Timer?displayProperty=nameWithType>, que dispara um evento e executa o código em um ou mais eventos coletores em intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="0031a-108"><xref:System.Timers.Timer?displayProperty=nameWithType>, which fires an event and executes the code in one or more event sinks at regular intervals.</span></span> <span data-ttu-id="0031a-109">A classe é destinada para uso como um servidor com base em ou componente de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não fica visível no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="0031a-109">The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</span></span>
> - <span data-ttu-id="0031a-110"><xref:System.Threading.Timer?displayProperty=nameWithType>, que executa um método de retorno de chamada única em um pool de threads em intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="0031a-110"><xref:System.Threading.Timer?displayProperty=nameWithType>, which executes a single callback method on a thread pool thread at regular intervals.</span></span> <span data-ttu-id="0031a-111">O método de retorno de chamada é definido quando o timer é instanciado e não pode ser alterado.</span><span class="sxs-lookup"><span data-stu-id="0031a-111">The callback method is defined when the timer is instantiated and cannot be changed.</span></span> <span data-ttu-id="0031a-112">Como o <xref:System.Timers.Timer?displayProperty=nameWithType> classe, essa classe é destinada para uso como um componente baseado em servidor ou serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não fica visível no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="0031a-112">Like the <xref:System.Timers.Timer?displayProperty=nameWithType> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</span></span>
> - <span data-ttu-id="0031a-113"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET framework somente), um componente de Windows Forms que dispara um evento e executa o código em um ou mais Coletores de eventos em intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="0031a-113"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET Framework only), a Windows Forms component that fires an event and executes the code in one or more event sinks at regular intervals.</span></span> <span data-ttu-id="0031a-114">O componente não tem nenhuma interface do usuário e é projetado para uso em um ambiente de thread único; ele executa no thread da interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="0031a-114">The component has no user interface and is designed for use in a single-threaded environment; it executes on the UI thread.</span></span>
> - <span data-ttu-id="0031a-115"><xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET framework somente), um componente do ASP.NET que executa a página da web assíncrona ou síncrona postbacks em intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="0031a-115"><xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET Framework only), an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</span></span>
  
 <span data-ttu-id="0031a-116">Quando você cria um temporizador, você pode especificar um período de tempo de espera antes da primeira execução do método (tempo) e um valor de tempo de espera entre as execuções subsequentes (período).</span><span class="sxs-lookup"><span data-stu-id="0031a-116">When you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period).</span></span> <span data-ttu-id="0031a-117">O <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema.</span><span class="sxs-lookup"><span data-stu-id="0031a-117">The <xref:System.Threading.Timer> class has the same resolution as the system clock.</span></span> <span data-ttu-id="0031a-118">Isso significa que, se o período for menor do que a resolução do relógio do sistema, o <xref:System.Threading.TimerCallback> representante será executado em intervalos definidos pela resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8.</span><span class="sxs-lookup"><span data-stu-id="0031a-118">This means that if the period is less than the resolution of the system clock, the <xref:System.Threading.TimerCallback> delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems.</span></span> <span data-ttu-id="0031a-119">Você pode alterar o devido tempo e período ou desabilitar o timer, usando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-119">You can change the due time and period, or disable the timer, by using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0031a-120">Enquanto você estiver usando um <xref:System.Threading.Timer>, você deve manter uma referência a ele.</span><span class="sxs-lookup"><span data-stu-id="0031a-120">As long as you are using a <xref:System.Threading.Timer>, you must keep a reference to it.</span></span> <span data-ttu-id="0031a-121">Assim como acontece com qualquer objeto gerenciado, uma <xref:System.Threading.Timer> está sujeito a coleta de lixo quando não houver nenhuma referência a ele.</span><span class="sxs-lookup"><span data-stu-id="0031a-121">As with any managed object, a <xref:System.Threading.Timer> is subject to garbage collection when there are no references to it.</span></span> <span data-ttu-id="0031a-122">O fato de que um <xref:System.Threading.Timer> é ativo ainda não impede que ele sendo coletados.</span><span class="sxs-lookup"><span data-stu-id="0031a-122">The fact that a <xref:System.Threading.Timer> is still active does not prevent it from being collected.</span></span>  
  
 <span data-ttu-id="0031a-123">Quando um timer não é mais necessário, use o <xref:System.Threading.Timer.Dispose%2A> método para liberar os recursos mantidos pelo timer.</span><span class="sxs-lookup"><span data-stu-id="0031a-123">When a timer is no longer needed, use the <xref:System.Threading.Timer.Dispose%2A> method to free the resources held by the timer.</span></span> <span data-ttu-id="0031a-124">Observe que os retornos de chamada podem ocorrer após a <xref:System.Threading.Timer.Dispose> sobrecarga do método foi chamada, porque o timer de filas de retornos de chamada para execução por threads de pool.</span><span class="sxs-lookup"><span data-stu-id="0031a-124">Note that callbacks can occur after the <xref:System.Threading.Timer.Dispose> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</span></span> <span data-ttu-id="0031a-125">Você pode usar o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método Aguarde até que todos os retornos de chamada de tem concluído.</span><span class="sxs-lookup"><span data-stu-id="0031a-125">You can use the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload to wait until all callbacks have completed.</span></span>  
  
 <span data-ttu-id="0031a-126">O método de retorno de chamada executado pelo temporizador deve ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads.</span><span class="sxs-lookup"><span data-stu-id="0031a-126">The callback method executed by the timer should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="0031a-127">O retorno de chamada pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o retorno de chamada, ou se todos os threads de pool estão em uso e o retorno de chamada é enfileirado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0031a-127">The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0031a-128"><xref:System.Threading.Timer?displayProperty=nameWithType> é um temporizador leve e simple que usa métodos de retorno de chamada e é fornecido por threads de pool.</span><span class="sxs-lookup"><span data-stu-id="0031a-128"><xref:System.Threading.Timer?displayProperty=nameWithType> is a simple, lightweight timer that uses callback methods and is served by thread pool threads.</span></span> <span data-ttu-id="0031a-129">Não é recomendável para uso com o Windows Forms, porque seus retornos de chamada não ocorrem no thread de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="0031a-129">It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread.</span></span> <span data-ttu-id="0031a-130"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> é uma opção melhor para uso com o Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="0031a-130"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> is a better choice for use with Windows Forms.</span></span> <span data-ttu-id="0031a-131">Para a funcionalidade de temporizador com base em servidor, você pode considerar o uso <xref:System.Timers.Timer?displayProperty=nameWithType>, que gera eventos e tem recursos adicionais.</span><span class="sxs-lookup"><span data-stu-id="0031a-131">For server-based timer functionality, you might consider using <xref:System.Timers.Timer?displayProperty=nameWithType>, which raises events and has additional features.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-132">O exemplo a seguir define uma `StatusChecker` classe que inclui um `CheckStatus` método cuja assinatura é o mesmo como o <xref:System.Threading.TimerCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="0031a-132">The following example defines a `StatusChecker` class  that includes a `CheckStatus` method whose signature is the same as the <xref:System.Threading.TimerCallback> delegate.</span></span> <span data-ttu-id="0031a-133">O `state` argumento o `CheckStatus` método é um <xref:System.Threading.AutoResetEvent> objeto que é usado para sincronizar o thread de aplicativo e o pool de threads que executa o representante de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="0031a-133">The  `state` argument of the `CheckStatus` method is an <xref:System.Threading.AutoResetEvent> object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate.</span></span> <span data-ttu-id="0031a-134">O `StatusChecker` classe também inclui duas variáveis de estado:</span><span class="sxs-lookup"><span data-stu-id="0031a-134">The `StatusChecker` class also includes two state variables:</span></span>  
  
 `invokeCount`  
 <span data-ttu-id="0031a-135">Indica o número de vezes que o método de retorno de chamada foi invocado.</span><span class="sxs-lookup"><span data-stu-id="0031a-135">Indicates the number of times the callback method has been invoked.</span></span>  
  
 `maxCount`  
 <span data-ttu-id="0031a-136">Determina o número máximo de vezes que o método de retorno de chamada deve ser invocado.</span><span class="sxs-lookup"><span data-stu-id="0031a-136">Determines the maximum number of times the callback method should be invoked.</span></span>  
  
 <span data-ttu-id="0031a-137">O thread de aplicativo cria o timer, que aguarda um segundo e, em seguida, executa o `CheckStatus` método de retorno de chamada cada 250 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="0031a-137">The application thread creates the timer, which waits one second and then executes  the `CheckStatus` callback method every 250 milliseconds.</span></span> <span data-ttu-id="0031a-138">O thread de aplicativo, em seguida, bloqueia até o <xref:System.Threading.AutoResetEvent> objeto é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="0031a-138">The application thread then blocks until the <xref:System.Threading.AutoResetEvent> object is signaled.</span></span> <span data-ttu-id="0031a-139">Quando o `CheckStatus` executa o método de retorno de chamada `maxCount` vezes, ele chama o `AutoResetEvent.Set` método para definir o estado do <xref:System.Threading.AutoResetEvent> objeto sinalizado.</span><span class="sxs-lookup"><span data-stu-id="0031a-139">When the `CheckStatus` callback method executes `maxCount` times, it calls the `AutoResetEvent.Set` method to set the state of the <xref:System.Threading.AutoResetEvent> object to signaled.</span></span> <span data-ttu-id="0031a-140">Na primeira vez isso acontecer, o thread de aplicativo chama o <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> método para que o método de retorno de chamada agora executa cada meio segundo.</span><span class="sxs-lookup"><span data-stu-id="0031a-140">The first time this happens, the application thread calls the <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> method so that the callback method now executes every half second.</span></span> <span data-ttu-id="0031a-141">Bloqueia novamente até que o <xref:System.Threading.AutoResetEvent> objeto é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="0031a-141">It once again blocks until the <xref:System.Threading.AutoResetEvent> object is signaled.</span></span> <span data-ttu-id="0031a-142">Quando isso acontece, o timer é destruído chamando seu <xref:System.Threading.Timer.Dispose%2A> método e o aplicativo será encerrado.</span><span class="sxs-lookup"><span data-stu-id="0031a-142">When this happens, the timer is destroyed by calling its <xref:System.Threading.Timer.Dispose%2A> method, and the application terminates.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="0031a-143">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0031a-143">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.TimerCallback" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0031a-144">Inicializa uma nova instância da classe <see langword="Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-144">Initializes a new instance of the <see langword="Timer" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback -&gt; System.Threading.Timer" Usage="new System.Threading.Timer callback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="0031a-145">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-145">A <see cref="T:System.Threading.TimerCallback" /> delegate representing a method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-146">Inicializa uma nova instância da classe <see cref="T:System.Threading.Timer" /> com um período infinito e um tempo de validade infinito usando o objeto <see cref="T:System.Threading.Timer" /> recém-criado como o objeto de estado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-146">Initializes a new instance of the <see cref="T:System.Threading.Timer" /> class with an infinite period and an infinite due time, using the newly created <see cref="T:System.Threading.Timer" /> object as the state object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-147">Chamar este construtor quando você deseja usar o <xref:System.Threading.Timer> próprio objeto como o objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="0031a-147">Call this constructor when you want to use the <xref:System.Threading.Timer> object itself as the state object.</span></span> <span data-ttu-id="0031a-148">Depois de criar o timer, use o <xref:System.Threading.Timer.Change%2A> método para definir o intervalo e a hora de vencimento.</span><span class="sxs-lookup"><span data-stu-id="0031a-148">After creating the timer, use the <xref:System.Threading.Timer.Change%2A> method to set the interval and due time.</span></span>  
  
 <span data-ttu-id="0031a-149">Este construtor Especifica um infinito devido tempo antes do retorno de chamada primeiro e um intervalo de infinito entre retornos de chamada, para impedir o retorno de chamada primeiro antes do <xref:System.Threading.Timer> objeto é atribuído ao objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="0031a-149">This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the <xref:System.Threading.Timer> object is assigned to the state object.</span></span>  
  
 <span data-ttu-id="0031a-150">O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads.</span><span class="sxs-lookup"><span data-stu-id="0031a-150">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="0031a-151">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0031a-151">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-152">O exemplo de código a seguir cria um novo timer, usando o temporizador de si mesmo como o objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="0031a-152">The following code example creates a new timer, using the timer itself as the state object.</span></span> <span data-ttu-id="0031a-153">O <xref:System.Threading.Timer.Change%2A> método é usado para iniciar o timer.</span><span class="sxs-lookup"><span data-stu-id="0031a-153">The <xref:System.Threading.Timer.Change%2A> method is used to start the timer.</span></span> <span data-ttu-id="0031a-154">Quando o retorno de chamada timer ocorre, o objeto de estado é usado para desativar o timer.</span><span class="sxs-lookup"><span data-stu-id="0031a-154">When the timer callback occurs, the state object is used to turn the timer off.</span></span>  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, int dueTime, int period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int * int -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="0031a-155">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-155">A <see cref="T:System.Threading.TimerCallback" /> delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="0031a-156">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-156">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="0031a-157">A quantidade de tempo de atraso antes que <c>callback</c> seja invocado, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-157">The amount of time to delay before <c>callback</c> is invoked, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-158">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-158">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="0031a-159">Especifica zero (0) para iniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-159">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-160">O intervalo de tempo entre invocações de <c>callback</c>, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-160">The time interval between invocations of <c>callback</c>, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-161">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-161">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-162">Inicializa uma nova instância da classe <see langword="Timer" />, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-162">Initializes a new instance of the <see langword="Timer" /> class, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-163">O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="0031a-163">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="0031a-164">Se `dueTime` é zero (0), `callback` é chamado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-164">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="0031a-165">Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-165">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-166">Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema, se `period`é menor do que a resolução do relógio do sistema.</span><span class="sxs-lookup"><span data-stu-id="0031a-166">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="0031a-167">Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-167">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-168">O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads.</span><span class="sxs-lookup"><span data-stu-id="0031a-168">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="0031a-169">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0031a-169">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-170">O exemplo de código a seguir mostra como criar um `TimerCallback` delegar e inicializar uma nova instância do `Timer` classe.</span><span class="sxs-lookup"><span data-stu-id="0031a-170">The following code example shows how to create a `TimerCallback` delegate and initialize a new instance of the `Timer` class.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-171">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-171">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0031a-172">O parâmetro <paramref name="callback" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-172">The <paramref name="callback" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, long dueTime, long period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int64 * int64 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="0031a-173">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-173">A <see cref="T:System.Threading.TimerCallback" /> delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="0031a-174">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-174">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="0031a-175">A quantidade de tempo de atraso antes que <c>callback</c> seja invocado, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-175">The amount of time to delay before <c>callback</c> is invoked, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-176">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-176">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="0031a-177">Especifica zero (0) para iniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-177">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-178">O intervalo de tempo entre invocações de <c>callback</c>, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-178">The time interval between invocations of <c>callback</c>, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-179">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-179">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-180">Inicializa uma nova instância da classe <see langword="Timer" />, usando um inteiro com sinal de 64 bits para medir intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-180">Initializes a new instance of the <see langword="Timer" /> class, using 64-bit signed integers to measure time intervals.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-181">O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="0031a-181">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="0031a-182">Se `dueTime` é zero (0), `callback` é chamado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-182">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="0031a-183">Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-183">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-184">Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema, se `period`é menor do que a resolução do relógio do sistema.</span><span class="sxs-lookup"><span data-stu-id="0031a-184">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="0031a-185">Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-185">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-186">O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads.</span><span class="sxs-lookup"><span data-stu-id="0031a-186">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="0031a-187">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0031a-187">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-188">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-188">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="0031a-189">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é maior que 4294967294.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-189">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is greater than 4294967294.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * TimeSpan * TimeSpan -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="0031a-190">Um delegado que representa um método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-190">A delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="0031a-191">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-191">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="0031a-192">A quantidade de tempo a ser atrasada antes que o parâmetro <c>callback</c> invoque seus métodos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-192">The amount of time to delay before the <c>callback</c> parameter invokes its methods.</span>
          </span>
          <span data-ttu-id="0031a-193">Especifique um milissegundo negativo (-1) para impedir que o temporizador seja iniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-193">Specify negative one (-1) milliseconds to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="0031a-194">Especifica zero (0) para iniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-194">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-195">O intervalo de tempo entre invocações dos métodos referenciados pelo <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-195">The time interval between invocations of the methods referenced by <c>callback</c>.</span>
          </span>
          <span data-ttu-id="0031a-196">Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-196">Specify negative one (-1) milliseconds to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-197">Inicializa uma nova instância da classe <see langword="Timer" />, usando valores <see cref="T:System.TimeSpan" /> para medir intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-197">Initializes a new instance of the <see langword="Timer" /> class, using <see cref="T:System.TimeSpan" /> values to measure time intervals.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-198">O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="0031a-198">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="0031a-199">Se `dueTime` é zero (0), `callback` é chamado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-199">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="0031a-200">Se `dueTime` é negativo um (-1) milissegundos, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-200">If `dueTime` is negative one (-1) milliseconds, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-201">Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema, se `period`é menor do que a resolução do relógio do sistema.</span><span class="sxs-lookup"><span data-stu-id="0031a-201">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="0031a-202">Se `period` é zero (0) ou negativo um (-1) milissegundos e `dueTime` for positivo, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-202">If `period` is zero (0) or negative one (-1) milliseconds and `dueTime` is positive, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-203">O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads.</span><span class="sxs-lookup"><span data-stu-id="0031a-203">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="0031a-204">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0031a-204">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-205">O exemplo de código a seguir mostra como criar um `TimerCallback` delegar e inicializar uma nova instância do `Timer` classe.</span><span class="sxs-lookup"><span data-stu-id="0031a-205">The following code example shows how to create a `TimerCallback` delegate and initialize a new instance of the `Timer` class.</span></span>  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-206">O número de milissegundos no valor de <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> ou é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-206">The number of milliseconds in the value of <paramref name="dueTime" /> or <paramref name="period" /> is negative and not equal to <see cref="F:System.Threading.Timeout.Infinite" />, or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0031a-207">O parâmetro <paramref name="callback" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-207">The <paramref name="callback" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * uint32 * uint32 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="0031a-208">Um delegado que representa um método a ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-208">A delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="0031a-209">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-209">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="0031a-210">A quantidade de tempo de atraso antes que <c>callback</c> seja invocado, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-210">The amount of time to delay before <c>callback</c> is invoked, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-211">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-211">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="0031a-212">Especifica zero (0) para iniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-212">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-213">O intervalo de tempo entre invocações de <c>callback</c>, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-213">The time interval between invocations of <c>callback</c>, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-214">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-214">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-215">Inicializa uma nova instância da classe <see langword="Timer" />, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-215">Initializes a new instance of the <see langword="Timer" /> class, using 32-bit unsigned integers to measure time intervals.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-216">O delegado especificado pelo `callback` parâmetro é chamado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o `period` ter decorrido de intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="0031a-216">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="0031a-217">Se `dueTime` é zero (0), `callback` é chamado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-217">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="0031a-218">Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-218">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-219">Porque o <xref:System.Threading.Timer> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado executa em intervalos definidos pela resolução do relógio do sistema, se `period`é menor do que a resolução do relógio do sistema.</span><span class="sxs-lookup"><span data-stu-id="0031a-219">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="0031a-220">Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-220">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="0031a-221">O método especificado para `callback` devem ser reentrante, porque ele é chamado em <xref:System.Threading.ThreadPool> threads.</span><span class="sxs-lookup"><span data-stu-id="0031a-221">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="0031a-222">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</span><span class="sxs-lookup"><span data-stu-id="0031a-222">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-223">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-223">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0031a-224">O parâmetro <paramref name="callback" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-224">The <paramref name="callback" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Change">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0031a-225">Altera a hora de início e o intervalo entre invocações de método para um temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-225">Changes the start time and the interval between method invocations for a timer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Integer, period As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(int dueTime, int period);" />
      <MemberSignature Language="F#" Value="member this.Change : int * int -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="0031a-226">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-226">The amount of time to delay before the invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-227">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o temporizador seja reiniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-227">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="0031a-228">Especifique zero (0) para reiniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-228">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-229">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-229">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-230">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-230">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-231">Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 32 bits para medir intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-231">Changes the start time and the interval between method invocations for a timer, using 32-bit signed integers to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0031a-232">
            <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-232">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-233">O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.</span><span class="sxs-lookup"><span data-stu-id="0031a-233">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="0031a-234">Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-234">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="0031a-235">Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="0031a-235">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="0031a-236">Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.</span><span class="sxs-lookup"><span data-stu-id="0031a-236">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `period`.</span></span>  
  
 <span data-ttu-id="0031a-237">O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="0031a-237">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-238">O exemplo de código a seguir demonstra como iniciar um `Timer` e, após um determinado número de chamadas, altere o período.</span><span class="sxs-lookup"><span data-stu-id="0031a-238">The following code example demonstrates how to start a `Timer` and, after a set number of invocations, change its period.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="0031a-239">O <see cref="T:System.Threading.Timer" /> já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-239">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-240">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-240">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Long, period As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(long dueTime, long period);" />
      <MemberSignature Language="F#" Value="member this.Change : int64 * int64 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="0031a-241">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-241">The amount of time to delay before the invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-242">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o temporizador seja reiniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-242">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="0031a-243">Especifique zero (0) para reiniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-243">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-244">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-244">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-245">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-245">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-246">Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 64 bits para medir intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-246">Changes the start time and the interval between method invocations for a timer, using 64-bit signed integers to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0031a-247">
            <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-247">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-248">O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.</span><span class="sxs-lookup"><span data-stu-id="0031a-248">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="0031a-249">Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-249">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="0031a-250">Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="0031a-250">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="0031a-251">Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.</span><span class="sxs-lookup"><span data-stu-id="0031a-251">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `period`.</span></span>  
  
 <span data-ttu-id="0031a-252">O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="0031a-252">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="0031a-253">O <see cref="T:System.Threading.Timer" /> já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-253">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-254">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-254">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="0031a-255">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é maior que 4294967294.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-255">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is greater than 4294967294.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As TimeSpan, period As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="member this.Change : TimeSpan * TimeSpan -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="0031a-256">O <see cref="T:System.TimeSpan" /> que representa o período de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-256">A <see cref="T:System.TimeSpan" /> representing the amount of time to delay before invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed.</span>
          </span>
          <span data-ttu-id="0031a-257">Especifique um milissegundo negativo (-1) para impedir que o temporizador seja reinicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-257">Specify negative one (-1) milliseconds to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="0031a-258">Especifique zero (0) para reiniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-258">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-259">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-259">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed.</span>
          </span>
          <span data-ttu-id="0031a-260">Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-260">Specify negative one (-1) milliseconds to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-261">Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando valores de <see cref="T:System.TimeSpan" /> para medir os intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-261">Changes the start time and the interval between method invocations for a timer, using <see cref="T:System.TimeSpan" /> values to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0031a-262">
            <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-262">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-263">O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.</span><span class="sxs-lookup"><span data-stu-id="0031a-263">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="0031a-264">Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-264">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="0031a-265">Se `dueTime` é negativo um (-1) milissegundos, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="0031a-265">If `dueTime` is negative one (-1) milliseconds, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="0031a-266">Se `period` é zero (0) ou negativo um (-1) milissegundos, e `dueTime` for positivo, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor maior que zero para `period`.</span><span class="sxs-lookup"><span data-stu-id="0031a-266">If `period` is zero (0) or negative one (-1) milliseconds, and `dueTime` is positive, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a value greater than zero for `period`.</span></span>  
  
 <span data-ttu-id="0031a-267">O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="0031a-267">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-268">O exemplo de código a seguir demonstra como iniciar um `Timer` e, após um determinado número de chamadas, altere o período.</span><span class="sxs-lookup"><span data-stu-id="0031a-268">The following code example demonstrates how to start a `Timer` and, after a set number of invocations, change its period.</span></span>  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="0031a-269">O <see cref="T:System.Threading.Timer" /> já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-269">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0031a-270">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" />, em milissegundos, é menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-270">The <paramref name="dueTime" /> or <paramref name="period" /> parameter, in milliseconds, is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="0031a-271">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" />, em milissegundos, é maior que 4294967294.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-271">The <paramref name="dueTime" /> or <paramref name="period" /> parameter, in milliseconds, is greater than 4294967294.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As UInteger, period As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="member this.Change : uint32 * uint32 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="0031a-272">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-272">The amount of time to delay before the invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-273">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o temporizador seja reiniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-273">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="0031a-274">Especifique zero (0) para reiniciar o temporizador imediatamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-274">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="0031a-275">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-275">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="0031a-276">Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-276">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-277">Altera a hora de início e o intervalo entre as invocações de método de um temporizador, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-277">Changes the start time and the interval between method invocations for a timer, using 32-bit unsigned integers to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0031a-278">
            <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-278">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-279">O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por `period` expira.</span><span class="sxs-lookup"><span data-stu-id="0031a-279">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="0031a-280">Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente.</span><span class="sxs-lookup"><span data-stu-id="0031a-280">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="0031a-281">Se `dueTime` é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="0031a-281">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="0031a-282">Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.</span><span class="sxs-lookup"><span data-stu-id="0031a-282">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `period`.</span></span>  
  
 <span data-ttu-id="0031a-283">O <xref:System.Threading.Timer.Change%2A> método pode ser chamado a partir de <xref:System.Threading.TimerCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="0031a-283">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="0031a-284">O <see cref="T:System.Threading.Timer" /> já foi descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-284">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0031a-285">Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-285">Releases all resources used by the current instance of <see cref="T:System.Threading.Timer" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="timer.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0031a-286">Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-286">Releases all resources used by the current instance of <see cref="T:System.Threading.Timer" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-287">Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.Timer> para ser realocada para outros fins.</span><span class="sxs-lookup"><span data-stu-id="0031a-287">Calling `Dispose` allows the resources used by the <xref:System.Threading.Timer> to be reallocated for other purposes.</span></span> <span data-ttu-id="0031a-288">Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="0031a-288">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0031a-289">Retornos de chamada podem ocorrer após a <xref:System.Threading.Timer.Dispose> sobrecarga do método foi chamada, porque o timer de filas de retornos de chamada para execução por threads de pool.</span><span class="sxs-lookup"><span data-stu-id="0031a-289">Callbacks can occur after the <xref:System.Threading.Timer.Dispose> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</span></span> <span data-ttu-id="0031a-290">Você pode usar o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método Aguarde até que todos os retornos de chamada de tem concluído.</span><span class="sxs-lookup"><span data-stu-id="0031a-290">You can use the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload to wait until all callbacks have completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0031a-291">O exemplo de código a seguir mostra como liberar os recursos mantidos por um `Timer`.</span><span class="sxs-lookup"><span data-stu-id="0031a-291">The following code example shows how to free the resources held by a `Timer`.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dispose (notifyObject As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Dispose(System::Threading::WaitHandle ^ notifyObject);" />
      <MemberSignature Language="F#" Value="member this.Dispose : System.Threading.WaitHandle -&gt; bool" Usage="timer.Dispose notifyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="notifyObject">
          <span data-ttu-id="0031a-292">O <see cref="T:System.Threading.WaitHandle" /> a ser sinalizado quando o <see langword="Timer" /> for descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-292">The <see cref="T:System.Threading.WaitHandle" /> to be signaled when the <see langword="Timer" /> has been disposed of.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0031a-293">Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" /> e indica quando o temporizador for descartado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-293">Releases all resources used by the current instance of <see cref="T:System.Threading.Timer" /> and signals when the timer has been disposed of.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0031a-294">
            <see langword="true" /> se a função for bem-sucedida; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-294">
              <see langword="true" /> if the function succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0031a-295">Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.Timer> para ser realocada para outros fins.</span><span class="sxs-lookup"><span data-stu-id="0031a-295">Calling `Dispose` allows the resources used by the <xref:System.Threading.Timer> to be reallocated for other purposes.</span></span> <span data-ttu-id="0031a-296">Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="0031a-296">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 <span data-ttu-id="0031a-297">Quando esse método é concluído, ele sinaliza o <xref:System.Threading.WaitHandle> especificado pelo `notifyObject` parâmetro. Use essa sobrecarga de <xref:System.Threading.Timer.Dispose%2A> método se você deseja bloquear até ter certeza de que o temporizador foi descartado.</span><span class="sxs-lookup"><span data-stu-id="0031a-297">When this method completes, it signals the <xref:System.Threading.WaitHandle> specified by the `notifyObject` parameter.Use this overload of the <xref:System.Threading.Timer.Dispose%2A> method if you want to be able to block until you are certain that the timer has been disposed.</span></span> <span data-ttu-id="0031a-298">O timer não é descartado até que todos os retornos de chamada atualmente na fila tenham concluído.</span><span class="sxs-lookup"><span data-stu-id="0031a-298">The timer is not disposed until all currently queued callbacks have completed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0031a-299">Se usar o retorno de chamada a <xref:System.Threading.Timer.Change%2A> método para definir o `dueTime` parâmetro como zero, uma condição de corrida pode ocorrer quando o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método é chamada: se o timer enfileira um retorno de chamada novo antes do <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método detecta que há nenhum retorno de chamada na fila, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> continue a bloquear; caso contrário, o temporizador é descartado enquanto o retorno de chamada novo está sendo enfileirado e um <xref:System.ObjectDisposedException> é gerada quando o retorno de chamada novo chama o <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="0031a-299">If the callback uses the <xref:System.Threading.Timer.Change%2A> method to set the `dueTime` parameter to zero, a race condition can occur when the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload is called: If the timer queues a new callback before the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload detects that there are no callbacks queued, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> continues to block; otherwise, the timer is disposed while the new callback is being queued, and an <xref:System.ObjectDisposedException> is thrown when the new callback calls the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0031a-300">O parâmetro <paramref name="notifyObject" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0031a-300">The <paramref name="notifyObject" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>