<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Timer.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac567fe19429800288028bf5585c9bd4f03134790db.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fe19429800288028bf5585c9bd4f03134790db</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Provides a mechanism for executing a method on a thread pool thread at specified intervals.</source>
          <target state="translated">Fornece um mecanismo para executar um método em um thread do pool de threads em intervalos especificados.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>This class cannot be inherited.</source>
          <target state="translated">Essa classe não pode ser herdada.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Use a <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate to specify the method you want the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to execute.</source>
          <target state="translated">Use um <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegado para especificar o método que você deseja o <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> para executar.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The signature of the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate is:</source>
          <target state="translated">A assinatura do <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegado é:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The timer delegate is specified when the timer is constructed, and cannot be changed.</source>
          <target state="translated">O representante de timer é especificado quando o timer é construído e não pode ser alterado.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The method does not execute on the thread that created the timer; it executes on a <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread supplied by the system.</source>
          <target state="translated">O método não é executado no thread que criou o timer; ele é executado em um <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread fornecido pelo sistema.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>.NET includes four classes named <ph id="ph1">`Timer`</ph>, each of which offers different functionality:</source>
          <target state="translated">.NET inclui quatro classes chamadas <ph id="ph1">`Timer`</ph>, cada um de que oferece funcionalidades diferentes:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, que dispara um evento e executa o código em um ou mais eventos coletores em intervalos regulares.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">A classe é destinada para uso como um servidor com base em ou componente de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não fica visível no tempo de execução.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, which executes a single callback method on a thread pool thread at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, que executa um método de retorno de chamada única em um pool de threads em intervalos regulares.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method is defined when the timer is instantiated and cannot be changed.</source>
          <target state="translated">O método de retorno de chamada é definido quando o timer é instanciado e não pode ser alterado.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Like the <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">Como o <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> classe, essa classe é destinada para uso como um componente baseado em servidor ou serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não fica visível no tempo de execução.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), a Windows Forms component that fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET framework somente), um componente de Windows Forms que dispara um evento e executa o código em um ou mais Coletores de eventos em intervalos regulares.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The component has no user interface and is designed for use in a single-threaded environment; it executes on the UI thread.</source>
          <target state="translated">O componente não tem nenhuma interface do usuário e é projetado para uso em um ambiente de thread único; ele executa no thread da interface do usuário.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET framework somente), um componente do ASP.NET que executa a página da web assíncrona ou síncrona postbacks em intervalos regulares.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period).</source>
          <target state="translated">Quando você cria um temporizador, você pode especificar um período de tempo de espera antes da primeira execução do método (tempo) e um valor de tempo de espera entre as execuções subsequentes (período).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe tem a mesma resolução que o relógio do sistema.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This means that if the period is less than the resolution of the system clock, the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems.</source>
          <target state="translated">Isso significa que, se o período for menor do que a resolução do relógio do sistema, o <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> representante será executado em intervalos definidos pela resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can change the due time and period, or disable the timer, by using the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Você pode alterar o devido tempo e período ou desabilitar o timer, usando o <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As long as you are using a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, you must keep a reference to it.</source>
          <target state="translated">Enquanto você estiver usando um <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, você deve manter uma referência a ele.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As with any managed object, a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is subject to garbage collection when there are no references to it.</source>
          <target state="translated">Assim como acontece com qualquer objeto gerenciado, uma <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> está sujeito a coleta de lixo quando não houver nenhuma referência a ele.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The fact that a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is still active does not prevent it from being collected.</source>
          <target state="translated">O fato de que um <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> é ativo ainda não impede que ele sendo coletados.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When a timer is no longer needed, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method to free the resources held by the timer.</source>
          <target state="translated">Quando um timer não é mais necessário, use o <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> método para liberar os recursos mantidos pelo timer.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Note that callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Observe que os retornos de chamada podem ocorrer após a <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> sobrecarga do método foi chamada, porque o timer de filas de retornos de chamada para execução por threads de pool.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga do método Aguarde até que todos os retornos de chamada de tem concluído.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method executed by the timer should be reentrant, because it is called on <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">O método de retorno de chamada executado pelo temporizador deve ser reentrante, porque ele é chamado em <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times.</source>
          <target state="translated">O retorno de chamada pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o retorno de chamada, ou se todos os threads de pool estão em uso e o retorno de chamada é enfileirado várias vezes.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> is a simple, lightweight timer that uses callback methods and is served by thread pool threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> é um temporizador leve e simple que usa métodos de retorno de chamada e é fornecido por threads de pool.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread.</source>
          <target state="translated">Não é recomendável para uso com o Windows Forms, porque seus retornos de chamada não ocorrem no thread de interface do usuário.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> is a better choice for use with Windows Forms.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> é uma opção melhor para uso com o Windows Forms.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>For server-based timer functionality, you might consider using <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which raises events and has additional features.</source>
          <target state="translated">Para a funcionalidade de temporizador com base em servidor, você pode considerar o uso <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, que gera eventos e tem recursos adicionais.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The following example defines a <ph id="ph1">`StatusChecker`</ph> class  that includes a <ph id="ph2">`CheckStatus`</ph> method whose signature is the same as the <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">O exemplo a seguir define uma <ph id="ph1">`StatusChecker`</ph> classe que inclui um <ph id="ph2">`CheckStatus`</ph> método cuja assinatura é o mesmo como o <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The  <ph id="ph1">`state`</ph> argument of the <ph id="ph2">`CheckStatus`</ph> method is an <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate.</source>
          <target state="translated">O <ph id="ph1">`state`</ph> argumento o <ph id="ph2">`CheckStatus`</ph> método é um <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objeto que é usado para sincronizar o thread de aplicativo e o pool de threads que executa o representante de retorno de chamada.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">`StatusChecker`</ph> class also includes two state variables:</source>
          <target state="translated">O <ph id="ph1">`StatusChecker`</ph> classe também inclui duas variáveis de estado:</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Indicates the number of times the callback method has been invoked.</source>
          <target state="translated">Indica o número de vezes que o método de retorno de chamada foi invocado.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Determines the maximum number of times the callback method should be invoked.</source>
          <target state="translated">Determina o número máximo de vezes que o método de retorno de chamada deve ser invocado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread creates the timer, which waits one second and then executes  the <ph id="ph1">`CheckStatus`</ph> callback method every 250 milliseconds.</source>
          <target state="translated">O thread de aplicativo cria o timer, que aguarda um segundo e, em seguida, executa o <ph id="ph1">`CheckStatus`</ph> método de retorno de chamada cada 250 milissegundos.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread then blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">O thread de aplicativo, em seguida, bloqueia até o <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objeto é sinalizado.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When the <ph id="ph1">`CheckStatus`</ph> callback method executes <ph id="ph2">`maxCount`</ph> times, it calls the <ph id="ph3">`AutoResetEvent.Set`</ph> method to set the state of the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object to signaled.</source>
          <target state="translated">Quando o <ph id="ph1">`CheckStatus`</ph> executa o método de retorno de chamada <ph id="ph2">`maxCount`</ph> vezes, ele chama o <ph id="ph3">`AutoResetEvent.Set`</ph> método para definir o estado do <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objeto sinalizado.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The first time this happens, the application thread calls the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> method so that the callback method now executes every half second.</source>
          <target state="translated">Na primeira vez isso acontecer, o thread de aplicativo chama o <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> método para que o método de retorno de chamada agora executa cada meio segundo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It once again blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">Bloqueia novamente até que o <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objeto é sinalizado.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When this happens, the timer is destroyed by calling its <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method, and the application terminates.</source>
          <target state="translated">Quando isso acontece, o timer é destruído chamando seu <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> método e o aplicativo será encerrado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo é thread-safe.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> que representa um método a ser executado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> class with an infinite period and an infinite due time, using the newly created <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> object as the state object.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> com um período infinito e um tempo de validade infinito usando o objeto <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> recém-criado como o objeto de estado.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Call this constructor when you want to use the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object itself as the state object.</source>
          <target state="translated">Chamar este construtor quando você deseja usar o <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> próprio objeto como o objeto de estado.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>After creating the timer, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the interval and due time.</source>
          <target state="translated">Depois de criar o timer, use o <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método para definir o intervalo e a hora de vencimento.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object is assigned to the state object.</source>
          <target state="translated">Este construtor Especifica um infinito devido tempo antes do retorno de chamada primeiro e um intervalo de infinito entre retornos de chamada, para impedir o retorno de chamada primeiro antes do <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> objeto é atribuído ao objeto de estado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">O método especificado para <ph id="ph1">`callback`</ph> devem ser reentrante, porque ele é chamado em <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The following code example creates a new timer, using the timer itself as the state object.</source>
          <target state="translated">O exemplo de código a seguir cria um novo timer, usando o temporizador de si mesmo como o objeto de estado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method is used to start the timer.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método é usado para iniciar o timer.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>When the timer callback occurs, the state object is used to turn the timer off.</source>
          <target state="translated">Quando o retorno de chamada timer ocorre, o objeto de estado é usado para desativar o timer.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> que representa um método a ser executado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">A quantidade de tempo de atraso antes que <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> seja invocado, em milissegundos.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para impedir que o timer seja inicializado.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifica zero (0) para iniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">O intervalo de tempo entre invocações de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, em milissegundos.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using a 32-bit signed integer to specify the time interval.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">O delegado especificado pelo <ph id="ph1">`callback`</ph> parâmetro é chamado uma vez após <ph id="ph2">`dueTime`</ph> tiver decorrido e depois disso cada vez que o <ph id="ph3">`period`</ph> ter decorrido de intervalo de tempo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), <ph id="ph2">`callback`</ph> é chamado imediatamente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o <ph id="ph2">`callback`</ph> delegado executa em intervalos definidos pela resolução do relógio do sistema se <ph id="ph3">`period`</ph> é menor do que a resolução do relógio do sistema.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`dueTime`</ph> não é <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">O método especificado para <ph id="ph1">`callback`</ph> devem ser reentrante, porque ele é chamado em <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar um <ph id="ph1">`TimerCallback`</ph> delegar e inicializar uma nova instância do <ph id="ph2">`Timer`</ph> classe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é negativo e não é igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Um delegado <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> que representa um método a ser executado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">A quantidade de tempo de atraso antes que <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> seja invocado, em milissegundos.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para impedir que o timer seja inicializado.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifica zero (0) para iniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">O intervalo de tempo entre invocações de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, em milissegundos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>, usando um inteiro com sinal de 64 bits para medir intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">O delegado especificado pelo <ph id="ph1">`callback`</ph> parâmetro é chamado uma vez após <ph id="ph2">`dueTime`</ph> tiver decorrido e depois disso cada vez que o <ph id="ph3">`period`</ph> ter decorrido de intervalo de tempo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), <ph id="ph2">`callback`</ph> é chamado imediatamente.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o <ph id="ph2">`callback`</ph> delegado executa em intervalos definidos pela resolução do relógio do sistema se <ph id="ph3">`period`</ph> é menor do que a resolução do relógio do sistema.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`dueTime`</ph> não é <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">O método especificado para <ph id="ph1">`callback`</ph> devem ser reentrante, porque ele é chamado em <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é negativo e não é igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é maior que 4294967294.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Um delegado que representa um método a ser executado.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The amount of time to delay before the <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> parameter invokes its methods.</source>
          <target state="translated">A quantidade de tempo a ser atrasada antes que o parâmetro <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> invoque seus métodos.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from starting.</source>
          <target state="translated">Especifique um milissegundo negativo (-1) para impedir que o temporizador seja iniciado.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifica zero (0) para iniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the methods referenced by <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">O intervalo de tempo entre invocações dos métodos referenciados pelo <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>, usando valores <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> para medir intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">O delegado especificado pelo <ph id="ph1">`callback`</ph> parâmetro é chamado uma vez após <ph id="ph2">`dueTime`</ph> tiver decorrido e depois disso cada vez que o <ph id="ph3">`period`</ph> ter decorrido de intervalo de tempo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), <ph id="ph2">`callback`</ph> é chamado imediatamente.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, <ph id="ph2">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é negativo um (-1) milissegundos, <ph id="ph2">`callback`</ph> não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o <ph id="ph2">`callback`</ph> delegado executa em intervalos definidos pela resolução do relógio do sistema se <ph id="ph3">`period`</ph> é menor do que a resolução do relógio do sistema.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds and <ph id="ph2">`dueTime`</ph> is positive, <ph id="ph3">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou negativo um (-1) milissegundos e <ph id="ph2">`dueTime`</ph> for positivo, <ph id="ph3">`callback`</ph> é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">O método especificado para <ph id="ph1">`callback`</ph> devem ser reentrante, porque ele é chamado em <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">O exemplo de código a seguir mostra como criar um <ph id="ph1">`TimerCallback`</ph> delegar e inicializar uma nova instância do <ph id="ph2">`Timer`</ph> classe.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The number of milliseconds in the value of <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> is negative and not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, or is greater than <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O número de milissegundos no valor de <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é negativo e não é igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> ou é maior que <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Um delegado que representa um método a ser executado.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">A quantidade de tempo de atraso antes que <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> seja invocado, em milissegundos.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para impedir que o timer seja inicializado.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifica zero (0) para iniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">O intervalo de tempo entre invocações de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, em milissegundos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">O delegado especificado pelo <ph id="ph1">`callback`</ph> parâmetro é chamado uma vez após <ph id="ph2">`dueTime`</ph> tiver decorrido e depois disso cada vez que o <ph id="ph3">`period`</ph> ter decorrido de intervalo de tempo.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), <ph id="ph2">`callback`</ph> é chamado imediatamente.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> não é invocada; o timer está desabilitado, mas pode ser habilitado novamente chamando o <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Porque o <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe tem a mesma resolução que o relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o <ph id="ph2">`callback`</ph> delegado executa em intervalos definidos pela resolução do relógio do sistema se <ph id="ph3">`period`</ph> é menor do que a resolução do relógio do sistema.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`dueTime`</ph> não é <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">O método especificado para <ph id="ph1">`callback`</ph> devem ser reentrante, porque ele é chamado em <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">O método pode ser executado simultaneamente em dois threads de pool se o intervalo de timer é menor que o tempo necessário para executar o método, ou se todos os threads de pool estão em uso e o método é enfileirado várias vezes.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é negativo e não é igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Changes the start time and the interval between method invocations for a timer.</source>
          <target state="translated">Altera a hora de início e o intervalo entre invocações de método para um temporizador.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído, em milissegundos.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para impedir que o temporizador seja reiniciado.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique zero (0) para reiniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído, em milissegundos.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit signed integers to measure time intervals.</source>
          <target state="translated">Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 32 bits para medir intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o temporizador foi atualizado com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">O método de retorno de chamada é invocado uma vez após <ph id="ph1">`dueTime`</ph> tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por <ph id="ph2">`period`</ph> expira.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), o método de retorno de chamada é invocado imediatamente.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">`dueTime`</ph> não é <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método pode ser chamado a partir de <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">O exemplo de código a seguir demonstra como iniciar um <ph id="ph1">`Timer`</ph> e, após um determinado número de chamadas, altere o período.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> já foi descartado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é negativo e não é igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído, em milissegundos.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para impedir que o temporizador seja reiniciado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique zero (0) para reiniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído, em milissegundos.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Changes the start time and the interval between method invocations for a timer, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 64 bits para medir intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o temporizador foi atualizado com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">O método de retorno de chamada é invocado uma vez após <ph id="ph1">`dueTime`</ph> tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por <ph id="ph2">`period`</ph> expira.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), o método de retorno de chamada é invocado imediatamente.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">`dueTime`</ph> não é <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método pode ser chamado a partir de <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> já foi descartado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is less than -1.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é menor que -1.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph> é maior que 4294967294.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to delay before invoking the callback method specified when the <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa o período de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from restarting.</source>
          <target state="translated">Especifique um milissegundo negativo (-1) para impedir que o temporizador seja reinicializado.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique zero (0) para reiniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Changes the start time and the interval between method invocations for a timer, using <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando valores de <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> para medir os intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o temporizador foi atualizado com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">O método de retorno de chamada é invocado uma vez após <ph id="ph1">`dueTime`</ph> tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por <ph id="ph2">`period`</ph> expira.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), o método de retorno de chamada é invocado imediatamente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph3">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é negativo um (-1) milissegundos, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph3">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds, and <ph id="ph2">`dueTime`</ph> is positive, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a value greater than zero for <ph id="ph4">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou negativo um (-1) milissegundos, e <ph id="ph2">`dueTime`</ph> for positivo, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor maior que zero para <ph id="ph4">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método pode ser chamado a partir de <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">O exemplo de código a seguir demonstra como iniciar um <ph id="ph1">`Timer`</ph> e, após um determinado número de chamadas, altere o período.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> já foi descartado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is less than -1.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>, em milissegundos, é menor que -1.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is greater than 4294967294.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> ou <ph id="ph2">&lt;paramref name="period" /&gt;</ph>, em milissegundos, é maior que 4294967294.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído, em milissegundos.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para impedir que o temporizador seja reiniciado.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique zero (0) para reiniciar o temporizador imediatamente.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> foi construído, em milissegundos.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifica <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para desabilitar a sinalização periódica.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Altera a hora de início e o intervalo entre as invocações de método de um temporizador, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o temporizador foi atualizado com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">O método de retorno de chamada é invocado uma vez após <ph id="ph1">`dueTime`</ph> tiver decorrido e depois disso cada vez que o intervalo de tempo especificado por <ph id="ph2">`period`</ph> expira.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é zero (0), o método de retorno de chamada é invocado imediatamente.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> é <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, o método de retorno de chamada é invocado nunca; o timer está desabilitado, mas pode ser habilitado novamente chamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> é zero (0) ou <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">`dueTime`</ph> não é <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e especificando um valor positivo para <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método pode ser chamado a partir de <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> já foi descartado.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual do <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual do <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">Chamando <ph id="ph1">`Dispose`</ph> permite que os recursos usados pelo <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> para ser realocada para outros fins.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`Dispose`</ph>, consulte <bpt id="p1">[</bpt>limpeza de recursos não gerenciados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Retornos de chamada podem ocorrer após a <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> sobrecarga do método foi chamada, porque o timer de filas de retornos de chamada para execução por threads de pool.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga do método Aguarde até que todos os retornos de chamada de tem concluído.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>The following code example shows how to free the resources held by a <ph id="ph1">`Timer`</ph>.</source>
          <target state="translated">O exemplo de código a seguir mostra como liberar os recursos mantidos por um <ph id="ph1">`Timer`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to be signaled when the <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> has been disposed of.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> a ser sinalizado quando o <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> for descartado.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> and signals when the timer has been disposed of.</source>
          <target state="translated">Libera todos os recursos usados pela instância atual do <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> e indica quando o temporizador for descartado.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the function succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a função for bem-sucedida; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">Chamando <ph id="ph1">`Dispose`</ph> permite que os recursos usados pelo <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> para ser realocada para outros fins.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`Dispose`</ph>, consulte <bpt id="p1">[</bpt>limpeza de recursos não gerenciados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>When this method completes, it signals the <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> specified by the <ph id="ph2">`notifyObject`</ph> parameter.Use this overload of the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method if you want to be able to block until you are certain that the timer has been disposed.</source>
          <target state="translated">Quando esse método é concluído, ele sinaliza o <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> especificado pelo <ph id="ph2">`notifyObject`</ph> parâmetro. Use essa sobrecarga de <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> método se você deseja bloquear até ter certeza de que o temporizador foi descartado.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The timer is not disposed until all currently queued callbacks have completed.</source>
          <target state="translated">O timer não é descartado até que todos os retornos de chamada atualmente na fila tenham concluído.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>If the callback uses the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the <ph id="ph2">`dueTime`</ph> parameter to zero, a race condition can occur when the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload is called: If the timer queues a new callback before the <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload detects that there are no callbacks queued, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continues to block; otherwise, the timer is disposed while the new callback is being queued, and an <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> is thrown when the new callback calls the <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se usar o retorno de chamada a <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método para definir o <ph id="ph2">`dueTime`</ph> parâmetro como zero, uma condição de corrida pode ocorrer quando o <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga do método é chamada: se o timer enfileira um retorno de chamada novo antes do <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga do método detecta que não há nenhum retorno de chamada na fila, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continue a bloquear; caso contrário, o temporizador é descartado enquanto o retorno de chamada novo está sendo enfileirado e um <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> é gerada quando o retorno de chamada novo chama o <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>