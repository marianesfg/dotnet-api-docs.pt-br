<Type Name="Timer" FullName="System.Threading.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d0f264481ebfa384ad9cf9faa53a1002409139c6" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609008" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Timer&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece um mecanismo para executar um método em um thread do pool de threads em intervalos especificados. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use uma <xref:System.Threading.TimerCallback> delegado para especificar o método que você deseja que o <xref:System.Threading.Timer> para executar. A assinatura do <xref:System.Threading.TimerCallback> delegado é:  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 O delegado de timer é especificado quando o temporizador é construído e não pode ser alterado. O método não é executado no thread que criou o timer; ele é executado em um <xref:System.Threading.ThreadPool> thread fornecido pelo sistema.  
  
> [!TIP]
> O .NET inclui quatro classes chamadas `Timer`, cada do que oferece uma funcionalidade diferente:  
>
> - <xref:System.Timers.Timer?displayProperty=nameWithType>, que dispara um evento e executa o código em um ou mais eventos coletores em intervalos regulares. A classe é destinada para uso como um servidor baseado em ou componente de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não estiver visível no tempo de execução.
> - <xref:System.Threading.Timer?displayProperty=nameWithType>, que executa um método de retorno de chamada único em um pool de threads em intervalos regulares. O método de retorno de chamada é definido quando o temporizador é instanciado e não pode ser alterado. Como o <xref:System.Timers.Timer?displayProperty=nameWithType> classe, essa classe é destinada para uso como um componente baseado em servidor ou de serviço em um ambiente multithreaded; ele não tem nenhuma interface de usuário e não estiver visível no tempo de execução.
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET framework só), um componente de Windows Forms que dispara um evento e executa o código em um ou mais Coletores de eventos em intervalos regulares. O componente não tem nenhuma interface de usuário e é projetado para uso em um ambiente single-threaded; ele executa no thread da interface do usuário.
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET framework só), um componente do ASP.NET que executa postbacks de página da web assíncrona ou síncrona em intervalos regulares.
  
 Quando você cria um temporizador, você pode especificar uma quantidade de tempo de espera antes da primeira execução do método (hora de vencimento,) e um valor de tempo de espera entre as execuções subsequentes (período). O <xref:System.Threading.Timer> classe tem a mesma resolução do relógio do sistema. Isso significa que, se o período for menor que a resolução do relógio do sistema, o <xref:System.Threading.TimerCallback> delegado será executado em intervalos definidos pela resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8. Você pode alterar o devido tempo e período ou desabilitar o temporizador, usando o <xref:System.Threading.Timer.Change%2A> método.  
  
> [!NOTE]
>  Enquanto você estiver usando um <xref:System.Threading.Timer>, você deve manter uma referência a ele. Assim como acontece com qualquer objeto gerenciado, um <xref:System.Threading.Timer> está sujeita à coleta de lixo quando não houver nenhuma referência a ele. O fato de que um <xref:System.Threading.Timer> é o Active Directory ainda não impede que ele seja coletado.  
  
 Quando um temporizador não for mais necessário, use o <xref:System.Threading.Timer.Dispose%2A> método para liberar os recursos mantidos pelo temporizador. Observe que os retornos de chamada podem ocorrer após o <xref:System.Threading.Timer.Dispose> sobrecarga de método foi chamada, porque o temporizador enfileira retornos de chamada para execução por threads do pool. Você pode usar o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga de método para aguardar até que todos os retornos de chamada sejam concluídas.  
  
 O método de retorno de chamada executado pelo temporizador deve ser reentrante, porque ele é chamado no <xref:System.Threading.ThreadPool> threads. O retorno de chamada pode ser executado simultaneamente em dois threads de pool se o intervalo do temporizador for menor que o tempo necessário para executar o retorno de chamada, ou se todos os threads do pool estão em uso e o retorno de chamada é colocada na fila várias vezes.  
  
> [!NOTE]
>  <xref:System.Threading.Timer?displayProperty=nameWithType> é um temporizador leve e simple que usa métodos de retorno de chamada e é fornecido por threads do pool. Não é recomendável para uso com o Windows Forms, porque seus retornos de chamada não ocorrem no thread da interface do usuário. <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> é uma opção melhor para uso com o Windows Forms. Para a funcionalidade de temporizador com base em servidor, você pode considerar usar <xref:System.Timers.Timer?displayProperty=nameWithType>, que gera eventos e tem recursos adicionais.  
  
   
  
## Examples  
 O exemplo a seguir define uma `StatusChecker` classe inclui um `CheckStatus` método cuja assinatura é o mesmo como o <xref:System.Threading.TimerCallback> delegar. O `state` argumento do `CheckStatus` método é um <xref:System.Threading.AutoResetEvent> objeto que é usado para sincronizar o thread do aplicativo e o pool de threads que executa o delegado de retorno de chamada. O `StatusChecker` classe também inclui duas variáveis de estado:  
  
 `invokeCount`  
 Indica o número de vezes que o método de retorno de chamada foi invocado.  
  
 `maxCount`  
 Determina o número máximo de vezes que o método de retorno de chamada deve ser invocado.  
  
 O thread do aplicativo cria o timer, que aguarda um segundo e, em seguida, executa o `CheckStatus` método de retorno de chamada cada 250 milissegundos. Em seguida, bloqueia o thread do aplicativo até que o <xref:System.Threading.AutoResetEvent> objeto é sinalizado. Quando o `CheckStatus` método de retorno de chamada é executado `maxCount` vezes, ele chama o `AutoResetEvent.Set` método para definir o estado do <xref:System.Threading.AutoResetEvent> objeto a ser sinalizado. Na primeira vez isso acontece, o thread do aplicativo chama o <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> método para que o método de retorno de chamada agora é executado a cada meio segundo. Mais uma vez, ele bloqueia até que o <xref:System.Threading.AutoResetEvent> objeto é sinalizado. Quando isso acontece, o temporizador for destruído, chamando seu <xref:System.Threading.Timer.Dispose%2A> método e o aplicativo é encerrado.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.TimerCallback" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback -&gt; System.Threading.Timer" Usage="new System.Threading.Timer callback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Timer" /> com um período infinito e um tempo de validade infinito usando o objeto <see cref="T:System.Threading.Timer" /> recém-criado como o objeto de estado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse construtor, quando você deseja usar o <xref:System.Threading.Timer> próprio objeto como o objeto de estado. Depois de criar o timer, use o <xref:System.Threading.Timer.Change%2A> método para definir o intervalo e a hora de vencimento.  
  
 Este construtor Especifica uma validade infinito tempo antes do primeiro retorno de chamada e um intervalo infinito entre retornos de chamada, para impedir que o primeiro retorno de chamada ocorra antes do <xref:System.Threading.Timer> objeto é atribuído ao objeto de estado.  
  
 O método especificado para `callback` deve ser reentrante, porque ele é chamado no <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads do pool se o intervalo do temporizador for menor que o tempo necessário para executar o método, ou se todos os threads do pool estão em uso e o método está na fila várias vezes.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo temporizador, usando o temporizador de si mesmo como o objeto de estado. O <xref:System.Threading.Timer.Change%2A> método é usado para iniciar o temporizador. Quando ocorre o retorno de chamada do timer, o objeto de estado é usado para desativar o temporizador.  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, int dueTime, int period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int * int -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de atraso antes que <c>callback</c> seja invocado, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de <c>callback</c>, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é invocado uma vez após `dueTime` tiver decorrido e daí em diante, sempre que o `period` seja decorrido do intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é invocada imediatamente. Se `dueTime` está <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocado; o temporizador é desabilitado, mas pode ser habilitado novamente chamando a <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução do relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado é executado em intervalos definidos pela resolução do relógio do sistema se `period`é menor que a resolução do relógio do sistema. Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` deve ser reentrante, porque ele é chamado no <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads do pool se o intervalo do temporizador for menor que o tempo necessário para executar o método, ou se todos os threads do pool estão em uso e o método está na fila várias vezes.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma `TimerCallback` delegar e inicializar uma nova instância do `Timer` classe.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, long dueTime, long period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int64 * int64 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado <see cref="T:System.Threading.TimerCallback" /> que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de atraso antes que <c>callback</c> seja invocado, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de <c>callback</c>, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando um inteiro com sinal de 64 bits para medir intervalos de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é invocado uma vez após `dueTime` tiver decorrido e daí em diante, sempre que o `period` seja decorrido do intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é invocada imediatamente. Se `dueTime` está <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocado; o temporizador é desabilitado, mas pode ser habilitado novamente chamando a <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução do relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado é executado em intervalos definidos pela resolução do relógio do sistema se `period`é menor que a resolução do relógio do sistema. Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` deve ser reentrante, porque ele é chamado no <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads do pool se o intervalo do temporizador for menor que o tempo necessário para executar o método, ou se todos os threads do pool estão em uso e o método está na fila várias vezes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é maior que 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * TimeSpan * TimeSpan -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo a ser atrasada antes que o parâmetro <c>callback</c> invoque seus métodos. Especifique um milissegundo negativo (-1) para impedir que o temporizador seja iniciado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações dos métodos referenciados pelo <c>callback</c>. Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando valores <see cref="T:System.TimeSpan" /> para medir intervalos de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é invocado uma vez após `dueTime` tiver decorrido e daí em diante, sempre que o `period` seja decorrido do intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é invocada imediatamente. Se `dueTime` é um (-1) milissegundo negativo, `callback` não é invocado; o temporizador é desabilitado, mas pode ser habilitado novamente chamando a <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução do relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado é executado em intervalos definidos pela resolução do relógio do sistema se `period`é menor que a resolução do relógio do sistema. Se `period` é zero (0) ou um (-1) milissegundo negativo e `dueTime` for positivo, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` deve ser reentrante, porque ele é chamado no <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads do pool se o intervalo do temporizador for menor que o tempo necessário para executar o método, ou se todos os threads do pool estão em uso e o método está na fila várias vezes.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar uma `TimerCallback` delegar e inicializar uma nova instância do `Timer` classe.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de milissegundos no valor de <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" /> ou é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * uint32 * uint32 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="callback">Um delegado que representa um método a ser executado.</param>
        <param name="state">Um objeto que contém informações a serem usadas pelo método de retorno de chamada, ou <see langword="null" />.</param>
        <param name="dueTime">A quantidade de tempo de atraso antes que <c>callback</c> seja invocado, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o timer seja inicializado. Especifica zero (0) para iniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre invocações de <c>callback</c>, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Inicializa uma nova instância da classe <see langword="Timer" />, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delegado especificado pelo `callback` parâmetro é invocado uma vez após `dueTime` tiver decorrido e daí em diante, sempre que o `period` seja decorrido do intervalo de tempo.  
  
 Se `dueTime` é zero (0), `callback` é invocada imediatamente. Se `dueTime` está <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` não é invocado; o temporizador é desabilitado, mas pode ser habilitado novamente chamando a <xref:System.Threading.Timer.Change%2A> método.  
  
 Porque o <xref:System.Threading.Timer> classe tem a mesma resolução do relógio do sistema, que é aproximadamente 15 milissegundos em sistemas Windows 7 e Windows 8, o `callback` delegado é executado em intervalos definidos pela resolução do relógio do sistema se `period`é menor que a resolução do relógio do sistema. Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente usando o <xref:System.Threading.Timer.Change%2A> método.  
  
 O método especificado para `callback` deve ser reentrante, porque ele é chamado no <xref:System.Threading.ThreadPool> threads. O método pode ser executado simultaneamente em dois threads do pool se o intervalo do temporizador for menor que o tempo necessário para executar o método, ou se todos os threads do pool estão em uso e o método está na fila várias vezes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="callback" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Change">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Altera a hora de início e o intervalo entre invocações de método para um temporizador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Integer, period As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(int dueTime, int period);" />
      <MemberSignature Language="F#" Value="member this.Change : int * int -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o temporizador seja reiniciado. Especifique zero (0) para reiniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 32 bits para medir intervalos de tempo.</summary>
        <returns>
          <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e, assim, cada vez o intervalo de tempo especificado por `period` tenha decorrido.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` está <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada nunca é invocado, o temporizador está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado do <xref:System.Threading.TimerCallback> delegar.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como iniciar um `Timer` e, após um determinado número de invocações, alterar seu período.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é negativo e não é igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Long, period As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(long dueTime, long period);" />
      <MemberSignature Language="F#" Value="member this.Change : int64 * int64 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dueTime">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o temporizador seja reiniciado. Especifique zero (0) para reiniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando inteiros com sinal de 64 bits para medir intervalos de tempo.</summary>
        <returns>
          <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e, assim, cada vez o intervalo de tempo especificado por `period` tenha decorrido.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` está <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada nunca é invocado, o temporizador está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado do <xref:System.Threading.TimerCallback> delegar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" /> é maior que 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As TimeSpan, period As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="member this.Change : TimeSpan * TimeSpan -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime">O <see cref="T:System.TimeSpan" /> que representa o período de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído. Especifique um milissegundo negativo (-1) para impedir que o temporizador seja reinicializado. Especifique zero (0) para reiniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído. Especifique um milissegundo negativo (-1) para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método para um temporizador, usando valores de <see cref="T:System.TimeSpan" /> para medir os intervalos de tempo.</summary>
        <returns>
          <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e, assim, cada vez o intervalo de tempo especificado por `period` tenha decorrido.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` é um (-1) milissegundo negativo, o método de retorno de chamada nunca é invocado, o temporizador está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou um (-1) milissegundo negativo, e `dueTime` for positivo, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor maior que zero para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado do <xref:System.Threading.TimerCallback> delegar.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como iniciar um `Timer` e, após um determinado número de invocações, alterar seu período.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" />, em milissegundos, é menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="dueTime" /> ou <paramref name="period" />, em milissegundos, é maior que 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As UInteger, period As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="member this.Change : uint32 * uint32 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dueTime">A quantidade de tempo de atraso antes de invocar o método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para impedir que o temporizador seja reiniciado. Especifique zero (0) para reiniciar o temporizador imediatamente.</param>
        <param name="period">O intervalo de tempo entre as invocações do método de retorno de chamada especificado quando o <see cref="T:System.Threading.Timer" /> foi construído, em milissegundos. Especifica <see cref="F:System.Threading.Timeout.Infinite" /> para desabilitar a sinalização periódica.</param>
        <summary>Altera a hora de início e o intervalo entre as invocações de método de um temporizador, usando inteiros sem sinal de 32 bits para medir os intervalos de tempo.</summary>
        <returns>
          <see langword="true" /> se o temporizador foi atualizado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de retorno de chamada é invocado uma vez após `dueTime` tiver decorrido e, assim, cada vez o intervalo de tempo especificado por `period` tenha decorrido.  
  
 Se `dueTime` é zero (0), o método de retorno de chamada é invocado imediatamente. Se `dueTime` está <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada nunca é invocado, o temporizador está desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `dueTime`.  
  
 Se `period` é zero (0) ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` não é <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, o método de retorno de chamada é invocado uma vez; o comportamento periódico do temporizador é desabilitado, mas pode ser habilitado novamente chamando <xref:System.Threading.Timer.Change%2A> e especificando um valor positivo para `period`.  
  
 O <xref:System.Threading.Timer.Change%2A> método pode ser chamado do <xref:System.Threading.TimerCallback> delegar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Timer" /> já foi descartado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="timer.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.Timer> para ser realocados para outras finalidades. Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).  
  
> [!NOTE]
>  Retornos de chamada poderá ocorrer após o <xref:System.Threading.Timer.Dispose> sobrecarga de método foi chamada, porque o temporizador enfileira retornos de chamada para execução por threads do pool. Você pode usar o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga de método para aguardar até que todos os retornos de chamada sejam concluídas.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como liberar os recursos mantidos por um `Timer`.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dispose (notifyObject As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Dispose(System::Threading::WaitHandle ^ notifyObject);" />
      <MemberSignature Language="F#" Value="member this.Dispose : System.Threading.WaitHandle -&gt; bool" Usage="timer.Dispose notifyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="notifyObject">O <see cref="T:System.Threading.WaitHandle" /> a ser sinalizado quando o <see langword="Timer" /> for descartado.</param>
        <summary>Libera todos os recursos usados pela instância atual do <see cref="T:System.Threading.Timer" /> e indica quando o temporizador for descartado.</summary>
        <returns>
          <see langword="true" /> se a função for bem-sucedida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.Timer> para ser realocados para outras finalidades. Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).  
  
 Quando esse método for concluído, ele sinaliza a <xref:System.Threading.WaitHandle> especificado pelo `notifyObject` parâmetro. Use essa sobrecarga da <xref:System.Threading.Timer.Dispose%2A> método se você quiser ser capaz de bloquear até ter certeza de que o temporizador foi descartado. O timer não é descartado até que todos os retornos de chamada em fila no momento sejam concluídas.  
  
> [!NOTE]
>  Se o retorno de chamada usa a <xref:System.Threading.Timer.Change%2A> método para definir o `dueTime` parâmetro como zero, uma condição de corrida pode ocorrer quando o <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método é chamada: se o temporizador enfileira um retorno de chamada de novo antes do <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga do método detecta que há nenhum retorno de chamada na fila, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> continua a bloquear; caso contrário, o temporizador for descartado enquanto o retorno de chamada de novo está sendo enfileirado e um <xref:System.ObjectDisposedException> é acionada quando chama o retorno de chamada de novo o <xref:System.Threading.Timer.Change%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="notifyObject" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Timer ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="timer.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>