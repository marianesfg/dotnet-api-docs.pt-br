<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50ab23464dfb39568b212b158b072363ca378da6" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37754726" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a thread synchronization event.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.EventWaitHandle> classe permite que os threads se comunicam entre si por meio da sinalização. Normalmente, um ou mais threads bloqueiam em uma <xref:System.Threading.EventWaitHandle> até que um thread desbloqueado chame o <xref:System.Threading.EventWaitHandle.Set%2A> método, liberando um ou mais threads bloqueados. Um thread pode sinalizar um <xref:System.Threading.EventWaitHandle> e, em seguida, bloqueá-lo, chamando o `static` (`Shared` no Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  O <xref:System.Threading.EventWaitHandle> classe fornece acesso a eventos de sincronização do sistema nomeado.  
  
 O comportamento de um <xref:System.Threading.EventWaitHandle> que tiver sido assinalada depende do seu modo de redefinição. Uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador é redefinido automaticamente quando sinalizado, após o lançamento de um único thread em espera. Uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador permanece sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.  
  
 Eventos de redefinição automática fornecem acesso exclusivo a um recurso. Se um evento de redefinição automática for sinalizado quando não houver threads em espera, ele permanecerá sinalizado até que um thread tente esperar por ele. O evento libera o thread e redefine imediatamente, bloqueando os threads subsequentes.  
  
 Eventos são como portões de redefinição manual. Quando o evento não é sinalizado, bloqueará threads que aguardam por ele. Quando o evento é sinalizado, todos os threads em espera são liberados e o evento permanece sinalizado (ou seja, esperas subsequentes não bloqueiam) até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado. Eventos de redefinição manual são úteis quando um thread deve concluir uma atividade antes de prosseguir com outros threads.  
  
 <xref:System.Threading.EventWaitHandle> objetos podem ser usados com o `static`(`Shared` no Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.  
  
 Para obter mais informações sobre mecanismos de sincronização de thread, consulte [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.  
  
 O exemplo inicia cinco threads e lhes permite bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER. O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.  
  
 O exemplo inicia cinco threads e lhes permite bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER. O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` está `null` ou uma cadeia de caracteres vazia, um local <xref:System.Threading.EventWaitHandle> é criado.  
  
 Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro será ignorado.  
  
> [!IMPORTANT]
>  Ao usar esse construtor para eventos de sistema nomeado, especifique `false` para `initialState`. Este construtor não fornece nenhuma maneira de determinar se um evento de sistema nomeado foi criado, portanto, você não pode fazer suposições sobre o estado do evento nomeado. Para determinar se um evento nomeado foi criado, use o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> construtor ou o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> construtor.  
  
 Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro será ignorado. Depois de chamar esse construtor, use o valor na variável especificada para o `ref` parâmetro (`ByRef` parâmetro no Visual Basic)`createdNew` para determinar se o evento de sistema nomeado já existia ou foi criado.  
  
 Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed. This parameter is passed uninitialized.</param>
        <param name="eventSecurity">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse construtor para aplicar a segurança de controle de acesso a um evento de sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle do evento.  
  
 Este construtor inicializa um <xref:System.Threading.EventWaitHandle> objeto que representa um evento do sistema. Você pode criar várias <xref:System.Threading.EventWaitHandle> objetos que representam o mesmo evento de sistema.  
  
 Se o evento do sistema não existir, ele é criado com a segurança de controle de acesso especificado. Se o evento existir, a segurança de controle de acesso especificado será ignorada.  
  
> [!NOTE]
>  O chamador tem controle total sobre o recém-criado <xref:System.Threading.EventWaitHandle> objeto mesmo se `eventSecurity` nega ou falha em conceder a alguns direitos de acesso para o usuário atual. No entanto, se o usuário atual tenta obter outra <xref:System.Threading.EventWaitHandle> representar o mesmo evento nomeado, usando um construtor de objeto ou o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método, o Windows a segurança de controle de acesso é aplicada.  
  
 Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro será ignorado. Depois de chamar esse construtor, use o valor na variável especificada para o `ref` parâmetro (`ByRef` parâmetro no Visual Basic) `createdNew` para determinar se o evento de sistema nomeado já existia ou foi criado.  
  
 Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</summary>
        <returns>An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para pesquisar as permissões: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 O usuário deve ter <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> direitos para chamar esse método e o evento devem ter sido abertos com o <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> sinalizador.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões tiverem sido lidos, usando o <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método, e o evento alterado, é aberto com os direitos necessários para esperar por ele e sinalizá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named synchronization event, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <summary>Opens the specified named synchronization event, if it already exists.</summary>
        <returns>An  object that represents the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método tenta abrir o evento de sistema nomeado especificado. Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema. Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.  
  
 Especificando o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread Aguarde o evento de sistema nomeado e especificando as <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named system event does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named synchronization event, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads para esperar o evento e o <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 O <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método tenta abrir um evento de sistema nomeado existente. Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema. Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named system event does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the state of the event to nonsignaled, causing threads to block.</summary>
        <returns>
          <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</summary>
        <returns>
          <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para um <xref:System.Threading.EventWaitHandle> com <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (incluindo <xref:System.Threading.AutoResetEvent>), o <xref:System.Threading.EventWaitHandle.Set%2A> método libera um único thread. Se não houver nenhum threads em espera, o identificador de espera permanece sinalizado até que um thread tentar aguardar nele, ou até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.  
  
> [!IMPORTANT]
>  Não há nenhuma garantia de que todas as chamadas para o <xref:System.Threading.EventWaitHandle.Set%2A> método lançará um thread de um <xref:System.Threading.EventWaitHandle> cujo modo redefinição é <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Se duas chamadas são muito próximos uns dos outros, para que a segunda chamada ocorre antes que um thread foi lançado, apenas um thread será liberado. É como se a segunda chamada não aconteceu. Além disso, se <xref:System.Threading.EventWaitHandle.Set%2A> é chamado quando não houver nenhum segmento esperando e o <xref:System.Threading.EventWaitHandle> já é sinalizado, a chamada não tem nenhum efeito.  
  
 Para um <xref:System.Threading.EventWaitHandle> com <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (incluindo <xref:System.Threading.ManualResetEvent>), chamar o <xref:System.Threading.EventWaitHandle.Set%2A> método deixa o identificador de espera em um estado sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.  
  
 O exemplo inicia cinco threads e lhes permite bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER. O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</param>
        <summary>Sets the access control security for a named system event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve ter <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> direitos para chamar esse método e o evento devem ter sido abertos com o <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> sinalizador.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, usando o <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> método, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  -or-  The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o evento de sincronização nomeado não existir, esse método não cria-lo. Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se um evento de sincronização nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método que lança uma exceção se o evento de sincronização não existe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit. Especificando o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread Aguarde o evento de sistema nomeado e especificando as <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o evento de sincronização nomeado não existir, esse método não cria-lo. Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se um evento de sincronização nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método que lança uma exceção se o evento de sincronização não existe.  
  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads para esperar o evento e o <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>