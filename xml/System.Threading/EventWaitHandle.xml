<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="EventWaitHandle.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac504ca1c444cfd772670659b4609b267628b38c728.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04ca1c444cfd772670659b4609b267628b38c728</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Represents a thread synchronization event.</source>
          <target state="translated">Representa um evento de sincronização de thread.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class allows threads to communicate with each other by signaling.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> classe permite que os threads para se comunicar entre si por sinalização.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Typically, one or more threads block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> until an unblocked thread calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, releasing one or more of the blocked threads.</source>
          <target state="translated">Normalmente, um ou mais threads bloqueiam um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> até que um thread desbloqueado chama o <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> método, liberando um ou mais threads bloqueados.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>A thread can signal an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> and then block on it, by calling the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Um thread pode sinalizar um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> e, em seguida, bloquear, chamando o <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> no Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> classe fornece acesso a chamado sistema de eventos de sincronização.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The behavior of an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> that has been signaled depends on its reset mode.</source>
          <target state="translated">O comportamento de um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> que tem sido sinalizado depende de seu modo de redefinição.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag resets automatically when signaled, after releasing a single waiting thread.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> sinalizador redefine automaticamente quando sinalizado, após o lançamento de um único thread de espera.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>An <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag remains signaled until its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> sinalizador permanece sinalizado até que seu <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Automatic reset events provide exclusive access to a resource.</source>
          <target state="translated">Eventos de redefinição automática fornecem acesso exclusivo a um recurso.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</source>
          <target state="translated">Se um evento de redefinição automática for sinalizado quando não houver threads em espera, ele permanecerá sinalizado até que um thread tente esperar por ele.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The event releases the thread and immediately resets, blocking subsequent threads.</source>
          <target state="translated">O evento libera o thread e redefine imediatamente, bloqueando os threads subsequentes.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are like gates.</source>
          <target state="translated">Eventos são como entradas de redefinição manual.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is not signaled, threads that wait on it will block.</source>
          <target state="translated">Quando o evento não será sinalizado, bloqueará threads que esperam nele.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Quando o evento é sinalizado, todos os threads de espera são liberados e o evento permanece sinalizado (ou seja, esperas subsequentes não bloqueiam) até que seu <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>Manual reset events are useful when one thread must complete an activity before other threads can proceed.</source>
          <target state="translated">Eventos de redefinição manual são úteis quando um thread deve concluir uma atividade para outros threads podem continuar.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects can be used with the <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objetos podem ser usados com o <ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> no Visual Basic) <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>For more information about thread synchronization mechanisms, see <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre mecanismos de sincronização de thread, consulte <bpt id="p1">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id="p1">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">O seguinte exemplo de código usa o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">O exemplo inicia cinco threads e permite bloquear um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.EventWaitHandle">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo é thread-safe.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para definir o estado inicial como sinalizado; <ph id="ph2">&lt;see langword="false" /&gt;</ph> para defini-lo como não sinalizado.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> que determina se o evento redefine automática ou manualmente.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, especificando se o identificador de espera é sinalizado inicialmente e se ele redefine automática ou manualmente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Se o estado inicial é sinalizado e o <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> sinalizador é especificado para <ph id="ph2">`mode`</ph>, threads que esperar o evento não serão bloqueado.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Se o estado inicial é sinalizado, e <ph id="ph1">`mode`</ph> é <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">O seguinte exemplo de código usa o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses ENTER key.</source>
          <target state="translated">O exemplo inicia cinco threads e permite bloquear um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <ph id="ph2">&lt;see langword="false" /&gt;</ph> para defini-lo como não sinalizado.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> que determina se o evento redefine automática ou manualmente.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">O nome de um evento de sincronização de todo o sistema.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente e o nome de um evento de sincronização do sistema.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If <ph id="ph1">`name`</ph> is <ph id="ph2">`null`</ph> or an empty string, a local <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is created.</source>
          <target state="translated">Se <ph id="ph1">`name`</ph> é <ph id="ph2">`null`</ph> ou uma cadeia de caracteres vazia, um local <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> é criado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Se um evento do sistema com o nome especificado para o <ph id="ph1">`name`</ph> já existe um parâmetro, o <ph id="ph2">`initialState`</ph> parâmetro é ignorado.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>When using this constructor for named system events, specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initialState`</ph>.</source>
          <target state="translated">Ao usar esse construtor para eventos do sistema nomeada, especifique <ph id="ph1">`false`</ph> para <ph id="ph2">`initialState`</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</source>
          <target state="translated">Este construtor oferece nenhuma forma de determinar se um evento do sistema nomeado foi criado, portanto, você não pode fazer suposições sobre o estado do evento nomeado.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>To determine whether a named event was created, use the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> constructor.</source>
          <target state="translated">Para determinar se um evento nomeado foi criado, use o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> construtor ou <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Se o estado inicial é sinalizado e o <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> sinalizador é especificado para <ph id="ph2">`mode`</ph>, threads que esperar o evento não serão bloqueado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Se o estado inicial é sinalizado, e <ph id="ph1">`mode`</ph> é <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <ph id="ph2">&lt;see langword="false" /&gt;</ph> para defini-lo como não sinalizado.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> que determina se o evento redefine automática ou manualmente.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">O nome de um evento de sincronização de todo o sistema.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">Quando este método retornar, conterá <ph id="ph1">&lt;see langword="true" /&gt;</ph> se um evento local tiver sido criado (isto é, se <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou uma cadeia de caracteres vazia) ou se o evento de sistema nomeado especificado tiver sido criado; <ph id="ph3">&lt;see langword="false" /&gt;</ph> se o evento de sistema nomeado especificado já existia.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente, o nome de um evento de sincronização do sistema e uma variável booliana cujo valor após a chamada indica se o evento de sistema nomeado foi criado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Se um evento do sistema com o nome especificado para o <ph id="ph1">`name`</ph> já existe um parâmetro, o <ph id="ph2">`initialState`</ph> parâmetro é ignorado.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic)<ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">Depois de chamar este construtor, use o valor na variável especificada para o <ph id="ph1">`ref`</ph> parâmetro (<ph id="ph2">`ByRef`</ph> parâmetro no Visual Basic)<ph id="ph3">`createdNew`</ph> para determinar se o evento do sistema nomeado já existia ou foi criado.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Se o estado inicial é sinalizado e o <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> sinalizador é especificado para <ph id="ph2">`mode`</ph>, threads que esperar o evento não serão bloqueado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Se o estado inicial é sinalizado, e <ph id="ph1">`mode`</ph> é <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to set the initial state to signaled if the named event is created as a result of this call; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to set it to nonsignaled.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <ph id="ph2">&lt;see langword="false" /&gt;</ph> para defini-lo como não sinalizado.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> values that determines whether the event resets automatically or manually.</source>
          <target state="translated">Um dos valores <ph id="ph1">&lt;see cref="T:System.Threading.EventResetMode" /&gt;</ph> que determina se o evento redefine automática ou manualmente.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The name of a system-wide synchronization event.</source>
          <target state="translated">O nome de um evento de sincronização de todo o sistema.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local event was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system event was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system event already existed.</source>
          <target state="translated">Quando este método retornar, conterá <ph id="ph1">&lt;see langword="true" /&gt;</ph> se um evento local tiver sido criado (isto é, se <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph2">&lt;see langword="null" /&gt;</ph> ou uma cadeia de caracteres vazia) ou se o evento de sistema nomeado especificado tiver sido criado; <ph id="ph3">&lt;see langword="false" /&gt;</ph> se o evento de sistema nomeado especificado já existia.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parâmetro é passado não inicializado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> que representa a segurança de controle de acesso a ser aplicada ao evento de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente, o nome de um evento de sincronização do sistema, uma variável booliana cujo valor após a chamada indica se o evento de sistema nomeado foi criado e a segurança de controle de acesso a ser aplicada ao evento nomeado se ele tiver sido criado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</source>
          <target state="translated">Use este construtor para aplicar segurança de controle de acesso a um evento do sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle do evento.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This constructor initializes an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object that represents a system event.</source>
          <target state="translated">Este construtor inicializa um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objeto que representa um evento do sistema.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objects that represent the same system event.</source>
          <target state="translated">Você pode criar várias <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objetos que representam o mesmo evento do sistema.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the system event does not exist, it is created with the specified access control security.</source>
          <target state="translated">Se o evento do sistema não existir, ele será criado com a segurança de controle de acesso especificado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event exists, the specified access control security is ignored.</source>
          <target state="translated">Se o evento existir, a segurança de controle de acesso especificado será ignorada.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object even if <ph id="ph2">`eventSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">O chamador tem controle total sobre recém-criado <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> objeto mesmo se <ph id="ph2">`eventSecurity`</ph> nega ou falhar ao conceder a alguns direitos de acesso para o usuário atual.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object to represent the same named event, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">No entanto, se o usuário atual tenta obter outro <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> representar o mesmo chamado event, usando um construtor do objeto ou o <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> método, Windows, segurança de controle de acesso é aplicada.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If a system event with the name specified for the <ph id="ph1">`name`</ph> parameter already exists, the <ph id="ph2">`initialState`</ph> parameter is ignored.</source>
          <target state="translated">Se um evento do sistema com o nome especificado para o <ph id="ph1">`name`</ph> já existe um parâmetro, o <ph id="ph2">`initialState`</ph> parâmetro é ignorado.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After calling this constructor, use the value in the variable specified for the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> parameter in Visual Basic) <ph id="ph3">`createdNew`</ph> to determine whether the named system event already existed or was created.</source>
          <target state="translated">Depois de chamar este construtor, use o valor na variável especificada para o <ph id="ph1">`ref`</ph> parâmetro (<ph id="ph2">`ByRef`</ph> parâmetro no Visual Basic) <ph id="ph3">`createdNew`</ph> para determinar se o evento do sistema nomeado já existia ou foi criado.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state of the event is nonsignaled, threads that wait on the event will block.</source>
          <target state="translated">Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and the <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> flag is specified for <ph id="ph2">`mode`</ph>, threads that wait on the event will not block.</source>
          <target state="translated">Se o estado inicial é sinalizado e o <ph id="ph1">&lt;xref:System.Threading.EventResetMode.ManualReset&gt;</ph> sinalizador é especificado para <ph id="ph2">`mode`</ph>, threads que esperar o evento não serão bloqueado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the initial state is signaled, and <ph id="ph1">`mode`</ph> is <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</source>
          <target state="translated">Se o estado inicial é sinalizado, e <ph id="ph1">`mode`</ph> é <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset&gt;</ph>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um evento nomeado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Depois que as permissões são alteradas, o evento é aberto com os direitos necessários para esperar e sinalizá-lo.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">O evento nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Não foi possível criar o evento nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event represented by the current <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> que representa a segurança de controle de acesso para o evento do sistema nomeado representado pelo objeto <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security for the named system event.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> que representa a segurança do controle de acesso para o evento do sistema nomeado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para procurar permissões: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, e <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O usuário deve ter <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> direitos para chamar esse método e o evento devem ter sido abertos com o <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um evento nomeado.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>After the permissions have been read, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> method, and changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Depois que as permissões tenham sido lidos, usando o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.GetAccessControl%2A&gt;</ph> método, e o evento alterado, é aberto com os direitos necessários para esperar e sinalizá-lo.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> atual representa um evento do sistema nomeado e o usuário não tem <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object represents a named system event, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> atual representa um evento de sistema nomeado e não foi aberto com <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.GetAccessControl">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> foi chamado anteriormente neste <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists.</source>
          <target state="translated">Abre um evento de sincronização nomeado especificado, se ele já existir.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">O nome do evento de sincronização de sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Opens the specified named synchronization event, if it already exists.</source>
          <target state="translated">Abre o evento de sincronização nomeado especificado, caso ele já exista.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>An  object that represents the named system event.</source>
          <target state="translated">Um objeto que representa o evento do sistema nomeado.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open the specified named system event.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> método tenta abrir o evento de sistema nomeado especificado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o evento do sistema quando ele ainda não existir, use uma da <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Essa sobrecarga de método é equivalente a chamar o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga de método e especificando <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> direitos, combinados com a operação OR bit a bit.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">Especificando o <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread para esperar o evento do sistema nomeado e especificando o <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread chamar o <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um evento nomeado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Depois que as permissões são alteradas, o evento é aberto com os direitos necessários para esperar e sinalizá-lo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named system event does not exist.</source>
          <target state="translated">O evento do sistema nomeado não existe.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>The named event exists, but the user does not have the security access required to use it.</source>
          <target state="translated">O evento nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">O nome do evento de sincronização de sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access.</source>
          <target state="translated">Abre o evento de sincronização nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>An object that represents the named system event.</source>
          <target state="translated">Um objeto que representa o evento do sistema nomeado.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">O <ph id="ph1">`rights`</ph> parâmetro deve incluir o <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads para esperar o evento e o <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads chamar o <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> e <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> method tries to open an existing named system event.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%2A&gt;</ph> método tenta abrir um evento de sistema nomeado existente.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the system event does not exist, this method throws an exception instead of creating the system event.</source>
          <target state="translated">Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o evento do sistema quando ele ainda não existir, use uma da <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um evento nomeado.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Depois que as permissões são alteradas, o evento é aberto com os direitos necessários para esperar e sinalizá-lo.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named system event does not exist.</source>
          <target state="translated">O evento do sistema nomeado não existe.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">Requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>Sets the state of the event to nonsignaled, causing threads to block.</source>
          <target state="translated">Define o estado do evento como não sinalizado, fazendo com que os threads sejam bloqueados.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação for bem-sucedida; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Reset">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> foi chamado anteriormente neste <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</source>
          <target state="translated">Define o estado do evento a ser sinalizado, permitindo que um ou mais threads de espera prossigam.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se a operação for bem-sucedida; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method releases a single thread.</source>
          <target state="translated">Para uma <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> com <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> (incluindo <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>), o <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> método libera um único thread.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Se não houver nenhum thread de espera, o identificador de espera permanece sinalizado até que um thread tente esperar nele, ou até que seu <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>There is no guarantee that every call to the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread from an <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> whose reset mode is <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Não há nenhuma garantia de que todas as chamadas para o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> método lançará um thread de um <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> cujo modo redefinição é <ph id="ph3">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</source>
          <target state="translated">Se duas chamadas estiverem muito juntos, para que a segunda chamada ocorre antes de um thread foi liberado, apenas um thread é liberado.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>It is as if the second call did not happen.</source>
          <target state="translated">É como se a segunda chamada não aconteceu.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>Also, if <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> is already signaled, the call has no effect.</source>
          <target state="translated">Além disso, se <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> é chamado quando não houver nenhum thread de espera e o <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> já está sinalizado, a chamada não tem nenhum efeito.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>For an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> with <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (including <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), calling the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method leaves the wait handle in a signaled state until its <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> method is called.</source>
          <target state="translated">Para uma <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> com <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> (incluindo <ph id="ph3">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>), chamar o <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> método deixa o identificador de espera em um estado sinalizado até que seu <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> método é chamado.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</source>
          <target state="translated">O seguinte exemplo de código usa o <ph id="ph1">&lt;xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29&gt;</ph> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example starts five threads and allows them to block on an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> flag, then releases one thread each time the user presses the ENTER key.</source>
          <target state="translated">O exemplo inicia cinco threads e permite bloquear um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType&gt;</ph> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The example then queues another five threads and releases them all using an <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with the <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> criado com o <ph id="ph2">&lt;xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.Set">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> foi chamado anteriormente neste <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system event.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /&gt;</ph> que representa a segurança de controle de acesso a ser aplicada ao evento de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>Sets the access control security for a named system event.</source>
          <target state="translated">Define a segurança de controle de acesso para um evento do sistema nomeado.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the event must have been opened with the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">O usuário deve ter <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> direitos para chamar esse método e o evento devem ter sido abertos com o <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> sinalizador.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named system event with access control security.</source>
          <target state="translated">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named event.</source>
          <target state="translated">O exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> sobrecarga do método para testar a existência de um evento nomeado.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</source>
          <target state="translated">Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload to wait on the event with the rights needed to read and change the permissions.</source>
          <target state="translated">A exceção é capturada e o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> method, the event is opened with the rights required to wait on it and signal it.</source>
          <target state="translated">Depois que as permissões forem alteradas, usando o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.SetAccessControl%2A&gt;</ph> método, o evento é aberto com os direitos necessários para esperar e sinalizá-lo.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>If you run the compiled example from a third command window, the example runs using the new permissions.</source>
          <target state="translated">Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventSecurity" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">O usuário não tem <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The event was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">O evento não foi aberto com <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object does not represent a named system event.</source>
          <target state="translated">O objeto <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> atual não representa um evento de sistema nomeado.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> method was previously called on this <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Threading.WaitHandle.Close" /&gt;</ph> foi chamado anteriormente neste <ph id="ph2">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Threading.EventWaitHandle">
          <source>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre um evento de sincronização nomeado especificado, se ele já existir e retorna um valor que indica se a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">O nome do evento de sincronização de sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quando é retornado, esse método contém um objeto <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> que representa o evento de sincronização nomeado se a chamada tiver sido bem-sucedida ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se a chamada tiver falhado.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Esse parâmetro é tratado como não inicializado.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre o evento de sincronização nomeado especificado, se ele já existir e retorna um valor que indica se a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o evento de sincronização nomeado foi aberto com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">Se o evento de sincronização nomeada não existir, este método não criá-lo.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o evento do sistema quando ele ainda não existir, use uma da <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">Se você não tiver certeza se existe um evento de sincronização nomeado, use essa sobrecarga de método em vez do <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29&gt;</ph> sobrecarga de método, o que gera uma exceção se o evento de sincronização não existe.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Essa sobrecarga de método é equivalente a chamar o <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29&gt;</ph> sobrecarga de método e especificando <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> direitos, combinados com a operação OR bit a bit.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the named system event, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">Especificando o <ph id="ph1">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread para esperar o evento do sistema nomeado e especificando o <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador permite que um thread chamar o <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> e <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The name of the system synchronization event to open.</source>
          <target state="translated">O nome do evento de sincronização de sistema a ser aberto.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> object that represents the named synchronization event if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quando é retornado, esse método contém um objeto <ph id="ph1">&lt;see cref="T:System.Threading.EventWaitHandle" /&gt;</ph> que representa o evento de sincronização nomeado se a chamada tiver sido bem-sucedida ou <ph id="ph2">&lt;see langword="null" /&gt;</ph> se a chamada tiver falhado.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Esse parâmetro é tratado como não inicializado.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre o evento de sincronização nomeado especificado, se ele já existir, com o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named synchronization event was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o evento de sincronização nomeado foi aberto com êxito; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If the named synchronization event does not exist, this method does not create it.</source>
          <target state="translated">Se o evento de sincronização nomeada não existir, este método não criá-lo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>To create the system event when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para criar o evento do sistema quando ele ainda não existir, use uma da <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.%23ctor%2A&gt;</ph> construtores que tem um <ph id="ph2">`name`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> method overload, which throws an exception if the synchronization event does not exist.</source>
          <target state="translated">Se você não tiver certeza se existe um evento de sincronização nomeado, use essa sobrecarga de método em vez do <ph id="ph1">&lt;xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29&gt;</ph> sobrecarga de método, o que gera uma exceção se o evento de sincronização não existe.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the event, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> methods.</source>
          <target state="translated">O <ph id="ph1">`rights`</ph> parâmetro deve incluir o <ph id="ph2">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads para esperar o evento e o <ph id="ph3">&lt;xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType&gt;</ph> sinalizador para permitir que os threads chamar o <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> e <ph id="ph5">&lt;xref:System.Threading.EventWaitHandle.Reset%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> object, even though the objects that are returned represent the same named system event.</source>
          <target state="translated">Várias chamadas a este método que usam o mesmo valor para <ph id="ph1">`name`</ph> não necessariamente retornam o mesmo <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é uma cadeia de caracteres vazia.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tem mais de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Erro do Win32.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>The named event exists, but the user does not have the desired security access.</source>
          <target state="translated">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requer confiança total para o chamador imediato.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>