<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50ab23464dfb39568b212b158b072363ca378da6" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37754726" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="b9121-101">Represents a thread synchronization event.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b9121-101">Represents a thread synchronization event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-102">O <xref:System.Threading.EventWaitHandle> classe permite que os threads se comunicam entre si por meio da sinalização.</span><span class="sxs-lookup"><span data-stu-id="b9121-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="b9121-103">Normalmente, um ou mais threads bloqueiam em uma <xref:System.Threading.EventWaitHandle> até que um thread desbloqueado chame o <xref:System.Threading.EventWaitHandle.Set%2A> método, liberando um ou mais threads bloqueados.</span><span class="sxs-lookup"><span data-stu-id="b9121-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="b9121-104">Um thread pode sinalizar um <xref:System.Threading.EventWaitHandle> e, em seguida, bloqueá-lo, chamando o `static` (`Shared` no Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="b9121-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9121-105">O <xref:System.Threading.EventWaitHandle> classe fornece acesso a eventos de sincronização do sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="b9121-106">O comportamento de um <xref:System.Threading.EventWaitHandle> que tiver sido assinalada depende do seu modo de redefinição.</span><span class="sxs-lookup"><span data-stu-id="b9121-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="b9121-107">Uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador é redefinido automaticamente quando sinalizado, após o lançamento de um único thread em espera.</span><span class="sxs-lookup"><span data-stu-id="b9121-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="b9121-108">Uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador permanece sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="b9121-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="b9121-109">Eventos de redefinição automática fornecem acesso exclusivo a um recurso.</span><span class="sxs-lookup"><span data-stu-id="b9121-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="b9121-110">Se um evento de redefinição automática for sinalizado quando não houver threads em espera, ele permanecerá sinalizado até que um thread tente esperar por ele.</span><span class="sxs-lookup"><span data-stu-id="b9121-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="b9121-111">O evento libera o thread e redefine imediatamente, bloqueando os threads subsequentes.</span><span class="sxs-lookup"><span data-stu-id="b9121-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="b9121-112">Eventos são como portões de redefinição manual.</span><span class="sxs-lookup"><span data-stu-id="b9121-112">Manual reset events are like gates.</span></span> <span data-ttu-id="b9121-113">Quando o evento não é sinalizado, bloqueará threads que aguardam por ele.</span><span class="sxs-lookup"><span data-stu-id="b9121-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="b9121-114">Quando o evento é sinalizado, todos os threads em espera são liberados e o evento permanece sinalizado (ou seja, esperas subsequentes não bloqueiam) até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="b9121-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="b9121-115">Eventos de redefinição manual são úteis quando um thread deve concluir uma atividade antes de prosseguir com outros threads.</span><span class="sxs-lookup"><span data-stu-id="b9121-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="b9121-116"><xref:System.Threading.EventWaitHandle> objetos podem ser usados com o `static`(`Shared` no Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="b9121-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="b9121-117">Para obter mais informações sobre mecanismos de sincronização de thread, consulte [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="b9121-117">For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-118">O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="b9121-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="b9121-119">O exemplo inicia cinco threads e lhes permite bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER.</span><span class="sxs-lookup"><span data-stu-id="b9121-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="b9121-120">O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="b9121-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="b9121-121">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b9121-121">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b9121-122">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-122">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="b9121-123">
            <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-123">
              <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="b9121-124">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-124">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-125">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-125">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-126">Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-126">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="b9121-127">Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-127">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="b9121-128">Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.</span><span class="sxs-lookup"><span data-stu-id="b9121-128">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-129">O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="b9121-129">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="b9121-130">O exemplo inicia cinco threads e lhes permite bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER.</span><span class="sxs-lookup"><span data-stu-id="b9121-130">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="b9121-131">O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="b9121-131">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="b9121-132">
            <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-132">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="b9121-133">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-133">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="b9121-134">The name of a system-wide synchronization event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-134">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-135">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-135">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-136">Se `name` está `null` ou uma cadeia de caracteres vazia, um local <xref:System.Threading.EventWaitHandle> é criado.</span><span class="sxs-lookup"><span data-stu-id="b9121-136">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="b9121-137">Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro será ignorado.</span><span class="sxs-lookup"><span data-stu-id="b9121-137">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b9121-138">Ao usar esse construtor para eventos de sistema nomeado, especifique `false` para `initialState`.</span><span class="sxs-lookup"><span data-stu-id="b9121-138">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="b9121-139">Este construtor não fornece nenhuma maneira de determinar se um evento de sistema nomeado foi criado, portanto, você não pode fazer suposições sobre o estado do evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-139">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="b9121-140">Para determinar se um evento nomeado foi criado, use o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> construtor ou o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="b9121-140">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="b9121-141">Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-141">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="b9121-142">Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-142">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="b9121-143">Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.</span><span class="sxs-lookup"><span data-stu-id="b9121-143">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-144">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-144">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-145">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-145">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="b9121-146">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-146">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-147">
            <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-147">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-148">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-148">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-149">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-149">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="b9121-150">
            <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-150">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="b9121-151">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-151">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="b9121-152">The name of a system-wide synchronization event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-152">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="b9121-153">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-153">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="b9121-154">This parameter is passed uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-154">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-155">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-155">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-156">Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro será ignorado.</span><span class="sxs-lookup"><span data-stu-id="b9121-156">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="b9121-157">Depois de chamar esse construtor, use o valor na variável especificada para o `ref` parâmetro (`ByRef` parâmetro no Visual Basic)`createdNew` para determinar se o evento de sistema nomeado já existia ou foi criado.</span><span class="sxs-lookup"><span data-stu-id="b9121-157">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="b9121-158">Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-158">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="b9121-159">Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-159">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="b9121-160">Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.</span><span class="sxs-lookup"><span data-stu-id="b9121-160">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-161">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-161">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-162">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-162">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="b9121-163">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-163">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-164">
            <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-164">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-165">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-165">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-166">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-166">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="b9121-167">
            <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-167">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="b9121-168">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-168">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="b9121-169">The name of a system-wide synchronization event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-169">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="b9121-170">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-170">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="b9121-171">This parameter is passed uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-171">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="eventSecurity">
          <span data-ttu-id="b9121-172">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-172">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-173">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-173">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-174">Use esse construtor para aplicar a segurança de controle de acesso a um evento de sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle do evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-174">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="b9121-175">Este construtor inicializa um <xref:System.Threading.EventWaitHandle> objeto que representa um evento do sistema.</span><span class="sxs-lookup"><span data-stu-id="b9121-175">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="b9121-176">Você pode criar várias <xref:System.Threading.EventWaitHandle> objetos que representam o mesmo evento de sistema.</span><span class="sxs-lookup"><span data-stu-id="b9121-176">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="b9121-177">Se o evento do sistema não existir, ele é criado com a segurança de controle de acesso especificado.</span><span class="sxs-lookup"><span data-stu-id="b9121-177">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="b9121-178">Se o evento existir, a segurança de controle de acesso especificado será ignorada.</span><span class="sxs-lookup"><span data-stu-id="b9121-178">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9121-179">O chamador tem controle total sobre o recém-criado <xref:System.Threading.EventWaitHandle> objeto mesmo se `eventSecurity` nega ou falha em conceder a alguns direitos de acesso para o usuário atual.</span><span class="sxs-lookup"><span data-stu-id="b9121-179">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="b9121-180">No entanto, se o usuário atual tenta obter outra <xref:System.Threading.EventWaitHandle> representar o mesmo evento nomeado, usando um construtor de objeto ou o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método, o Windows a segurança de controle de acesso é aplicada.</span><span class="sxs-lookup"><span data-stu-id="b9121-180">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="b9121-181">Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro será ignorado.</span><span class="sxs-lookup"><span data-stu-id="b9121-181">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="b9121-182">Depois de chamar esse construtor, use o valor na variável especificada para o `ref` parâmetro (`ByRef` parâmetro no Visual Basic) `createdNew` para determinar se o evento de sistema nomeado já existia ou foi criado.</span><span class="sxs-lookup"><span data-stu-id="b9121-182">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="b9121-183">Se o estado inicial do evento for não sinalizado, bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-183">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="b9121-184">Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador for especificado para `mode`, não bloqueará threads que aguardam no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-184">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="b9121-185">Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread que aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e os threads subsequentes serão bloqueados.</span><span class="sxs-lookup"><span data-stu-id="b9121-185">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-186">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="b9121-186">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="b9121-187">O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-187">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="b9121-188">Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-188">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="b9121-189">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="b9121-189">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="b9121-190">A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-190">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="b9121-191">Depois que as permissões forem alteradas, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-191">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="b9121-192">Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-192">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-193">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-193">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-194">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-194">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="b9121-195">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-195">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-196">
            <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-196">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-197">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-197">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-198">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-198">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b9121-199">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-199">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-200">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-200">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-201">O <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para pesquisar as permissões: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9121-201">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9121-202">O usuário deve ter <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> direitos para chamar esse método e o evento devem ter sido abertos com o <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="b9121-202">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-203">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="b9121-203">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="b9121-204">O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-204">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="b9121-205">Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-205">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="b9121-206">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="b9121-206">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="b9121-207">A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-207">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="b9121-208">Depois que as permissões tiverem sido lidos, usando o <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método, e o evento alterado, é aberto com os direitos necessários para esperar por ele e sinalizá-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-208">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="b9121-209">Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-209">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-210">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-210">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="b9121-211">-or-  The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-211">-or-  The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="b9121-212">Not supported for Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-212">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b9121-213">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-213">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b9121-214">Opens a specified named synchronization event, if it already exists.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-214">Opens a specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b9121-215">The name of the system synchronization event to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-215">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-216">Opens the specified named synchronization event, if it already exists.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-216">Opens the specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-217">An  object that represents the named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-217">An  object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-218">O <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método tenta abrir o evento de sistema nomeado especificado.</span><span class="sxs-lookup"><span data-stu-id="b9121-218">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="b9121-219">Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema.</span><span class="sxs-lookup"><span data-stu-id="b9121-219">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="b9121-220">Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="b9121-220">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="b9121-221">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-221">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="b9121-222">Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="b9121-222">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="b9121-223">Especificando o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread Aguarde o evento de sistema nomeado e especificando as <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="b9121-223">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-224">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="b9121-224">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="b9121-225">O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-225">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="b9121-226">Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-226">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="b9121-227">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="b9121-227">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="b9121-228">A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-228">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="b9121-229">Depois que as permissões forem alteradas, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-229">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="b9121-230">Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-230">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-231">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-231">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b9121-232">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-232">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b9121-233">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-233">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="b9121-234">The named system event does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-234">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-235">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-235">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-236">The named event exists, but the user does not have the security access required to use it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-236">The named event exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-237">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-237">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-238">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-238">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b9121-239">The name of the system synchronization event to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-239">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="b9121-240">A bitwise combination of the enumeration values that represent the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-240">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-241">Opens the specified named synchronization event, if it already exists, with the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-241">Opens the specified named synchronization event, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-242">An object that represents the named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-242">An object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-243">O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads para esperar o evento e o <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="b9121-243">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="b9121-244">O <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método tenta abrir um evento de sistema nomeado existente.</span><span class="sxs-lookup"><span data-stu-id="b9121-244">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="b9121-245">Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema.</span><span class="sxs-lookup"><span data-stu-id="b9121-245">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="b9121-246">Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="b9121-246">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="b9121-247">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-247">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-248">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="b9121-248">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="b9121-249">O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-249">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="b9121-250">Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-250">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="b9121-251">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="b9121-251">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="b9121-252">A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-252">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="b9121-253">Depois que as permissões forem alteradas, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-253">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="b9121-254">Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-254">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-255">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-255">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b9121-256">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-256">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b9121-257">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-257">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="b9121-258">The named system event does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-258">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-259">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-259">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-260">The named event exists, but the user does not have the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-260">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-261">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-261">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-262">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-262">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b9121-263">Sets the state of the event to nonsignaled, causing threads to block.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-263">Sets the state of the event to nonsignaled, causing threads to block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-264">
            <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-264">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b9121-265">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-265">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b9121-266">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-266">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-267">
            <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-267">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-268">Para um <xref:System.Threading.EventWaitHandle> com <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (incluindo <xref:System.Threading.AutoResetEvent>), o <xref:System.Threading.EventWaitHandle.Set%2A> método libera um único thread.</span><span class="sxs-lookup"><span data-stu-id="b9121-268">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="b9121-269">Se não houver nenhum threads em espera, o identificador de espera permanece sinalizado até que um thread tentar aguardar nele, ou até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="b9121-269">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b9121-270">Não há nenhuma garantia de que todas as chamadas para o <xref:System.Threading.EventWaitHandle.Set%2A> método lançará um thread de um <xref:System.Threading.EventWaitHandle> cujo modo redefinição é <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9121-270">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9121-271">Se duas chamadas são muito próximos uns dos outros, para que a segunda chamada ocorre antes que um thread foi lançado, apenas um thread será liberado.</span><span class="sxs-lookup"><span data-stu-id="b9121-271">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="b9121-272">É como se a segunda chamada não aconteceu.</span><span class="sxs-lookup"><span data-stu-id="b9121-272">It is as if the second call did not happen.</span></span> <span data-ttu-id="b9121-273">Além disso, se <xref:System.Threading.EventWaitHandle.Set%2A> é chamado quando não houver nenhum segmento esperando e o <xref:System.Threading.EventWaitHandle> já é sinalizado, a chamada não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="b9121-273">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="b9121-274">Para um <xref:System.Threading.EventWaitHandle> com <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (incluindo <xref:System.Threading.ManualResetEvent>), chamar o <xref:System.Threading.EventWaitHandle.Set%2A> método deixa o identificador de espera em um estado sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="b9121-274">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-275">O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="b9121-275">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="b9121-276">O exemplo inicia cinco threads e lhes permite bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER.</span><span class="sxs-lookup"><span data-stu-id="b9121-276">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="b9121-277">O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="b9121-277">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b9121-278">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-278">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <span data-ttu-id="b9121-279">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-279">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-280">Sets the access control security for a named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-280">Sets the access control security for a named system event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-281">O usuário deve ter <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> direitos para chamar esse método e o evento devem ter sido abertos com o <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="b9121-281">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9121-282">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento de sistema nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="b9121-282">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="b9121-283">O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um evento nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-283">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="b9121-284">Se o evento não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de ler e alterar as permissões no evento.</span><span class="sxs-lookup"><span data-stu-id="b9121-284">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="b9121-285">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="b9121-285">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="b9121-286">A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método para aguardar o evento com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-286">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="b9121-287">Depois que as permissões forem alteradas, usando o <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> método, o evento é aberto com os direitos necessários para esperar por ele e sinalizá-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-287">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="b9121-288">Se você executar o exemplo compilado de uma terceira janela de comando, o exemplo é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="b9121-288">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b9121-289">
            <paramref name="eventSecurity" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-289">
              <paramref name="eventSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-290">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-290">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="b9121-291">-or-  The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-291">-or-  The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="b9121-292">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-292">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b9121-293">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-293">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b9121-294">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-294">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b9121-295">The name of the system synchronization event to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-295">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="b9121-296">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-296">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="b9121-297">This parameter is treated as uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-297">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-298">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-298">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-299">
            <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-299">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-300">Se o evento de sincronização nomeado não existir, esse método não cria-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-300">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="b9121-301">Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="b9121-301">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="b9121-302">Se você não tiver certeza se um evento de sincronização nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método que lança uma exceção se o evento de sincronização não existe.</span><span class="sxs-lookup"><span data-stu-id="b9121-302">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="b9121-303">Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="b9121-303">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="b9121-304">Especificando o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread Aguarde o evento de sistema nomeado e especificando as <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="b9121-304">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="b9121-305">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-305">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-306">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-306">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b9121-307">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-307">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b9121-308">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-308">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-309">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-309">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-310">The named event exists, but the user does not have the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-310">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-311">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-311">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-312">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-312">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="b9121-313">The name of the system synchronization event to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-313">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="b9121-314">A bitwise combination of the enumeration values that represent the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-314">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="b9121-315">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-315">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="b9121-316">This parameter is treated as uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-316">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b9121-317">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-317">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b9121-318">
            <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-318">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9121-319">Se o evento de sincronização nomeado não existir, esse método não cria-lo.</span><span class="sxs-lookup"><span data-stu-id="b9121-319">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="b9121-320">Para criar o evento do sistema quando ele ainda não existir, use um dos <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="b9121-320">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="b9121-321">Se você não tiver certeza se um evento de sincronização nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método que lança uma exceção se o evento de sincronização não existe.</span><span class="sxs-lookup"><span data-stu-id="b9121-321">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="b9121-322">O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads para esperar o evento e o <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="b9121-322">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="b9121-323">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="b9121-323">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="b9121-324">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-324">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="b9121-325">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-325">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="b9121-326">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-326">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="b9121-327">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-327">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="b9121-328">The named event exists, but the user does not have the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-328">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="b9121-329">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-329">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="b9121-330">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b9121-330">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>