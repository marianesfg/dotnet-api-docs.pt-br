<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="046aa46d0a3da304f9348792a16e1353c5fa4596" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56403025" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="cc366-101">Encapsula objetos específicos do sistema operacional que aguardam acesso exclusivo aos recursos compartilhados.</span><span class="sxs-lookup"><span data-stu-id="cc366-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-102">O <xref:System.Threading.WaitHandle> classe encapsula um identificador de sincronização do sistema operacional nativo e é usado para representar todos os objetos de sincronização no tempo de execução que permitem que várias operações de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="cc366-103">Para obter uma comparação de identificadores de espera com outros objetos de sincronização, consulte [visão geral dos primitivos de sincronização](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="cc366-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="cc366-104">O <xref:System.Threading.WaitHandle> própria classe é abstrata.</span><span class="sxs-lookup"><span data-stu-id="cc366-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="cc366-105">As classes derivadas <xref:System.Threading.WaitHandle> definem um mecanismo de sinalização para indicar demorando ou liberar o acesso a um recurso compartilhado, mas usam o herdadas <xref:System.Threading.WaitHandle> métodos para bloquear enquanto espera para acessar os recursos compartilhados.</span><span class="sxs-lookup"><span data-stu-id="cc366-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="cc366-106">As classes derivadas de <xref:System.Threading.WaitHandle> incluem:</span><span class="sxs-lookup"><span data-stu-id="cc366-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="cc366-107">O <xref:System.Threading.Mutex> classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="cc366-108">Ver [Mutexes](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="cc366-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="cc366-109">O <xref:System.Threading.EventWaitHandle> classe e suas classes derivadas, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="cc366-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="cc366-110">O <xref:System.Threading.Semaphore> classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="cc366-111">Ver [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="cc366-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="cc366-112">Threads podem bloquear em um identificador de espera individuais chamando o método de instância <xref:System.Threading.WaitHandle.WaitOne%2A>, que é herdado por classes derivadas de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cc366-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="cc366-113">As classes derivadas de <xref:System.Threading.WaitHandle> diferem na afinidade do thread.</span><span class="sxs-lookup"><span data-stu-id="cc366-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="cc366-114">Identificadores de espera de evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e semaphores não têm afinidade de thread; qualquer thread pode sinalizar um identificador de espera de evento ou semáforo.</span><span class="sxs-lookup"><span data-stu-id="cc366-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="cc366-115">Mutexes, por outro lado, têm afinidade de thread; o thread que possui um mutex deverá liberá-lo e uma exceção é lançada se um thread chama o <xref:System.Threading.Mutex.ReleaseMutex%2A> método em um mutex que não é proprietário.</span><span class="sxs-lookup"><span data-stu-id="cc366-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="cc366-116">Porque o <xref:System.Threading.WaitHandle> deriva de classe <xref:System.MarshalByRefObject>, essas classes podem ser usadas para sincronizar as atividades de threads entre limites de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="cc366-117">Além de suas classes derivadas, o <xref:System.Threading.WaitHandle> classe tiver um número de métodos estáticos que bloqueia um thread até que um ou mais objetos de sincronização recebam um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="cc366-118">Elas incluem:</span><span class="sxs-lookup"><span data-stu-id="cc366-118">These include:</span></span>  
  
-   <span data-ttu-id="cc366-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que um thread sinalizar um identificador de espera e esperar imediatamente em outro.</span><span class="sxs-lookup"><span data-stu-id="cc366-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="cc366-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que um thread Aguarde até que todos os identificadores de espera em uma matriz recebam um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="cc366-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que um thread espere até que qualquer um de um conjunto especificado de identificadores de espera foi sinalizado.</span><span class="sxs-lookup"><span data-stu-id="cc366-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="cc366-122">As sobrecargas dos métodos a seguir fornecem os intervalos de tempo limite para abandonar a espera e a oportunidade para sair de um contexto de sincronização antes de entrar em espera, permitindo que outros threads usar o contexto de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cc366-123">Esse tipo implementa o <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="cc366-124">Quando você terminar de usar o tipo ou um tipo derivado dele, você deve descartá-lo diretamente ou indiretamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="cc366-125">Para descartar o tipo diretamente, chame seu <xref:System.Threading.WaitHandle.Close%2A> método em um `try` / `catch` bloco.</span><span class="sxs-lookup"><span data-stu-id="cc366-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="cc366-126">Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="cc366-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="cc366-127">Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="cc366-128"><xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="cc366-129">Consulte [implementando um Dispose método](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="cc366-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="cc366-130">Quando você deriva <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador do sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="cc366-131">Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos não gerenciados adicionais.</span><span class="sxs-lookup"><span data-stu-id="cc366-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-132">O seguinte exemplo de código mostra como dois threads podem fazem tarefas em segundo plano enquanto principal thread aguarda as conclusão das tarefas usando estático <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> métodos do <xref:System.Threading.WaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="cc366-133">Este tipo é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="cc366-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="cc366-134">Threading</span><span class="sxs-lookup"><span data-stu-id="cc366-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="cc366-135">Threading de objetos e recursos</span><span class="sxs-lookup"><span data-stu-id="cc366-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="cc366-136">Mutexes</span><span class="sxs-lookup"><span data-stu-id="cc366-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="cc366-137">EventWaitHandle, AutoResetEvent e ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="cc366-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="cc366-138">Semáforos</span><span class="sxs-lookup"><span data-stu-id="cc366-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cc366-139">Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cc366-140">Libera todos os recursos mantidos pelo <see cref="T:System.Threading.WaitHandle" /> atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-141">Esse método é a implementação pública do <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para o <xref:System.Threading.WaitHandle> classe e suas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="cc366-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="cc366-142">Ele fornece uma implementação padrão que chama o `Dispose(Boolean)` sobrecarga com um `true` argumento e, em seguida, chama o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cc366-143">Chame esse método para liberar todos os recursos mantidos por uma instância do `WaitHandle` ou uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="cc366-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="cc366-144">Depois que esse método é chamado, as referências à instância atual causam um comportamento indefinido.</span><span class="sxs-lookup"><span data-stu-id="cc366-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-145">Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cc366-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="cc366-146">Caso contrário, os recursos que ele está usando não serão liberados.</span><span class="sxs-lookup"><span data-stu-id="cc366-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="cc366-147">Você deve substituir o <see langword="Dispose(Boolean)" /> classes derivadas de método para liberar recursos alocados.</span><span class="sxs-lookup"><span data-stu-id="cc366-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="cc366-148">Implementando um método Dispose</span><span class="sxs-lookup"><span data-stu-id="cc366-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cc366-149">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" /></span><span class="sxs-lookup"><span data-stu-id="cc366-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cc366-150">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-151">Esse método é equivalente a <xref:System.Threading.WaitHandle.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-152">Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cc366-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="cc366-153">Caso contrário, os recursos que ele está usando não serão liberados.</span><span class="sxs-lookup"><span data-stu-id="cc366-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="cc366-154">Limpando recursos não gerenciados</span><span class="sxs-lookup"><span data-stu-id="cc366-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="cc366-155"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="cc366-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="cc366-156">Quando substituído em uma classe derivada, libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.WaitHandle" /> e, opcionalmente, libera os recursos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="cc366-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-157">Esse método é chamado pelo <xref:System.Threading.WaitHandle.Close%2A> e o <xref:System.Threading.WaitHandle.Dispose> métodos com o `explicitDisposing` parâmetro definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="cc366-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="cc366-158">Quando o `explicitDisposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Threading.WaitHandle> referências de objeto.</span><span class="sxs-lookup"><span data-stu-id="cc366-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="cc366-159">Você deve substituir o <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> classes derivadas de método para liberar recursos alocados.</span><span class="sxs-lookup"><span data-stu-id="cc366-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="cc366-160">O <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> método pode ser chamado várias vezes por outros objetos.</span><span class="sxs-lookup"><span data-stu-id="cc366-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="cc366-161">Ao substituir esse método, tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see langword="Dispose" /> ou <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="cc366-162">Implementando um método Dispose</span><span class="sxs-lookup"><span data-stu-id="cc366-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cc366-163">Libera os recursos mantidos pela instância atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="cc366-164">Este membro foi removido do .NET Framework versão 2.0 e versões posteriores.</span><span class="sxs-lookup"><span data-stu-id="cc366-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="cc366-165">Este tópico se aplica somente às versões listadas em "Informações de versão" posteriormente neste tópico.</span><span class="sxs-lookup"><span data-stu-id="cc366-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="cc366-166">O código do aplicativo não chama esse método; ele é invocado automaticamente durante a coleta de lixo, a menos que a finalização pelo coletor de lixo tenha sido desabilitada.</span><span class="sxs-lookup"><span data-stu-id="cc366-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="cc366-167">Para obter mais informações, consulte <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> e <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="cc366-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="cc366-168">Este método substitui <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="cc366-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cc366-169">Obtém ou define o identificador de sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="cc366-170">Um <see langword="IntPtr" /> que representa o identificador do sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="cc366-171">O padrão é o valor do campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-172">Atribuir um novo valor para o <xref:System.Threading.WaitHandle.Handle%2A> propriedade não fecha o identificador anterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="cc366-173">Isso pode resultar em um identificador vazado.</span><span class="sxs-lookup"><span data-stu-id="cc366-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="cc366-174">Não use essa propriedade no .NET Framework versão 2.0 ou posterior; Use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade em vez disso.</span><span class="sxs-lookup"><span data-stu-id="cc366-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="cc366-175">Definir essa propriedade como um identificador válido também define o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, mas defini-lo como <xref:System.Threading.WaitHandle.InvalidHandle> pode resultar em um identificador vazado.</span><span class="sxs-lookup"><span data-stu-id="cc366-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cc366-176">Requer confiança total para o chamador imediato definir o valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="cc366-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="cc366-177">Este membro não pode ser definido por código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="cc366-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="cc366-178">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para definir o valor da propriedade.</span><span class="sxs-lookup"><span data-stu-id="cc366-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cc366-179">Representa um identificador de sistema operacional nativo inválido.</span><span class="sxs-lookup"><span data-stu-id="cc366-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="cc366-180">Este campo é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="cc366-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-181">Usada internamente para inicializar o <xref:System.Threading.WaitHandle.Handle%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="cc366-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="cc366-182">Você pode usar esse valor para determinar se o <see cref="P:System.Threading.WaitHandle.Handle" /> propriedade contém um identificador válido do sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cc366-183">Obtém ou define o identificador de sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="cc366-184">Um <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa o identificador de sistema operacional nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-185">Quando você atribui um novo valor para o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, o identificador anterior será fechado quando anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objeto seja coletado.</span><span class="sxs-lookup"><span data-stu-id="cc366-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="cc366-186">Não feche manualmente o identificador, porque isso resulta em uma <xref:System.ObjectDisposedException> quando o <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta fechar o identificador.</span><span class="sxs-lookup"><span data-stu-id="cc366-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="cc366-187"><xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="cc366-188">Consulte [implementando um Dispose método](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="cc366-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="cc366-189">Quando você deriva <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="cc366-190">Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos não gerenciados adicionais.</span><span class="sxs-lookup"><span data-stu-id="cc366-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cc366-191">Requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="cc366-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cc366-192">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="cc366-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="cc366-193">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para chamar esse membro.</span><span class="sxs-lookup"><span data-stu-id="cc366-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cc366-194">Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</span><span class="sxs-lookup"><span data-stu-id="cc366-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="cc366-195">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</span><span class="sxs-lookup"><span data-stu-id="cc366-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="cc366-196">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</span><span class="sxs-lookup"><span data-stu-id="cc366-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="cc366-197">Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</span><span class="sxs-lookup"><span data-stu-id="cc366-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="cc366-198"><see langword="true" /> se o sinal e a espera forem concluídos com êxito. Se a espera não for concluída, o método não será retornado.</span><span class="sxs-lookup"><span data-stu-id="cc366-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-199">Esta operação não é garantida para ser atômicas.</span><span class="sxs-lookup"><span data-stu-id="cc366-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="cc366-200">Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.</span><span class="sxs-lookup"><span data-stu-id="cc366-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-201">O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="cc366-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="cc366-202">O exemplo inicia threads de cinco, permite que eles bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e versões de um thread cada vez o usuário pressiona a tecla ENTER.</span><span class="sxs-lookup"><span data-stu-id="cc366-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="cc366-203">O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="cc366-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-204"><paramref name="toSignal" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-205">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-205">-or-</span></span> 
 <span data-ttu-id="cc366-206"><paramref name="toWaitOn" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-207">O método foi chamado em um thread que tinha <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="cc366-208">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-209"><paramref name="toSignal" /> é um semáforo e já tem uma contagem total.</span><span class="sxs-lookup"><span data-stu-id="cc366-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-210">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-211">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="cc366-212">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</span><span class="sxs-lookup"><span data-stu-id="cc366-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="cc366-213">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</span><span class="sxs-lookup"><span data-stu-id="cc366-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-214">Um inteiro que representa o intervalo de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="cc366-215">Se o valor for <see cref="F:System.Threading.Timeout.Infinite" />, ou seja, -1, a espera será infinita.</span><span class="sxs-lookup"><span data-stu-id="cc366-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-216"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-217">Sinaliza um <see cref="T:System.Threading.WaitHandle" /> e espera outro, especificando um intervalo de tempo limite como um inteiro com sinal de 32 bits e especificando se é necessário sair do domínio de sincronização do contexto antes de entrar em espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-218"><see langword="true" /> se o sinal e a espera foram concluídos com êxito ou <see langword="false" /> se o sinal foi concluído, mas a espera atingiu o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-219">Esta operação não é garantida para ser atômicas.</span><span class="sxs-lookup"><span data-stu-id="cc366-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="cc366-220">Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.</span><span class="sxs-lookup"><span data-stu-id="cc366-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="cc366-221">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-222">Ele testa o estado do `toWaitOn` e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-223">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-224">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-225">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-226">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-227">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="cc366-228">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-229">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-230">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-231">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-232">Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-233"><paramref name="toSignal" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-234">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-234">-or-</span></span> 
 <span data-ttu-id="cc366-235"><paramref name="toWaitOn" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-236">O método é chamado em um thread que tem <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="cc366-237">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-238">O <see cref="T:System.Threading.WaitHandle" /> não pode ser sinalizado porque isso excederia sua contagem máxima.</span><span class="sxs-lookup"><span data-stu-id="cc366-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-239"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-240">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-241">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="cc366-242">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</span><span class="sxs-lookup"><span data-stu-id="cc366-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="cc366-243">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</span><span class="sxs-lookup"><span data-stu-id="cc366-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="cc366-244">Um <see cref="T:System.TimeSpan" /> que representa o intervalo de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="cc366-245">Se o valor for -1, a espera será infinita.</span><span class="sxs-lookup"><span data-stu-id="cc366-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-246"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-247">Sinaliza um <see cref="T:System.Threading.WaitHandle" /> e espera outro, especificando um intervalo de tempo limite como um <see cref="T:System.TimeSpan" /> e especificando se é necessário sair do domínio de sincronização do contexto antes de entrar em espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-248"><see langword="true" /> se o sinal e a espera foram concluídos com êxito ou <see langword="false" /> se o sinal foi concluído, mas a espera atingiu o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-249">Esta operação não é garantida para ser atômicas.</span><span class="sxs-lookup"><span data-stu-id="cc366-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="cc366-250">Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.</span><span class="sxs-lookup"><span data-stu-id="cc366-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="cc366-251">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="cc366-252">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-253">Ele testa o estado do `toWaitOn` e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-254">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-255">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-256">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-257">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-258">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="cc366-259">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-260">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-261">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-262">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-263">Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-264"><paramref name="toSignal" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-265">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-265">-or-</span></span> 
 <span data-ttu-id="cc366-266"><paramref name="toWaitOn" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-267">O método foi chamado em um thread que tinha <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="cc366-268">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-269"><paramref name="toSignal" /> é um semáforo e já tem uma contagem total.</span><span class="sxs-lookup"><span data-stu-id="cc366-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-270"><paramref name="timeout" /> é avaliado como um número negativo de milissegundos diferente de -1.</span><span class="sxs-lookup"><span data-stu-id="cc366-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="cc366-271">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-271">-or-</span></span> 
 <span data-ttu-id="cc366-272"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-273">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-274">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cc366-275">Libera todos os recursos usados pelo <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="cc366-276">Chamando `Dispose` permite que os recursos usados pelo <xref:System.Threading.WaitHandle> para ser realocados para outras finalidades.</span><span class="sxs-lookup"><span data-stu-id="cc366-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="cc366-277">Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="cc366-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cc366-278">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-279">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="cc366-280">Essa matriz não pode conter várias referências ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="cc366-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="cc366-281">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="cc366-282"><see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, o método nunca retornará.</span><span class="sxs-lookup"><span data-stu-id="cc366-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-283"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-284">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="cc366-285">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-286">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-287">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-288">O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando todos os identificadores são sinalizados.</span><span class="sxs-lookup"><span data-stu-id="cc366-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="cc366-289">Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="cc366-290">Se a matriz contém duplicatas, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="cc366-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-291">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="cc366-292">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-293">O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="cc366-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="cc366-294">Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="cc366-295">O thread principal aguarda todos os itens sinalizar e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="cc366-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-296">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="cc366-297">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-297">-or-</span></span> 
<span data-ttu-id="cc366-298">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> são <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-299">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-299">-or-</span></span> 
 <span data-ttu-id="cc366-300"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="cc366-301">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="cc366-302">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="cc366-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-303">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="cc366-304">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-304">-or-</span></span> 
<span data-ttu-id="cc366-305">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="cc366-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cc366-306"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="cc366-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-307">A espera terminou porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-308">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-309">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-310">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="cc366-311">Esta matriz não pode conter várias referências ao mesmo objeto (duplicações).</span><span class="sxs-lookup"><span data-stu-id="cc366-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-312">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cc366-313">Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="cc366-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="cc366-314"><see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-315">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-316">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-317">O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido.</span><span class="sxs-lookup"><span data-stu-id="cc366-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="cc366-318">Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="cc366-319">Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="cc366-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-320">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="cc366-321">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-322">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-323">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-323">-or-</span></span> 
<span data-ttu-id="cc366-324">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-325">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-325">-or-</span></span> 
 <span data-ttu-id="cc366-326"><paramref name="waitHandles" /> é uma matriz sem elementos.</span><span class="sxs-lookup"><span data-stu-id="cc366-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="cc366-327">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="cc366-328">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="cc366-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-329">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="cc366-330">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-330">-or-</span></span> 
<span data-ttu-id="cc366-331">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="cc366-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-332"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-333">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-334">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-335">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-336">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="cc366-337">Essa matriz não pode conter várias referências ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="cc366-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="cc366-338">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cc366-339">Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="cc366-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="cc366-340"><see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-341">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-342">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-343">O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou que ocorra um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="cc366-344">Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="cc366-345">Se a matriz contém duplicatas, a chamada falhará.</span><span class="sxs-lookup"><span data-stu-id="cc366-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-346">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="cc366-347">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="cc366-348">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-349">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-350">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-350">-or-</span></span> 
<span data-ttu-id="cc366-351">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-352">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-352">-or-</span></span> 
 <span data-ttu-id="cc366-353"><paramref name="waitHandles" /> é uma matriz sem elementos.</span><span class="sxs-lookup"><span data-stu-id="cc366-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="cc366-354">Em vez disso, no <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicativos da Windows Store</see> ou na <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="cc366-355">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="cc366-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-356">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="cc366-357">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-357">-or-</span></span> 
<span data-ttu-id="cc366-358">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="cc366-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-359"><paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="cc366-360">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-360">-or-</span></span> 
 <span data-ttu-id="cc366-361"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-362">A espera terminou porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-363">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-364">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-365">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="cc366-366">Esta matriz não pode conter várias referências ao mesmo objeto (duplicações).</span><span class="sxs-lookup"><span data-stu-id="cc366-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-367">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-368"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-369">Espera todos os elementos da matriz especificada receberem um sinal, usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-370"><see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-371">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-372">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-373"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-374">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="cc366-375">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-376">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-377">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-378">O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido.</span><span class="sxs-lookup"><span data-stu-id="cc366-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="cc366-379">Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="cc366-380">Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="cc366-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-381">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-382">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-383">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-384">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-385">Mesmo se atualmente você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-386">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="cc366-387">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-388">Isso pode ser útil quando a classe de contexto de associação tem o <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="cc366-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="cc366-389">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-390">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-391">Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-392">O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="cc366-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="cc366-393">Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="cc366-394">O thread principal aguarda todos os itens sinalizar e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="cc366-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-395">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-396">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-396">-or-</span></span> 
<span data-ttu-id="cc366-397">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-398">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-398">-or-</span></span> 
 <span data-ttu-id="cc366-399"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="cc366-400">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="cc366-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-401">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="cc366-402">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-402">-or-</span></span> 
<span data-ttu-id="cc366-403">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="cc366-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cc366-404"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="cc366-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-405"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-406">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-407">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-408">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-409">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="cc366-410">Essa matriz não pode conter várias referências ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="cc366-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="cc366-411">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-412"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-413">Aguarda até que todos os elementos da matriz especificada recebam um sinal, usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificando se sairá do domínio de sincronização antes da espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-414"><see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-415">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-416">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-417"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-418">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="cc366-419">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-420">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-421">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-422">O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou que ocorra um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="cc366-423">Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="cc366-424">Se a matriz contém duplicatas, a chamada falhará.</span><span class="sxs-lookup"><span data-stu-id="cc366-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-425">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="cc366-426">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-427">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-428">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-429">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-430">Mesmo se atualmente você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-431">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="cc366-432">Ele retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-433">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-434">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-435">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-436">Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-437">O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="cc366-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="cc366-438">Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="cc366-439">O thread principal aguarda todos os itens sinalizar e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="cc366-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-440">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-441">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-441">-or-</span></span> 
<span data-ttu-id="cc366-442">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-443">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-443">-or-</span></span> 
 <span data-ttu-id="cc366-444"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="cc366-445">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="cc366-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-446">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="cc366-447">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-447">-or-</span></span> 
<span data-ttu-id="cc366-448">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span><span class="sxs-lookup"><span data-stu-id="cc366-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cc366-449"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="cc366-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-450"><paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="cc366-451">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-451">-or-</span></span> 
 <span data-ttu-id="cc366-452"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-453">A espera terminou porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-454">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-455">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cc366-456">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-457">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="cc366-458">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="cc366-459">O índice da matriz do objeto que atendeu à espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-460"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-461">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="cc366-462">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-463">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-464">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-465">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="cc366-466">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-467">Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.</span><span class="sxs-lookup"><span data-stu-id="cc366-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="cc366-468">Esse método retorna quando qualquer identificador é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="cc366-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="cc366-469">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="cc366-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="cc366-470">Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="cc366-471">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-472">O exemplo de código a seguir demonstra a chamada a <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-473">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-474">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-474">-or-</span></span> 
<span data-ttu-id="cc366-475">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-476">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cc366-477"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="cc366-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-478">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-479">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cc366-480"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-481">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-482">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-483">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cc366-484">Espera qualquer um dos elementos na matriz especificada receber um sinal usando um inteiro com sinal de 32 bits a fim de especificar o intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="cc366-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="cc366-485">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</span><span class="sxs-lookup"><span data-stu-id="cc366-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-486">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-487">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-488">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="cc366-489">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="cc366-490">Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="cc366-491">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="cc366-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="cc366-492">Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="cc366-493">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-494">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-495">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-495">-or-</span></span> 
<span data-ttu-id="cc366-496">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-497">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-498"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-499">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-500">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cc366-501"><paramref name="waitHandles" /> é uma matriz sem elementos.</span><span class="sxs-lookup"><span data-stu-id="cc366-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-502">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-503">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="cc366-504">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cc366-505">Aguarda até todos os elementos na matriz especificada receberem um sinal usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="cc366-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="cc366-506">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</span><span class="sxs-lookup"><span data-stu-id="cc366-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-507">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-508">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-509">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="cc366-510">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="cc366-511">Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="cc366-512">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="cc366-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="cc366-513">Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="cc366-514">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="cc366-515">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-516">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-517">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-517">-or-</span></span> 
<span data-ttu-id="cc366-518">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-519">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-520"><paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="cc366-521">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-521">-or-</span></span> 
 <span data-ttu-id="cc366-522"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-523">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-524">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cc366-525"><paramref name="waitHandles" /> é uma matriz sem elementos.</span><span class="sxs-lookup"><span data-stu-id="cc366-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-526">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-527">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-528">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-529"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-530">Espera todos os elementos na matriz especificada receberem um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-531">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</span><span class="sxs-lookup"><span data-stu-id="cc366-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-532">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-533">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-534"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-535">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="cc366-536">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-537">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-538">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-539">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="cc366-540">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-541">Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.</span><span class="sxs-lookup"><span data-stu-id="cc366-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="cc366-542">Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="cc366-543">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="cc366-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="cc366-544">Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-545">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-546">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-547">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-548">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-549">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="cc366-550">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-551">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-552">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-553">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-554">Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-555">O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="cc366-556">Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="cc366-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-557">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-558">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-558">-or-</span></span> 
<span data-ttu-id="cc366-559">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-560">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cc366-561"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="cc366-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-562"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-563">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-564">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cc366-565"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-566">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="cc366-567">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span><span class="sxs-lookup"><span data-stu-id="cc366-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="cc366-568">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-569"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-570">Espera todos os elementos na matriz especificada receberem um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-571">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</span><span class="sxs-lookup"><span data-stu-id="cc366-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-572">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-573">Ele testa o estado dos identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-574"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-575">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="cc366-576">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-577">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-578">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-579">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="cc366-580">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cc366-581">Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.</span><span class="sxs-lookup"><span data-stu-id="cc366-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="cc366-582">Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="cc366-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="cc366-583">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="cc366-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="cc366-584">Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="cc366-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="cc366-585">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-586">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-587">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-588">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-589">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-590">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="cc366-591">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-592">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-593">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-594">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-595">Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-596">O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="cc366-597">Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="cc366-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cc366-598">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="cc366-599">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-599">-or-</span></span> 
<span data-ttu-id="cc366-600">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cc366-601">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span><span class="sxs-lookup"><span data-stu-id="cc366-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cc366-602"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span><span class="sxs-lookup"><span data-stu-id="cc366-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-603"><paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="cc366-604">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-604">-or-</span></span> 
 <span data-ttu-id="cc366-605"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-606">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-607">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cc366-608"><paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="cc366-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-609">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cc366-610">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cc366-611">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="cc366-612"><see langword="true" /> se a instância atual receber um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="cc366-613">Se a instância atual nunca for sinalizada, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nunca será retornado.</span><span class="sxs-lookup"><span data-stu-id="cc366-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-614"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-615">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="cc366-616">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-617">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-618">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-619">O chamador de blocos esse método indefinidamente até que a instância atual receba um sinal.</span><span class="sxs-lookup"><span data-stu-id="cc366-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="cc366-620">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="cc366-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="cc366-621">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="cc366-622">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o primeiro parâmetro e `false` para o segundo parâmetro.</span><span class="sxs-lookup"><span data-stu-id="cc366-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="cc366-623">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="cc366-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-624">O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.</span><span class="sxs-lookup"><span data-stu-id="cc366-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cc366-625">A instância atual já foi descartada.</span><span class="sxs-lookup"><span data-stu-id="cc366-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-626">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-627">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-628">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-629">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cc366-630">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="cc366-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="cc366-631"><see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-632">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-633">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-634">O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="cc366-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="cc366-635">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="cc366-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="cc366-636">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="cc366-637">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="cc366-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="cc366-638">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-639">O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.</span><span class="sxs-lookup"><span data-stu-id="cc366-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cc366-640">A instância atual já foi descartada.</span><span class="sxs-lookup"><span data-stu-id="cc366-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-641"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-642">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-643">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-644">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="cc366-645">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cc366-646">Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="cc366-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="cc366-647"><see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-648">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-649">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-650">O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="cc366-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="cc366-651">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="cc366-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="cc366-652">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="cc366-653">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="cc366-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="cc366-654">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="cc366-655">Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="cc366-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cc366-656">A instância atual já foi descartada.</span><span class="sxs-lookup"><span data-stu-id="cc366-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-657"><paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="cc366-658">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-658">-or-</span></span> 
 <span data-ttu-id="cc366-659"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-660">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-661">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-662">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="cc366-663">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-664"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-665">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-666"><see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-667">Se `millisecondsTimeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-668">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-669"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-670">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="cc366-671">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-672">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-673">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-674">O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="cc366-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="cc366-675">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="cc366-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="cc366-676">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="cc366-677">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="cc366-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-678">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-679">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-680">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-681">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-682">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="cc366-683">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-684">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-685">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-686">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-687">Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-688">A exemplo a seguir mostra como o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método se comporta quando ele é chamado dentro de um domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="cc366-689">Primeiro, um thread aguarda com `exitContext` definido como `false` e bloqueia até que o tempo limite de espera expire.</span><span class="sxs-lookup"><span data-stu-id="cc366-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="cc366-690">Um segundo thread é executado após o primeiro thread é encerrado e aguarda com `exitContext` definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="cc366-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="cc366-691">A chamada para sinalizar o identificador de espera para este segundo segmento não está bloqueada e o thread ser concluído antes do tempo limite de espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cc366-692">A instância atual já foi descartada.</span><span class="sxs-lookup"><span data-stu-id="cc366-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-693"><paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-694">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-695">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-696">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="cc366-697">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="cc366-698"><see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cc366-699">Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</span><span class="sxs-lookup"><span data-stu-id="cc366-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="cc366-700"><see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-701">Se `timeout` for zero, o método não bloqueia.</span><span class="sxs-lookup"><span data-stu-id="cc366-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="cc366-702">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="cc366-703"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="cc366-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="cc366-704">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="cc366-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="cc366-705">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="cc366-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="cc366-706">No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="cc366-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="cc366-707">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="cc366-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="cc366-708">O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="cc366-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="cc366-709">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="cc366-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="cc366-710">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="cc366-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="cc366-711">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="cc366-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="cc366-712">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="cc366-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="cc366-713">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="cc366-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="cc366-714">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto de gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="cc366-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="cc366-715">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="cc366-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="cc366-716">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="cc366-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="cc366-717">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cc366-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="cc366-718">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="cc366-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="cc366-719">Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="cc366-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="cc366-720">Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="cc366-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="cc366-721">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="cc366-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="cc366-722">Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="cc366-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-723">O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.</span><span class="sxs-lookup"><span data-stu-id="cc366-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cc366-724">A instância atual já foi descartada.</span><span class="sxs-lookup"><span data-stu-id="cc366-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cc366-725"><paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="cc366-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="cc366-726">- ou -</span><span class="sxs-lookup"><span data-stu-id="cc366-726">-or-</span></span> 
 <span data-ttu-id="cc366-727"><paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cc366-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="cc366-728">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span><span class="sxs-lookup"><span data-stu-id="cc366-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="cc366-729">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="cc366-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cc366-730">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="cc366-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="cc366-731">Indica que uma operação <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> atingiu o tempo limite antes que algum dos identificadores de espera fosse sinalizado.</span><span class="sxs-lookup"><span data-stu-id="cc366-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="cc366-732">Este campo é constante.</span><span class="sxs-lookup"><span data-stu-id="cc366-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cc366-733">Este campo é um dos possíveis valores de retorno de `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="cc366-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cc366-734">O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="cc366-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="cc366-735">Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="cc366-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>