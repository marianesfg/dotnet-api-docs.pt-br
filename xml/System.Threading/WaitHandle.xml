<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="12fe7b4aeb7e4229c3b0b19f8900c53c137c3e29" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39873552" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula objetos específicos do sistema operacional que aguardam acesso exclusivo aos recursos compartilhados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.WaitHandle> classe encapsula os identificadores de sincronização do Win32 e é usado para representar todos os objetos de sincronização no tempo de execução que permitem que várias operações de espera. Para obter uma comparação de identificadores de espera com outros objetos de sincronização, consulte [visão geral dos primitivos de sincronização](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 O <xref:System.Threading.WaitHandle> própria classe é abstrata. As classes derivadas <xref:System.Threading.WaitHandle> definem um mecanismo de sinalização para indicar demorando ou liberar o acesso a um recurso compartilhado, mas usam o herdadas <xref:System.Threading.WaitHandle> métodos para bloquear enquanto espera para acessar os recursos compartilhados. As classes derivadas de <xref:System.Threading.WaitHandle> incluem:  
  
-   O <xref:System.Threading.Mutex> classe. Ver [Mutexes](~/docs/standard/threading/mutexes.md).  
  
-   O <xref:System.Threading.EventWaitHandle> classe e suas classes derivadas, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>. Confira [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   O <xref:System.Threading.Semaphore> classe. Ver [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Threads podem bloquear em um identificador de espera individuais chamando o método de instância <xref:System.Threading.WaitHandle.WaitOne%2A>, que é herdado por classes derivadas de <xref:System.Threading.WaitHandle>.  
  
 As classes derivadas de <xref:System.Threading.WaitHandle> diferem na afinidade do thread. Identificadores de espera de evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e semaphores não têm afinidade de thread; qualquer thread pode sinalizar um identificador de espera de evento ou semáforo. Mutexes, por outro lado, têm afinidade de thread; o thread que possui um mutex deverá liberá-lo e uma exceção é lançada se um thread chama o <xref:System.Threading.Mutex.ReleaseMutex%2A> método em um mutex que não é proprietário.  
  
 Porque o <xref:System.Threading.WaitHandle> deriva de classe <xref:System.MarshalByRefObject>, essas classes podem ser usadas para sincronizar as atividades de threads entre limites de domínio de aplicativo.  
  
 Além de suas classes derivadas, o <xref:System.Threading.WaitHandle> classe tiver um número de métodos estáticos que bloqueia um thread até que um ou mais objetos de sincronização recebam um sinal... Elas incluem:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que um thread sinalizar um identificador de espera e esperar imediatamente em outro.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que um thread Aguarde até que todos os identificadores de espera em uma matriz recebam um sinal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que um thread espere até que qualquer um de um conjunto especificado de identificadores de espera foi sinalizado.  
  
 As sobrecargas dos métodos a seguir fornecem os intervalos de tempo limite para abandonar a espera e a oportunidade para sair de um contexto de sincronização antes de entrar em espera, permitindo que outros threads usar o contexto de sincronização.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo ou um tipo derivado dele, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.Threading.WaitHandle.Close%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 <xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão. Ver [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md). Quando você deriva <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo. Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos não gerenciados adicionais.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como dois threads podem fazem tarefas em segundo plano enquanto principal thread aguarda as conclusão das tarefas usando estático <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> métodos do <xref:System.Threading.WaitHandle> classe.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos mantidos pelo <see cref="T:System.Threading.WaitHandle" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a implementação pública do <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para o <xref:System.Threading.WaitHandle> classe e suas classes derivadas. Ele fornece uma implementação padrão que chama o `Dispose(Boolean)` sobrecarga com um `true` argumento e, em seguida, chama o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método. Chame esse método para liberar todos os recursos mantidos por uma instância do `WaitHandle` ou uma classe derivada.  
  
 Depois que esse método é chamado, as referências à instância atual causam um comportamento indefinido.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>. Caso contrário, os recursos que ele está usando não serão liberados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir o <see langword="Dispose(Boolean)" /> classes derivadas de método para liberar recursos alocados.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.Threading.WaitHandle.Close%2A> método.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>. Caso contrário, os recursos que ele está usando não serão liberados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Quando substituído em uma classe derivada, libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.WaitHandle" /> e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Threading.WaitHandle.Close%2A> e o <xref:System.Threading.WaitHandle.Dispose> métodos com o `explicitDisposing` parâmetro definido como `true`.  Quando o `explicitDisposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Threading.WaitHandle> referências de objeto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir o <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> classes derivadas de método para liberar recursos alocados.  O <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> método pode ser chamado várias vezes por outros objetos. Ao substituir esse método, tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see langword="Dispose" /> ou <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador de sistema operacional nativo.</summary>
        <value>Um <see langword="IntPtr" /> que representa o identificador do sistema operacional nativo. O padrão é o valor do campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atribuir um novo valor para o <xref:System.Threading.WaitHandle.Handle%2A> propriedade não fecha o identificador anterior. Isso pode resultar em um identificador vazado.  
  
 Não use essa propriedade no .NET Framework versão 2.0 ou posterior; Use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade em vez disso. Definir essa propriedade como um identificador válido também define o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, mas defini-lo como <xref:System.Threading.WaitHandle.InvalidHandle> pode resultar em um identificador vazado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato definir o valor da propriedade. Este membro não pode ser definido por código transparente ou parcialmente confiável.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para definir o valor da propriedade.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa um identificador de sistema operacional nativo inválido. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usada internamente para inicializar o <xref:System.Threading.WaitHandle.Handle%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você pode usar esse valor para determinar se o <see cref="P:System.Threading.WaitHandle.Handle" /> propriedade contém um identificador válido do sistema operacional nativo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador de sistema operacional nativo.</summary>
        <value>Um <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa o identificador de sistema operacional nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você atribui um novo valor para o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, o identificador anterior será fechado quando anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objeto seja coletado. Não feche manualmente o identificador, porque isso resulta em uma <xref:System.ObjectDisposedException> quando o <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta fechar o identificador.  
  
 <xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão. Ver [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md). Quando você deriva <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo. Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos não gerenciados adicionais.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para chamar esse membro.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</param>
        <param name="toWaitOn">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</param>
        <summary>Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</summary>
        <returns>
          <see langword="true" /> se o sinal e a espera forem concluídos com êxito. Se a espera não for concluída, o método não será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida para ser atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.  
  
 O exemplo inicia threads de cinco, permite que eles bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e versões de um thread cada vez o usuário pressiona a tecla ENTER. O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="toWaitOn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O método foi chamado em um thread que tinha <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> é um semáforo e já tem uma contagem total.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</param>
        <param name="toWaitOn">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</param>
        <param name="millisecondsTimeout">Um inteiro que representa o intervalo de espera. Se o valor for <see cref="F:System.Threading.Timeout.Infinite" />, ou seja, -1, a espera será infinita.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Sinaliza um <see cref="T:System.Threading.WaitHandle" /> e espera outro, especificando um intervalo de tempo limite como um inteiro com sinal de 32 bits e especificando se é necessário sair do domínio de sincronização do contexto antes de entrar em espera.</summary>
        <returns>
          <see langword="true" /> se o sinal e a espera foram concluídos com êxito ou <see langword="false" /> se o sinal foi concluído, mas a espera atingiu o tempo limite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida para ser atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.  
  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado do `toWaitOn` e retorna imediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="toWaitOn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O método é chamado em um thread que tem <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Threading.WaitHandle" /> não pode ser sinalizado porque isso excederia sua contagem máxima.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</param>
        <param name="toWaitOn">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o intervalo de espera. Se o valor for -1, a espera será infinita.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Sinaliza um <see cref="T:System.Threading.WaitHandle" /> e espera outro, especificando um intervalo de tempo limite como um <see cref="T:System.TimeSpan" /> e especificando se é necessário sair do domínio de sincronização do contexto antes de entrar em espera.</summary>
        <returns>
          <see langword="true" /> se o sinal e a espera foram concluídos com êxito ou <see langword="false" /> se o sinal foi concluído, mas a espera atingiu o tempo limite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida para ser atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado do `toWaitOn` e retorna imediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="toWaitOn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O método foi chamado em um thread que tinha <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> é um semáforo e já tem uma contagem total.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é avaliado como um número negativo de milissegundos diferente de -1.  
  
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aguarda até que todos os elementos na matriz especificada recebam um sinal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Essa matriz não pode conter várias referências ao mesmo objeto.</param>
        <summary>Aguarda até que todos os elementos na matriz especificada recebam um sinal.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, o método nunca retornará.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando todos os identificadores são sinalizados. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />. - ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> são <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), verifique a exceção de classe base, <see cref="T:System.ArgumentException" />.  </para>
          </block>  
  
A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
- ou - 
O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera terminou porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Esta matriz não pode conter várias referências ao mesmo objeto (duplicações).</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), verifique a exceção de classe base, <see cref="T:System.ArgumentException" />.  </para>
          </block>  
  
A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
- ou - 
O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Essa matriz não pode conter várias referências ao mesmo objeto.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou que ocorra um tempo limite. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), verifique a exceção de classe base, <see cref="T:System.ArgumentException" />.  </para>
          </block>  
  
A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
- ou - 
O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera terminou porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Esta matriz não pode conter várias referências ao mesmo objeto (duplicações).</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Espera todos os elementos da matriz especificada receberem um sinal, usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem o <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
- ou - 
O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Essa matriz não pode conter várias referências ao mesmo objeto.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Aguarda até que todos os elementos da matriz especificada recebam um sinal, usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificando se sairá do domínio de sincronização antes da espera.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou que ocorra um tempo limite. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método. Ele retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
- ou - 
O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera terminou porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aguarda até que todos os elementos na matriz especificada recebam um sinal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <summary>Aguarda até que todos os elementos na matriz especificada recebam um sinal.</summary>
        <returns>O índice da matriz do objeto que atendeu à espera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.  
  
 Esse método retorna quando qualquer identificador é sinalizado. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a chamada a <xref:System.Threading.WaitHandle.WaitAny%2A> método.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Espera qualquer um dos elementos na matriz especificada receber um sinal usando um inteiro com sinal de 32 bits a fim de especificar o intervalo de tempo.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Aguarda até todos os elementos na matriz especificada receberem um sinal usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Espera todos os elementos na matriz especificada receberem um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Espera todos os elementos na matriz especificada receberem um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
- ou - 
Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</summary>
        <returns>
          <see langword="true" /> se a instância atual receber um sinal. Se a instância atual nunca for sinalizada, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nunca será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos esse método indefinidamente até que a instância atual receba um sinal. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o primeiro parâmetro e `false` para o segundo parâmetro.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo em milissegundos.</summary>
        <returns>
          <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</summary>
        <returns>
          <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</summary>
        <returns>
          <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 A exemplo a seguir mostra como o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método se comporta quando ele é chamado dentro de um domínio de sincronização. Primeiro, um thread aguarda com `exitContext` definido como `false` e bloqueia até que o tempo limite de espera expire. Um segundo thread é executado após o primeiro thread é encerrado e aguarda com `exitContext` definido como `true`. A chamada para sinalizar o identificador de espera para este segundo segmento não está bloqueada e o thread ser concluído antes do tempo limite de espera.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</summary>
        <returns>
          <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito. 
- ou - 
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indica que uma operação <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> atingiu o tempo limite antes que algum dos identificadores de espera fosse sinalizado. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo é um dos possíveis valores de retorno de `WaitAny`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>