<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531500" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="63f17-101">Encapsula objetos específicos do sistema operacional que aguardam acesso exclusivo aos recursos compartilhados.</span>
      <span class="sxs-lookup">
        <span data-stu-id="63f17-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-102">O <xref:System.Threading.WaitHandle> classe encapsula os manipuladores de sincronização do Win32 e é usada para representar todos os objetos de sincronização no tempo de execução que permitem que várias operações de espera.</span><span class="sxs-lookup"><span data-stu-id="63f17-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="63f17-103">Para obter uma comparação de identificadores de espera com outros objetos de sincronização, consulte [visão geral dos primitivos de sincronização](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="63f17-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="63f17-104">O <xref:System.Threading.WaitHandle> própria classe é abstrata.</span><span class="sxs-lookup"><span data-stu-id="63f17-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="63f17-105">Classes derivadas de <xref:System.Threading.WaitHandle> definir um mecanismo de sinalização para indicar demorando ou liberar o acesso a um recurso compartilhado, mas utilizam o herdadas <xref:System.Threading.WaitHandle> métodos seja bloqueado enquanto aguarda para acessar os recursos compartilhados.</span><span class="sxs-lookup"><span data-stu-id="63f17-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="63f17-106">As classes derivadas de <xref:System.Threading.WaitHandle> incluem:</span><span class="sxs-lookup"><span data-stu-id="63f17-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="63f17-107">O <xref:System.Threading.Mutex> classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="63f17-108">Consulte [Mutexes](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="63f17-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="63f17-109">O <xref:System.Threading.EventWaitHandle> classe e suas classes derivadas, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="63f17-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="63f17-110">Confira [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="63f17-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="63f17-111">O <xref:System.Threading.Semaphore> classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="63f17-112">Consulte [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="63f17-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="63f17-113">Threads podem bloquear um identificador de espera individuais chamando o método de instância <xref:System.Threading.WaitHandle.WaitOne%2A>, que é herdado por classes derivadas de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="63f17-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="63f17-114">As classes derivadas de <xref:System.Threading.WaitHandle> diferem na afinidade do thread.</span><span class="sxs-lookup"><span data-stu-id="63f17-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="63f17-115">Identificadores de espera de eventos (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e semáforos não têm afinidade de thread; qualquer thread pode sinalizar um identificador de espera do evento ou um semáforo.</span><span class="sxs-lookup"><span data-stu-id="63f17-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="63f17-116">Mutexes, por outro lado, têm afinidade de thread; o thread que possui um mutex deve liberá-lo e uma exceção será lançada se um thread chama o <xref:System.Threading.Mutex.ReleaseMutex%2A> método em um mutex que não possui.</span><span class="sxs-lookup"><span data-stu-id="63f17-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="63f17-117">Porque o <xref:System.Threading.WaitHandle> classe derivada de <xref:System.MarshalByRefObject>, essas classes podem ser usadas para sincronizar as atividades de threads nos limites do domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="63f17-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="63f17-118">Além de suas classes derivadas, a <xref:System.Threading.WaitHandle> classe tiver um número de métodos estáticos que o bloqueio de um thread até que um ou mais objetos de sincronização recebem um sinal.</span><span class="sxs-lookup"><span data-stu-id="63f17-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="63f17-119">Elas incluem:</span><span class="sxs-lookup"><span data-stu-id="63f17-119">These include:</span></span>  
  
-   <span data-ttu-id="63f17-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que um thread para sinalizar um identificador de espera e aguarde imediatamente em outro.</span><span class="sxs-lookup"><span data-stu-id="63f17-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="63f17-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que um thread de espera até que todos os identificadores de espera em uma matriz recebem um sinal.</span><span class="sxs-lookup"><span data-stu-id="63f17-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="63f17-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que um thread de espera até que qualquer um de um conjunto especificado de identificadores de espera foi sinalizado.</span><span class="sxs-lookup"><span data-stu-id="63f17-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="63f17-123">As sobrecargas dos métodos a seguir fornecem os intervalos de tempo limite para abandonar a espera e a oportunidade de sair de um contexto de sincronização antes de entrar em espera, permitindo que outros threads para usar o contexto de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="63f17-124">Este tipo implementa o <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="63f17-125">Quando você terminar de usar o tipo ou um tipo derivado dele, descarte-direta ou indiretamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="63f17-126">Para descartar o tipo diretamente, chame seu <xref:System.Threading.WaitHandle.Close%2A> método em um `try` / `catch` bloco.</span><span class="sxs-lookup"><span data-stu-id="63f17-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="63f17-127">Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="63f17-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="63f17-128">Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="63f17-129"><xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="63f17-130">Consulte [Dispose padrão](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="63f17-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="63f17-131">Quando você deriva de <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="63f17-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="63f17-132">Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos adicionais de não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="63f17-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-133">O seguinte exemplo de código mostra como dois threads podem fazem tarefas em segundo plano enquanto principal thread aguarda as a conclusão de tarefas usando o estático <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> métodos de <xref:System.Threading.WaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="63f17-134">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="63f17-134">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63f17-135">Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63f17-136">Libera todos os recursos mantidos pelo <see cref="T:System.Threading.WaitHandle" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-137">Esse método é a implementação pública a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para o <xref:System.Threading.WaitHandle> classe e suas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="63f17-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="63f17-138">Ele fornece uma implementação padrão chama o `Dispose(Boolean)` sobrecarga com um `true` argumento e, em seguida, chama o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="63f17-139">Chame este método para liberar todos os recursos mantidos por uma instância de `WaitHandle` ou uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="63f17-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="63f17-140">Quando este método é chamado, as referências à instância atual causam um comportamento indefinido.</span><span class="sxs-lookup"><span data-stu-id="63f17-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-141">Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="63f17-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="63f17-142">Caso contrário, os recursos que está usando não serão liberados.</span><span class="sxs-lookup"><span data-stu-id="63f17-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="63f17-143">Você deve substituir o <see langword="Dispose(Boolean)" /> classes derivadas de método para liberar recursos alocados.</span>
            <span class="sxs-lookup">
              <span data-stu-id="63f17-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-144">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63f17-145">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-146">Esse método é equivalente a <xref:System.Threading.WaitHandle.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-147">Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="63f17-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="63f17-148">Caso contrário, os recursos que está usando não serão liberados.</span><span class="sxs-lookup"><span data-stu-id="63f17-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="63f17-149">
            <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-149">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-150">Quando substituído em uma classe derivada, libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.WaitHandle" /> e, opcionalmente, libera os recursos gerenciados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-151">Este método é chamado pelo <xref:System.Threading.WaitHandle.Close%2A> e <xref:System.Threading.WaitHandle.Dispose> métodos com o `explicitDisposing` parâmetro definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="63f17-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="63f17-152">Quando o `explicitDisposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Threading.WaitHandle> referências de objeto.</span><span class="sxs-lookup"><span data-stu-id="63f17-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="63f17-153">Você deve substituir o <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> classes derivadas de método para liberar recursos alocados.</span>
            <span class="sxs-lookup">
              <span data-stu-id="63f17-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="63f17-154">O <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> método pode ser chamado várias vezes por outros objetos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="63f17-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="63f17-155">Ao substituir esse método, tenha cuidado para não fazer referência a objetos que foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" /> ou <see langword="Close" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="63f17-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-156">Obtém ou define o identificador de sistema operacional nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-156">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="63f17-157">Um <see langword="IntPtr" /> que representa o identificador do sistema operacional nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-157">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="63f17-158">O padrão é o valor do campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-159">Atribuir um novo valor para o <xref:System.Threading.WaitHandle.Handle%2A> propriedade não fechar o identificador anterior.</span><span class="sxs-lookup"><span data-stu-id="63f17-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="63f17-160">Isso pode resultar em um identificador vazou.</span><span class="sxs-lookup"><span data-stu-id="63f17-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="63f17-161">Não use essa propriedade no .NET Framework versão 2.0 ou posterior; Use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade em vez disso.</span><span class="sxs-lookup"><span data-stu-id="63f17-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="63f17-162">Definir essa propriedade como um identificador válido também define o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, mas defini-la como <xref:System.Threading.WaitHandle.InvalidHandle> pode resultar em um identificador vazou.</span><span class="sxs-lookup"><span data-stu-id="63f17-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="63f17-163">Requer confiança total para o chamador imediato definir o valor da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-163">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="63f17-164">Este membro não pode ser definido por código parcialmente confiável ou transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-164">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="63f17-165">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para definir o valor da propriedade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-166">Representa um identificador de sistema operacional nativo inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-166">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="63f17-167">Este campo é somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-167">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-168">Usada internamente para inicializar o <xref:System.Threading.WaitHandle.Handle%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="63f17-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="63f17-169">Você pode usar esse valor para determinar se o <see cref="P:System.Threading.WaitHandle.Handle" /> propriedade contém um identificador válido do sistema operacional nativo.</span>
            <span class="sxs-lookup">
              <span data-stu-id="63f17-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-170">Obtém ou define o identificador de sistema operacional nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-170">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="63f17-171">Um <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa o identificador de sistema operacional nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-172">Quando você atribui um novo valor para o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, o identificador anterior será fechado quando anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objeto é coletado.</span><span class="sxs-lookup"><span data-stu-id="63f17-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="63f17-173">Não feche manualmente a alça, porque isso resulta em uma <xref:System.ObjectDisposedException> quando o <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta fechar o identificador.</span><span class="sxs-lookup"><span data-stu-id="63f17-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="63f17-174"><xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="63f17-175">Consulte [Dispose padrão](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="63f17-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="63f17-176">Quando você deriva de <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="63f17-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="63f17-177">Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos adicionais de não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="63f17-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="63f17-178">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-178">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="63f17-179">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-179">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="63f17-180">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para chamar esse membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-181">Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="63f17-182">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="63f17-183">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-184">Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-185">
            <see langword="true" /> se o sinal e a espera forem concluídos com êxito. Se a espera não for concluída, o método não será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-185">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-186">Esta operação não é garantida atômicas.</span><span class="sxs-lookup"><span data-stu-id="63f17-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="63f17-187">Após os sinais de thread atual `toSignal` , mas antes de ele espera `toWaitOn`, um thread que está sendo executado em outro processador pode sinalizar `toWaitOn` ou esperar.</span><span class="sxs-lookup"><span data-stu-id="63f17-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-188">O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="63f17-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="63f17-189">O exemplo inicia cinco threads, permite bloquear um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e versões de um thread cada vez o usuário pressiona a tecla ENTER.</span><span class="sxs-lookup"><span data-stu-id="63f17-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="63f17-190">O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.</span><span class="sxs-lookup"><span data-stu-id="63f17-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-191">
            <paramref name="toSignal" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-191">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-192">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-192">-or-</span>
          </span>
          <span data-ttu-id="63f17-193">
            <paramref name="toWaitOn" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-193">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-194">O método foi chamado em um thread que tinha <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="63f17-195">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-196">
            <paramref name="toSignal" /> é um semáforo e já tem uma contagem total.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-196">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-197">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-197">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-198">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="63f17-199">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="63f17-200">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-201">Um inteiro que representa o intervalo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-201">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="63f17-202">Se o valor for <see cref="F:System.Threading.Timeout.Infinite" />, ou seja, -1, a espera será infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-203">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-203">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-204">Sinaliza um <see cref="T:System.Threading.WaitHandle" /> e espera outro, especificando um intervalo de tempo limite como um inteiro com sinal de 32 bits e especificando se é necessário sair do domínio de sincronização do contexto antes de entrar em espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-205">
            <see langword="true" /> se o sinal e a espera foram concluídos com êxito ou <see langword="false" /> se o sinal foi concluído, mas a espera atingiu o tempo limite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-205">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-206">Esta operação não é garantida atômicas.</span><span class="sxs-lookup"><span data-stu-id="63f17-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="63f17-207">Após os sinais de thread atual `toSignal` , mas antes de ele espera `toWaitOn`, um thread que está sendo executado em outro processador pode sinalizar `toWaitOn` ou esperar.</span><span class="sxs-lookup"><span data-stu-id="63f17-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="63f17-208">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-209">Ele testa o estado do `toWaitOn` e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-210">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-211">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-212">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-213">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-214">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="63f17-215">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-216">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-217">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-218">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-219">Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-220">
            <paramref name="toSignal" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-220">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-221">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-221">-or-</span>
          </span>
          <span data-ttu-id="63f17-222">
            <paramref name="toWaitOn" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-222">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-223">O método é chamado em um thread que tem <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="63f17-224">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-225">O <see cref="T:System.Threading.WaitHandle" /> não pode ser sinalizado porque isso excederia sua contagem máxima.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-226">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-226">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-227">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-227">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-228">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="63f17-229">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="63f17-230">O <see cref="T:System.Threading.WaitHandle" /> a ser esperado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="63f17-231">Um <see cref="T:System.TimeSpan" /> que representa o intervalo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="63f17-232">Se o valor for -1, a espera será infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-232">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-233">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-233">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-234">Sinaliza um <see cref="T:System.Threading.WaitHandle" /> e espera outro, especificando um intervalo de tempo limite como um <see cref="T:System.TimeSpan" /> e especificando se é necessário sair do domínio de sincronização do contexto antes de entrar em espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-235">
            <see langword="true" /> se o sinal e a espera foram concluídos com êxito ou <see langword="false" /> se o sinal foi concluído, mas a espera atingiu o tempo limite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-235">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-236">Esta operação não é garantida atômicas.</span><span class="sxs-lookup"><span data-stu-id="63f17-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="63f17-237">Após os sinais de thread atual `toSignal` , mas antes de ele espera `toWaitOn`, um thread que está sendo executado em outro processador pode sinalizar `toWaitOn` ou esperar.</span><span class="sxs-lookup"><span data-stu-id="63f17-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="63f17-238">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="63f17-239">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-240">Ele testa o estado do `toWaitOn` e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-241">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-242">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-243">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-244">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-245">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="63f17-246">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-247">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-248">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-249">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-250">Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-251">
            <paramref name="toSignal" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-251">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-252">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-252">-or-</span>
          </span>
          <span data-ttu-id="63f17-253">
            <paramref name="toWaitOn" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-253">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-254">O método foi chamado em um thread que tinha <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="63f17-255">Esse método não é compatível com o Windows 98 nem com o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-256">
            <paramref name="toSignal" /> é um semáforo e já tem uma contagem total.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-256">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-257">
            <paramref name="timeout" /> é avaliado como um número negativo de milissegundos diferente de -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-257">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="63f17-258">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-258">-or-</span>
          </span>
          <span data-ttu-id="63f17-259">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-259">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-260">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-260">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-261">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-262">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-262">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-263">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="63f17-264">Essa matriz não pode conter várias referências ao mesmo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-264">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-265">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-265">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-266">
            <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, o método nunca retornará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-266">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-267"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-268">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="63f17-269">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-270">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-271">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-272">O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando todos os identificadores são sinalizados.</span><span class="sxs-lookup"><span data-stu-id="63f17-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="63f17-273">Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="63f17-274">Se a matriz contém duplicatas, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="63f17-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-275">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="63f17-276">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e a especificação de -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-277">O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="63f17-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="63f17-278">Cada operação de gravação está na fila como um item de trabalho e sinaliza quando ele for concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="63f17-279">O thread principal aguarda até que todos os itens sinalizar e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="63f17-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-280">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-281">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-281">-or-</span>
          </span>
          <span data-ttu-id="63f17-282">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> são <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-283">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-283">-or-</span>
          </span>
          <span data-ttu-id="63f17-284">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-284">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="63f17-285">Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="63f17-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="63f17-286">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-287">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="63f17-288">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-288">-or-</span>
          </span>
          <span data-ttu-id="63f17-289">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="63f17-290">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-290">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-291">A espera terminou porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-291">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-292">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-293">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-294">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="63f17-295">Esta matriz não pode conter várias referências ao mesmo objeto (duplicações).</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-295">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-296">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-297">Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-298">
            <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-298">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-299">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-300">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-301">O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido.</span><span class="sxs-lookup"><span data-stu-id="63f17-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="63f17-302">Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="63f17-303">Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="63f17-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-304">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="63f17-305">Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-306">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-307">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-307">-or-</span>
          </span>
          <span data-ttu-id="63f17-308">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-309">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-309">-or-</span>
          </span>
          <span data-ttu-id="63f17-310">
            <paramref name="waitHandles" /> é uma matriz sem elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-310">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="63f17-311">Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="63f17-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="63f17-312">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-313">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="63f17-314">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-314">-or-</span>
          </span>
          <span data-ttu-id="63f17-315">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-316">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-316">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-317">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-317">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-318">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-319">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-320">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="63f17-321">Essa matriz não pode conter várias referências ao mesmo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-321">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="63f17-322">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-323">Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-324">
            <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-324">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-325">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-326">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-327">O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="63f17-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="63f17-328">Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="63f17-329">Se a matriz contém duplicatas, a chamada falhará.</span><span class="sxs-lookup"><span data-stu-id="63f17-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-330">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="63f17-331">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="63f17-332">Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-333">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-334">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-334">-or-</span>
          </span>
          <span data-ttu-id="63f17-335">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-336">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-336">-or-</span>
          </span>
          <span data-ttu-id="63f17-337">
            <paramref name="waitHandles" /> é uma matriz sem elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-337">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="63f17-338">Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="63f17-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="63f17-339">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-340">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="63f17-341">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-341">-or-</span>
          </span>
          <span data-ttu-id="63f17-342">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-343">
            <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-343">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="63f17-344">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-344">-or-</span>
          </span>
          <span data-ttu-id="63f17-345">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-345">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-346">A espera terminou porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-346">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-347">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-348">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-349">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="63f17-350">Esta matriz não pode conter várias referências ao mesmo objeto (duplicações).</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-350">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-351">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-352">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-352">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-353">Espera todos os elementos da matriz especificada receberem um sinal, usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-354">
            <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-354">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-355">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-356">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-357"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-358">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="63f17-359">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-360">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-361">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-362">O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido.</span><span class="sxs-lookup"><span data-stu-id="63f17-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="63f17-363">Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="63f17-364">Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="63f17-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-365">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-366">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-367">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-368">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-369">Mesmo se você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-370">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="63f17-371">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-372">Isso pode ser útil quando a classe de contexto associado tem o <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="63f17-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="63f17-373">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-374">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-375">Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-376">O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="63f17-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="63f17-377">Cada operação de gravação está na fila como um item de trabalho e sinaliza quando ele for concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="63f17-378">O thread principal aguarda até que todos os itens sinalizar e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="63f17-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-379">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-380">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-380">-or-</span>
          </span>
          <span data-ttu-id="63f17-381">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-382">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-382">-or-</span>
          </span>
          <span data-ttu-id="63f17-383">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-383">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="63f17-384">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-385">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="63f17-386">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-386">-or-</span>
          </span>
          <span data-ttu-id="63f17-387">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="63f17-388">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-388">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-389">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-389">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-390">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-390">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-391">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-392">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-393">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="63f17-394">Essa matriz não pode conter várias referências ao mesmo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-394">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="63f17-395">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-396">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-396">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-397">Aguarda até que todos os elementos da matriz especificada recebam um sinal, usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificando se sairá do domínio de sincronização antes da espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-398">
            <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-398">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-399">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-400">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-401"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-402">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="63f17-403">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-404">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-405">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-406">O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="63f17-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="63f17-407">Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="63f17-408">Se a matriz contém duplicatas, a chamada falhará.</span><span class="sxs-lookup"><span data-stu-id="63f17-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-409">O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="63f17-410">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-411">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-412">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-413">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-414">Mesmo se você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-415">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="63f17-416">Ele retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-417">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-418">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-419">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-420">Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-421">O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="63f17-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="63f17-422">Cada operação de gravação está na fila como um item de trabalho e sinaliza quando ele for concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="63f17-423">O thread principal aguarda até que todos os itens sinalizar e, em seguida, sai.</span><span class="sxs-lookup"><span data-stu-id="63f17-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-424">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-425">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-425">-or-</span>
          </span>
          <span data-ttu-id="63f17-426">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-427">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-427">-or-</span>
          </span>
          <span data-ttu-id="63f17-428">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-428">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="63f17-429">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-430">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="63f17-431">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-431">-or-</span>
          </span>
          <span data-ttu-id="63f17-432">O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="63f17-433">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-433">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-434">
            <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-434">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="63f17-435">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-435">-or-</span>
          </span>
          <span data-ttu-id="63f17-436">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-436">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-437">A espera terminou porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-437">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-438">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-439">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-440">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-440">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-441">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-442">Aguarda até que todos os elementos na matriz especificada recebam um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-442">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-443">O índice da matriz do objeto que atendeu à espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-443">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-444"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-445">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, pois um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="63f17-446">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-447">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-448">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-449">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="63f17-450">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-451">Em versões do .NET Framework anterior à versão 2.0, se um thread encerrado ou anulada sem soltar explicitamente um <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128, em vez de 0.</span><span class="sxs-lookup"><span data-stu-id="63f17-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="63f17-452">Esse método retorna quando qualquer identificador é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="63f17-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="63f17-453">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="63f17-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="63f17-454">Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="63f17-455">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e a especificação de -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-456">O exemplo de código a seguir demonstra a chamar o <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-457">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-458">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-458">-or-</span>
          </span>
          <span data-ttu-id="63f17-459">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-460">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="63f17-461">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-461">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-462">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-462">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-463">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="63f17-464">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-464">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-465">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-466">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-467">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-468">Espera qualquer um dos elementos na matriz especificada receber um sinal usando um inteiro com sinal de 32 bits a fim de especificar o intervalo de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-469">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-470">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-471">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-472">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="63f17-473">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="63f17-474">Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="63f17-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="63f17-475">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="63f17-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="63f17-476">Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="63f17-477">Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-478">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-479">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-479">-or-</span>
          </span>
          <span data-ttu-id="63f17-480">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-481">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-482">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-482">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-483">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-483">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-484">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="63f17-485">
            <paramref name="waitHandles" /> é uma matriz sem elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-485">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-486">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-487">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="63f17-488">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-489">Aguarda até todos os elementos na matriz especificada receberem um sinal usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-490">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-491">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-492">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-493">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="63f17-494">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="63f17-495">Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="63f17-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="63f17-496">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="63f17-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="63f17-497">Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="63f17-498">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="63f17-499">Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-500">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-501">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-501">-or-</span>
          </span>
          <span data-ttu-id="63f17-502">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-503">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-504">
            <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-504">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="63f17-505">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-505">-or-</span>
          </span>
          <span data-ttu-id="63f17-506">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-506">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-507">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-507">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-508">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="63f17-509">
            <paramref name="waitHandles" /> é uma matriz sem elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-509">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-510">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-511">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-512">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-513">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-513">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-514">Espera todos os elementos na matriz especificada receberem um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-515">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-516">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-517">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-518"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-519">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, pois um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="63f17-520">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-521">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-522">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-523">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="63f17-524">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-525">Em versões do .NET Framework anterior à versão 2.0, se um thread encerrado ou anulada sem soltar explicitamente um <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128, em vez de 0.</span><span class="sxs-lookup"><span data-stu-id="63f17-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="63f17-526">Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="63f17-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="63f17-527">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="63f17-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="63f17-528">Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-529">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-530">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-531">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-532">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-533">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="63f17-534">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-535">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-536">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-537">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-538">Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-539">O exemplo de código a seguir demonstra como usar o pool de threads para pesquisar um arquivo em vários discos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="63f17-540">Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="63f17-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-541">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-542">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-542">-or-</span>
          </span>
          <span data-ttu-id="63f17-543">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-544">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="63f17-545">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-545">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-546">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-546">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-547">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-547">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-548">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="63f17-549">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-549">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-550">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="63f17-551">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="63f17-552">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-553">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-553">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-554">Espera todos os elementos na matriz especificada receberem um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-555">O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-556">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-557">Ele testa o estado de identificadores de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-558"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-559">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, pois um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="63f17-560">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-561">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-562">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-563">O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="63f17-564">Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63f17-565">Em versões do .NET Framework anterior à versão 2.0, se um thread encerrado ou anulada sem soltar explicitamente um <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128, em vez de 0.</span><span class="sxs-lookup"><span data-stu-id="63f17-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="63f17-566">Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite.</span><span class="sxs-lookup"><span data-stu-id="63f17-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="63f17-567">Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados.</span><span class="sxs-lookup"><span data-stu-id="63f17-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="63f17-568">Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="63f17-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="63f17-569">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-570">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-571">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-572">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-573">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-574">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="63f17-575">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-576">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-577">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-578">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-579">Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-580">O exemplo de código a seguir demonstra como usar o pool de threads para pesquisar um arquivo em vários discos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="63f17-581">Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="63f17-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="63f17-582">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="63f17-583">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-583">-or-</span>
          </span>
          <span data-ttu-id="63f17-584">Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="63f17-585">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="63f17-586">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-586">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-587">
            <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-587">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="63f17-588">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-588">-or-</span>
          </span>
          <span data-ttu-id="63f17-589">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-589">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-590">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-590">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-591">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="63f17-592">
            <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-592">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-593">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-594">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63f17-595">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-596">
            <see langword="true" /> se a instância atual receber um sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-596">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="63f17-597">Se a instância atual nunca for sinalizada, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nunca será retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-598"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-599">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="63f17-600">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-601">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-602">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-603">O chamador de blocos esse método indefinidamente até que a instância atual recebe um sinal.</span><span class="sxs-lookup"><span data-stu-id="63f17-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="63f17-604">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="63f17-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="63f17-605">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="63f17-606">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método e a especificação de -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o primeiro parâmetro e `false` para o segundo parâmetro.</span><span class="sxs-lookup"><span data-stu-id="63f17-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="63f17-607">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="63f17-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-608">O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto aguarda um thread em segundo plano sejam concluídas.</span><span class="sxs-lookup"><span data-stu-id="63f17-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="63f17-609">A instância atual já foi descartada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-609">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-610">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-610">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-611">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-612">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-613">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-614">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo em milissegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-615">
            <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-615">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-616">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-617">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-618">O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="63f17-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="63f17-619">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="63f17-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="63f17-620">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="63f17-621">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="63f17-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="63f17-622">Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-623">O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto aguarda um thread em segundo plano sejam concluídas.</span><span class="sxs-lookup"><span data-stu-id="63f17-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="63f17-624">A instância atual já foi descartada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-624">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-625">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-625">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-626">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-626">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-627">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-628">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="63f17-629">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-630">Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-631">
            <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-631">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-632">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-633">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-634">O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="63f17-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="63f17-635">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="63f17-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="63f17-636">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="63f17-637">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="63f17-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="63f17-638">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="63f17-639">Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="63f17-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="63f17-640">A instância atual já foi descartada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-640">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-641">
            <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-641">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="63f17-642">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-642">-or-</span>
          </span>
          <span data-ttu-id="63f17-643">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-643">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-644">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-644">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-645">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-646">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="63f17-647">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-648">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-648">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-649">Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-650">
            <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-650">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-651">Se `millisecondsTimeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-652">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-653"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-654">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="63f17-655">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-656">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-657">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-658">O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="63f17-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="63f17-659">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="63f17-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="63f17-660">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="63f17-661">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="63f17-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-662">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-663">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-664">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-665">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-666">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="63f17-667">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-668">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-669">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-670">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-671">Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-672">A exemplo a seguir mostra como o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método se comporta quando ele é chamado dentro de um domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="63f17-673">Primeiro, um thread aguarda com `exitContext` definido como `false` e bloqueia até que o tempo limite de espera expire.</span><span class="sxs-lookup"><span data-stu-id="63f17-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="63f17-674">Um thread de segundo é executado após o primeiro thread termina e aguarda com `exitContext` definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="63f17-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="63f17-675">A chamada para indicar que o identificador de espera para esse thread de segundo não é bloqueada e o thread seja concluída antes do tempo limite de espera.</span><span class="sxs-lookup"><span data-stu-id="63f17-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="63f17-676">A instância atual já foi descartada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-676">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-677">
            <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-677">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-678">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-678">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-679">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-680">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="63f17-681">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="63f17-682">
            <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-682">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63f17-683">Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63f17-684">
            <see langword="true" /> se a instância atual receber um sinal, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-684">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-685">Se `timeout` for zero, o método não bloquear.</span><span class="sxs-lookup"><span data-stu-id="63f17-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="63f17-686">Ele testa o estado do identificador de espera e retorna imediatamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="63f17-687"><xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="63f17-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="63f17-688">Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado.</span><span class="sxs-lookup"><span data-stu-id="63f17-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="63f17-689">Um mutex abandonado geralmente indica um erro grave de codificação.</span><span class="sxs-lookup"><span data-stu-id="63f17-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="63f17-690">No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="63f17-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="63f17-691">A exceção contém informações úteis para depuração.</span><span class="sxs-lookup"><span data-stu-id="63f17-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="63f17-692">O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre.</span><span class="sxs-lookup"><span data-stu-id="63f17-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="63f17-693">Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída.</span><span class="sxs-lookup"><span data-stu-id="63f17-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="63f17-694">Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.</span><span class="sxs-lookup"><span data-stu-id="63f17-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="63f17-695">Substitua este método para personalizar o comportamento de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="63f17-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="63f17-696">O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63f17-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="63f17-697">Anotações na saída do contexto</span><span class="sxs-lookup"><span data-stu-id="63f17-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="63f17-698">O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto gerenciado não padrão.</span><span class="sxs-lookup"><span data-stu-id="63f17-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="63f17-699">Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="63f17-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="63f17-700">Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.</span><span class="sxs-lookup"><span data-stu-id="63f17-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="63f17-701">Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="63f17-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="63f17-702">O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.</span><span class="sxs-lookup"><span data-stu-id="63f17-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="63f17-703">Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="63f17-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="63f17-704">Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe.</span><span class="sxs-lookup"><span data-stu-id="63f17-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="63f17-705">Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="63f17-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="63f17-706">Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.</span><span class="sxs-lookup"><span data-stu-id="63f17-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-707">O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto aguarda um thread em segundo plano sejam concluídas.</span><span class="sxs-lookup"><span data-stu-id="63f17-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="63f17-708">A instância atual já foi descartada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-708">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="63f17-709">
            <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-709">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="63f17-710">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-710">-or-</span>
          </span>
          <span data-ttu-id="63f17-711">
            <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-711">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="63f17-712">A espera foi concluída porque um thread foi encerrado sem liberar um mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-712">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="63f17-713">Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="63f17-714">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="63f17-715">Indica que uma operação <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> atingiu o tempo limite antes que algum dos identificadores de espera fosse sinalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="63f17-716">Este campo é constante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63f17-716">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63f17-717">Este campo é um dos possíveis valores de retorno de `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="63f17-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63f17-718">O exemplo de código a seguir demonstra como usar o pool de threads para pesquisar um arquivo em vários discos simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="63f17-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="63f17-719">Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.</span><span class="sxs-lookup"><span data-stu-id="63f17-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>