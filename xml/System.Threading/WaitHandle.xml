<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a13a27594fa1d97d7387994076cdc3b3a30d735d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609268" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.WaitHandle> classe encapsula os identificadores de sincronização do Win32 e é usado para representar todos os objetos de sincronização no tempo de execução que permitem que várias operações de espera. Para obter uma comparação de identificadores de espera com outros objetos de sincronização, consulte [visão geral dos primitivos de sincronização](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 O <xref:System.Threading.WaitHandle> própria classe é abstrata. As classes derivadas <xref:System.Threading.WaitHandle> definem um mecanismo de sinalização para indicar demorando ou liberar o acesso a um recurso compartilhado, mas usam o herdadas <xref:System.Threading.WaitHandle> métodos para bloquear enquanto espera para acessar os recursos compartilhados. As classes derivadas de <xref:System.Threading.WaitHandle> incluem:  
  
-   O <xref:System.Threading.Mutex> classe. Ver [Mutexes](~/docs/standard/threading/mutexes.md).  
  
-   O <xref:System.Threading.EventWaitHandle> classe e suas classes derivadas, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>. Confira [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   O <xref:System.Threading.Semaphore> classe. Ver [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Threads podem bloquear em um identificador de espera individuais chamando o método de instância <xref:System.Threading.WaitHandle.WaitOne%2A>, que é herdado por classes derivadas de <xref:System.Threading.WaitHandle>.  
  
 As classes derivadas de <xref:System.Threading.WaitHandle> diferem na afinidade do thread. Identificadores de espera de evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e semaphores não têm afinidade de thread; qualquer thread pode sinalizar um identificador de espera de evento ou semáforo. Mutexes, por outro lado, têm afinidade de thread; o thread que possui um mutex deverá liberá-lo e uma exceção é lançada se um thread chama o <xref:System.Threading.Mutex.ReleaseMutex%2A> método em um mutex que não é proprietário.  
  
 Porque o <xref:System.Threading.WaitHandle> deriva de classe <xref:System.MarshalByRefObject>, essas classes podem ser usadas para sincronizar as atividades de threads entre limites de domínio de aplicativo.  
  
 Além de suas classes derivadas, o <xref:System.Threading.WaitHandle> classe tiver um número de métodos estáticos que bloqueia um thread até que um ou mais objetos de sincronização recebam um sinal... Elas incluem:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que um thread sinalizar um identificador de espera e esperar imediatamente em outro.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que um thread Aguarde até que todos os identificadores de espera em uma matriz recebam um sinal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que um thread espere até que qualquer um de um conjunto especificado de identificadores de espera foi sinalizado.  
  
 As sobrecargas dos métodos a seguir fornecem os intervalos de tempo limite para abandonar a espera e a oportunidade para sair de um contexto de sincronização antes de entrar em espera, permitindo que outros threads usar o contexto de sincronização.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo ou um tipo derivado dele, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.Threading.WaitHandle.Close%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 <xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão. Ver [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md). Quando você deriva <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo. Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos não gerenciados adicionais.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como dois threads podem fazem tarefas em segundo plano enquanto principal thread aguarda as conclusão das tarefas usando estático <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> métodos do <xref:System.Threading.WaitHandle> classe.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a implementação pública do <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para o <xref:System.Threading.WaitHandle> classe e suas classes derivadas. Ele fornece uma implementação padrão que chama o `Dispose(Boolean)` sobrecarga com um `true` argumento e, em seguida, chama o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método. Chame esse método para liberar todos os recursos mantidos por uma instância do `WaitHandle` ou uma classe derivada.  
  
 Depois que esse método é chamado, as referências à instância atual causam um comportamento indefinido.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>. Caso contrário, os recursos que ele está usando não serão liberados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir o <see langword="Dispose(Boolean)" /> classes derivadas de método para liberar recursos alocados.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.Threading.WaitHandle.Close%2A> método.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>. Caso contrário, os recursos que ele está usando não serão liberados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Threading.WaitHandle.Close%2A> e o <xref:System.Threading.WaitHandle.Dispose> métodos com o `explicitDisposing` parâmetro definido como `true`.  Quando o `explicitDisposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Threading.WaitHandle> referências de objeto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir o <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> classes derivadas de método para liberar recursos alocados.  O <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> método pode ser chamado várias vezes por outros objetos. Ao substituir esse método, tenha cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see langword="Dispose" /> ou <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>Um <see langword="IntPtr" /> que representa o identificador do sistema operacional nativo. O padrão é o valor do campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atribuir um novo valor para o <xref:System.Threading.WaitHandle.Handle%2A> propriedade não fecha o identificador anterior. Isso pode resultar em um identificador vazado.  
  
 Não use essa propriedade no .NET Framework versão 2.0 ou posterior; Use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade em vez disso. Definir essa propriedade como um identificador válido também define o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, mas defini-lo como <xref:System.Threading.WaitHandle.InvalidHandle> pode resultar em um identificador vazado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato definir o valor da propriedade. Este membro não pode ser definido por código transparente ou parcialmente confiável.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para definir o valor da propriedade.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents an invalid native operating system handle. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usada internamente para inicializar o <xref:System.Threading.WaitHandle.Handle%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você pode usar esse valor para determinar se o <see cref="P:System.Threading.WaitHandle.Handle" /> propriedade contém um identificador válido do sistema operacional nativo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the native operating system handle.</summary>
        <value>Um <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa o identificador de sistema operacional nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você atribui um novo valor para o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, o identificador anterior será fechado quando anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objeto seja coletado. Não feche manualmente o identificador, porque isso resulta em uma <xref:System.ObjectDisposedException> quando o <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta fechar o identificador.  
  
 <xref:System.Threading.WaitHandle> implementa o <xref:System.IDisposable.Dispose%2A> padrão. Ver [padrão de descarte](~/docs/standard/design-guidelines/dispose-pattern.md). Quando você deriva <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo. Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos não gerenciados adicionais.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para chamar esse membro.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida para ser atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga de método para permitir que o thread principal sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclua uma tarefa.  
  
 O exemplo inicia threads de cinco, permite que eles bloquear em uma <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e versões de um thread cada vez o usuário pressiona a tecla ENTER. O exemplo, em seguida, coloca na fila outro cinco segmentos e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="millisecondsTimeout">An integer that represents the interval to wait. If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida para ser atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.  
  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado do `toWaitOn` e retorna imediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">The <see cref="T:System.Threading.WaitHandle" /> to signal.</param>
        <param name="toWaitOn">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the interval to wait. If the value is -1, the wait is infinite.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</summary>
        <returns>
          <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida para ser atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele aguarda `toWaitOn`, um thread que está em execução em outro processador pode sinalizar `toWaitOn` ou esperar por ele.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado do `toWaitOn` e retorna imediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> is <see langword="null" />.  -or-  <paramref name="toWaitOn" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">This method is not supported on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> is a semaphore, and it already has a full count.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <summary>Waits for all the elements in the specified array to receive a signal.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando todos os identificadores são sinalizados. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />. -or-  One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou que ocorra um tempo limite. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para> In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.  </para>
          </block>  The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem o <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método é retornado quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou que ocorra um tempo limite. Em algumas implementações, se mais de 64 identificadores forem passados, uma <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em threads que tiverem <xref:System.STAThreadAttribute>.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método. Ele retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação é enfileirada como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.  -or-  <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">The <paramref name="waitHandles" /> array contains elements that are duplicates.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.  -or-  The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal.</summary>
        <returns>The array index of the object that satisfied the wait.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.  
  
 Esse método retorna quando qualquer identificador é sinalizado. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a chamada a <xref:System.Threading.WaitHandle.WaitAny%2A> método.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado dos identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, porque um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando a espera for concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Nas versões do .NET Framework anteriores à versão 2.0, se um thread é encerrado ou anula sem liberar explicitamente uma <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128 em vez de 0.  
  
 Esse método retorna quando a espera termina quando qualquer uma das alças são sinalizado ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, uma <xref:System.NotSupportedException> é gerada.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="waitHandles" /> parameter is <see langword="null" />.  -or-  One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal. If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos esse método indefinidamente até que a instância atual receba um sinal. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método e especificando -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o primeiro parâmetro e `false` para o segundo parâmetro.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Essa sobrecarga de método de chamada é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 A exemplo a seguir mostra como o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método se comporta quando ele é chamado dentro de um domínio de sincronização. Primeiro, um thread aguarda com `exitContext` definido como `false` e bloqueia até que o tempo limite de espera expire. Um segundo thread é executado após o primeiro thread é encerrado e aguarda com `exitContext` definido como `true`. A chamada para sinalizar o identificador de espera para este segundo segmento não está bloqueada e o thread ser concluído antes do tempo limite de espera.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</param>
        <param name="exitContext">
          <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</param>
        <summary>Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</summary>
        <returns>
          <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloqueia. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, ele pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos este método até que a instância atual receba um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> receba um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto de gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto de associação tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para os membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para inserir novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto ele aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.  -or-  <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo é um dos possíveis valores de retorno de `WaitAny`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de segmentos para procurar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>