<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="30925d1ed481842882180e068760ea83b7059bc8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57920463" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Um primitivo de sincronização que também pode ser usado para sincronização entre processos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando dois ou mais threads precisam acessar um recurso compartilhado ao mesmo tempo, o sistema precisa de um mecanismo de sincronização para garantir que apenas um thread por vez use o recurso. <xref:System.Threading.Mutex> é uma sincronização primitiva que concede acesso exclusivo ao recurso compartilhado a um único thread. Se um thread adquire um mutex, o segundo thread que quiser adquirir essa exclusão mútua é suspenso até que o primeiro thread libera o mutex.  
  
> [!IMPORTANT]
>  Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
 Você pode usar o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método para solicitar a propriedade de um mutex. O chamada thread bloqueia até que ocorra um dos seguintes:  
  
-   O mutex será sinalizado para indicar que ele não pertence. Quando isso acontece, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true`, e o thread de chamada assume a propriedade do mutex e acessa o recurso protegido pelo mutex. Quando tiver concluído a acessar o recurso, o thread deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar a propriedade do mutex. O primeiro exemplo na seção exemplos ilustra esse padrão.  
  
-   O intervalo de tempo limite especificado na chamada para um <xref:System.Threading.WaitHandle.WaitOne%2A> método que tem um `millisecondsTimeout` ou `timeout` parâmetro tiver decorrido. Quando isso acontece, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `false`, e nenhuma outra tentativa de adquirir a propriedade do mutex faz com que o thread de chamada. Nesse caso, você deve estruturar seu código para que o acesso ao recurso que é protegido pelo mutex é negado para o thread de chamada. Como o thread nunca adquiriu a propriedade do mutex, ele não deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método. O segundo exemplo na seção exemplos ilustra esse padrão.  
  
 O <xref:System.Threading.Mutex> classe impõe a identidade do thread, portanto, um mutex pode ser liberado somente pelo thread que o adquiriu. Por outro lado, o <xref:System.Threading.Semaphore> classe não impõe a identidade do thread. Um mutex também pode ser passado entre limites de domínio de aplicativo.  
  
 O thread que possui um mutex pode solicitar o mesmo mutex em chamadas repetidas para <xref:System.Threading.WaitHandle.WaitOne%2A> sem bloquear a execução. No entanto, o thread deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método o mesmo número de vezes para liberar a propriedade do mutex.  
  
 Porque o <xref:System.Threading.Mutex> herda <xref:System.Threading.WaitHandle>, você também pode chamar estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos para sincronizar o acesso a um recurso protegido.  
  
 Se um thread é encerrado enquanto for proprietário de um mutex, será considerado o mutex abandonado. O estado do mutex é definido como sinalizado e o próxima thread em espera obtém a propriedade. Começando na versão 2.0 do .NET Framework, um <xref:System.Threading.AbandonedMutexException> é gerada no próximo thread que adquire o mutex abandonado. Antes da versão 2.0 do .NET Framework, nenhuma exceção foi lançada.  
  
> [!CAUTION]
>  Um mutex abandonado geralmente indica um erro grave no código. Quando um thread é encerrado sem liberar o mutex, as estruturas de dados protegidas pelo mutex podem não ser em um estado consistente. O próximo thread a solicitar a propriedade do mutex pode tratar essa exceção e continuar, se a integridade das estruturas de dados pode ser verificada.  
  
 No caso de um mutex de todo o sistema, um mutex abandonado pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de Tarefas do Windows).  
  
 Mutexes são de dois tipos: mutexes locais, que são e sem-nome mutexes de sistema. Um mutex local existe somente dentro de seu processo. Ele pode ser usado por qualquer thread no processo que tem uma referência para o <xref:System.Threading.Mutex> objeto que representa o mutex. Cada sem nome <xref:System.Threading.Mutex> objeto representa um mutex local separado.  
  
 Do sistema nomeado mutexes são visíveis em todo o sistema operacional e pode ser usados para sincronizar as atividades de processos. Você pode criar um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado usando um construtor que aceita um nome. O objeto do sistema operacional pode ser criado ao mesmo tempo, ou existir antes da criação do <xref:System.Threading.Mutex> objeto. Você pode criar vários objetos <xref:System.Threading.Mutex> que representam o mesmo mutex de sistema nomeado, e você pode usar o método <xref:System.Threading.Mutex.OpenExisting%2A> para abrir um mutex de sistema nomeado existente.  
  
> [!NOTE]
>  Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade. Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server. Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado. Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor. Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\". Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server. Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Este exemplo mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido. Como cada thread de chamada é bloqueado até que ele adquire a propriedade do mutex, ela deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar a propriedade do thread.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 No exemplo a seguir, cada thread chama o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> método para adquirir o mutex. Se o intervalo de tempo limite expira, o método retorna `false`, e o thread não adquire o mutex nem obtém acesso ao recurso protege o mutex. O <xref:System.Threading.Mutex.ReleaseMutex%2A> método é chamado somente pelo thread que adquire o mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com propriedades padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga de construtor é o mesmo que chamar o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> sobrecarga de construtor e especificando `false` para a propriedade inicial do mutex. Ou seja, o thread de chamada não possuir o mutex.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido. O thread que cria o mutex não possui-lo inicialmente.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" /> para dar ao thread de chamada propriedade inicial do mutex; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial do mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido. O thread que cria o <xref:System.Threading.Mutex> possui-lo inicialmente.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
        <param name="name">O nome do <see cref="T:System.Threading.Mutex" />. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter uma propriedade inicial do mutex e uma cadeia de caracteres que é o nome do mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` não é `null` e `initiallyOwned` é `true`, o thread de chamada possui o mutex somente se o mutex de sistema nomeado foi criado como resultado dessa chamada. Como não há nenhum mecanismo para determinar se o mutex de sistema nomeado foi criado, é melhor especificar `false` para `initiallyOwned` ao chamar essa sobrecarga de construtor. Você pode usar o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> construtor se você precisar determinar a propriedade inicial.  
  
 Este construtor inicializa um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado. Você pode criar várias <xref:System.Threading.Mutex> mutex do sistema nomeado de objetos que representam o mesmo.  
  
 Se o mutex nomeado já foi criado com a segurança de controle de acesso e o chamador não tem <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, uma exceção será lançada. Para abrir um mutex nomeado com somente as permissões necessárias para sincronizar as atividades de thread existente, consulte o <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um mutex local é criado, como se você tivesse chamado o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como elas são em todo o sistema, mutexes nomeados pode ser usados para coordenar o uso de recursos entre os limites do processo.  
  
> [!NOTE]
>  Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade. Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server. Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado. Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor. Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\". Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server. Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 O exemplo a seguir mostra como um mutex nomeado é usado para sinalizar entre os threads em execução em dois processos separados.  
  
 Execute este programa de duas ou mais janelas de comando. Cada processo cria uma <xref:System.Threading.Mutex> objeto que representa o mutex nomeado `MyMutex`. O mutex nomeado é um objeto do sistema cujo tempo de vida é limitado pelos tempos de vida de <xref:System.Threading.Mutex> objetos que representam a ele. O mutex nomeado é criado quando o primeiro processo cria seu <xref:System.Threading.Mutex> objeto; neste exemplo, o mutex nomeado é de propriedade o primeiro processo que executa o programa. O mutex nomeado é destruído quando todos os o <xref:System.Threading.Mutex> objetos que representam a ele foram lançados.  
  
 A sobrecarga de construtor usada neste exemplo não pode determinar o thread de chamada se a propriedade inicial do mutex nomeado foi concedida. Você não deve usar esse construtor para solicitar a propriedade inicial, a menos que você pode ter certeza de que o thread irá criar o mutex nomeado.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> tem mais de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
        <param name="name">O nome do <see cref="T:System.Threading.Mutex" />. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
        <param name="createdNew">Quando este método retorna, contém um valor booliano que é <see langword="true" /> se um mutex local foi criado (ou seja, se <paramref name="name" /> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o mutex do sistema nomeado especificado foi criado; <see langword="false" /> se o mutex do sistema nomeado já existia. Este parâmetro é passado não inicializado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial de mutex, uma cadeia de caracteres que é o nome do mutex e um valor booliano que, quando o método retorna, indica se o thread de chamada foi concedido a propriedade inicial do mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` não é `null` e `initiallyOwned` é `true`, o thread de chamada possui o mutex nomeado apenas se `createdNew` é `true` após a chamada. Caso contrário, o thread pode solicitar o mutex chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método.  
  
 Este construtor inicializa um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado. Você pode criar várias <xref:System.Threading.Mutex> mutex do sistema nomeado de objetos que representam o mesmo.  
  
 Se o mutex nomeado já foi criado com a segurança de controle de acesso e o chamador não tem <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> direitos, uma exceção será lançada. Para abrir um mutex nomeado com somente as permissões necessárias para sincronizar as atividades de thread existente, consulte o <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um mutex local é criado, como se você tivesse chamado o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como elas são em todo o sistema, mutexes nomeados pode ser usados para coordenar o uso de recursos entre os limites do processo.  
  
> [!NOTE]
>  Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade. Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server. Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado. Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor. Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\". Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server. Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 O exemplo de código a seguir mostra como um mutex nomeado é usado para sinalizar entre processos ou threads. Execute este programa de duas ou mais janelas de comando. Cada processo cria um <xref:System.Threading.Mutex> objeto que representa o mutex nomeado "MyMutex". O mutex nomeado é um objeto do sistema. Neste exemplo, seu tempo de vida é limitado pelos tempos de vida de <xref:System.Threading.Mutex> objetos que representam a ele. O mutex nomeado é criado quando o primeiro processo cria seu local <xref:System.Threading.Mutex> do objeto e destruído quando todos os o <xref:System.Threading.Mutex> objetos que representam a ele foram lançados. O primeiro processo inicialmente pertence o mutex nomeado. O segundo processo e todos os processos subsequentes aguardam processos mais antigos liberar o mutex nomeado.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> tem mais de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</param>
        <param name="name">O nome do mutex do sistema. Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</param>
        <param name="createdNew">Quando este método retorna, contém um valor booliano que é <see langword="true" /> se um mutex local foi criado (ou seja, se <paramref name="name" /> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o mutex do sistema nomeado especificado foi criado; <see langword="false" /> se o mutex do sistema nomeado já existia. Este parâmetro é passado não inicializado.</param>
        <param name="mutexSecurity">Um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao mutex de sistema nomeado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial de mutex, uma cadeia de caracteres que é o nome do mutex, uma variável booliana que, quando o método retorna, indica se o thread de chamada foi concedido a propriedade inicial de mutex e a segurança de controle de acesso a ser aplicado ao mutex nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` não é `null` e `initiallyOwned` é `true`, o thread de chamada possui o mutex nomeado apenas se `createdNew` é `true` após a chamada. Caso contrário, o thread pode solicitar o mutex chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método.  
  
 Use esse construtor para aplicar segurança de controle de acesso a um mutex nomeado do sistema quando ele é criado, impedindo que o outro código assumindo o controle do mutex.  
  
 Este construtor inicializa um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado. Você pode criar várias <xref:System.Threading.Mutex> mutex do sistema nomeado de objetos que representam o mesmo.  
  
 Se o mutex de sistema nomeado não existir, ele é criado com a segurança de controle de acesso especificado. Se o mutex nomeado existe, a segurança de controle de acesso especificado será ignorada.  
  
> [!NOTE]
>  O chamador tem controle total sobre o recém-criado <xref:System.Threading.Mutex> objeto mesmo se `mutexSecurity` nega ou falha em conceder a alguns direitos de acesso para o usuário atual. No entanto, se o usuário atual tenta obter outra <xref:System.Threading.Mutex> representar o mesmo mutex nomeado, usando um construtor de objeto ou o <xref:System.Threading.Mutex.OpenExisting%2A> método, o Windows a segurança de controle de acesso é aplicada.  
  
 Se o mutex nomeado já foi criado com a segurança de controle de acesso e o chamador não tem <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, uma exceção será lançada. Para abrir um mutex nomeado com somente as permissões necessárias para sincronizar as atividades de thread existente, consulte o <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um mutex local é criado, como se você tivesse chamado o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como elas são em todo o sistema, mutexes nomeados pode ser usados para coordenar o uso de recursos entre os limites do processo.  
  
> [!NOTE]
>  Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade. Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server. Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado. Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor. Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\". Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server. Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.  
  
 Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> tem mais de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança do controle de acesso para o mutex nomeado.</summary>
        <returns>Um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança do controle de acesso para o mutex nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Mutex.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para pesquisar as permissões: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 O usuário deve ter <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> chamar esse método e o mutex o deve ter sido aberto com <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.  
  
 Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões, usando o <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.  
  
 Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O objeto <see cref="T:System.Threading.Mutex" /> atual representa um mutex nomeado do sistema, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
- ou - 
O objeto <see cref="T:System.Threading.Mutex" /> atual representa um mutex nomeado do sistema e não foi aberto com <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um mutex nomeado especificado, caso ele já exista.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mutex do sistema a ser aberto.</param>
        <summary>Abre o mutex nomeado especificado, caso ele já exista.</summary>
        <returns>Um objeto que representa o mutex do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Mutex.OpenExisting%2A> método tenta abrir especificado o mutex do sistema nomeado. Se o mutex do sistema não existir, este método lança uma exceção em vez de criar o objeto do sistema. Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.  
  
 Especificando o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread de espera no mutex e especificando as <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Esse método não solicitar a propriedade do mutex.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.  
  
 Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O mutex nomeado não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mutex do sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</param>
        <summary>Abre o mutex nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</summary>
        <returns>Um objeto que representa o mutex do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads de espera no mutex e o <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 O <xref:System.Threading.Mutex.OpenExisting%2A> método tenta abrir um mutex nomeado existente. Se o mutex do sistema não existir, este método lança uma exceção em vez de criar o objeto do sistema. Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.  
  
 Esse método não solicitar a propriedade do mutex.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.  
  
 Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O mutex nomeado não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe, mas o usuário não tem o acesso de segurança desejado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera o <see cref="T:System.Threading.Mutex" /> uma vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sempre que um thread adquire um mutex (por exemplo, chamando seu <xref:System.Threading.WaitHandle.WaitOne%2A> método), ela deve chamar subsequentemente <xref:System.Threading.Mutex.ReleaseMutex%2A> para liberar a propriedade do mutex e desbloquear outros threads que tentam obter propriedade do mutex. Se a tentativa de obter a propriedade do mutex falha (por exemplo, quando uma chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método com um `millisecondsTimeout` ou um `timeout` parâmetro retorna `false` porque a solicitação expira), o thread não deve chamar <xref:System.Threading.Mutex.ReleaseMutex%2A>, neste os casos, o thread deve também não ter permissão para acessar o recurso protegido pelo mutex, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Um thread que possui um mutex pode especificar o mesmo mutex em chamadas de função repetidas espera sem bloquear a execução. O número de chamadas é mantido pelo common language runtime. O thread deve chamar <xref:System.Threading.Mutex.ReleaseMutex%2A> o mesmo número de vezes para liberar a propriedade do mutex.  
  
 Se um thread é encerrado enquanto for proprietário de um mutex, será considerado o mutex abandonado. O estado do mutex é definido como sinalizado e o próxima thread em espera obtém a propriedade. Se ninguém possui o mutex, o estado do mutex é sinalizado. Começando na versão 2.0 do .NET Framework, um <xref:System.Threading.AbandonedMutexException> é gerada no próximo thread que adquire o mutex. Antes da versão 2.0 do .NET Framework, nenhuma exceção foi lançada.  
  
> [!CAUTION]
>  Um mutex abandonado geralmente indica um erro grave no código. Quando um thread é encerrado sem liberar o mutex, as estruturas de dados protegidas pelo mutex podem não ser em um estado consistente. O próximo thread a solicitar a propriedade do mutex pode tratar essa exceção e continuar, se a integridade das estruturas de dados pode ser verificada.  
  
 No caso de um mutex de todo o sistema, um mutex abandonado pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de Tarefas do Windows).  
  
   
  
## Examples  
 O exemplo a seguir mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido. O thread que cria o mutex não possui-lo inicialmente. O <xref:System.Threading.Mutex.ReleaseMutex%2A> método é usado para liberar o mutex, quando ele não for mais necessário.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread de chamada não tem o mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gerenciado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao mutex de sistema nomeado.</param>
        <summary>Define a segurança de controle de acesso para um mutex de sistema nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve ter <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> direitos para chamar esse método e o mutex devem ter sido abertos com <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.  
  
 Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões, usando o <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.  
  
 Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
- ou - 
O mutex não foi aberto com <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">O objeto <see cref="T:System.Threading.Mutex" /> atual não representa um mutex de sistema nomeado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se um mutex nomeado especificado já existe, abre-o e retorna um valor que indica se a operação foi bem-sucedida.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mutex do sistema a ser aberto.</param>
        <param name="result">Quando este método retorna, ele contém um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Abre o mutex nomeado especificado, quando ele já existe e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns><see langword="true" /> se o mutex nomeado foi aberto com sucesso, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o mutex nomeado não existir, esse método não cria-lo. Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se um mutex nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método que lança uma exceção se o mutex não existir.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit. Especificando o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread de espera no mutex e especificando as <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Esse método não solicitar a propriedade do mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mutex do sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</param>
        <param name="result">Quando este método retorna, ele contém um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Se o mutex nomeado especificado já existe, abre-o com o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns><see langword="true" /> se o mutex nomeado foi aberto com sucesso, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o mutex nomeado não existir, esse método não cria-lo. Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se um mutex nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método que lança uma exceção se o mutex não existir.  
  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads de espera no mutex e o <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.  
  
 Esse método não solicitar a propriedade do mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>