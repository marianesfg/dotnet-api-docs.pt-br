<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7de03c355dd0d74e383476a827f9b04199da1cf4" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48748904" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="16cc7-101">Um primitivo de sincronização que também pode ser usado para sincronização entre processos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="16cc7-101">A synchronization primitive that can also be used for interprocess synchronization.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-102">Quando dois ou mais threads precisam acessar um recurso compartilhado ao mesmo tempo, o sistema precisa de um mecanismo de sincronização para garantir que apenas um thread por vez use o recurso.</span><span class="sxs-lookup"><span data-stu-id="16cc7-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="16cc7-103"><xref:System.Threading.Mutex> é uma sincronização primitiva que concede acesso exclusivo ao recurso compartilhado a um único thread.</span><span class="sxs-lookup"><span data-stu-id="16cc7-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="16cc7-104">Se um thread adquire um mutex, o segundo thread que quiser adquirir essa exclusão mútua é suspenso até que o primeiro thread libera o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="16cc7-105">Esse tipo implementa o <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="16cc7-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="16cc7-106">Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="16cc7-107">Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco.</span><span class="sxs-lookup"><span data-stu-id="16cc7-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="16cc7-108">Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="16cc7-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="16cc7-109">Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.</span><span class="sxs-lookup"><span data-stu-id="16cc7-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="16cc7-110">Você pode usar o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método para solicitar a propriedade de um mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="16cc7-111">O chamada thread bloqueia até que ocorra um dos seguintes:</span><span class="sxs-lookup"><span data-stu-id="16cc7-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="16cc7-112">O mutex será sinalizado para indicar que ele não pertence.</span><span class="sxs-lookup"><span data-stu-id="16cc7-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="16cc7-113">Quando isso acontece, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true`, e o thread de chamada assume a propriedade do mutex e acessa o recurso protegido pelo mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="16cc7-114">Quando tiver concluído a acessar o recurso, o thread deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="16cc7-115">O primeiro exemplo na seção exemplos ilustra esse padrão.</span><span class="sxs-lookup"><span data-stu-id="16cc7-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="16cc7-116">O intervalo de tempo limite especificado na chamada para um <xref:System.Threading.WaitHandle.WaitOne%2A> método que tem um `millisecondsTimeout` ou `timeout` parâmetro tiver decorrido.</span><span class="sxs-lookup"><span data-stu-id="16cc7-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="16cc7-117">Quando isso acontece, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `false`, e nenhuma outra tentativa de adquirir a propriedade do mutex faz com que o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="16cc7-118">Nesse caso, você deve estruturar seu código para que o acesso ao recurso que é protegido pelo mutex é negado para o thread de chamada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="16cc7-119">Como o thread nunca adquiriu a propriedade do mutex, ele não deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="16cc7-120">O segundo exemplo na seção exemplos ilustra esse padrão.</span><span class="sxs-lookup"><span data-stu-id="16cc7-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="16cc7-121">O <xref:System.Threading.Mutex> classe impõe a identidade do thread, portanto, um mutex pode ser liberado somente pelo thread que o adquiriu.</span><span class="sxs-lookup"><span data-stu-id="16cc7-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="16cc7-122">Por outro lado, o <xref:System.Threading.Semaphore> classe não impõe a identidade do thread.</span><span class="sxs-lookup"><span data-stu-id="16cc7-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="16cc7-123">Um mutex também pode ser passado entre limites de domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="16cc7-124">O thread que possui um mutex pode solicitar o mesmo mutex em chamadas repetidas para <xref:System.Threading.WaitHandle.WaitOne%2A> sem bloquear a execução.</span><span class="sxs-lookup"><span data-stu-id="16cc7-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="16cc7-125">No entanto, o thread deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método o mesmo número de vezes para liberar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-126">Porque o <xref:System.Threading.Mutex> herda <xref:System.Threading.WaitHandle>, você também pode chamar estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos para sincronizar o acesso a um recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="16cc7-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="16cc7-127">Se um thread é encerrado enquanto for proprietário de um mutex, será considerado o mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="16cc7-128">O estado do mutex é definido como sinalizado e o próxima thread em espera obtém a propriedade.</span><span class="sxs-lookup"><span data-stu-id="16cc7-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="16cc7-129">Começando na versão 2.0 do .NET Framework, um <xref:System.Threading.AbandonedMutexException> é gerada no próximo thread que adquire o mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="16cc7-130">Antes da versão 2.0 do .NET Framework, nenhuma exceção foi lançada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="16cc7-131">Um mutex abandonado geralmente indica um erro grave no código.</span><span class="sxs-lookup"><span data-stu-id="16cc7-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="16cc7-132">Quando um thread é encerrado sem liberar o mutex, as estruturas de dados protegidas pelo mutex podem não ser em um estado consistente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="16cc7-133">O próximo thread a solicitar a propriedade do mutex pode tratar essa exceção e continuar, se a integridade das estruturas de dados pode ser verificada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="16cc7-134">No caso de um mutex de todo o sistema, um mutex abandonado pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de Tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="16cc7-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="16cc7-135">Mutexes são de dois tipos: mutexes locais, que são e sem-nome mutexes de sistema.</span><span class="sxs-lookup"><span data-stu-id="16cc7-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="16cc7-136">Um mutex local existe somente dentro de seu processo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="16cc7-137">Ele pode ser usado por qualquer thread no processo que tem uma referência para o <xref:System.Threading.Mutex> objeto que representa o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="16cc7-138">Cada sem nome <xref:System.Threading.Mutex> objeto representa um mutex local separado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="16cc7-139">Do sistema nomeado mutexes são visíveis em todo o sistema operacional e pode ser usados para sincronizar as atividades de processos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="16cc7-140">Você pode criar um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado usando um construtor que aceita um nome.</span><span class="sxs-lookup"><span data-stu-id="16cc7-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="16cc7-141">O objeto do sistema operacional pode ser criado ao mesmo tempo, ou existir antes da criação do <xref:System.Threading.Mutex> objeto.</span><span class="sxs-lookup"><span data-stu-id="16cc7-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="16cc7-142">Você pode criar vários objetos <xref:System.Threading.Mutex> que representam o mesmo mutex de sistema nomeado, e você pode usar o método <xref:System.Threading.Mutex.OpenExisting%2A> para abrir um mutex de sistema nomeado existente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16cc7-143">Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="16cc7-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="16cc7-144">Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="16cc7-145">Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="16cc7-146">Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="16cc7-147">Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="16cc7-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="16cc7-148">Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="16cc7-149">Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="16cc7-150">Este exemplo mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="16cc7-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="16cc7-151">Como cada thread de chamada é bloqueado até que ele adquire a propriedade do mutex, ela deve chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar a propriedade do thread.</span><span class="sxs-lookup"><span data-stu-id="16cc7-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="16cc7-152">No exemplo a seguir, cada thread chama o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> método para adquirir o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="16cc7-153">Se o intervalo de tempo limite expira, o método retorna `false`, e o thread não adquire o mutex nem obtém acesso ao recurso protege o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="16cc7-154">O <xref:System.Threading.Mutex.ReleaseMutex%2A> método é chamado somente pelo thread que adquire o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="16cc7-155">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="16cc7-155">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="16cc7-156">Threading gerenciado</span>
      <span class="sxs-lookup">
        <span data-stu-id="16cc7-156">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="16cc7-157">Mutexes</span>
      <span class="sxs-lookup">
        <span data-stu-id="16cc7-157">Mutexes</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="16cc7-158">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="16cc7-159">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com propriedades padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-160">Chamar essa sobrecarga de construtor é o mesmo que chamar o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> sobrecarga de construtor e especificando `false` para a propriedade inicial do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="16cc7-161">Ou seja, o thread de chamada não possuir o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="16cc7-162">O seguinte exemplo de código mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="16cc7-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="16cc7-163">O thread que cria o mutex não possui-lo inicialmente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="16cc7-164">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-164">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="16cc7-165">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-165">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="16cc7-166">
            <see langword="true" /> para dar ao thread de chamada propriedade inicial do mutex; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-166">
              <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-167">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial do mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="16cc7-168">O seguinte exemplo de código mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="16cc7-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="16cc7-169">O thread que cria o <xref:System.Threading.Mutex> possui-lo inicialmente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="16cc7-170">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-170">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="16cc7-171">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-171">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="16cc7-172">
            <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-172">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="16cc7-173">O nome do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-173">The name of the <see cref="T:System.Threading.Mutex" />.</span>
          </span>
          <span data-ttu-id="16cc7-174">Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-174">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-175">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter uma propriedade inicial do mutex e uma cadeia de caracteres que é o nome do mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-176">Se `name` não é `null` e `initiallyOwned` é `true`, o thread de chamada possui o mutex somente se o mutex de sistema nomeado foi criado como resultado dessa chamada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-176">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="16cc7-177">Como não há nenhum mecanismo para determinar se o mutex de sistema nomeado foi criado, é melhor especificar `false` para `initiallyOwned` ao chamar essa sobrecarga de construtor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-177">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="16cc7-178">Você pode usar o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> construtor se você precisar determinar a propriedade inicial.</span><span class="sxs-lookup"><span data-stu-id="16cc7-178">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="16cc7-179">Este construtor inicializa um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-179">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="16cc7-180">Você pode criar várias <xref:System.Threading.Mutex> mutex do sistema nomeado de objetos que representam o mesmo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-180">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-181">Se o mutex nomeado já foi criado com a segurança de controle de acesso e o chamador não tem <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-181">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="16cc7-182">Para abrir um mutex nomeado com somente as permissões necessárias para sincronizar as atividades de thread existente, consulte o <xref:System.Threading.Mutex.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-182">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-183">Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um mutex local é criado, como se você tivesse chamado o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-183">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="16cc7-184">Nesse caso, `createdNew` é sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="16cc7-184">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="16cc7-185">Como elas são em todo o sistema, mutexes nomeados pode ser usados para coordenar o uso de recursos entre os limites do processo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-185">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16cc7-186">Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="16cc7-186">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="16cc7-187">Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-187">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="16cc7-188">Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-188">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="16cc7-189">Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-189">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="16cc7-190">Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="16cc7-190">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="16cc7-191">Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-191">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="16cc7-192">Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-192">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="16cc7-193">O exemplo a seguir mostra como um mutex nomeado é usado para sinalizar entre os threads em execução em dois processos separados.</span><span class="sxs-lookup"><span data-stu-id="16cc7-193">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="16cc7-194">Execute este programa de duas ou mais janelas de comando.</span><span class="sxs-lookup"><span data-stu-id="16cc7-194">Run this program from two or more command windows.</span></span> <span data-ttu-id="16cc7-195">Cada processo cria uma <xref:System.Threading.Mutex> objeto que representa o mutex nomeado `MyMutex`.</span><span class="sxs-lookup"><span data-stu-id="16cc7-195">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="16cc7-196">O mutex nomeado é um objeto do sistema cujo tempo de vida é limitado pelos tempos de vida de <xref:System.Threading.Mutex> objetos que representam a ele.</span><span class="sxs-lookup"><span data-stu-id="16cc7-196">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="16cc7-197">O mutex nomeado é criado quando o primeiro processo cria seu <xref:System.Threading.Mutex> objeto; neste exemplo, o mutex nomeado é de propriedade o primeiro processo que executa o programa.</span><span class="sxs-lookup"><span data-stu-id="16cc7-197">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="16cc7-198">O mutex nomeado é destruído quando todos os o <xref:System.Threading.Mutex> objetos que representam a ele foram lançados.</span><span class="sxs-lookup"><span data-stu-id="16cc7-198">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="16cc7-199">A sobrecarga de construtor usada neste exemplo não pode determinar o thread de chamada se a propriedade inicial do mutex nomeado foi concedida.</span><span class="sxs-lookup"><span data-stu-id="16cc7-199">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="16cc7-200">Você não deve usar esse construtor para solicitar a propriedade inicial, a menos que você pode ter certeza de que o thread irá criar o mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-200">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-201">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-201">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-202">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-202">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="16cc7-203">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-203">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-204">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-204">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-205">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-205">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-206">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-206">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="16cc7-207">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-207">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="16cc7-208">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-208">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="16cc7-209">
            <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-209">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="16cc7-210">O nome do <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-210">The name of the <see cref="T:System.Threading.Mutex" />.</span>
          </span>
          <span data-ttu-id="16cc7-211">Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-211">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="16cc7-212">Quando este método retorna, contém um valor booliano que é <see langword="true" /> se um mutex local foi criado (ou seja, se <c>name</c> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o mutex do sistema nomeado especificado foi criado; <see langword="false" /> se o mutex do sistema nomeado já existia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-212">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span>
          </span>
          <span data-ttu-id="16cc7-213">Este parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-213">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-214">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial de mutex, uma cadeia de caracteres que é o nome do mutex e um valor booliano que, quando o método retorna, indica se o thread de chamada foi concedido a propriedade inicial do mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-214">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-215">Se `name` não é `null` e `initiallyOwned` é `true`, o thread de chamada possui o mutex nomeado apenas se `createdNew` é `true` após a chamada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-215">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="16cc7-216">Caso contrário, o thread pode solicitar o mutex chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-216">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-217">Este construtor inicializa um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-217">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="16cc7-218">Você pode criar várias <xref:System.Threading.Mutex> mutex do sistema nomeado de objetos que representam o mesmo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-218">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-219">Se o mutex nomeado já foi criado com a segurança de controle de acesso e o chamador não tem <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> direitos, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-219">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="16cc7-220">Para abrir um mutex nomeado com somente as permissões necessárias para sincronizar as atividades de thread existente, consulte o <xref:System.Threading.Mutex.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-220">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-221">Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um mutex local é criado, como se você tivesse chamado o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-221">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="16cc7-222">Nesse caso, `createdNew` é sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="16cc7-222">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="16cc7-223">Como elas são em todo o sistema, mutexes nomeados pode ser usados para coordenar o uso de recursos entre os limites do processo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-223">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16cc7-224">Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="16cc7-224">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="16cc7-225">Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-225">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="16cc7-226">Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-226">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="16cc7-227">Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-227">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="16cc7-228">Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="16cc7-228">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="16cc7-229">Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-229">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="16cc7-230">Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-230">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="16cc7-231">O exemplo de código a seguir mostra como um mutex nomeado é usado para sinalizar entre processos ou threads.</span><span class="sxs-lookup"><span data-stu-id="16cc7-231">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="16cc7-232">Execute este programa de duas ou mais janelas de comando.</span><span class="sxs-lookup"><span data-stu-id="16cc7-232">Run this program from two or more command windows.</span></span> <span data-ttu-id="16cc7-233">Cada processo cria um <xref:System.Threading.Mutex> objeto que representa o mutex nomeado "MyMutex".</span><span class="sxs-lookup"><span data-stu-id="16cc7-233">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="16cc7-234">O mutex nomeado é um objeto do sistema.</span><span class="sxs-lookup"><span data-stu-id="16cc7-234">The named mutex is a system object.</span></span> <span data-ttu-id="16cc7-235">Neste exemplo, seu tempo de vida é limitado pelos tempos de vida de <xref:System.Threading.Mutex> objetos que representam a ele.</span><span class="sxs-lookup"><span data-stu-id="16cc7-235">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="16cc7-236">O mutex nomeado é criado quando o primeiro processo cria seu local <xref:System.Threading.Mutex> do objeto e destruído quando todos os o <xref:System.Threading.Mutex> objetos que representam a ele foram lançados.</span><span class="sxs-lookup"><span data-stu-id="16cc7-236">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="16cc7-237">O primeiro processo inicialmente pertence o mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-237">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="16cc7-238">O segundo processo e todos os processos subsequentes aguardam processos mais antigos liberar o mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-238">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-239">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-239">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-240">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-240">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="16cc7-241">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-241">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-242">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-242">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-243">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-243">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-244">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-244">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="16cc7-245">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-245">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="16cc7-246">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-246">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="16cc7-247">
            <see langword="true" /> para dar ao thread de chamada a propriedade inicial do mutex do sistema nomeado se o mutex nomeado sistema foi criado como resultado dessa chamada; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-247">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="16cc7-248">O nome do mutex do sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-248">The name of the system mutex.</span>
          </span>
          <span data-ttu-id="16cc7-249">Se o valor for <see langword="null" />, o <see cref="T:System.Threading.Mutex" /> estará sem nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-249">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="16cc7-250">Quando este método retorna, contém um valor booliano que é <see langword="true" /> se um mutex local foi criado (ou seja, se <c>name</c> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o mutex do sistema nomeado especificado foi criado; <see langword="false" /> se o mutex do sistema nomeado já existia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-250">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span>
          </span>
          <span data-ttu-id="16cc7-251">Este parâmetro é passado não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-251">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="mutexSecurity">
          <span data-ttu-id="16cc7-252">Um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao mutex de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-252">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-253">Inicializa uma nova instância da classe <see cref="T:System.Threading.Mutex" /> com um valor booliano que indica se o thread de chamada deve ter a propriedade inicial de mutex, uma cadeia de caracteres que é o nome do mutex, uma variável booliana que, quando o método retorna, indica se o thread de chamada foi concedido a propriedade inicial de mutex e a segurança de controle de acesso a ser aplicado ao mutex nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-253">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-254">Se `name` não é `null` e `initiallyOwned` é `true`, o thread de chamada possui o mutex nomeado apenas se `createdNew` é `true` após a chamada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-254">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="16cc7-255">Caso contrário, o thread pode solicitar o mutex chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-255">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-256">Use esse construtor para aplicar segurança de controle de acesso a um mutex nomeado do sistema quando ele é criado, impedindo que o outro código assumindo o controle do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-256">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-257">Este construtor inicializa um <xref:System.Threading.Mutex> objeto que representa um mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-257">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="16cc7-258">Você pode criar várias <xref:System.Threading.Mutex> mutex do sistema nomeado de objetos que representam o mesmo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-258">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-259">Se o mutex de sistema nomeado não existir, ele é criado com a segurança de controle de acesso especificado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-259">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="16cc7-260">Se o mutex nomeado existe, a segurança de controle de acesso especificado será ignorada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-260">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16cc7-261">O chamador tem controle total sobre o recém-criado <xref:System.Threading.Mutex> objeto mesmo se `mutexSecurity` nega ou falha em conceder a alguns direitos de acesso para o usuário atual.</span><span class="sxs-lookup"><span data-stu-id="16cc7-261">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="16cc7-262">No entanto, se o usuário atual tenta obter outra <xref:System.Threading.Mutex> representar o mesmo mutex nomeado, usando um construtor de objeto ou o <xref:System.Threading.Mutex.OpenExisting%2A> método, o Windows a segurança de controle de acesso é aplicada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-262">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="16cc7-263">Se o mutex nomeado já foi criado com a segurança de controle de acesso e o chamador não tem <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-263">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="16cc7-264">Para abrir um mutex nomeado com somente as permissões necessárias para sincronizar as atividades de thread existente, consulte o <xref:System.Threading.Mutex.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-264">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-265">Se você especificar `null` ou uma cadeia de caracteres vazia `name`, um mutex local é criado, como se você tivesse chamado o <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-265">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="16cc7-266">Nesse caso, `createdNew` é sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="16cc7-266">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="16cc7-267">Como elas são em todo o sistema, mutexes nomeados pode ser usados para coordenar o uso de recursos entre os limites do processo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-267">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="16cc7-268">Em um servidor que esteja executando serviços de Terminal, um mutex nomeado do sistema pode ter dois níveis de visibilidade.</span><span class="sxs-lookup"><span data-stu-id="16cc7-268">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="16cc7-269">Se o nome começa com o prefixo "Global\\", o mutex está visível em todas as sessões do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-269">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="16cc7-270">Se o nome começa com o prefixo "Local\\", o mutex está visível somente na sessão do terminal server no qual ele foi criado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-270">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="16cc7-271">Nesse caso, um mutex separado com o mesmo nome pode existir em cada uma das outras sessões do terminal server no servidor.</span><span class="sxs-lookup"><span data-stu-id="16cc7-271">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="16cc7-272">Se você não especificar um prefixo ao criar um mutex nomeado, ele usa o prefixo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="16cc7-272">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="16cc7-273">Dentro de uma sessão de servidor de terminal, dois mutexes cujos nomes diferem apenas por seus prefixos são mutexes separado e ambos são visíveis para todos os processos na sessão do terminal server.</span><span class="sxs-lookup"><span data-stu-id="16cc7-273">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="16cc7-274">Ou seja, os nomes de prefixo "Global\\" e "Local\\" descrevem o escopo do nome do mutex em relação a sessões do terminal server, não em relação a processos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-274">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="16cc7-275">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="16cc7-275">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="16cc7-276">O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-276">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="16cc7-277">Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-277">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-278">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-278">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="16cc7-279">A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-279">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="16cc7-280">Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-280">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="16cc7-281">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-281">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-282">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-282">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-283">O mutex nomeado existe e tem segurança de controle de acesso, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-283">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="16cc7-284">Não foi possível criar o mutex nomeado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-284">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-285">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-285">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-286">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-286">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-287">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-287">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="16cc7-288">Obtém um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança do controle de acesso para o mutex nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-288">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="16cc7-289">Um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança do controle de acesso para o mutex nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-289">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-290">O <xref:System.Threading.Mutex.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para pesquisar as permissões: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-290">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="16cc7-291">O usuário deve ter <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> chamar esse método e o mutex o deve ter sido aberto com <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-291">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="16cc7-292">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="16cc7-292">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="16cc7-293">O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-293">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="16cc7-294">Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-294">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-295">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-295">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="16cc7-296">A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões, usando o <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-296">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="16cc7-297">Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-297">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="16cc7-298">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-298">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-299">O objeto <see cref="T:System.Threading.Mutex" /> atual representa um mutex nomeado do sistema, mas o usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-299">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="16cc7-300">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-300">-or-</span>
          </span>
          <span data-ttu-id="16cc7-301">O objeto <see cref="T:System.Threading.Mutex" /> atual representa um mutex nomeado do sistema e não foi aberto com <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-301">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="16cc7-302">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-302">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="16cc7-303">Abre um mutex nomeado especificado, caso ele já exista.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-303">Opens a specified named mutex, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="16cc7-304">O nome do mutex do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-304">The name of the system mutex to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-305">Abre o mutex nomeado especificado, caso ele já exista.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-305">Opens the specified named mutex, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="16cc7-306">Um objeto que representa o mutex do sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-306">An object that represents the named system mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-307">O <xref:System.Threading.Mutex.OpenExisting%2A> método tenta abrir especificado o mutex do sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-307">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="16cc7-308">Se o mutex do sistema não existir, este método lança uma exceção em vez de criar o objeto do sistema.</span><span class="sxs-lookup"><span data-stu-id="16cc7-308">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="16cc7-309">Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="16cc7-309">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="16cc7-310">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-310">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-311">Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="16cc7-311">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="16cc7-312">Especificando o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread de espera no mutex e especificando as <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-312">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-313">Esse método não solicitar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-313">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="16cc7-314">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="16cc7-314">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="16cc7-315">O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-315">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="16cc7-316">Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-316">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-317">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-317">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="16cc7-318">A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-318">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="16cc7-319">Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-319">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="16cc7-320">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-320">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-321">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-321">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="16cc7-322">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-322">-or-</span>
          </span>
          <span data-ttu-id="16cc7-323">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-323">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="16cc7-324">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-324">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="16cc7-325">O mutex nomeado não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-325">The named mutex does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-326">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-326">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-327">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-327">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-328">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-328">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-329">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-329">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="16cc7-330">O nome do mutex do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-330">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="16cc7-331">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-331">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-332">Abre o mutex nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-332">Opens the specified named mutex, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="16cc7-333">Um objeto que representa o mutex do sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-333">An object that represents the named system mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-334">O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads de espera no mutex e o <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-334">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-335">O <xref:System.Threading.Mutex.OpenExisting%2A> método tenta abrir um mutex nomeado existente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-335">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="16cc7-336">Se o mutex do sistema não existir, este método lança uma exceção em vez de criar o objeto do sistema.</span><span class="sxs-lookup"><span data-stu-id="16cc7-336">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="16cc7-337">Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="16cc7-337">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="16cc7-338">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-338">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-339">Esse método não solicitar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-339">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="16cc7-340">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="16cc7-340">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="16cc7-341">O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-341">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="16cc7-342">Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-342">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-343">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-343">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="16cc7-344">A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-344">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="16cc7-345">Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-345">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="16cc7-346">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-346">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-347">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-347">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="16cc7-348">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-348">-or-</span>
          </span>
          <span data-ttu-id="16cc7-349">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-349">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="16cc7-350">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-350">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="16cc7-351">O mutex nomeado não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-351">The named mutex does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-352">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-352">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-353">O mutex nomeado existe, mas o usuário não tem o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-353">The named mutex exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-354">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-354">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-355">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-355">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="16cc7-356">Libera o <see cref="T:System.Threading.Mutex" /> uma vez.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-356">Releases the <see cref="T:System.Threading.Mutex" /> once.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-357">Sempre que um thread adquire um mutex (por exemplo, chamando seu <xref:System.Threading.WaitHandle.WaitOne%2A> método), ela deve chamar subsequentemente <xref:System.Threading.Mutex.ReleaseMutex%2A> para liberar a propriedade do mutex e desbloquear outros threads que tentam obter propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-357">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="16cc7-358">Se a tentativa de obter a propriedade do mutex falha (por exemplo, quando uma chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método com um `millisecondsTimeout` ou um `timeout` parâmetro retorna `false` porque a solicitação expira), o thread não deve chamar <xref:System.Threading.Mutex.ReleaseMutex%2A>, neste os casos, o thread deve também não ter permissão para acessar o recurso protegido pelo mutex, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="16cc7-358">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="16cc7-359">Um thread que possui um mutex pode especificar o mesmo mutex em chamadas de função repetidas espera sem bloquear a execução.</span><span class="sxs-lookup"><span data-stu-id="16cc7-359">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="16cc7-360">O número de chamadas é mantido pelo common language runtime.</span><span class="sxs-lookup"><span data-stu-id="16cc7-360">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="16cc7-361">O thread deve chamar <xref:System.Threading.Mutex.ReleaseMutex%2A> o mesmo número de vezes para liberar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-361">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-362">Se um thread é encerrado enquanto for proprietário de um mutex, será considerado o mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-362">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="16cc7-363">O estado do mutex é definido como sinalizado e o próxima thread em espera obtém a propriedade.</span><span class="sxs-lookup"><span data-stu-id="16cc7-363">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="16cc7-364">Se ninguém possui o mutex, o estado do mutex é sinalizado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-364">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="16cc7-365">Começando na versão 2.0 do .NET Framework, um <xref:System.Threading.AbandonedMutexException> é gerada no próximo thread que adquire o mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-365">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="16cc7-366">Antes da versão 2.0 do .NET Framework, nenhuma exceção foi lançada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-366">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="16cc7-367">Um mutex abandonado geralmente indica um erro grave no código.</span><span class="sxs-lookup"><span data-stu-id="16cc7-367">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="16cc7-368">Quando um thread é encerrado sem liberar o mutex, as estruturas de dados protegidas pelo mutex podem não ser em um estado consistente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-368">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="16cc7-369">O próximo thread a solicitar a propriedade do mutex pode tratar essa exceção e continuar, se a integridade das estruturas de dados pode ser verificada.</span><span class="sxs-lookup"><span data-stu-id="16cc7-369">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="16cc7-370">No caso de um mutex de todo o sistema, um mutex abandonado pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de Tarefas do Windows).</span><span class="sxs-lookup"><span data-stu-id="16cc7-370">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="16cc7-371">O exemplo a seguir mostra como um local <xref:System.Threading.Mutex> objeto é usado para sincronizar o acesso a um recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="16cc7-371">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="16cc7-372">O thread que cria o mutex não possui-lo inicialmente.</span><span class="sxs-lookup"><span data-stu-id="16cc7-372">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="16cc7-373">O <xref:System.Threading.Mutex.ReleaseMutex%2A> método é usado para liberar o mutex, quando ele não for mais necessário.</span><span class="sxs-lookup"><span data-stu-id="16cc7-373">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="16cc7-374">O thread de chamada não tem o mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-374">The calling thread does not own the mutex.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="16cc7-375">A instância atual já foi descartada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-375">The current instance has already been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="16cc7-376">Threading gerenciado</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-376">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">
          <span data-ttu-id="16cc7-377">Mutexes</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-377">Mutexes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">
          <span data-ttu-id="16cc7-378">Um objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa a segurança de controle de acesso a ser aplicada ao mutex de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-378">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-379">Define a segurança de controle de acesso para um mutex de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-379">Sets the access control security for a named system mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-380">O usuário deve ter <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> direitos para chamar esse método e o mutex devem ter sido abertos com <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-380">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="16cc7-381">O exemplo de código a seguir demonstra o comportamento de processo cruzado de um mutex nomeado com a segurança de controle de acesso.</span><span class="sxs-lookup"><span data-stu-id="16cc7-381">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="16cc7-382">O exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método para testar a existência de um mutex nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-382">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="16cc7-383">Se o mutex não existir, ele é criado com a propriedade inicial e a segurança de controle de acesso que impede que o usuário atual o direito de usar o mutex, mas concede o direito de ler e alterar as permissões no mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-383">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="16cc7-384">Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="16cc7-384">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="16cc7-385">A exceção é capturada e o exemplo usa o <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método para abrir o mutex com os direitos necessários para ler e alterar as permissões, usando o <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="16cc7-385">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="16cc7-386">Depois que as permissões forem alteradas, o mutex é aberto com os direitos necessários para inserir e liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-386">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="16cc7-387">Se você executar o exemplo compilado de uma terceira janela de comando, ele é executado usando as novas permissões.</span><span class="sxs-lookup"><span data-stu-id="16cc7-387">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="16cc7-388">
            <paramref name="mutexSecurity" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-388">
              <paramref name="mutexSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-389">O usuário não tem <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-389">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="16cc7-390">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-390">-or-</span>
          </span>
          <span data-ttu-id="16cc7-391">O mutex não foi aberto com <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-391">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="16cc7-392">O objeto <see cref="T:System.Threading.Mutex" /> atual não representa um mutex de sistema nomeado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-392">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="16cc7-393">Se um mutex nomeado especificado já existe, abre-o e retorna um valor que indica se a operação foi bem-sucedida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-393">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="16cc7-394">O nome do mutex do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-394">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="16cc7-395">Quando este método retorna, ele contém um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-395">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="16cc7-396">Esse parâmetro é tratado como não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-396">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-397">Abre o mutex nomeado especificado, quando ele já existe e retorna um valor que indica se a operação foi bem-sucedida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-397">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="16cc7-398">
            <see langword="true" /> se o mutex nomeado foi aberto com sucesso, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-398">
              <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-399">Se o mutex nomeado não existir, esse método não cria-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-399">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="16cc7-400">Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="16cc7-400">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="16cc7-401">Se você não tiver certeza se um mutex nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga de método que lança uma exceção se o mutex não existir.</span><span class="sxs-lookup"><span data-stu-id="16cc7-401">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="16cc7-402">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-402">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-403">Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="16cc7-403">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="16cc7-404">Especificando o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador permite que um thread de espera no mutex e especificando as <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-404">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-405">Esse método não solicitar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-405">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-406">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-406">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="16cc7-407">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-407">-or-</span>
          </span>
          <span data-ttu-id="16cc7-408">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-408">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="16cc7-409">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-409">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-410">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-410">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-411">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-411">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-412">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-412">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-413">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-413">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="16cc7-414">O nome do mutex do sistema a ser aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-414">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="16cc7-415">Uma combinação bit a bit dos valores de enumeração que representa o acesso de segurança desejado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-415">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="16cc7-416">Quando este método retorna, ele contém um objeto <see cref="T:System.Threading.Mutex" /> que representa o mutex nomeado se a chamada foi bem-sucedida ou <see langword="null" /> se a chamada falhou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-416">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="16cc7-417">Esse parâmetro é tratado como não inicializado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-417">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="16cc7-418">Se o mutex nomeado especificado já existe, abre-o com o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-418">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="16cc7-419">
            <see langword="true" /> se o mutex nomeado foi aberto com sucesso, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-419">
              <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="16cc7-420">Se o mutex nomeado não existir, esse método não cria-lo.</span><span class="sxs-lookup"><span data-stu-id="16cc7-420">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="16cc7-421">Para criar o mutex do sistema quando ele ainda não existir, use um dos <xref:System.Threading.Mutex.%23ctor%2A> construtores que tem um `name` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="16cc7-421">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="16cc7-422">Se você não tiver certeza se um mutex nomeado existe, use essa sobrecarga de método em vez do <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga de método que lança uma exceção se o mutex não existir.</span><span class="sxs-lookup"><span data-stu-id="16cc7-422">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="16cc7-423">O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> sinalizador para permitir que os threads de espera no mutex e o <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="16cc7-423">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="16cc7-424">Várias chamadas para esse método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Mutex> do objeto, mesmo que os objetos que são retornados representam o mesmo mutex de sistema nomeado.</span><span class="sxs-lookup"><span data-stu-id="16cc7-424">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="16cc7-425">Esse método não solicitar a propriedade do mutex.</span><span class="sxs-lookup"><span data-stu-id="16cc7-425">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="16cc7-426">
            <paramref name="name" /> é uma cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-426">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="16cc7-427">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-427">-or-</span>
          </span>
          <span data-ttu-id="16cc7-428">
            <paramref name="name" /> tem mais de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-428">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="16cc7-429">
            <paramref name="name" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-429">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="16cc7-430">Erro do Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-430">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="16cc7-431">O mutex nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-431">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="16cc7-432">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-432">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="16cc7-433">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="16cc7-433">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>