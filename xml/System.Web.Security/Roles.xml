<Type Name="Roles" FullName="System.Web.Security.Roles">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cad064b36e9a290c953de2f65314d8fef4aa3e1d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51935099" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Roles" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Roles extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.Roles" />
  <TypeSignature Language="VB.NET" Value="Public Class Roles" />
  <TypeSignature Language="C++ CLI" Value="public ref class Roles abstract sealed" />
  <TypeSignature Language="F#" Value="type Roles = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gerencia a associação do usuário em funções para verificação de autorização em um aplicativo ASP.NET. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gerenciamento de função do ASP.NET permite que você gerencie a autorização para seu aplicativo com base em grupos de usuários, conhecidos como funções. Atribuindo usuários a funções, você pode controlar o acesso a diferentes partes ou recursos do seu aplicativo Web com base na função em vez de, ou além, especificando a autorização com base no nome de usuário. Por exemplo, um aplicativo do funcionário pode ter funções como gerentes, funcionários, diretores e assim por diante, em que privilégios diferentes são especificados para cada função.  
  
 Os usuários podem pertencer a mais de uma função. Por exemplo, se seu site for um fórum de discussão, alguns usuários talvez na função de membros e os moderadores. Você pode definir cada função para ter privilégios diferentes no site, e um usuário que está em ambas as funções, em seguida, teria dois conjuntos de privilégios.  
  
 Para habilitar o gerenciamento de função para seu aplicativo ASP.NET, use o elemento da `system.web` seção no arquivo Web. config para seu aplicativo, conforme mostrado no exemplo a seguir.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
  <roleManager defaultProvider="SqlProvider"   
    enabled="true"  
    cacheRolesInCookie="true"  
    cookieName=".ASPROLES"  
    cookieTimeout="30"  
    cookiePath="/"  
    cookieRequireSSL="false"  
    cookieSlidingExpiration="true"  
    cookieProtection="All" >  
    <providers>  
      <add  
        name="SqlProvider"  
        type="System.Web.Security.SqlRoleProvider"  
        connectionStringName="SqlServices"  
        applicationName="SampleApplication" />  
      </providers>  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Você pode especificar regras de autorização no arquivo de configuração para seu aplicativo Web ou por meio de programação em seu código. Por exemplo, a seção a seguir de um arquivo Web. config exige que os usuários façam logon (pela negação de usuários anônimos) e, em seguida, permite que somente usuários na função de administradores tenham acesso.  
  
```  
<authorization>  
  <deny users="?" />  
  <allow roles="Administrators" />  
  <deny users="*" />  
</authorization>  
```  
  
 Se você usar o `authorization` seção no arquivo de Web. config do seu aplicativo para especificar a autorização baseada em funções, usuários do seu aplicativo deve fornecer uma identidade de usuário autenticado. Você pode autenticar usuários usando a autenticação do Windows ou formulários. Os usuários anônimos não podem ser atribuídos a uma função. Funções podem ser usadas independentemente de, ou em conjunto com o ASP.NET <xref:System.Web.Security.Membership> classes.  
  
 Para verificar a associação de função por meio de programação, você pode usar o <xref:System.Web.Security.Roles> classe ou o <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> propriedade com o <xref:System.Web.Security.Roles.IsUserInRole%2A> método, ou você pode usar os <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> propriedade com o <xref:System.Security.Principal.IPrincipal.IsInRole%2A?displayProperty=nameWithType> método. Para exemplo de código que verifica a associação de função programaticamente, consulte a seção de exemplo neste tópico.  
  
 O <xref:System.Web.Security.Roles> classe também permite que você criar e excluir funções e adicionar usuários ou remover usuários das funções.  
  
> [!NOTE]
>  Se você tiver configurado seu aplicativo para usar o <xref:System.Web.Security.WindowsTokenRoleProvider> classe, você não pode modificar as funções ou associação de função. O <xref:System.Web.Security.WindowsTokenRoleProvider> somente grupos de associação de classverifies na segurança do Windows. Nesse caso, você deve usar o gerenciamento de conta de usuário do Windows em vez de funções do ASP.NET para criar e excluir grupos e gerenciar a associação de grupo.  
  
 Você pode armazenar informações de função em várias fontes de dados.  
  
-   Você pode usar o <xref:System.Web.Security.WindowsTokenRoleProvider> classe para recuperar informações de função com base na associação em grupos do Windows.  
  
-   Você pode armazenar informações de função em um banco de dados do SQL Server usando o <xref:System.Web.Security.SqlRoleProvider> classe.  
  
-   Se você tiver informações de função existente, ou deseja armazenar as informações de função no e recuperar informações de função de uma fonte de dados que não sejam Windows, uma autorização Store ou do SQL Server, você pode implementar um provedor de função personalizada, criando uma classe que herda de <xref:System.Web.Security.RoleProvider> classe abstrata. Para obter mais informações, consulte [implementando um provedor de função](https://msdn.microsoft.com/library/851671ce-bf9b-43f2-aba4-bc9d28b11c7d).  
  
 Se o navegador do usuário aceitar cookies, você pode armazenar informações de função para que o usuário em um cookie no computador do usuário. Em cada solicitação de página, o ASP.NET lê as informações de função para o usuário do cookie. Isso pode melhorar o desempenho do aplicativo, reduzindo a quantidade de comunicação necessária com a fonte de dados para recuperar informações de função. Se as informações de função para um usuário são muito longos para armazenar em um cookie, o ASP.NET armazena apenas as informações de função usadas mais recentemente no cookie e, em seguida, procura informações de função adicionais na fonte de dados conforme necessário. Se o navegador do usuário não dá suporte a cookies ou cookies estão desabilitados, informações de função não é armazenado em cache em um cookie.  
  
 Você pode melhorar a confiabilidade dos nomes de função armazenados em cache em um cookie, especificando um <xref:System.Web.Security.Roles.CookieProtectionValue%2A> propriedade quando você configura funções do ASP.NET. O padrão <xref:System.Web.Security.Roles.CookieProtectionValue%2A> é `All`, que criptografa os nomes de função no cookie e valida que o conteúdo do cookie não foi alterado.  
  
   
  
## Examples  
 O exemplo a seguir mostra o arquivo Web. config para um aplicativo configurado para usar a associação do ASP.NET e funções do ASP.NET e usar o <xref:System.Web.Security.SqlRoleProvider> para armazenar informações de associação e funções em um banco de dados do SQL Server. Os usuários são autenticados com autenticação de formulários e somente os usuários na função de administradores podem acessar o aplicativo.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
    <authorization>  
      <deny users="?" />  
      <allow roles="Administrators" />  
      <deny users="*" />  
    </authorization>  
  
    <membership defaultProvider="AspNetSqlProvider" userIsOnlineTimeWindow="15">  
    </membership>  
  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="true"  
      cookieSlidingExpiration="true"  
      cookieProtection="All" >  
  
      <providers>  
        <clear />  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="SampleApplication" />  
        </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 O exemplo de código a seguir por meio de programação verifica se o logon do usuário está na função de administradores antes de permitir que o usuário exibir as funções a outros usuários.  
  
  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName="AddUsersToRole">
      <MemberSignature Language="C#" Value="public static void AddUsersToRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRole(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUsersToRole (usernames As String(), roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUsersToRole(cli::array &lt;System::String ^&gt; ^ usernames, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member AddUsersToRole : string[] * string -&gt; unit" Usage="System.Web.Security.Roles.AddUsersToRole (usernames, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário para adicionar à função especificada.</param>
        <param name="roleName">A função à qual adicionar os nomes de usuários especificados.</param>
        <summary>Adiciona os usuários especificados à função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUsersToRole%2A> método chama o provedor de função padrão para associar os usuários especificados com a função especificada na fonte de dados.  
  
 Se seu aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que já está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um ou mais usuários a uma função ou remove um usuário de uma função com base na entrada do usuário. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
- ou - 
Um dos elementos em <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
Um do elementos em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="usernames" /> contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddUsersToRoles">
      <MemberSignature Language="C#" Value="public static void AddUsersToRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUsersToRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUsersToRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member AddUsersToRoles : string[] * string[] -&gt; unit" Usage="System.Web.Security.Roles.AddUsersToRoles (usernames, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário para adicionar às funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de nomes de função à qual adicionar os nomes de usuário.</param>
        <summary>Adiciona os usuários especificados às funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUsersToRoles%2A> método chama o provedor de função padrão para associar os usuários especificados com as funções especificadas na fonte de dados.  
  
 Se seu aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que já está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um ou mais usuários a uma ou mais funções. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/adduserstorolescs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.Roles#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/adduserstorolesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções no <paramref name="roleNames" /> é <see langword="null" />.  
  
- ou - 
Um dos usuários no <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
Um do usuários em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="roleNames" /> contém um elemento duplicado.  
  
- ou - 
 <paramref name="usernames" /> contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRole">
      <MemberSignature Language="C#" Value="public static void AddUserToRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUserToRole (username As String, roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUserToRole(System::String ^ username, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member AddUserToRole : string * string -&gt; unit" Usage="System.Web.Security.Roles.AddUserToRole (username, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O nome de usuário a ser adicionado à função especificada.</param>
        <param name="roleName">A função a ser adicionada ao nome de usuário especificado.</param>
        <summary>Adiciona o usuário especificado à função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUserToRole%2A> método chama o provedor de função padrão para associar o usuário especificado com a função especificada na fonte de dados.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um usuário a uma função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.Roles#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.  
  
- ou - 
O usuário já foi atribuído à função especificada.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRoles">
      <MemberSignature Language="C#" Value="public static void AddUserToRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRoles(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUserToRoles (username As String, roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUserToRoles(System::String ^ username, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member AddUserToRoles : string * string[] -&gt; unit" Usage="System.Web.Security.Roles.AddUserToRoles (username, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">O nome de usuário a ser adicionado às funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de funções às quais adicionar os nomes de usuário especificados.</param>
        <summary>Adiciona o usuário especificado às funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUserToRoles%2A> método chama o provedor de função padrão para associar o usuário especificado com as funções especificadas na fonte de dados.  
  
 Se seu aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.Roles.AddUserToRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que já está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um usuário a uma ou mais funções. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolescs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.Roles#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolesvb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções no <paramref name="roleNames" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="roleNames" /> contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.Security.Roles.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do aplicativo no qual as informações de função serão armazenadas e recuperadas.</summary>
        <value>O nome do aplicativo no qual as informações de função serão armazenadas e recuperadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade é usada pelo <xref:System.Web.Security.Roles> classe para associar usuários e funções com diferentes aplicativos. Isso permite que vários aplicativos usam a mesma fonte de dados para armazenar informações de usuário e função sem encontrar conflitos entre nomes de usuários duplicados ou nomes de função duplicada. Vários aplicativos ASP.NET podem usar a mesma fonte de dados, especificando o mesmo valor no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade. Você pode definir as <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade por meio de programação, ou você pode defini-lo declarativamente no arquivo de configuração para o aplicativo Web usando o `applicationName` atributo.  
  
 Se seu aplicativo Web é usando o <xref:System.Web.Security.SqlRoleProvider> classe e um valor não for especificado para o `applicationName` atributo no arquivo de configuração, o <xref:System.Web.HttpRequest.ApplicationPath%2A?displayProperty=nameWithType> valor da propriedade atual <xref:System.Web.HttpContext.Request%2A?displayProperty=nameWithType> propriedade é usada.  
  
> [!CAUTION]
>  Como uma instância do provedor de função única padrão é usada para todas as solicitações atendidas por um <xref:System.Web.HttpApplication> do objeto, você pode ter várias solicitações em execução simultaneamente e tentar definir o <xref:System.Web.Security.Roles.ApplicationName%2A> valor da propriedade. O <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade não é thread-safe para várias gravações e alterar o <xref:System.Web.Security.Roles.ApplicationName%2A> valor da propriedade pode resultar em comportamento inesperado para vários usuários de um aplicativo. Você deve evitar escrever código para permitir que os usuários definam o <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade, a menos que necessário. Um exemplo de um aplicativo no qual a configuração o <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade pode ser necessária é um aplicativo administrativo que gerencia dados de função para vários aplicativos. Um aplicativo desse tipo deve ser um aplicativo de usuário único e não é um aplicativo Web.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o `applicationName` atributo `MyApplication`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CacheRolesInCookie">
      <MemberSignature Language="C#" Value="public static bool CacheRolesInCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CacheRolesInCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CacheRolesInCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CacheRolesInCookie As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CacheRolesInCookie { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheRolesInCookie : bool" Usage="System.Web.Security.Roles.CacheRolesInCookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se as funções do usuário atual são armazenadas em cache em um cookie.</summary>
        <value>
          <see langword="true" /> se as funções do usuário atual são armazenadas em cache em um cookie. Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> estiver definida como `true` no arquivo Web. config, informações de função para cada usuário são armazenadas em um cookie. Quando o gerenciamento de função verifica para ver se um usuário está em uma função específica, o cookie de funções é verificado antes do provedor de função é chamado para verificar a lista de funções na fonte de dados. O cookie é dinamicamente atualizado para armazenar em cache os nomes de função mais recentemente é validados.  
  
 Você pode melhorar a confiabilidade dos nomes de função armazenados em cache em um cookie, especificando um <xref:System.Web.Security.Roles.CookieProtectionValue%2A> propriedade quando você configura funções do ASP.NET. O padrão <xref:System.Web.Security.Roles.CookieProtectionValue%2A> é `All`, que criptografa os nomes de função no cookie e valida que o conteúdo do cookie não foi alterado.  
  
> [!NOTE]
>  Como os nomes de função podem ser armazenados em cache além da fonte de dados, é possível que as alterações para o gerenciamento de função na fonte de dados seriam refletidas nos valores armazenados em cache. Nesse caso, o usuário deve fechar e reabrir o navegador para limpar o valor do cookie em cache.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o `cacheRolesInCookie` atributo `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
   </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CookieName">
      <MemberSignature Language="C#" Value="public static string CookieName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookieName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookieName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieName : string" Usage="System.Web.Security.Roles.CookieName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do cookie em que os nomes de função são armazenados em cache.</summary>
        <value>O nome do cookie em que os nomes de função são armazenados em cache. O padrão é. ASPXROLES.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar o nome do cookie em que as funções são armazenadas em cache para seu aplicativo definindo o `cookieName` atributo no arquivo Web. config para seu aplicativo ASP.NET. Isso é útil quando você deseja identificar exclusivamente um cookie para o seu aplicativo ou quando um cookie é compartilhado entre vários aplicativos, como um cookie de domínio.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o `cookieName` atributo. ASPROLES.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CookiePath">
      <MemberSignature Language="C#" Value="public static string CookiePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookiePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookiePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookiePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookiePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookiePath : string" Usage="System.Web.Security.Roles.CookiePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho para o cookie de nomes de função em cache.</summary>
        <value>O caminho do cookie em que os nomes de função são armazenados em cache. O padrão é /.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar o caminho do cookie em que as funções são armazenadas em cache para seu aplicativo definindo o `cookiePath` atributo no arquivo Web. config para seu aplicativo ASP.NET. Para obter mais informações sobre caminhos de cookie, consulte <xref:System.Web.HttpCookie.Path%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o `cookiePath` /MyApplication do atributo.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CookieProtectionValue">
      <MemberSignature Language="C#" Value="public static System.Web.Security.CookieProtection CookieProtectionValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.Security.CookieProtection CookieProtectionValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieProtectionValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieProtectionValue As CookieProtection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::CookieProtection CookieProtectionValue { System::Web::Security::CookieProtection get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieProtectionValue : System.Web.Security.CookieProtection" Usage="System.Web.Security.Roles.CookieProtectionValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.CookieProtection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica como os nomes de função armazenados em cache em um cookie são protegidos.</summary>
        <value>Um do <see cref="T:System.Web.Security.CookieProtection" /> valores de enumeração que indica como os nomes de função são armazenados em cache em um cookie são protegidos. O padrão é <see langword="All" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar a proteção do cookie em que as funções são armazenadas em cache para seu aplicativo definindo o `cookieProtection` atributo no arquivo Web. config para seu aplicativo ASP.NET. O `cookieProtection` atributo utiliza um <xref:System.Web.Security.CookieProtection> valor de enumeração que indica se os nomes de função são criptografados, validado, ambos ou nenhum.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define `cookieProtection` atributo `Encrypted`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CookieRequireSSL">
      <MemberSignature Language="C#" Value="public static bool CookieRequireSSL { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieRequireSSL" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieRequireSSL" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieRequireSSL As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookieRequireSSL { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieRequireSSL : bool" Usage="System.Web.Security.Roles.CookieRequireSSL" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o cookie de nomes de função requer o SSL para ser retornado ao servidor.</summary>
        <value>
          <see langword="true" /> Se o SSL é necessário para retornar o cookie de nomes de função para o servidor. Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar se o SSL (Secure Sockets Layer) é necessário para retornar o cookie de nomes de função para o servidor em seu aplicativo definindo o `cookieRequireSSL` atributo no arquivo Web. config para seu aplicativo ASP.NET. Para obter mais informações, consulte <xref:System.Web.HttpCookie.Secure%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define `cookieRequireSSL` para `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CookieSlidingExpiration">
      <MemberSignature Language="C#" Value="public static bool CookieSlidingExpiration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieSlidingExpiration" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieSlidingExpiration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookieSlidingExpiration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieSlidingExpiration : bool" Usage="System.Web.Security.Roles.CookieSlidingExpiration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se a data e hora de expiração do cookie de nomes de função será redefinida periodicamente.</summary>
        <value>
          <see langword="true" /> Se a data de expiração do cookie de nomes de função e a hora serão redefinidos periodicamente; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar se nomes de funções de data de expiração do cookie e tempo será redefinido com cada resposta usando o `cookieSlidingExpiration` atributo no arquivo Web. config para seu aplicativo ASP.NET. Se `true`, a expiração do cookie será inicialmente definida como a data e hora atual mais o <xref:System.Web.Security.Roles.CookieTimeout%2A> em minutos. Embora o usuário continue a usar ativamente o aplicativo ASP.NET, a data de expiração do cookie serão atualizados automaticamente se houver menos da metade do <xref:System.Web.Security.Roles.CookieTimeout%2A> restantes. Para obter mais informações, consulte a propriedade <xref:System.Web.HttpCookie.Expires%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> propriedade `false`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="false"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CookieTimeout">
      <MemberSignature Language="C#" Value="public static int CookieTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CookieTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CookieTimeout { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieTimeout : int" Usage="System.Web.Security.Roles.CookieTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de minutos antes da expiração do cookie de funções.</summary>
        <value>Um inteiro que especifica o número de minutos antes da expiração do cookie de funções. O padrão é 30 minutos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.CookieTimeout%2A> propriedade é usada quando o <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> é de propriedade `true` e especifica o tempo de vida em minutos para que o cookie de funções. Para definir a <xref:System.Web.Security.Roles.CookieTimeout%2A> de valor, adicione o `cookieTimeout` de atributos para o elemento no arquivo Web. config para o aplicativo ASP.NET e especifique um valor inteiro.  
  
 Se <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> é `false`, essa propriedade será ignorada.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o <xref:System.Web.Security.Roles.CookieTimeout%2A> propriedade para 30 minutos.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
  <add  
    name="SqlProvider"  
    type="System.Web.Security.SqlRoleProvider"  
    connectionStringName="SqlServices"  
    applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersistentCookie">
      <MemberSignature Language="C#" Value="public static bool CreatePersistentCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CreatePersistentCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CreatePersistentCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CreatePersistentCookie As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CreatePersistentCookie { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CreatePersistentCookie : bool" Usage="System.Web.Security.Roles.CreatePersistentCookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o cookie de nomes de função é baseado em sessão ou persistente.</summary>
        <value>
          <see langword="true" /> se o cookie de nomes de função é um cookie persistente; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.CreatePersistentCookie%2A> valor da propriedade é definido na configuração de um aplicativo ASP.NET usando o `createPersistentCookie` atributo do elemento de configuração.  
  
 Quando `false`, o cookie de nomes de função é um cookie de sessão, ou seja, o cookie é perdido quando o navegador é fechado. Quando `true`, o cookie de nomes de função é um cookie persistente que está disponível em várias sessões do navegador. A data de expiração do cookie persistente e a hora estão definidas para a data e hora atual mais o <xref:System.Web.Security.Roles.CookieTimeout%2A> valor em minutos.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRole">
      <MemberSignature Language="C#" Value="public static void CreateRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.CreateRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateRole (roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member CreateRole : string -&gt; unit" Usage="System.Web.Security.Roles.CreateRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser criada.</param>
        <summary>Adiciona uma nova função à fonte de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.CreateRole%2A> método adiciona um nome de função à fonte de dados. <xref:System.Web.Security.Roles.CreateRole%2A> chamadas a <xref:System.Web.Security.RoleProvider.CreateRole%2A> método do provedor de função padrão para adicionar a função especificada para a fonte de dados.  
  
> [!NOTE]
>  Nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma nova função na fonte de dados. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia.  
  
- ou - 
 <paramref name="roleName" /> contém uma vírgula.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteCookie">
      <MemberSignature Language="C#" Value="public static void DeleteCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteCookie();" />
      <MemberSignature Language="F#" Value="static member DeleteCookie : unit -&gt; unit" Usage="System.Web.Security.Roles.DeleteCookie " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui o cookie em que os nomes de função são armazenados em cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.DeleteCookie%2A> método limpa o conteúdo do cookie que é usado para nomes de função em cache. Para obter mais informações sobre nomes de função de cache, consulte <xref:System.Web.Security.Roles.CacheRolesInCookie%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código chama o <xref:System.Web.Security.Roles.DeleteCookie%2A> método para limpar qualquer armazenados em cache os nomes de função quando um usuário fizer logon. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/logincs.aspx#5)]
 [!code-aspx-vb[System.Web.Security.Roles#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/loginvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteRole">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remove uma função da fonte de dados.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeleteRole (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeleteRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member DeleteRole : string -&gt; bool" Usage="System.Web.Security.Roles.DeleteRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser excluída.</param>
        <summary>Remove uma função da fonte de dados.</summary>
        <returns>
          <see langword="true" /> se <paramref name="roleName" /> tiver sido excluído da fonte de dados; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.DeleteRole%2A> método Remove um nome de função da fonte de dados. <xref:System.Web.Security.Roles.DeleteRole%2A> chamadas a <xref:System.Web.Security.RoleProvider.DeleteRole%2A> método do provedor de função padrão para remover a função especificada da fonte de dados.  
  
 Se a função identificada pelo `roleName` parâmetro tem um ou mais membros, em seguida, uma exceção será gerada e a função não será excluída.  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma função da fonte de dados. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" /> tem um ou mais membros.  
  
- ou - 
O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName, bool throwOnPopulatedRole) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeleteRole (roleName As String, throwOnPopulatedRole As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeleteRole(System::String ^ roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="F#" Value="static member DeleteRole : string * bool -&gt; bool" Usage="System.Web.Security.Roles.DeleteRole (roleName, throwOnPopulatedRole)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="throwOnPopulatedRole" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser excluída.</param>
        <param name="throwOnPopulatedRole">Se <see langword="true" />, gerará uma exceção se <c>roleName</c> tiver um ou mais membros.</param>
        <summary>Remove uma função da fonte de dados.</summary>
        <returns>
          <see langword="true" /> se <paramref name="roleName" /> tiver sido excluído da fonte de dados; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.DeleteRole%2A> método Remove um nome de função da fonte de dados. <xref:System.Web.Security.Roles.DeleteRole%2A> chamadas a <xref:System.Web.Security.RoleProvider.DeleteRole%2A> método do provedor de função padrão para remover a função especificada da fonte de dados.  
  
 Se `throwOnPopulatedRole` está `true`, em seguida, uma exceção será gerada e a função não será excluída se a função identificada pelo `roleName` parâmetro tem um ou mais membros. Se `throwOnPopulatedRole` é `false`, a função será excluído se ela estiver vazia ou não.  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma função da fonte de dados. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" /> tem um ou mais membros e <paramref name="throwOnPopulatedRole" /> é <see langword="true" />.  
  
- ou - 
O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public static string Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Domain { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string" Usage="System.Web.Security.Roles.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor do domínio do cookie de nomes de função.</summary>
        <value>O <see cref="P:System.Web.HttpCookie.Domain" /> do cookie de nomes de função.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.Domain%2A> valor da propriedade é definido na configuração de um aplicativo ASP.NET usando o `domain` atributo do elemento de configuração.  
  
 Se nenhum valor for especificado na configuração para o atributo de domínio, o <xref:System.Web.Security.Roles.Domain%2A> propriedade retorna `null` e o domínio do cookie de nomes de função padrão é o comportamento da <xref:System.Web.HttpCookie> <xref:System.Web.HttpCookie.Domain%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public static bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Web.Security.Roles.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o gerenciamento de função está habilitado para o aplicativo Web atual.</summary>
        <value>
          <see langword="true" /> Se o gerenciamento de função estiver habilitado; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o `enabled` atributo `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="FindUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] FindUsersInRole (string roleName, string usernameToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] FindUsersInRole(string roleName, string usernameToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.FindUsersInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindUsersInRole (roleName As String, usernameToMatch As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ FindUsersInRole(System::String ^ roleName, System::String ^ usernameToMatch);" />
      <MemberSignature Language="F#" Value="static member FindUsersInRole : string * string -&gt; string[]" Usage="System.Web.Security.Roles.FindUsersInRole (roleName, usernameToMatch)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="usernameToMatch" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">A função a ser pesquisada.</param>
        <param name="usernameToMatch">O nome de usuário a ser pesquisado.</param>
        <summary>Obtém uma lista de usuários em uma função especificada em que o nome de usuário contém o nome de usuário especificado a ser correspondido.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todos os usuários cujo nome de usuário corresponde a <paramref name="usernameToMatch" /> e que são membros da função especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.FindUsersInRole%2A> Retorna uma lista de usuários em uma função em que o nome de usuário contém uma correspondência de fornecido `usernameToMatch` configurado `applicationName`. Por exemplo, se o `usernameToMatch` parâmetro for definido como "usuário" e, em seguida, os usuários "Usuário1", "Usuário2", "usuário3", e assim por diante são retornados. Os usuários são retornados em ordem alfabética por nome de usuário.  
  
 O <xref:System.Web.Security.SqlRoleProvider> executa a pesquisa usando uma cláusula LIKE em relação a `usernameToMatch` parâmetro. Curingas que são suportados pelo SQL Server em como as cláusulas podem ser usadas no `usernameToMatch` valor do parâmetro.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.FindUsersInRole%2A> método para exibir a associação de função com base na entrada do usuário. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#11](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/FindUsersInRolecs.aspx#11)]
 [!code-aspx-vb[System.Web.Security.Roles#11](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/FindUsersInRolevb.aspx#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" /> (<see langword="Nothing" /> no Visual Basic).  
  
- ou - 
 <paramref name="usernameToMatch" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="usernameToMatch" /> é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllRoles">
      <MemberSignature Language="C#" Value="public static string[] GetAllRoles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetAllRoles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetAllRoles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllRoles () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetAllRoles();" />
      <MemberSignature Language="F#" Value="static member GetAllRoles : unit -&gt; string[]" Usage="System.Web.Security.Roles.GetAllRoles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma lista de todas as funções do aplicativo.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todas as funções armazenadas na fonte de dados do aplicativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetAllRoles%2A> chamadas de método a <xref:System.Web.Security.RoleProvider.GetAllRoles%2A?displayProperty=nameWithType> método do provedor de função padrão para obter uma lista de todas as funções da fonte de dados para um aplicativo. Somente as funções para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetAllRoles%2A> método para obter a lista de funções para um aplicativo e associar os resultados para um <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRolesForUser">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém uma lista das funções de que o usuário faz parte.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRolesForUser () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetRolesForUser();" />
      <MemberSignature Language="F#" Value="static member GetRolesForUser : unit -&gt; string[]" Usage="System.Web.Security.Roles.GetRolesForUser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma lista das funções nas quais o usuário conectado no momento está.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todas as funções nas quais o usuário conectado no momento está.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetRolesForUser%2A> chamadas de método a <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> as funções que o usuário conectado no momento está no método do provedor de função padrão para recuperar usando os dados da fonte. O usuário conectado no momento é identificado pelo <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedade do atual <xref:System.Web.HttpContext?displayProperty=nameWithType>, ou por <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> para não-HTTP ambientes de hospedagem. Se nenhum usuário estiver conectado, uma exceção será lançada. Somente as funções para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
 Se <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> está `true`, em seguida, os resultados do <xref:System.Web.Security.Roles.GetRolesForUser%2A> método pode ser retornado do cache de função em vez do provedor de função especificado.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetRolesForUser%2A> método para recuperar uma lista de funções para um usuário especificado e associar as funções retornadas para um <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Não há nenhum usuário conectado no momento.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser (string username);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser(string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRolesForUser (username As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetRolesForUser(System::String ^ username);" />
      <MemberSignature Language="F#" Value="static member GetRolesForUser : string -&gt; string[]" Usage="System.Web.Security.Roles.GetRolesForUser username" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O usuário para o qual será retornada uma lista de funções.</param>
        <summary>Obtém uma lista das funções de que o usuário faz parte.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todas as funções das quais o usuário especificado faz parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetRolesForUser%2A> chamadas de método a <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> as funções que o usuário está no método do provedor de função padrão para recuperar usando os dados da fonte. Somente as funções para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
 Se `username` é igual ao usuário atual conectado e <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> é `true`, os resultados da <xref:System.Web.Security.Roles.GetRolesForUser%2A> método pode ser retornado do cache de função em vez de especificado <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetRolesForUser%2A> método para recuperar uma lista de funções para um usuário especificado e associar as funções retornadas para um <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="username" /> contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] GetUsersInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetUsersInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetUsersInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUsersInRole (roleName As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetUsersInRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member GetUsersInRole : string -&gt; string[]" Usage="System.Web.Security.Roles.GetUsersInRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">A função para obter a lista de usuários.</param>
        <summary>Obtém uma lista de usuários na função especificada.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todos os usuários que são membros da função especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetUsersInRole%2A> chamadas de método a <xref:System.Web.Security.RoleProvider.GetUsersInRole%2A> método do provedor de função padrão para recuperar os nomes de usuário associados a uma função da fonte de dados. Somente as funções para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetUsersInRole%2A> método para obter uma lista de usuários em uma função específica e vincula os resultados para um <xref:System.Web.UI.WebControls.GridView> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUserInRole">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um valor que indica se o usuário especificado está na função especificada.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUserInRole (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUserInRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member IsUserInRole : string -&gt; bool" Usage="System.Web.Security.Roles.IsUserInRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser pesquisada.</param>
        <summary>Obtém um valor que indica se o usuário conectado no momento está na função especificada. A API é destinada a ser chamada apenas no contexto de um thread de solicitação do ASP.NET e, nesse caso de uso sancionado, é thread-safe.</summary>
        <returns>
          <see langword="true" /> se o usuário conectado no momento estiver na função especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.IsUserInRole%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.IsUserInRole%2A?displayProperty=nameWithType> método do provedor de função padrão para determinar se o usuário conectado no momento está associado uma função da fonte de dados para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade. O usuário conectado no momento é identificado pelo <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedade do atual <xref:System.Web.HttpContext?displayProperty=nameWithType>, ou por <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> para não-HTTP ambientes de hospedagem. Se nenhum usuário estiver conectado, uma exceção será lançada. Somente as funções para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
 Se <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> está `true`, em seguida, `roleName` podem ser verificados em relação o cache de funções em vez do provedor de função especificado.  
  
   
  
## Examples  
 O exemplo de código a seguir por meio de programação verifica se o usuário conectado no momento está na função de administradores antes de permitir que o usuário exibir as configurações de funções para o aplicativo. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
- ou - 
Não há nenhum usuário conectado no momento.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUserInRole (username As String, roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUserInRole(System::String ^ username, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member IsUserInRole : string * string -&gt; bool" Usage="System.Web.Security.Roles.IsUserInRole (username, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O nome do usuário a ser pesquisado.</param>
        <param name="roleName">O nome da função a ser pesquisada.</param>
        <summary>Obtém um valor que indica se o usuário especificado está na função especificada para a função especificada. A API é destinada a ser chamada apenas no contexto de um thread de solicitação do ASP.NET e, nesse caso de uso sancionado, é thread-safe.</summary>
        <returns>
          <see langword="true" /> se o usuário especificado estiver na função especificada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.IsUserInRole%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.IsUserInRole%2A> método do provedor de função padrão para determinar se um nome de usuário é associado a uma função da fonte de dados para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade.  
  
 Se `username` é igual ao usuário atual conectado e o <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> é o valor da propriedade `true`, `roleName` podem ser verificados em relação o cache de função em vez de especificado <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir por meio de programação verifica se um usuário está na função de administradores antes de permitir que o usuário exibir as configurações de funções para o aplicativo. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="username" /> contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MaxCachedResults">
      <MemberSignature Language="C#" Value="public static int MaxCachedResults { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxCachedResults" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.MaxCachedResults" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxCachedResults As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxCachedResults { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCachedResults : int" Usage="System.Web.Security.Roles.MaxCachedResults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número máximo de nomes de função a ser armazenado em cache para um usuário.</summary>
        <value>O número máximo de nomes de função a ser armazenado em cache para um usuário. O padrão é 25.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.MaxCachedResults%2A> propriedade é definida usando o `maxCachedResults` atributo de configuração. O valor da `maxCachedResults` atributo de configuração deve ser definido como um valor inteiro maior que zero.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento no `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e define o `maxCachedResults` de atributo para 10.  
  
```  
<roleManager  
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All"   
  maxCachedResults="10" />  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProvider Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProvider Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Provider" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Provider As RoleProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::RoleProvider ^ Provider { System::Web::Security::RoleProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Provider : System.Web.Security.RoleProvider" Usage="System.Web.Security.Roles.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o provedor de função padrão do aplicativo.</summary>
        <value>O provedor de função padrão do aplicativo, que é exposto como uma classe que herda a classe abstrata <see cref="T:System.Web.Security.RoleProvider" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.Provider%2A> propriedade permite que você referenciar diretamente o provedor de função padrão para um aplicativo. Isso é comumente usado para acessar membros do provedor de função personalizados que não são parte do <xref:System.Web.Security.RoleProvider> classe abstrata.  
  
 Por exemplo, o <xref:System.Web.Security.WindowsTokenRoleProvider> classe inclui uma sobrecarga da <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> método que permite que você determine se um usuário está em uma função comum do Windows usando um <xref:System.Security.Principal.WindowsBuiltInRole> valor de enumeração. Uma referência para o <xref:System.Web.Security.WindowsTokenRoleProvider> classe para um aplicativo pode ser obtido usando o <xref:System.Web.Security.Roles.Provider%2A> propriedade e pode ser convertido como um <xref:System.Web.Security.WindowsTokenRoleProvider> para fazer referência à <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> sobrecarregar.  
  
 Se vários provedores de função estiverem configurados para um aplicativo, você pode acessar os provedores de função diferente usando o <xref:System.Web.Security.Roles.Providers%2A> coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir converte o provedor de função padrão como um <xref:System.Web.Security.WindowsTokenRoleProvider> e verifica se o usuário conectado no momento está na função de administradores antes de permitir que o usuário exibir as configurações de funções para o aplicativo. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.WindowsTokenRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/CS/ViewRoles2cs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/VB/ViewRoles2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Providers" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Providers As RoleProviderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::RoleProviderCollection ^ Providers { System::Web::Security::RoleProviderCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Providers : System.Web.Security.RoleProviderCollection" Usage="System.Web.Security.Roles.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de provedores de função para o aplicativo ASP.NET.</summary>
        <value>Um <see cref="T:System.Web.Security.RoleProviderCollection" /> que contém os provedores de função configurados para o aplicativo ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.Providers%2A> propriedade faz referência a todos os provedores de função habilitados para um aplicativo, incluindo quaisquer provedores adicionados no arquivo Web. config. Você pode controlar qual função provedores estão disponíveis para um aplicativo usando o `providers` elemento da seção no arquivo Web. config para seu aplicativo.  
  
 O exemplo a seguir mostra uma seção que remove quaisquer provedores existentes (como aquelas especificadas no arquivo Machine. config) e adiciona um <xref:System.Web.Security.SqlRoleProvider> instância como o provedor de função para o aplicativo.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=MySqlServer;Integrated Security=SSPI;Initial Catalog=aspnetdb;" />  
  </connectionStrings>  
  
  <system.web>  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="false"  
      cookieSlidingExpiration="true"  
      cookieProtection="Encrypted">  
  
      <providers>  
        <clear/>  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="MyApplication" />  
         </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Você pode obter uma referência fortemente tipada para um provedor a partir de <xref:System.Web.Security.Roles.Providers%2A> coleção por indexação o provedor de função por nome e convertê-lo como o tipo desejado.  
  
 Você pode obter uma referência para o provedor padrão para um aplicativo usando o <xref:System.Web.Security.Roles.Provider%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir lista os provedores habilitados para um aplicativo e seus respectivos tipos.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/Providerscs.aspx#7)]
 [!code-aspx-vb[System.Web.Security.Roles#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/Providersvb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUserFromRole (username As String, roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUserFromRole(System::String ^ username, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member RemoveUserFromRole : string * string -&gt; unit" Usage="System.Web.Security.Roles.RemoveUserFromRole (username, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O usuário a ser removido da função especificada.</param>
        <param name="roleName">A função da qual o usuário especificado será removido.</param>
        <summary>Remove o usuário indicado da função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUserFromRole%2A> método chama o provedor de função padrão para remover o usuário especificado da função especificada na fonte de dados.  
  
   
  
## Examples  
 O exemplo de código a seguir remove um usuário de uma função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,) 
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRoles(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUserFromRoles (username As String, roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUserFromRoles(System::String ^ username, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member RemoveUserFromRoles : string * string[] -&gt; unit" Usage="System.Web.Security.Roles.RemoveUserFromRoles (username, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">O usuário a ser removido das funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de nomes de função os quais remover o usuário especificado.</param>
        <summary>Remove o usuário especificado das funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> método chama o provedor de função padrão para remover o usuário especificado das funções especificadas na fonte de dados.  
  
 Se o aplicativo está configurado para usar o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que não está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> método para remover um usuário de uma ou mais funções. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUserFromRolescs.aspx#10)]
 [!code-aspx-vb[System.Web.Security.Roles#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUserFromRolesvb.aspx#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções no <paramref name="roleNames" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="roleNames" /> contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRole(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUsersFromRole (usernames As String(), roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUsersFromRole(cli::array &lt;System::String ^&gt; ^ usernames, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member RemoveUsersFromRole : string[] * string -&gt; unit" Usage="System.Web.Security.Roles.RemoveUsersFromRole (usernames, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário a remover das funções especificadas.</param>
        <param name="roleName">O nome da função da qual remover os usuários especificados.</param>
        <summary>Remove os usuários especificados da função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> método chama o provedor de função padrão para remover os usuários especificados da função especificada na fonte de dados.  
  
 Se o aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que não está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> método para remover um ou mais usuários de uma função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolecs.aspx#9)]
 [!code-aspx-vb[System.Web.Security.Roles#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolevb.aspx#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
- ou - 
Um dos nomes de um usuário em <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
Um dos nomes de usuário em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="usernames" /> contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUsersFromRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUsersFromRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member RemoveUsersFromRoles : string[] * string[] -&gt; unit" Usage="System.Web.Security.Roles.RemoveUsersFromRoles (usernames, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário a remover das funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de nomes de função os quais remover os usuários especificados.</param>
        <summary>Remove os nomes de usuário especificados das funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> método chama o provedor de função padrão para remover os usuários especificados das funções especificadas na fonte de dados.  
  
 Se o aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que não está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> método para remover um ou mais usuários de uma ou mais funções com base na entrada do usuário. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolescs.aspx#8)]
 [!code-aspx-vb[System.Web.Security.Roles#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolesvb.aspx#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções especificadas em <paramref name="roleNames" /> é <see langword="null" />.  
  
- ou - 
Um dos usuários especificados em <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções especificadas em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
Um dos usuários especificados em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
- ou - 
 <paramref name="roleNames" /> contém um elemento duplicado.  
  
- ou - 
 <paramref name="usernames" /> contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RoleExists">
      <MemberSignature Language="C#" Value="public static bool RoleExists (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RoleExists(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RoleExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RoleExists (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool RoleExists(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member RoleExists : string -&gt; bool" Usage="System.Web.Security.Roles.RoleExists roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função pela qual pesquisar na fonte de dados.</param>
        <summary>Obtém um valor que indica se o nome da função especificada já existe na fonte de dados de função.</summary>
        <returns>
          <see langword="true" /> se o nome da função já existir na fonte de dados; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RoleExists%2A> chamadas de método de `RoleExists` método do provedor de função padrão para determinar se um nome de função existe na fonte de dados para o aplicativo que é especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RoleExists%2A> método para determinar se um nome de função já existe antes de criar a função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" /> (<see langword="Nothing" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/a0d2f19d-a2a7-496d-88b6-30133f8ea3d6">Noções básicas sobre gerenciamento de função ASP.NET</related>
      </Docs>
    </Member>
  </Members>
</Type>