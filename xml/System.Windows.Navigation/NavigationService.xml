<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d4d64e95223ead25be6eb0a447e2f5dd78e82b25" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36465077" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contains methods, properties, and events to support navigation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> encapsula a capacidade de baixar o conteúdo dentro do contexto de navegação de um estilo de navegador.  
  
 Conteúdo pode ser qualquer tipo de objeto do .NET Framework e arquivos HTML. Em geral, no entanto, páginas são preferenciais como o modo de conteúdo do pacote para navegação (consulte <xref:System.Windows.Controls.Page>).  
  
 Conteúdo pode ser navegado, fornecendo uma instância de um objeto e chamar uma sobrecarga de <xref:System.Windows.Navigation.NavigationService.Navigate%2A> método que aceita um objeto:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 Como alternativa, conteúdo pode ser navegado, passando um URI relativo ou absoluto para uma da <xref:System.Windows.Navigation.NavigationService.Navigate%2A> sobrecargas do método que aceita um URI:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 Quando o conteúdo é navegado por URI, <xref:System.Windows.Navigation.NavigationService> retornará um objeto que contém o conteúdo.  
  
 O tempo de vida de uma navegação pode ser controlado por meio de eventos a seguir:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>.  
  
 Nem todos os eventos são gerados sempre que ocorra uma navegação; o conjunto de eventos que são gerados é determinado pelo tipo de navegação que ocorre (fragmento de conteúdo ou conteúdo) e como a navegação é concluída (cancelada, interrompido ou falha).  
  
 A figura a seguir ilustra a sequência na qual esses eventos são gerados:  
  
 ![Gráfico de fluxo de navegação de página](~/add/media/navigationoverviewfigure11.png "gráfico de fluxo de navegação de página")  
  
 Durante ou após uma navegação <xref:System.Windows.Navigation.NavigationService> fornece informações sobre o conteúdo que está sendo navegado, incluindo o URI do conteúdo que está sendo navegado (<xref:System.Windows.Navigation.NavigationService.Source%2A>), o URI do conteúdo atual (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>) e um objeto que contém o conteúdo que foi direcionado (<xref:System.Windows.Navigation.NavigationService.Content%2A>).  
  
 Quando o conteúdo é direcionado, <xref:System.Windows.Navigation.NavigationService> registra a navegação como uma entrada no histórico de navegação. Uma entrada é adicionada para fazer o histórico de navegação quando ocorre uma nova navegação, chamando o <xref:System.Windows.Navigation.NavigationService.Navigate%2A> método, ou navegando para uma entrada no histórico de navegação de avanço, chamando <xref:System.Windows.Navigation.NavigationService.GoForward%2A>. Uma entrada é adicionada ao histórico de navegação de avanço, navegando para uma entrada no histórico de navegação, chamando <xref:System.Windows.Navigation.NavigationService.GoBack%2A>. <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> e <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> relatar se há entradas no e o histórico de navegação de avanço, respectivamente. Além disso, a entrada mais recente no histórico de navegação pode ser removido chamando <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>.  
  
 Por padrão, <xref:System.Windows.Navigation.NavigationService> não armazene uma instância de um objeto de conteúdo no histórico de navegação. Em vez disso, <xref:System.Windows.Navigation.NavigationService> cria uma nova instância do objeto conteúdo de cada vez que ele é para onde navegar usando o histórico de navegação. Esse comportamento é projetado para evitar o consumo excessivo de memória quando grandes números e grandes partes do conteúdo estão sendo navegados. Consequentemente, o estado do conteúdo não será lembrado na barra de uma navegação para a próxima. No entanto, o WPF fornece várias técnicas que você pode armazenar uma parte do estado de uma parte do conteúdo no histórico de navegação.  
  
 Usando <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, lembre-se também vários conjuntos de estado para uma instância única página.  
  
 <xref:System.Windows.Navigation.NavigationService> é um `sealed` classe e, portanto, não pode ser instanciado; em vez disso, <xref:System.Windows.Navigation.NavigationService> é usado por navegadores para permitir a navegação. No WPF, há dois navegadores: <xref:System.Windows.Navigation.NavigationWindow> e <xref:System.Windows.Controls.Frame>.  
  
 Visualmente, [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] usar [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] como um navegador, para fornecer uma experiência de usuário integrada. Fisicamente, no entanto, [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] usam de fato <xref:System.Windows.Navigation.NavigationWindow> como o navegador; o <xref:System.Windows.Application.MainWindow%2A> propriedade de um [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] em execução no [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] retornará uma referência para o <xref:System.Windows.Navigation.NavigationWindow>e o histórico de navegação que é gerenciado pela <xref:System.Windows.Navigation.NavigationWindow> é integrado com o histórico de navegação que é gerenciado pelo [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] das seguintes maneiras:  
  
-   Quando o conteúdo é navegar até chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, e <xref:System.Windows.Navigation.NavigationService.GoForward%2A> de dentro um [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] as entradas de histórico de navegação relevantes também são adicionadas ao [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] histórico de navegação.  
  
-   Quando as entradas na [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] forem selecionadas, [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] faz com que <xref:System.Windows.Navigation.NavigationService> navegar de volta ou encaminha para o conteúdo que está associado essas entradas.  
  
> [!NOTE]
>  Um <xref:System.Windows.Controls.Frame> pode fornecer seu próprio histórico de navegação, ou usar o histórico de navegação do navegador que o hospeda. Se <xref:System.Windows.Controls.Frame> fornece seu próprio histórico de navegação, ele pode exibir sua própria navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] para navegar por meio de entradas no histórico de navegação; essas entradas não são adicionadas ao histórico de navegação do navegador de host (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) e, consequentemente, não pode ser acessada de painel de navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de cada (consulte <xref:System.Windows.Controls.Frame.JournalOwnership%2A>).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Navigation.CustomContentState" /> object that represents application-defined state that is associated with a specific piece of content.</param>
        <summary>Adds an entry to back navigation history that contains a <see cref="T:System.Windows.Navigation.CustomContentState" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, <xref:System.Windows.Navigation.CustomContentState>, e <xref:System.Windows.Navigation.IProvideCustomContentState> são usados para ajudar a lembrar vários conjuntos de estado para o conteúdo atual.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" /> is <see langword="null" />, and a <see cref="T:System.Windows.Navigation.CustomContentState" /> object isn't returned from <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" />.</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether there is at least one entry in back navigation history.</summary>
        <value>
          <see langword="true" /> se houver pelo menos uma entrada no histórico de navegação. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> para determinar se há pelo menos uma entrada no histórico de navegação. Essa propriedade deverá ser inspecionada antes de chamar <xref:System.Windows.Navigation.NavigationService.GoBack%2A>; se <xref:System.Windows.Navigation.NavigationService.GoBack%2A> é chamado e não existem entradas no histórico de navegação, um <xref:System.InvalidOperationException> é gerada.  
  
> [!NOTE]
>  que se o histórico de navegação é compartilhado por vários navegadores (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), a maioria dos entrada recente no histórico de navegação pode não ter sido adicionado pelo <xref:System.Windows.Navigation.NavigationService> para o navegador atual.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether there is at least one entry in forward navigation history.</summary>
        <value>
          <see langword="true" /> Se houver pelo menos uma entrada no histórico de navegação de avanço; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> para determinar se há pelo menos uma entrada no histórico de navegação de avanço. Essa propriedade deverá ser inspecionada antes de chamar <xref:System.Windows.Navigation.NavigationService.GoForward%2A>; se <xref:System.Windows.Navigation.NavigationService.GoForward%2A> é chamado e não existem entradas no histórico de navegação de avanço, um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a reference to the object that contains the current content.</summary>
        <value>Um objeto que é uma referência para o objeto que contém o conteúdo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conteúdo pode ser definido em uma das duas maneiras:  
  
-   Diretamente, definindo-o para uma referência a um objeto.  
  
-   Indiretamente, chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, ou <xref:System.Windows.Navigation.NavigationService.GoForward%2A>.  
  
 Configuração <xref:System.Windows.Navigation.NavigationService> inicia uma nova navegação; como navegação é assíncrona, <xref:System.Windows.Navigation.NavigationService.Content%2A> não retorna um valor se ele é inspecionado imediatamente depois que está sendo definido.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the URI of the content that was last navigated to.</summary>
        <value>Um <see cref="T:System.Uri" /> para o conteúdo que foi acessado pela última, se navegada usando um URI; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> propriedade não será alterada até que a navegação para um URI diferente foi concluída com êxito.  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> pode ser definido com um URI somente fragmento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when navigation to a content fragment begins, which occurs immediately, if the desired fragment is in the current content, or after the source [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] content has been loaded, if the desired fragment is in different content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, um fragmento de conteúdo é conteúdo que é contido por um conjunto nomeado <xref:System.Windows.UIElement>, que é um <xref:System.Windows.UIElement> cujo <xref:System.Windows.FrameworkElement.Name%2A> atributo for definido, por exemplo:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 Navegue até um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] fragmento, fornecendo um URI com um sufixo no seguinte formato:  
  
 \#*FragmentName*  
  
 O exemplo a seguir mostra um exemplo de um URI que faz referência a um fragmento de conteúdo:  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 Depois que a página de origem é carregada (após <xref:System.Windows.Navigation.NavigationService.LoadCompleted> é gerado), começa a navegação de fragmento e <xref:System.Windows.Navigation.NavigationService> tenta localizar o [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fragmento. Se o [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fragmento for encontrado, <xref:System.Windows.Navigation.NavigationService> instrui o navegador de conteúdo (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) para mostrar o fragmento. Se você precisar alterar esse comportamento, você pode manipular <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para fornecer seu próprio comportamento de navegação de fragmento. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> é passado um <xref:System.Windows.Navigation.FragmentNavigationEventArgs> parâmetro que expõe propriedades que são úteis para essa finalidade, incluindo:  
  
-   O navegador que possui este serviço de navegação (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   O nome do fragmento.  
  
 Você pode manipular <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para substituir a implementação padrão de fragmento WPF com sua própria implementação personalizada. Se você fizer isso, você precisará definir <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> para `true`; caso contrário, o fragmento WPF padrão comportamento de processamento é aplicado.  
  
 Você deve evitar iniciar diretamente a navegação de dentro um <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> manipulador de eventos. Como <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> é gerado durante uma navegação existente, iniciando uma nova navegação de um <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> manipulador de eventos cria uma navegação aninhada que pode causar o <xref:System.ExecutionEngineException> seja gerada. Em vez disso, você pode iniciar indiretamente navegação criando um trabalho assíncrono usando o item de <xref:System.Windows.Threading.Dispatcher>.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> gera <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>, ele também gera <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> evento sobre o <xref:System.Windows.Application> objeto.  
  
> [!IMPORTANT]
>  Navegação de fragmento não há suporte para perder [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] páginas (somente marcação [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivos com `Page` como elemento raiz) nos seguintes casos:  
>   
>  • Ao navegar para um fragmento em um flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página.  
>   
>  • Durante a navegação de um flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página a um fragmento em outro flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página.  
>   
>  No entanto, um flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página pode navegar para seus próprios fragmentos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para fornecer um comportamento de navegação de fragmento personalizado. Nesse caso, o exemplo abre um erro [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] página se o fragmento na fonte [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] página não foi encontrada.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">The <see cref="T:System.Windows.DependencyObject" /> in content that is hosted by a navigator.</param>
        <summary>Gets a reference to the <see cref="T:System.Windows.Navigation.NavigationService" /> for the navigator whose content contains the specified <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A reference to the <see cref="T:System.Windows.Navigation.NavigationService" /> for the navigator whose content contains the specified <see cref="T:System.Windows.DependencyObject" />; can be <see langword="null" /> in some cases.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um navegador possui um <xref:System.Windows.Navigation.NavigationService> que manipula a navegação de conteúdo. WPF tem dois navegadores: <xref:System.Windows.Navigation.NavigationWindow> e <xref:System.Windows.Controls.Frame>. Para processar solicitações de navegação e gerenciar o tempo de vida de navegação, um navegador usa o serviço de navegação do WPF, que é implementado como o <xref:System.Windows.Navigation.NavigationService> classe. Conteúdo que é hospedado por um navegador pode obter uma referência para o navegador <xref:System.Windows.Navigation.NavigationService> chamando o <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> método.  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> Retorna `null` quando o `dependencyObject`:  
  
-   É um <xref:System.Windows.Navigation.NavigationWindow>.  
  
-   É um <xref:System.Windows.Controls.Frame> que:  
  
    1.  É hospedado por outro navegador.  
  
    2.  Tem seu <xref:System.Windows.Controls.Frame.JournalOwnership%2A> propriedade definida como <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>.  
  
-   Não é parte do conteúdo que é hospedado por um navegador.  
  
 WPF oferece dois atalhos para adquirir uma referência para o <xref:System.Windows.Navigation.NavigationService>:  
  
-   O <xref:System.Windows.Navigation.NavigationService> que processado a navegação para um <xref:System.Windows.Controls.Page> pode ser acessado a partir de <xref:System.Windows.Controls.Page> próprio obtendo o valor de seu <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> propriedade.  
  
-   O <xref:System.Windows.Navigation.NavigationService> que é usado por um <xref:System.Windows.Controls.Frame> processar navegação pode ser acessado por obter o valor da <xref:System.Windows.Controls.Frame.NavigationService%2A> propriedade.  
  
   
  
## Examples  
 A exemplo a seguir mostra como um <xref:System.Windows.Controls.UserControl> pode recuperar um serviço de navegação chamando <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>.  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="dependencyObject" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigates to the most recent entry in back navigation history, if there is one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de chamar <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, o <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> propriedade pode ser inspecionada para determinar se há entradas no histórico de navegação.  
  
   
  
## Examples  
 O exemplo a seguir navega para a entrada mais recente no histórico de navegação, se houver.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> is called when there are no entries in back navigation history.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navigate to the most recent entry in forward navigation history, if there is one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de chamar <xref:System.Windows.Navigation.NavigationService.GoForward%2A>, o <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> propriedade pode ser inspecionada para determinar se há entradas no histórico de navegação de avanço.  
  
   
  
## Examples  
 O exemplo a seguir navega para a entrada mais recente no histórico de navegação de avanço, se houver.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Navigation.NavigationService.GoForward" /> is called when there are no entries in forward navigation history.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when content that was navigated to has been loaded, parsed, and has begun rendering.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Manipular <xref:System.Windows.Navigation.NavigationService.LoadCompleted> se você precisar descobrir informações pertinentes sobre a solicitação de navegação após a conclusão do carregamento. Essas informações estão disponíveis do <xref:System.Windows.Navigation.NavigationEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.LoadCompleted> manipulador de eventos e inclui:  
  
-   O conteúdo e seu URI.  
  
-   O navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Dados adicionais, se a navegação foi iniciada chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ou <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Detalhes da resposta (usando um <xref:System.Net.WebResponse> objeto).  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> não é gerado quando a página de código-fonte não pode ser encontrada ou carregada, caso em que <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é gerado.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> gera <xref:System.Windows.Navigation.NavigationService.LoadCompleted>, ele também gera <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> evento sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.LoadCompleted>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navigate asynchronously to the specified source content.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">An object that contains the content to navigate to.</param>
        <summary>Navigate asynchronously to content that is contained by an object.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> navegará para a <xref:System.Object> especificado por `root` se as seguintes condições forem verdadeiras:  
  
-   O <xref:System.Windows.Navigation.NavigationService.Navigating> evento não foi cancelado.  
  
-   Uma solicitação da web (consulte <xref:System.Windows.Navigation.NavigationService.Navigating>) pode ser criado.  
  
 Se `root` é `null`, o conteúdo existente (<xref:System.Windows.Navigation.NavigationService.Content%2A>) está desmarcada.  
  
> [!NOTE]
>  Ao baixar o conteúdo da Web, você receberá uma exceção da Web (por exemplo, 404: arquivo não encontrado). Você pode tratar essas exceções de <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como navegar até um <xref:System.Windows.Controls.Page> objeto que contém a árvore de conteúdo de origem.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Uri" /> object initialized with the URI for the desired content.</param>
        <summary>Navigate asynchronously to content that is specified by a URI.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de `source` pode ser uma Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] ou um URI de pacote válido (consulte [URIs de pacote no WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> navegará para o URI especificado por `source` se as seguintes condições forem verdadeiras:  
  
-   O <xref:System.Windows.Navigation.NavigationService.Navigating> evento não foi cancelado.  
  
-   Uma solicitação da web (consulte <xref:System.Windows.Navigation.NavigationService.Navigating>) pode ser criado.  
  
 Se `source` é `null`, o conteúdo existente (<xref:System.Windows.Navigation.NavigationService.Content%2A>) está desmarcada.  
  
> [!NOTE]
>  Ao baixar o conteúdo da Web, você receberá uma exceção da Web (por exemplo, 404: arquivo não encontrado). Você pode tratar essas exceções de <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 Você pode usar <xref:System.Windows.Navigation.NavigationService.Navigate%2A> para navegar até um fragmento de conteúdo. Se o conteúdo identificado pelo URI é o conteúdo atual, ele não será baixado novamente.  
  
   
  
## Examples  
 O exemplo a seguir mostra como navegar para um URI.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">An object that contains the content to navigate to.</param>
        <param name="navigationState">An object that contains data to be used for processing during navigation.</param>
        <summary>Navigate asynchronously to content that is contained by an object, and pass an object that contains data to be used for processing during navigation.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método tem o mesmo comportamento que <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, embora um objeto é passado em vez de um URI.  
  
   
  
## Examples  
 O exemplo a seguir mostra como navegar até um <xref:System.Windows.Controls.Page> do objeto que contém o conteúdo de origem e passar o estado de navegação.  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Uri" /> object initialized with the URI for the desired content.</param>
        <param name="navigationState">An object that contains data to be used for processing during navigation.</param>
        <summary>Navigate asynchronously to source content located at a URI, and pass an object that contains data to be used for processing during navigation.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como navegações são assíncronas, é possível que várias navegações para estar em andamento ao mesmo tempo. Por exemplo, se houver dois quadros filho em uma única página, ambos os quadros podem navegar. Nesse caso, os vários eventos de navegação que são gerados pelo <xref:System.Windows.Navigation.NavigationService> pode ser gerada várias vezes, uma para cada parte do conteúdo que está sendo navegado, e não necessariamente para que as navegações foram solicitadas. Consequentemente, se precisar de uma solicitação de navegação específico processar os dados que são específicos para a solicitação individual, ele não pode usar dados que estão disponíveis para todas as solicitações de navegação. Em vez disso, você pode usar `navigationState` para passar dados para navegação de processamento que é específica para a solicitação de navegação de um.  
  
 Os argumentos de evento a seguir fornecem acesso ao estado de navegação:  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (passado para o <xref:System.Windows.Navigation.NavigationService.Navigating> evento).  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (passado para o <xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted> manipuladores de eventos).  
  
   
  
## Examples  
 O exemplo a seguir demonstra navegando para um URI e passar o estado de navegação.  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">A <see cref="T:System.Uri" /> object initialized with the URI for the desired content.</param>
        <param name="navigationState">An object that contains data to be used for processing during navigation.</param>
        <param name="sandboxExternalContent">Download content into a partial trust security sandbox (with the default Internet zone set of permissions, if <see langword="true" />. The default is <see langword="false" />.</param>
        <summary>Navigate asynchronously to source content located at a URI, pass an object containing navigation state for processing during navigation, and sandbox the content.</summary>
        <returns>
          <see langword="true" /> if a navigation is not canceled; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é somente para aplicativos autônomos e [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] conteúdo.  
  
 Esse método apresenta o mesmo comportamento que <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, e amplia, garantindo que o conteúdo que está sendo carregado é colocado em uma área restrita de confiança parcial (com o conjunto de zona de Internet padrão de permissões - consulte [confiança parcial do WPF Segurança](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the content that is being navigated to has been found, and is available from the <see cref="P:System.Windows.Navigation.NavigationService.Content" /> property, although it may not have completed loading.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Manipular <xref:System.Windows.Navigation.NavigationService.Navigated> se você precisar descobrir informações pertinentes sobre a solicitação de navegação ao fazer o download começa. Essas informações estão disponíveis do <xref:System.Windows.Navigation.NavigationEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.Navigated> manipulador de eventos e inclui:  
  
-   A página de código-fonte. Quando <xref:System.Windows.Navigation.NavigationService.Navigated> é gerado, pelo menos parte da página de código-fonte [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] árvore foi analisada e anexada a um controle de conteúdo de destino.  
  
-   O URI solicitado.  
  
-   O navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Dados adicionais, se a navegação foi iniciada chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ou <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Detalhes da resposta (usando um <xref:System.Net.WebResponse> objeto).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> não é gerado quando a página de código-fonte não pode ser encontrada ou carregada, caso em que <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é gerado.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> gera <xref:System.Windows.Navigation.NavigationService.NavigationFailed>, ele também gera <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> evento sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.Navigated>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a new navigation is requested.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> é gerado quando uma nova navegação é solicitada, mas antes da fonte de conteúdo for solicitado, incluindo quando:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%2A> é chamado.  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> ou <xref:System.Windows.Navigation.NavigationService.GoForward%2A> é chamado (ou uma entrada está selecionada na barra de navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]).  
  
-   Navega para um fragmento de conteúdo.  
  
 Manipular <xref:System.Windows.Navigation.NavigationService.Navigating> se você precisar descobrir informações pertinentes sobre a solicitação de navegação antes do início da navegação. Essas informações estão disponíveis do <xref:System.Windows.Navigation.NavigatingCancelEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.Navigating> manipulador de eventos.  
  
 Um <xref:System.Net.WebRequest> do objeto para a navegação é criado e está disponível na <xref:System.Windows.Navigation.NavigatingCancelEventArgs> parâmetro; porque a solicitação real ainda não foram feita neste ponto, você pode reconfigurar o <xref:System.Net.WebRequest> do objeto, se necessário.  
  
 Você também tratar <xref:System.Windows.Navigation.NavigatingCancelEventArgs> para cancelar a navegação, se necessário, definindo <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> como true. Se você cancelar a navegação, nenhum outro evento de navegação é gerado.  
  
> [!NOTE]
>  Se seu aplicativo for hospedado no navegador, você não pode impedir que o usuário navegar para fora de seu aplicativo, cancelando o <xref:System.Windows.Navigation.NavigationService.Navigating> evento.  
  
 Depois que a primeira parte do conteúdo é navegada por um navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), cada parte do conteúdo é navegado para fora é adicionado ao histórico de navegação. Se você precisar salvar informações de estado sobre o conteúdo que você está navegando longe do, você pode adicionar o estado para a entrada do diário para esse conteúdo definindo <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> com um <xref:System.Windows.Navigation.CustomContentState> objeto.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> gera <xref:System.Windows.Navigation.NavigationService.Navigating>, ele também gera <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> evento sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.Navigating> para detectar se foi feita uma solicitação para atualizar o conteúdo estático e, nesse caso, para cancelar a solicitação.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an error occurs while navigating to the requested content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando tanto uma <xref:System.Net.WebException> ou um <xref:System.IO.IOException> é lançada durante a navegação, a <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é gerado. <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é passado um <xref:System.Windows.Navigation.NavigationFailedEventArgs> que encapsula informações sobre a exceção e os detalhes do painel de navegação que causou a exceção.  
  
 Quando uma exceção resulta de uma falha na navegação e é sem tratamento, os seguintes eventos são gerados na ordem listada:  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> ou <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 Se um navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) é hospedado por um ou mais navegadores `NavigationFailed` não é gerado em qualquer um deles.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs periodically during a download to provide navigation progress information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> é passado um <xref:System.Windows.Navigation.NavigationProgressEventArgs> que expõe as seguintes informações de progresso:  
  
-   Número de bytes baixados até o momento (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>).  
  
-   Número total de bytes para download (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>).  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> é gerado uma vez para cada 1024 bytes do conteúdo baixado e mais uma vez se o número de bytes restantes é sempre menor que 1024 bytes. Por esse motivo, tratamento <xref:System.Windows.Navigation.NavigationService.NavigationProgress> fornece uma maneira útil de controlar e exibir o andamento de um download atual.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> não será criado em alguns casos, como quando a mesma parte do conteúdo é direcionada, ou quando um fragmento de conteúdo é para onde navegar no conteúdo que está atualmente carregado (ou seja, o valor da <xref:System.Windows.Navigation.NavigationService.Content%2A> propriedade).  
  
 Ao navegar para um recurso XAML compilado, o último <xref:System.Windows.Navigation.NavigationService.NavigationProgress> evento não pode ser gerado. Isso significa que, ao final do download, o último relatado <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> valor não pode ser igual a <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> valor. Manipular o <xref:System.Windows.Navigation.NavigationService.LoadCompleted> evento para ser notificado quando a navegação foi concluída.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> gera <xref:System.Windows.Navigation.NavigationService.NavigationProgress>, ele também gera <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> evento sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.NavigationProgress>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> method is called, or when a new navigation is requested while a current navigation is in progress.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Manipular <xref:System.Windows.Navigation.NavigationService.NavigationStopped> se desejar descobrir informações pertinentes sobre a solicitação de navegação quando o download é interrompido. Essas informações estão disponíveis do <xref:System.Windows.Navigation.NavigationEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.NavigationStopped> manipulador de eventos e inclui:  
  
-   O URI solicitado.  
  
-   O navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Dados adicionais, se a navegação foi iniciada chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> ou <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> gera <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, ele também gera <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> evento sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como tratar <xref:System.Windows.Navigation.NavigationService.NavigationStopped>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reloads the current content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o conteúdo atual (especificado pelo valor da <xref:System.Windows.Navigation.NavigationService.Source%2A> propriedade) é direcionada novamente, <xref:System.Windows.Navigation.NavigationService> não baixa o conteúdo novamente. Para forçar <xref:System.Windows.Navigation.NavigationService> para navegar novamente para o conteúdo, chame <xref:System.Windows.Navigation.NavigationService.Refresh%2A>.  
  
 Observe que, se o conteúdo atual é direcionado novamente, ao chamar <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ou <xref:System.Windows.Navigation.NavigationService.Refresh%2A>, uma nova entrada não é adicionada ao histórico de navegação.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes the most recent journal entry from back history.</summary>
        <returns>The most recent <see cref="T:System.Windows.Navigation.JournalEntry" /> in back navigation history, if there is one.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se dois ou mais navegadores (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) compartilham o mesmo histórico de navegação, um navegador pode usar <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> para recuperar a entrada do histórico de navegação para uma navegação que ocorreu em outro navegador.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the URI of the current content, or the URI of new content that is currently being navigated to.</summary>
        <value>Um <see cref="T:System.Uri" /> que contém o URI para o conteúdo atual ou o conteúdo que está atualmente sendo navegado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você definir essa propriedade como um URI diferente daquela que está sendo exibido no momento, o navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) navega para o URI especificado.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> é definido como o conteúdo que é carregado do URI que é acessada, a menos que a navegação é cancelada.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> pode ser definido com um URI somente fragmento e pode ser definido como `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops further downloading of content for the current navigation request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> pode ser chamado, assim como <xref:System.Windows.Navigation.NavigationService.Navigate%2A> retorna e deixa de navegação que está em andamento em quadros filho.  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 Chamando o <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> método gera o <xref:System.Windows.Navigation.NavigationService.NavigationStopped> evento.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> deve ser chamado no mesmo thread que iniciou a navegação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como interromper o carregamento.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>