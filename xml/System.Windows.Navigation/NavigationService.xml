<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ada487929a3270b8b3a3f316486ea10531a71ff1" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39762281" /></Metadata><TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contém métodos, propriedades e eventos para dar suporte à navegação.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> encapsula a capacidade de baixar o conteúdo dentro do contexto de uma navegação de estilo de navegador.  
  
 Conteúdo pode ser qualquer tipo de objeto do .NET Framework e arquivos HTML. Em geral, no entanto, as páginas são preferenciais como a maneira de empacotar conteúdo para navegação (consulte <xref:System.Windows.Controls.Page>).  
  
 Conteúdo pode ser navegado, fornecendo uma instância de um objeto e chamando uma sobrecarga da <xref:System.Windows.Navigation.NavigationService.Navigate%2A> método que aceita um objeto:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 Como alternativa, conteúdo pode ser navegado, passando um URI relativo ou absoluto para um do <xref:System.Windows.Navigation.NavigationService.Navigate%2A> sobrecargas de método que aceita um URI:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 Quando o conteúdo é acessado pelo URI, <xref:System.Windows.Navigation.NavigationService> retornará um objeto que contém o conteúdo.  
  
 O tempo de vida de uma navegação pode ser controlado por meio de eventos a seguir:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>.  
  
 Nem todos os eventos são acionados sempre que ocorra uma navegação; o conjunto de eventos que são gerados é determinado pelo tipo de navegação que ocorre (fragmento de conteúdo ou conteúdo) e como a navegação for concluída (cancelada, parado ou falha).  
  
 A figura a seguir ilustra a sequência na qual esses eventos são gerados:  
  
 ![Fluxograma de navegação de página](~/add/media/navigationoverviewfigure11.png "fluxograma de navegação de página")  
  
 Durante ou após uma navegação <xref:System.Windows.Navigation.NavigationService> fornece informações sobre o conteúdo que está sendo navegado, incluindo o URI do conteúdo de navegação (<xref:System.Windows.Navigation.NavigationService.Source%2A>), o URI do conteúdo atual (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>) e um objeto que contém o conteúdo que foi acessado (<xref:System.Windows.Navigation.NavigationService.Content%2A>).  
  
 Quando o conteúdo é navegado, <xref:System.Windows.Navigation.NavigationService> registra a navegação como uma entrada no histórico de navegação. Uma entrada é adicionada ao histórico de navegação de volta quando ocorre uma nova navegação, chamando o <xref:System.Windows.Navigation.NavigationService.Navigate%2A> método, ou navegando para uma entrada no histórico de Navegação progressiva, chamando <xref:System.Windows.Navigation.NavigationService.GoForward%2A>. Uma entrada é adicionada ao histórico de Navegação progressiva, navegando até uma entrada no histórico de navegação, chamando <xref:System.Windows.Navigation.NavigationService.GoBack%2A>. <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> e <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> relatar se há entradas novamente e o histórico de Navegação progressiva, respectivamente. Além disso, a entrada mais recente no histórico de navegação pode ser removido por meio da chamada <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>.  
  
 Por padrão, <xref:System.Windows.Navigation.NavigationService> não armazena uma instância de um objeto de conteúdo no histórico de navegação. Em vez disso, <xref:System.Windows.Navigation.NavigationService> cria uma nova instância do objeto de conteúdo de cada vez que ele é navegado usando o histórico de navegação. Esse comportamento foi desenvolvido para evitar o consumo excessivo de memória quando grandes números e grandes partes de conteúdo estão sendo navegadas. Consequentemente, o estado do conteúdo não foi memorizado no painel de navegação de um para o próximo. No entanto, o WPF fornece várias técnicas pelas quais você pode armazenar uma parte do estado para uma parte do conteúdo no histórico de navegação.  
  
 Usando <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, lembre-se também vários conjuntos de estado para uma instância de página única.  
  
 <xref:System.Windows.Navigation.NavigationService> é um `sealed` de classe e, portanto, não pode ser instanciada; em vez disso, <xref:System.Windows.Navigation.NavigationService> é usado por navegadores para permitir a navegação. No WPF, há dois navegadores: <xref:System.Windows.Navigation.NavigationWindow> e <xref:System.Windows.Controls.Frame>.  
  
 Visualmente, [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] usar [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] como um navegador, para fornecer uma experiência integrada de usuário. Fisicamente, no entanto, [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] , na verdade, usar <xref:System.Windows.Navigation.NavigationWindow> como o navegador; o <xref:System.Windows.Application.MainWindow%2A> propriedade de um [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] em execução no [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] retornará uma referência para o <xref:System.Windows.Navigation.NavigationWindow>e o histórico de navegação que é gerenciado pelo <xref:System.Windows.Navigation.NavigationWindow> é integrado com o histórico de navegação que é gerenciado pelo [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] das seguintes maneiras:  
  
-   Quando conteúdo é acessado chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, e <xref:System.Windows.Navigation.NavigationService.GoForward%2A> de dentro um [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] as entradas de histórico de navegação relevantes também são adicionadas ao [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] histórico de navegação.  
  
-   Quando as entradas na [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] forem selecionadas, [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] faz com que <xref:System.Windows.Navigation.NavigationService> para navegar de volta ou encaminhará para o conteúdo que está associado essas entradas.  
  
> [!NOTE]
>  Um <xref:System.Windows.Controls.Frame> pode fornecer seu próprio histórico de navegação, ou usar o histórico de navegação do navegador que o hospeda. Se <xref:System.Windows.Controls.Frame> fornece seu próprio histórico de navegação, ele pode exibir sua própria navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] para navegar pelas entradas no histórico de navegação; essas entradas não são adicionadas ao histórico de navegação do navegador de host (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) e, consequentemente, não podem ser navegados na barra de navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de cada (consulte <xref:System.Windows.Controls.Frame.JournalOwnership%2A>).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">Um objeto <see cref="T:System.Windows.Navigation.CustomContentState" /> que representa o estado definido pelo aplicativo associado um conteúdo específico.</param>
        <summary>Adiciona uma entrada ao histórico de navegação pregresso que contém um objeto <see cref="T:System.Windows.Navigation.CustomContentState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, <xref:System.Windows.Navigation.CustomContentState>, e <xref:System.Windows.Navigation.IProvideCustomContentState> são usados para ajudar a lembrar de vários conjuntos de estado para o conteúdo atual.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="state" /> é <see langword="null" /> e um objeto <see cref="T:System.Windows.Navigation.CustomContentState" /> não é retornado de <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" />.</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se há pelo menos uma entrada no histórico de navegação.</summary>
        <value><see langword="true" /> se houver pelo menos uma entrada no histórico de navegação. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> para determinar se há pelo menos uma entrada no histórico de navegação. Essa propriedade deve ser examinada antes de chamar <xref:System.Windows.Navigation.NavigationService.GoBack%2A>; se <xref:System.Windows.Navigation.NavigationService.GoBack%2A> é chamado e não existem entradas no histórico de navegação, uma <xref:System.InvalidOperationException> é gerada.  
  
> [!NOTE]
>  que se o histórico de navegação é compartilhado por vários navegadores (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), a maioria dos entrada recente novamente histórico de navegação pode não ter sido adicionado pelo <xref:System.Windows.Navigation.NavigationService> para o navegador atual.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se há pelo menos uma entrada no histórico de navegação progressivo.</summary>
        <value><see langword="true" /> Se houver pelo menos uma entrada no histórico de Navegação progressiva; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> para determinar se há pelo menos uma entrada no histórico de Navegação progressiva. Essa propriedade deve ser examinada antes de chamar <xref:System.Windows.Navigation.NavigationService.GoForward%2A>; se <xref:System.Windows.Navigation.NavigationService.GoForward%2A> é chamado e não existem entradas no histórico de navegação de avanço, um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma referência ao objeto que contém o conteúdo atual.</summary>
        <value>Um objeto que é uma referência ao objeto que contém o conteúdo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conteúdo pode ser definido em uma das duas maneiras:  
  
-   Diretamente, definindo-a como uma referência a um objeto.  
  
-   Indiretamente, chamando <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, ou <xref:System.Windows.Navigation.NavigationService.GoForward%2A>.  
  
 Definindo <xref:System.Windows.Navigation.NavigationService> inicia uma nova navegação; pois a navegação é assíncrona, <xref:System.Windows.Navigation.NavigationService.Content%2A> não retornará um valor se ele é inspecionado imediatamente após a que está sendo definido.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI do conteúdo para o qual se navegou por último.</summary>
        <value>Um <see cref="T:System.Uri" /> para o conteúdo que foi acessado pela última vez, se navegou por meio de um URI; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> propriedade não é alterada até que a navegação para um URI diferente foi concluída com êxito.  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> pode ser definido com um URI somente fragmento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a navegação para um fragmento de conteúdo começar, o que ocorre imediatamente caso o fragmento desejado esteja no conteúdo atual ou então, se o fragmento desejado estiver em outro conteúdo, ocorre após o conteúdo da fonte [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ter sido carregado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, um fragmento de conteúdo é conteúdo que é contido por um nomeada <xref:System.Windows.UIElement>, que é um <xref:System.Windows.UIElement> cuja <xref:System.Windows.FrameworkElement.Name%2A> atributo for definido, por exemplo:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 Navegue até um [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] fragmento, fornecendo um URI com um sufixo no seguinte formato:  
  
 \#*FragmentName*  
  
 O exemplo a seguir mostra um exemplo de um URI que faz referência a um fragmento de conteúdo:  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 Depois que a página de código-fonte for carregada (após <xref:System.Windows.Navigation.NavigationService.LoadCompleted> é gerado), começa a navegação de fragmento e a <xref:System.Windows.Navigation.NavigationService> tenta localizar o [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fragmento. Se o [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] é encontrado, fragmento <xref:System.Windows.Navigation.NavigationService> instrui o navegador de conteúdo (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) para mostrar o fragmento. Se você precisar alterar esse comportamento, você pode manipular <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para fornecer seu próprio comportamento de navegação de fragmento. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> é passado um <xref:System.Windows.Navigation.FragmentNavigationEventArgs> parâmetro que expõe propriedades que são úteis para essa finalidade, incluindo:  
  
-   O navegador que possui este serviço de navegação (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   O nome do fragmento.  
  
 Você pode manipular <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para substituir a implementação padrão de fragmento WPF com sua própria implementação personalizada. Se você fizer isso, você precisará definir <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> para `true`; caso contrário, o fragmento do WPF padrão comportamento de processamento é aplicado.  
  
 Você deve evitar iniciar diretamente a navegação de dentro um <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> manipulador de eventos. Uma vez que <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> é gerado durante uma navegação existente, iniciando uma nova navegação de um <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> manipulador de eventos cria uma navegação aninhada que pode causar o <xref:System.ExecutionEngineException> seja lançada. Em vez disso, você pode iniciar indiretamente a navegação, criando um trabalho assíncrono usando o item a <xref:System.Windows.Threading.Dispatcher>.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> aciona <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>, ele também gera <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> eventos sobre o <xref:System.Windows.Application> objeto.  
  
> [!IMPORTANT]
>  Navegação de fragmento não é suportada para perder [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] páginas (somente marcação [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivos com `Page` como o elemento raiz) nos seguintes casos:  
>   
>  • Durante a navegação para um fragmento em um flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página.  
>   
>  • Durante a navegação de um flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página para um fragmento em outro flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página.  
>   
>  No entanto, um flexível [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] página pode navegar para seus próprios fragmentos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> para fornecer um comportamento de navegação de fragmento personalizado. Nesse caso, o exemplo abre um erro [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] se o fragmento na fonte de [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] página não foi encontrada.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">O <see cref="T:System.Windows.DependencyObject" /> no conteúdo que é hospedado por um navegador.</param>
        <summary>Obtém uma referência ao <see cref="T:System.Windows.Navigation.NavigationService" /> do navegador cujo conteúdo contém o <see cref="T:System.Windows.DependencyObject" /> especificado.</summary>
        <returns>Uma referência ao <see cref="T:System.Windows.Navigation.NavigationService" /> do navegador cujo conteúdo contém o <see cref="T:System.Windows.DependencyObject" /> especificado; pode ser <see langword="null" /> em alguns casos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um navegador tem um <xref:System.Windows.Navigation.NavigationService> que manipula a navegação de conteúdo. O WPF tem dois navegadores: <xref:System.Windows.Navigation.NavigationWindow> e <xref:System.Windows.Controls.Frame>. Para processar solicitações de navegação e gerenciar o tempo de vida de navegação, um navegador usa o serviço de navegação do WPF, que é implementado como o <xref:System.Windows.Navigation.NavigationService> classe. Conteúdo que é hospedado por um navegador pode obter uma referência para o navegador <xref:System.Windows.Navigation.NavigationService> chamando o <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> método.  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> Retorna `null` quando o `dependencyObject`:  
  
-   É um <xref:System.Windows.Navigation.NavigationWindow>.  
  
-   É um <xref:System.Windows.Controls.Frame> que:  
  
    1.  É hospedado por outro navegador.  
  
    2.  Tem seu <xref:System.Windows.Controls.Frame.JournalOwnership%2A> propriedade definida como <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>.  
  
-   Não é parte do conteúdo que é hospedado por um navegador.  
  
 O WPF oferece dois atalhos para adquirir uma referência para o <xref:System.Windows.Navigation.NavigationService>:  
  
-   O <xref:System.Windows.Navigation.NavigationService> que processado a navegação para um <xref:System.Windows.Controls.Page> podem ser acessados da <xref:System.Windows.Controls.Page> próprio obtendo o valor de seu <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> propriedade.  
  
-   O <xref:System.Windows.Navigation.NavigationService> que é usado por um <xref:System.Windows.Controls.Frame> processar navegação pode ser acessados pela obtenção do valor da <xref:System.Windows.Controls.Frame.NavigationService%2A> propriedade.  
  
   
  
## Examples  
 A exemplo a seguir mostra como uma <xref:System.Windows.Controls.UserControl> pode recuperar um serviço de navegação chamando <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>.  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="dependencyObject" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navega para a entrada mais recente do histórico de navegação de retorno, se houver.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de chamar <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, o <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> propriedade pode ser inspecionada para determinar se há entradas no histórico de navegação.  
  
   
  
## Examples  
 O exemplo a seguir navega para a entrada mais recente no histórico de navegação, se houver um.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> é chamado quando não existem entradas no histórico de navegação de retorno.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Navegue para a entrada mais recente do histórico de navegação de avanço, se houver.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de chamar <xref:System.Windows.Navigation.NavigationService.GoForward%2A>, o <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> propriedade pode ser inspecionada para determinar se existem entradas no histórico de navegação de avanço.  
  
   
  
## Examples  
 O exemplo a seguir navega para a entrada mais recente no histórico de navegação de avanço, se houver.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Windows.Navigation.NavigationService.GoForward" /> é chamado quando não existem entradas no histórico de navegação de avanço.</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o conteúdo para o qual se navegou foi carregado, analisado e iniciou a renderização.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você lida com <xref:System.Windows.Navigation.NavigationService.LoadCompleted> se você precisar descobrir informações pertinentes sobre a solicitação de navegação após a conclusão do carregamento. Essas informações estão disponíveis a partir de <xref:System.Windows.Navigation.NavigationEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.LoadCompleted> manipulador de eventos e inclui:  
  
-   O conteúdo e seu URI.  
  
-   O navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Dados adicionais, se a navegação foi iniciada com uma chamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ou <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Detalhes da resposta (usando um <xref:System.Net.WebResponse> objeto).  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> não é gerado quando a página de código-fonte não pode ser encontrada ou carregada, caso em que <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é gerado.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> aciona <xref:System.Windows.Navigation.NavigationService.LoadCompleted>, ele também gera <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> eventos sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.LoadCompleted>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Navegue de maneira assíncrona para o conteúdo de origem especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">Um objeto que contém o conteúdo para navegação.</param>
        <summary>Navegue de forma assíncrona para o conteúdo contido por um objeto.</summary>
        <returns><see langword="true" /> se uma navegação não tiver sido cancelada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> navegará para a <xref:System.Object> especificado pelo `root` se as seguintes condições forem verdadeiras:  
  
-   O <xref:System.Windows.Navigation.NavigationService.Navigating> evento não for cancelado.  
  
-   Uma solicitação da web (consulte <xref:System.Windows.Navigation.NavigationService.Navigating>) pode ser criado.  
  
 Se `root` está `null`, o conteúdo existente (<xref:System.Windows.Navigation.NavigationService.Content%2A>) está desmarcada.  
  
> [!NOTE]
>  Ao baixar o conteúdo da Web, você poderá receber uma exceção da Web (por exemplo, 404: arquivo não encontrado). Você pode manipular essas exceções de <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como navegar até um <xref:System.Windows.Controls.Page> objeto que contém a árvore de conteúdo de origem.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">Um objeto <see cref="T:System.Uri" /> inicializado com o URI para o conteúdo desejado.</param>
        <summary>Navegue de maneira assíncrona para o conteúdo que é especificado por um URI.</summary>
        <returns><see langword="true" /> se uma navegação não tiver sido cancelada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de `source` pode ser uma Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] ou um URI de pacote válido (consulte [URIs de pacote no WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> navegará para o URI especificado por `source` se as seguintes condições forem verdadeiras:  
  
-   O <xref:System.Windows.Navigation.NavigationService.Navigating> evento não for cancelado.  
  
-   Uma solicitação da web (consulte <xref:System.Windows.Navigation.NavigationService.Navigating>) pode ser criado.  
  
 Se `source` está `null`, o conteúdo existente (<xref:System.Windows.Navigation.NavigationService.Content%2A>) está desmarcada.  
  
> [!NOTE]
>  Ao baixar o conteúdo da Web, você poderá receber uma exceção da Web (por exemplo, 404: arquivo não encontrado). Você pode manipular essas exceções de <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 Você pode usar <xref:System.Windows.Navigation.NavigationService.Navigate%2A> para navegar até um fragmento de conteúdo. Se o conteúdo identificado pelo URI é o conteúdo atual, ele não será baixado novamente.  
  
   
  
## Examples  
 O exemplo a seguir mostra como navegar até um URI.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">Um objeto que contém o conteúdo para navegação.</param>
        <param name="navigationState">Um objeto que contém os dados a serem usados para processamento durante a navegação.</param>
        <summary>Navegue de forma assíncrona o conteúdo contido por um objeto e passe um objeto que contém dados a serem usados para processamento durante a navegação.</summary>
        <returns><see langword="true" /> se uma navegação não tiver sido cancelada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método tem o mesmo comportamento que <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, embora um objeto é passado em vez de um URI.  
  
   
  
## Examples  
 O exemplo a seguir mostra como navegar até um <xref:System.Windows.Controls.Page> do objeto que contém o conteúdo de origem e a transferência de estado de navegação.  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Um objeto <see cref="T:System.Uri" /> inicializado com o URI para o conteúdo desejado.</param>
        <param name="navigationState">Um objeto que contém os dados a serem usados para processamento durante a navegação.</param>
        <summary>Navegue de forma assíncrona para o conteúdo de origem localizado em um URI e passe um objeto que contém dados que serão usados para processamento durante a navegação.</summary>
        <returns><see langword="true" /> se uma navegação não tiver sido cancelada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como as navegações são assíncronas, é possível que vários navegações para estar em andamento ao mesmo tempo. Por exemplo, se houver dois quadros filho em uma única página, os dois quadros podem navegar. Nesse caso, os diversos eventos de navegação que são gerados por <xref:System.Windows.Navigation.NavigationService> pode ser gerada várias vezes, uma para cada parte do conteúdo que está sendo navegado e não necessariamente para que as navegações foram solicitadas. Consequentemente, se precisar de uma solicitação de navegação particular processar dados que são específicos para a solicitação individual, ele não é possível usar dados que estão disponíveis para todas as solicitações de navegação. Em vez disso, você pode usar `navigationState` para passar dados para navegação de processamento que é específica para a solicitação de navegação de um.  
  
 Os seguintes argumentos de evento fornecem acesso ao estado de navegação:  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (passado para o <xref:System.Windows.Navigation.NavigationService.Navigating> evento).  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (passado para o <xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted> manipuladores de eventos).  
  
   
  
## Examples  
 O exemplo a seguir demonstra navegando até um URI e passar o estado de navegação.  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Um objeto <see cref="T:System.Uri" /> inicializado com o URI para o conteúdo desejado.</param>
        <param name="navigationState">Um objeto que contém os dados a serem usados para processamento durante a navegação.</param>
        <param name="sandboxExternalContent">Baixe o conteúdo para uma área restrita de confiança parcial (com o conjunto de permissões padrão da zona da Internet), se <see langword="true" />. O padrão é <see langword="false" />.</param>
        <summary>Navegue de maneira assíncrona para conteúdo de origem localizado em um URI, passe um objeto que contém o estado de navegação para processamento durante a navegação e coloque o conteúdo na área restrita.</summary>
        <returns><see langword="true" /> se uma navegação não tiver sido cancelada; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é somente para aplicativos autônomos e [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] conteúdo.  
  
 Esse método apresenta o mesmo comportamento que <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, e a estende, garantindo que o conteúdo que está sendo baixado é colocado em uma área restrita de confiança parcial (com o conjunto de zona de Internet padrão de permissões - consulte [confiança parcial do WPF Segurança](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o conteúdo para o qual se está navegando foi encontrado e está disponível na propriedade <see cref="P:System.Windows.Navigation.NavigationService.Content" />, embora ele talvez não tenha concluído o carregamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você lida com <xref:System.Windows.Navigation.NavigationService.Navigated> se você precisar descobrir informações pertinentes sobre a solicitação de navegação quando o download começa. Essas informações estão disponíveis a partir de <xref:System.Windows.Navigation.NavigationEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.Navigated> manipulador de eventos e inclui:  
  
-   A página de código-fonte. Quando <xref:System.Windows.Navigation.NavigationService.Navigated> é acionado, pelo menos parte da página de código-fonte [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] árvore foi analisado e anexado ao controle de conteúdo de destino.  
  
-   O URI solicitado.  
  
-   O navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Dados adicionais, se a navegação foi iniciada com uma chamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ou <xref:System.Windows.Navigation.NavigationService.Navigate%2A>.  
  
-   Detalhes da resposta (usando um <xref:System.Net.WebResponse> objeto).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> não é gerado quando a página de código-fonte não pode ser encontrada ou carregada, caso em que <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é gerado.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> aciona <xref:System.Windows.Navigation.NavigationService.NavigationFailed>, ele também gera <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> eventos sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.Navigated>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma nova navegação é solicitada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> é gerado quando uma nova navegação é solicitada, mas antes da fonte de conteúdo for solicitado, inclusive quando:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%2A> é chamado.  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> ou <xref:System.Windows.Navigation.NavigationService.GoForward%2A> é chamado (ou uma entrada é selecionada em uma navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]).  
  
-   Um fragmento de conteúdo é navegado.  
  
 Você lida com <xref:System.Windows.Navigation.NavigationService.Navigating> se você precisar descobrir informações pertinentes sobre a solicitação de navegação antes do início da navegação. Essas informações estão disponíveis a partir de <xref:System.Windows.Navigation.NavigatingCancelEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.Navigating> manipulador de eventos.  
  
 Um <xref:System.Net.WebRequest> do objeto para a navegação é criada e esteja disponível do <xref:System.Windows.Navigation.NavigatingCancelEventArgs> parâmetro; porque a solicitação real ainda não foram feita nesse ponto, você pode reconfigurar o <xref:System.Net.WebRequest> do objeto, se necessário.  
  
 Você também manipular <xref:System.Windows.Navigation.NavigatingCancelEventArgs> cancelar a navegação, se necessário, definindo <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> como true. Se você cancelar a navegação, nenhum outro evento de navegação é acionado.  
  
> [!NOTE]
>  Se seu aplicativo estiver hospedado no navegador, você não pode impedir que o usuário navegar para fora de seu aplicativo, cancelando a <xref:System.Windows.Navigation.NavigationService.Navigating> eventos.  
  
 Depois que a primeira parte do conteúdo é acessada por um navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), cada parte do conteúdo é navegado para fora é adicionado ao histórico de navegação. Se você precisar salvar informações de estado sobre o conteúdo que você está navegando longe do, você pode adicionar o estado para a entrada de diário para esse conteúdo, definindo <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> com um <xref:System.Windows.Navigation.CustomContentState> objeto.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> aciona <xref:System.Windows.Navigation.NavigationService.Navigating>, ele também gera <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> eventos sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.Navigating> para detectar se foi feita uma solicitação para atualizar o conteúdo estático e, nesse caso, para cancelar a solicitação.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando há um erro durante a navegação para conteúdo solicitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando tanto uma <xref:System.Net.WebException> ou um <xref:System.IO.IOException> for gerada durante uma navegação a <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é gerado. <xref:System.Windows.Navigation.NavigationService.NavigationFailed> é passado um <xref:System.Windows.Navigation.NavigationFailedEventArgs> que encapsula informações sobre a exceção e os detalhes do painel de navegação que causou a exceção.  
  
 Quando uma exceção resulta de uma falha na navegação e não pode ser manipulada, os seguintes eventos são gerados na ordem listada:  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> ou <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 Se um navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) é hospedado por um ou mais navegadores `NavigationFailed` não é gerado em qualquer um deles.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.NavigationFailed>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre periodicamente durante um download para fornecer informações sobre o andamento da navegação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> é passado um <xref:System.Windows.Navigation.NavigationProgressEventArgs> que expõe as seguintes informações de progresso:  
  
-   Número de bytes baixados até o momento (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>).  
  
-   Número total de bytes para baixar (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>).  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> é gerado depois que para cada 1024 bytes do conteúdo baixado, e mais uma vez se o número de bytes restantes é sempre menor que 1024 bytes. Por esse motivo, tratando <xref:System.Windows.Navigation.NavigationService.NavigationProgress> fornece uma maneira útil de controlar e exibir o andamento de um download atual.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> não será gerado em alguns casos, como quando a mesma parte do conteúdo é navegada, ou quando um fragmento de conteúdo é para onde navegar no conteúdo que está atualmente carregado (ou seja, o valor da <xref:System.Windows.Navigation.NavigationService.Content%2A> propriedade).  
  
 Ao navegar para um recurso XAML compilado, o último <xref:System.Windows.Navigation.NavigationService.NavigationProgress> eventos não podem ser gerados. Isso significa que, no final do download, o último relatado <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> valor não pode ser igual a <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> valor. Manipular o <xref:System.Windows.Navigation.NavigationService.LoadCompleted> evento a ser notificado quando a navegação foi concluída.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> aciona <xref:System.Windows.Navigation.NavigationService.NavigationProgress>, ele também gera <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> eventos sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.NavigationProgress>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o método <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> é chamado ou quando uma nova navegação é solicitada durante uma navegação atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você lida com <xref:System.Windows.Navigation.NavigationService.NavigationStopped> se você precisa descobrir informações pertinentes sobre a solicitação de navegação quando o download for interrompido. Essas informações estão disponíveis a partir de <xref:System.Windows.Navigation.NavigationEventArgs> objeto que é passado para o <xref:System.Windows.Navigation.NavigationService.NavigationStopped> manipulador de eventos e inclui:  
  
-   O URI solicitado.  
  
-   O navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   Dados adicionais, se a navegação foi iniciada com uma chamada a <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> ou <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Quando <xref:System.Windows.Navigation.NavigationService> aciona <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, ele também gera <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> eventos sobre o <xref:System.Windows.Application> objeto.  
  
   
  
## Examples  
 O exemplo a seguir mostra como manipular <xref:System.Windows.Navigation.NavigationService.NavigationStopped>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recarrega o conteúdo atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o conteúdo atual (especificado pelo valor da <xref:System.Windows.Navigation.NavigationService.Source%2A> propriedade) é para onde navegar novamente, <xref:System.Windows.Navigation.NavigationService> não baixa o conteúdo novamente. Para forçar <xref:System.Windows.Navigation.NavigationService> para navegar novamente até o conteúdo, chame <xref:System.Windows.Navigation.NavigationService.Refresh%2A>.  
  
 Observe que, se o conteúdo atual é navegado novamente, ao chamar <xref:System.Windows.Navigation.NavigationService.Navigate%2A> ou <xref:System.Windows.Navigation.NavigationService.Refresh%2A>, uma nova entrada não é adicionada ao histórico de navegação.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove a entrada de diário mais recente do histórico anterior.</summary>
        <returns>O <see cref="T:System.Windows.Navigation.JournalEntry" /> mais recente no histórico de navegação anterior, se houver.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se dois ou mais navegadores (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) compartilham o mesmo histórico de navegação, um navegador pode usar <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> para recuperar a entrada de histórico de navegação de retorno para uma navegação que ocorreram no outro navegador.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o URI do conteúdo atual ou o URI do conteúdo novo para o qual se está navegando atualmente.</summary>
        <value>Um <see cref="T:System.Uri" /> que contém o URI para o conteúdo atual ou o conteúdo que está atualmente sendo navegado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você definir essa propriedade como um URI diferente daquele que está sendo exibido no momento, o navegador (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) navega para o URI especificado.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> é definido como o conteúdo que é carregado do URI que é acessado, a menos que a navegação é cancelada.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> pode ser definida com um URI somente fragmento e pode ser definido como `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe o download de mais de conteúdo para a solicitação de navegação atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> pode ser chamado assim que <xref:System.Windows.Navigation.NavigationService.Navigate%2A> retorna e para de navegação que está em andamento em quadros de filho.  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 Chamar o <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> método aciona o <xref:System.Windows.Navigation.NavigationService.NavigationStopped> eventos.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> deve ser chamado no mesmo thread que iniciou a navegação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como interromper o carregamento.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>