<Type Name="DbDataAdapter" FullName="System.Data.Common.DbDataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3826e6f3e20f9dbc94d47c3d958b6e469e8cfe76" />
    <Meta Name="ms.sourcegitcommit" Value="e7865e39826e7aaf54da4c7042975153813a31c7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/16/2018" />
    <Meta Name="ms.locfileid" Value="31044256" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DbDataAdapter extends System.Data.Common.DataAdapter implements class System.Data.IDataAdapter, class System.Data.IDbDataAdapter, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Common.DbDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DbDataAdapter&#xA;Inherits DataAdapter&#xA;Implements ICloneable, IDbDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class DbDataAdapter abstract : System::Data::Common::DataAdapter, ICloneable, System::Data::IDbDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DataAdapter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.IDbDataAdapter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Ajuda na implementação da interface <see cref="T:System.Data.IDbDataAdapter" />. Os herdeiros de <see cref="T:System.Data.Common.DbDataAdapter" /> implementam um conjunto de funções para fornecer uma tipagem forte, mas herdam a maioria das funcionalidades necessárias para implementar um **DataAdapter** por completo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter> classe herda o <xref:System.Data.Common.DataAdapter> classe e implemente o <xref:System.Data.IDbDataAdapter> interface. Ele ajuda a uma classe implemente um **DataAdapter** projetados para uso com um banco de dados relacional.  
  
 Um aplicativo não cria uma instância do <xref:System.Data.Common.DbDataAdapter> classe diretamente, mas cria uma instância de uma classe que herda a partir dela.  
  
 As classes que herdam <xref:System.Data.Common.DbDataAdapter> deve implementar os membros herdados e geralmente definem membros adicionais para adicionar funcionalidade específica do provedor. Por exemplo, o <xref:System.Data.Common.DbDataAdapter> classe define o <xref:System.Data.IDbDataAdapter.SelectCommand%2A> propriedade e o <xref:System.Data.Common.DbDataAdapter> classe define oito sobrecargas do <xref:System.Data.IDataAdapter.Fill%2A> método. Por sua vez, o <xref:System.Data.OleDb.OleDbDataAdapter> classe herda o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método e também define duas sobrecargas adicionais do <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> que levam a um objeto de conjunto de registros ADO como um parâmetro.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando você herda o <see cref="T:System.Data.Common.DbDataAdapter" /> classe, é recomendável que você implemente os construtores a seguir:  
  
 <list type="table"><listheader><term> Item  
  
 </term><description> Descrição  
  
 </description></listheader><item><term> *Prv*DataAdapter()  
  
 </term><description> Inicializa uma nova instância do *Prv*classe DataAdapter.  
  
 </description></item><item><term> *Prv*DataAdapter (*Prv*comando *selectCommand*)  
  
 </term><description> Inicializa uma nova instância do *Prv*DataAdapter classe com a instrução SQL SELECT.  
  
 </description></item><item><term> *Prv*DataAdapter (cadeia de caracteres *selectCommandText*, cadeia de caracteres *selectConnectionString*)  
  
 </term><description> Inicializa uma nova instância do *Prv*DataAdapter classe com uma instrução SQL SELECT e uma cadeia de caracteres de conexão.  
  
 </description></item><item><term> *Prv*DataAdapter (cadeia de caracteres *selectCommandText*, *Prv*Conexão *selectConnection*)  
  
 </term><description> Inicializa uma nova instância do *Prv*DataAdapter classe com uma instrução SQL SELECT e um *Prv*objeto de Conexão.  
  
 </description></item></list>  
  
 Para promover a consistência entre os provedores de dados .NET Framework, você deve nomear a classe herdada no formulário *Prv*DataAdapter, onde *Prv* é o prefixo uniforme fornecido para todas as classes no .NET específica Namespace do provedor de dados do Framework. Por exemplo, "Sql" é o prefixo do <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> classe no **SqlClient** namespace.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância de uma classe <see langword="DataAdapter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância de uma classe **DataAdapter**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você cria uma instância de <xref:System.Data.Common.DbDataAdapter>, as seguintes propriedades de leitura/gravação são definidas para os seguintes valores iniciais.  
  
|Propriedades|Valor inicial|  
|----------------|-------------------|  
|<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|Um novo <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|Um novo <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|Um novo <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|Um novo <xref:System.Data.IDbCommand>.|  
|<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  
|<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|  
  
 Você pode alterar o valor de qualquer uma dessas propriedades por meio de uma chamada separada para a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.Common.DbDataAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (adapter As DbDataAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DbDataAdapter(System::Data::Common::DbDataAdapter ^ adapter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="adapter" Type="System.Data.Common.DbDataAdapter" />
      </Parameters>
      <Docs>
        <param name="adapter">Um objeto <see langword="DataAdapter" /> usado para criar o novo <see langword="DataAdapter" />.</param>
        <summary>Inicializa uma nova instância da classe <see langword="DataAdapter" /> de um objeto existente do mesmo tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Data.Common.DbDataAdapter> construtor é projetado para uso por um provedor de dados .NET Framework ao implementar um construtor semelhante para uso em uma implementação de clone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToBatch">
      <MemberSignature Language="C#" Value="protected virtual int AddToBatch (System.Data.IDbCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 AddToBatch(class System.Data.IDbCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function AddToBatch (command As IDbCommand) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int AddToBatch(System::Data::IDbCommand ^ command);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Data.IDbCommand" />
      </Parameters>
      <Docs>
        <param name="command">O <see cref="T:System.Data.IDbCommand" /> a ser adicionado ao lote.</param>
        <summary>Adiciona um <see cref="T:System.Data.IDbCommand" /> ao lote atual.</summary>
        <returns>O número de comandos no lote antes de adicionar o <see cref="T:System.Data.IDbCommand" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em <xref:System.Data.Common.DbDataAdapter>, este método lança <xref:System.NotSupportedException>. Classes que herdam de <xref:System.Data.Common.DbDataAdapter> substituir esse método para fornecer suporte para lotes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O adaptador não dá suporte a lotes.</exception>
        <block subset="none" type="overrides">
          <para>Esse método é protegido e é projetado para uso por um provedor de dados do .NET Framework.  
  
 Se uma classe que herda de <see cref="T:System.Data.Common.DbDataAdapter" /> oferece suporte a lotes, classe substitui esse método para permitir que os usuários adicionar um comando a um lote.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ClearBatch">
      <MemberSignature Language="C#" Value="protected virtual void ClearBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ClearBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearBatch ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os objetos <see cref="T:System.Data.IDbCommand" /> do lote.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em <xref:System.Data.Common.DbDataAdapter>, este método lança <xref:System.NotSupportedException>. Classes que herdam de <xref:System.Data.Common.DbDataAdapter> substituir esse método para fornecer suporte para lotes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O adaptador não dá suporte a lotes.</exception>
        <block subset="none" type="overrides">
          <para>Esse método é protegido e é projetado para uso por um provedor de dados do .NET Framework.  
  
 Se uma classe que herda de <see cref="T:System.Data.Common.DbDataAdapter" /> oferece suporte a lotes, classe substitui esse método para permitir que os usuários remover todos os comandos de um lote.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatedEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatedEventArgs ^ CreateRowUpdatedEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatedEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow">O <see cref="T:System.Data.DataRow" /> usado para atualizar a fonte de dados.</param>
        <param name="command">O <see cref="T:System.Data.IDbCommand" /> executado durante o <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</param>
        <param name="statementType">Se o comando é uma instrução UPDATE, INSERT, DELETE ou SELECT.</param>
        <param name="tableMapping">Um objeto <see cref="T:System.Data.Common.DataTableMapping" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.Common.RowUpdatedEventArgs" />.</summary>
        <returns>Uma nova instância da classe <see cref="T:System.Data.Common.RowUpdatedEventArgs" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateRowUpdatingEvent">
      <MemberSignature Language="C#" Value="protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent(class System.Data.DataRow dataRow, class System.Data.IDbCommand command, valuetype System.Data.StatementType statementType, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::Common::RowUpdatingEventArgs ^ CreateRowUpdatingEvent(System::Data::DataRow ^ dataRow, System::Data::IDbCommand ^ command, System::Data::StatementType statementType, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.RowUpdatingEventArgs</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRow" Type="System.Data.DataRow" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="statementType" Type="System.Data.StatementType" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRow">O <see cref="T:System.Data.DataRow" /> que atualiza a fonte de dados.</param>
        <param name="command">O <see cref="T:System.Data.IDbCommand" /> a ser executado durante o <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />.</param>
        <param name="statementType">Se o comando é uma instrução UPDATE, INSERT, DELETE ou SELECT.</param>
        <param name="tableMapping">Um objeto <see cref="T:System.Data.Common.DataTableMapping" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.Common.RowUpdatingEventArgs" />.</summary>
        <returns>Uma nova instância da classe <see cref="T:System.Data.Common.RowUpdatingEventArgs" />.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSourceTableName">
      <MemberSignature Language="C#" Value="public const string DefaultSourceTableName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string DefaultSourceTableName" />
      <MemberSignature Language="DocId" Value="F:System.Data.Common.DbDataAdapter.DefaultSourceTableName" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultSourceTableName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ DefaultSourceTableName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>O nome padrão usado pelo objeto <see cref="T:System.Data.Common.DataAdapter" /> para mapeamentos de tabela.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 "Table" é o nome padrão usado pelo <xref:System.Data.Common.DataAdapter> objeto para mapeamentos de tabela.  
  
 <xref:System.Data.Common.DbDataAdapter.DefaultSourceTableName> Quando um aplicativo adiciona um mapeamento de tabela a ser usada com <xref:System.Data.Common.DbDataAdapter.Fill%2A>, mas não especifica um <xref:System.Data.DataTable> nome.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.DeleteCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property DeleteCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ DeleteCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um comando para excluir registros do conjunto de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> usado durante a <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> para excluir registros na fonte de dados para linhas excluídas no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante a <xref:System.Data.Common.DbDataAdapter.Update%2A>, se essa propriedade não está definida e informações de chave primária estão presentes no <xref:System.Data.DataSet>, o <xref:System.Data.IDbDataAdapter.DeleteCommand%2A> é gerado automaticamente.  
  
   
  
## Examples  
 O exemplo a seguir cria a classe derivada <xref:System.Data.OleDb.OleDbDataAdapter> e define algumas de suas propriedades.  
  
 [!code-csharp[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.DeleteCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Data.Common.DbDataAdapter" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteBatch">
      <MemberSignature Language="C#" Value="protected virtual int ExecuteBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 ExecuteBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.ExecuteBatch" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ExecuteBatch () As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int ExecuteBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Executa o lote atual.</summary>
        <returns>O valor retornado do último comando no lote.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em <xref:System.Data.Common.DbDataAdapter>, este método lança <xref:System.NotSupportedException>. Classes que herdam de <xref:System.Data.Common.DbDataAdapter> substituir esse método para fornecer suporte para lotes.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esse método é protegido e é projetado para uso por um provedor de dados do .NET Framework.  
  
 Se uma classe que herda de <see cref="T:System.Data.Common.DbDataAdapter" /> oferece suporte a lotes, classe substitui esse método para permitir que os usuários executar um lote. Uma implementação deste método combina os comandos no adaptador em um lote, em seguida, executa o lote e retorna o valor de retorno do lote.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Fill">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Preenche um <see cref="T:System.Data.DataSet" /> ou <see cref="T:System.Data.DataTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public override int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Fill(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Um <see cref="T:System.Data.DataSet" /> a ser preenchido com registros e, se necessário, esquema.</param>
        <summary>Adiciona ou atualiza linhas no <see cref="T:System.Data.DataSet" />.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataSet" />. Isso não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera os dados da fonte de dados usando uma instrução SELECT. O <xref:System.Data.IDbConnection> objeto associado com o comando select deve ser válido, mas ele não precisa ser aberta. Se o <xref:System.Data.IDbConnection> está fechado antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e, em seguida, fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 Se um erro ou exceção é encontrada ao preencher as tabelas de dados, as linhas adicionadas antes da ocorrência do erro permanecem nas tabelas de dados. O restante da operação é anulado.  
  
 Se um comando não retorna nenhuma linha, não há tabelas são adicionadas ao <xref:System.Data.DataSet>, e nenhuma exceção é gerada.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> objeto encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante.  
  
 Quando a consulta especificada retorna vários resultados, o conjunto de resultados de consulta de retorno de cada linha é colocado em uma tabela separada. Os conjuntos de resultados adicionais são nomeados adicionando-se valores integrais ao nome da tabela especificado (por exemplo, "Tabela", "Tabela1", "Tabela2" e assim por diante). Porque nenhuma tabela foi criada para uma consulta que não retorna linhas, se você processar uma consulta insert seguida por uma consulta select, a tabela criada para a consulta select é chamada de "Tabela" porque ele é a primeira tabela criada. Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 Quando a instrução SELECT é usada para popular o <xref:System.Data.DataSet> retorna vários resultados, tais como instruções SQL de lote, se um dos resultados contiver um erro, todos os resultados subsequentes serão ignorados e não são adicionados ao <xref:System.Data.DataSet>.  
  
 Ao usar subsequentes <xref:System.Data.Common.DbDataAdapter.Fill%2A> chamadas para atualizar o conteúdo do <xref:System.Data.DataSet>, duas condições devem ser atendidas:  
  
1.  A instrução SQL deve corresponder àquela inicialmente usada para preencher o <xref:System.Data.DataSet>.  
  
2.  O **chave** informações de coluna devem estar presentes.  
  
 Se houver informações de chave primária, quaisquer linhas duplicadas são reconciliadas e aparecer apenas uma vez no <xref:System.Data.DataTable> que corresponde do <xref:System.Data.DataSet>. Informações de chave primária podem ser definidas por meio de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, especificando o <xref:System.Data.DataTable.PrimaryKey%2A> propriedade do <xref:System.Data.DataTable>, ou definindo o <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> propriedade `AddWithKey`.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataTable ^ dataTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">O nome do <see cref="T:System.Data.DataTable" /> a ser usado para mapeamento de tabela.</param>
        <summary>Adiciona ou atualiza linhas em um intervalo especificado no <see cref="T:System.Data.DataSet" /> para corresponder àquelas na fonte de dados usando o nome <see cref="T:System.Data.DataTable" />.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataSet" />. Isso não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera as linhas da fonte de dados usando a instrução SELECT especificada por um associado <xref:System.Data.IDbDataAdapter.SelectCommand%2A> propriedade. O objeto de conexão associado à instrução SELECT deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> operação, em seguida, adiciona as linhas ao destino <xref:System.Data.DataTable> objetos no <xref:System.Data.DataSet>, criando o <xref:System.Data.DataTable> objetos se eles ainda não existir. Ao criar <xref:System.Data.DataTable> objetos, o <xref:System.Data.Common.DbDataAdapter.Fill%2A> operação normalmente cria apenas os metadados de nome de coluna. No entanto, caso a propriedade <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> seja definida como `AddWithKey`, as chaves primárias apropriadas e as restrições também são criadas.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada.  
  
 A sobrecarga do <xref:System.Data.Common.DbDataAdapter.Fill%2A> que usa `DataTable` como um parâmetro obtém somente o primeiro resultado. Use uma sobrecarga de <xref:System.Data.Common.DbDataAdapter.Fill%2A> que usa `DataSet` como um parâmetro para obter vários resultados.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.Fill%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
 dataset.Tables.Add("AAA");  
 adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
    adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Você pode usar o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método várias vezes no mesmo <xref:System.Data.DataTable>. Caso haja uma chave primária, as linhas de entrada são mescladas com linhas correspondentes já existentes. Caso não haja nenhuma chave primária, as linhas de entrada são acrescentadas ao <xref:System.Data.DataTable>.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.Fill%2A> e <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para dados do .NET Framework provedor recupera informações de esquema para apenas o primeiro resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <block subset="none" type="overrides">
          <para>Esta sobrecarga do <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> método é protegido e é projetado para uso por um provedor de dados do .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">Um <see cref="T:System.Data.DataSet" /> a ser preenchido com registros e, se necessário, esquema.</param>
        <param name="srcTable">O nome da tabela de origem a ser usado para mapeamento de tabela.</param>
        <summary>Adiciona ou atualiza linhas no <see cref="T:System.Data.DataSet" /> para corresponder às existentes na fonte de dados usando os nomes <see cref="T:System.Data.DataSet" /> e <see cref="T:System.Data.DataTable" />.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataSet" />. Isso não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera os dados da fonte de dados usando uma instrução SELECT. O <xref:System.Data.IDbConnection> objeto associado com o comando select deve ser válido, mas ele não precisa ser aberta. Se o <xref:System.Data.IDbConnection> está fechado antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 Se um comando não retorna nenhuma linha, não há tabelas são adicionadas ao <xref:System.Data.DataSet>, e nenhuma exceção é gerada.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> objeto encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele irá gerar nomes para as colunas subsequentes, usando o padrão "nome_da_coluna1", "columnname2", "columnname3" e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante.  
  
 Quando a consulta especificada retorna vários resultados, cada conjunto de resultados é colocado em uma tabela separada. Os conjuntos de resultados adicionais são nomeados adicionando-se valores integrais ao nome da tabela especificado (por exemplo, "Tabela", "Tabela1", "Tabela2" e assim por diante). Já que nenhuma tabela foi criada para uma consulta que não retorna linhas, se você processar uma consulta insert seguida por uma consulta select, a tabela criada para a consulta select será chamada "Table", porque ele é a primeira tabela criada. Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.Fill%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Se um erro ou exceção é encontrada ao preencher as tabelas de dados, as linhas adicionadas antes da ocorrência do erro permanecem nas tabelas de dados. O restante da operação é anulado.  
  
 Quando a instrução SELECT é usada para popular o <xref:System.Data.DataSet> retornar vários resultados, como um lote de instrução SQL, esteja ciente das seguintes opções:  
  
-   Se um dos resultados contiver um erro, todos os resultados subsequentes são ignorados e não adicionados ao <xref:System.Data.DataSet>.  
  
 Ao usar subsequentes <xref:System.Data.Common.DbDataAdapter.Fill%2A> chamadas para atualizar o conteúdo do <xref:System.Data.DataSet>, duas condições devem ser atendidas:  
  
1.  A instrução SQL deve corresponder àquela inicialmente usada para preencher o <xref:System.Data.DataSet>.  
  
2.  O **chave** informações de coluna devem estar presentes. Se houver informações de chave primária, quaisquer linhas duplicadas são reconciliadas e aparecer apenas uma vez no <xref:System.Data.DataTable> que corresponde do <xref:System.Data.DataSet>. Informações de chave primária podem ser definidas por meio de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, especificando o <xref:System.Data.DataTable.PrimaryKey%2A> propriedade do <xref:System.Data.DataTable>, ou definindo o <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> propriedade `AddWithKey`.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.OleDb.OleDbDataAdapter>, para preencher um <xref:System.Data.DataSet> com linhas da tabela de categorias. Este exemplo supõe que você tenha criado um <xref:System.Data.OleDb.OleDbDataAdapter> e um <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">A tabela de origem é inválida.</exception>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable dataTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataTable ^ dataTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">Um <see cref="T:System.Data.DataTable" /> a ser preenchido com registros e, se necessário, esquema.</param>
        <param name="command">A instrução SQL SELECT usada para recuperar linhas da fonte de dados.</param>
        <param name="behavior">Um dos valores de <see cref="T:System.Data.CommandBehavior" />.</param>
        <summary>Adiciona ou atualiza linhas em um <see cref="T:System.Data.DataTable" /> para corresponder às existentes na fonte de dados usando o <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.IDbCommand" /> e <see cref="T:System.Data.CommandBehavior" /> especificados.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataTable" />. Isso não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera as linhas da fonte de dados usando a instrução SELECT especificada por um associado <xref:System.Data.IDbDataAdapter.SelectCommand%2A> propriedade. O objeto de conexão associado à instrução SELECT deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e, em seguida, fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> operação, em seguida, adiciona as linhas para o destino especificado <xref:System.Data.DataTable> objeto o <xref:System.Data.DataSet>, criando o <xref:System.Data.DataTable> objeto se ele ainda não existir. Ao criar um <xref:System.Data.DataTable> objeto, o <xref:System.Data.Common.DbDataAdapter.Fill%2A> operação normalmente cria apenas os metadados de nome de coluna. No entanto, caso a propriedade <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> seja definida como `AddWithKey`, as chaves primárias apropriadas e as restrições também são criadas.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> objeto encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele irá gerar nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante.  
  
 A sobrecarga do <xref:System.Data.Common.DbDataAdapter.Fill%2A> que usa `DataTable` como um parâmetro obtém somente o primeiro resultado. Use uma sobrecarga de <xref:System.Data.Common.DbDataAdapter.Fill%2A> que usa `DataSet` como um parâmetro para obter vários resultados.  
  
 Você pode usar o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método várias vezes no mesmo <xref:System.Data.DataTable>. Caso haja uma chave primária, as linhas de entrada são mescladas com linhas correspondentes já existentes. Caso não haja nenhuma chave primária, as linhas de entrada são acrescentadas ao <xref:System.Data.DataTable>.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esta sobrecarga do <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> método é protegido e é projetado para uso por um provedor de dados do .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (int startRecord, int maxRecords, params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(int32 startRecord, int32 maxRecords, class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Fill (startRecord As Integer, maxRecords As Integer, ParamArray dataTables As DataTable()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(int startRecord, int maxRecords, ... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startRecord">O número de registro baseado em zero pelo qual começar.</param>
        <param name="maxRecords">O número máximo de registros a serem obtidos.</param>
        <param name="dataTables">Os objetos <see cref="T:System.Data.DataTable" /> a preencher da fonte de dados.</param>
        <summary>Adiciona ou atualiza linhas em um <see cref="T:System.Data.DataTable" /> para corresponder àquelas na fonte de dados, começando pelo registro especificado e recuperando até o número máximo de registros.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataTable" />. Esse valor não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DataAdapter.Fill%2A> método recupera as linhas da fonte de dados usando a instrução SELECT especificada por um associado <xref:System.Data.IDbDataAdapter.SelectCommand%2A> propriedade. O objeto de conexão associado à instrução SELECT deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DataAdapter.Fill%2A> é chamado, ele está sendo usado para recuperar dados e, em seguida, ele é fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 O <xref:System.Data.Common.DataAdapter.Fill%2A> operação, em seguida, adiciona as linhas ao destino <xref:System.Data.DataTable> objetos no <xref:System.Data.DataSet>, criando o <xref:System.Data.DataTable> objetos se eles ainda não existir. Ao criar <xref:System.Data.DataTable> objetos, o <xref:System.Data.Common.DataAdapter.Fill%2A> operação normalmente cria apenas os metadados de nome de coluna. No entanto, caso a propriedade <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> seja definida como `AddWithKey`, as chaves primárias apropriadas e as restrições também são criadas.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Se o adaptador de dados encontrar colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "nome_da_coluna1", "columnname2", "columnname3" e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet>, cada conjunto de resultados é colocado em uma tabela separada. Os conjuntos de resultados adicionais são nomeados adicionando-se valores integrais ao nome da tabela especificado (por exemplo, "Tabela", "Tabela1", "Tabela2" e assim por diante). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 Quando a instrução SELECT é usada para popular o <xref:System.Data.DataSet> retornar vários resultados, como um lote SQL, se um dos resultados contiver um erro, todos os resultados subsequentes são ignorados e não adicionados ao <xref:System.Data.DataSet>.  
  
 Você pode usar o <xref:System.Data.Common.DataAdapter.Fill%2A> método várias vezes no mesmo <xref:System.Data.DataTable>. Caso haja uma chave primária, as linhas de entrada são mescladas com linhas correspondentes já existentes. Caso não haja nenhuma chave primária, as linhas de entrada são acrescentadas ao <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">Um <see cref="T:System.Data.DataSet" /> a ser preenchido com registros e, se necessário, esquema.</param>
        <param name="startRecord">O número de registro baseado em zero pelo qual começar.</param>
        <param name="maxRecords">O número máximo de registros a serem obtidos.</param>
        <param name="srcTable">O nome da tabela de origem a ser usado para mapeamento de tabela.</param>
        <summary>Adiciona ou atualiza linhas em um intervalo especificado no <see cref="T:System.Data.DataSet" /> para corresponder àquelas na fonte de dados usando os nomes <see cref="T:System.Data.DataSet" /> e <see cref="T:System.Data.DataTable" />.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataSet" />. Isso não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um `maxRecords` valor 0 obtém todos os registros encontrados após o registro de início. Se `maxRecords` é maior que o número de linhas restantes, somente as linhas restantes são retornadas, e nenhum erro é emitido.  
  
 Se o comando select correspondente é uma instrução retornar vários resultados, <xref:System.Data.Common.DbDataAdapter.Fill%2A> só se aplica `maxRecords` para o primeiro resultado.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera os dados da fonte de dados usando uma instrução SELECT. O <xref:System.Data.IDbConnection> objeto associado com a instrução SELECT deve ser válido, mas ele não precisa ser aberta. Se o <xref:System.Data.IDbConnection> está fechado antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e, em seguida, fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 Se um comando não retorna nenhuma linha, não há tabelas são adicionadas ao <xref:System.Data.DataSet>, mas nenhuma exceção é gerada.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> objeto encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele irá gerar nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante.  
  
 Quando a consulta especificada retorna vários resultados, cada conjunto de resultados é colocado em uma tabela separada. Os conjuntos de resultados adicionais são nomeados adicionando-se valores integrais ao nome da tabela especificado (por exemplo, "Tabela", "Tabela1", "Tabela2" e assim por diante). Porque nenhuma tabela foi criada para uma consulta que não retorna linhas, se você processar uma consulta insert seguida por uma consulta select, a tabela criada para a consulta select é chamada de "Tabela", porque ele é a primeira tabela criada. Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.Fill%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Se um erro ou exceção é encontrada ao preencher as tabelas de dados, as linhas adicionadas antes da ocorrência do erro permanecem nas tabelas de dados. O restante da operação é anulado.  
  
 Quando a instrução SELECT é usada para popular o <xref:System.Data.DataSet> retorna vários resultados, tais como instruções SQL de lote, esteja ciente das seguintes opções:  
  
-   Durante o processamento de vários resultados de um lote de instrução SQL, `maxRecords` aplica-se somente para o primeiro resultado. O mesmo é verdadeiro para as linhas que contém resultados em capítulos (.NET Framework Data Provider para OLE DB apenas). O resultado de nível superior é limitado pelo `maxRecords`, mas todas as linhas filho serão adicionadas.  
  
-   Se um dos resultados contiver um erro, todos os resultados subsequentes são ignorados e não adicionados ao <xref:System.Data.DataSet>.  
  
 Ao usar subsequentes <xref:System.Data.Common.DbDataAdapter.Fill%2A> chamadas para atualizar o conteúdo do <xref:System.Data.DataSet>, duas condições devem ser atendidas:  
  
1.  A instrução SQL deve corresponder àquela inicialmente usada para preencher o <xref:System.Data.DataSet>.  
  
2.  O **chave** informações de coluna devem estar presentes.  
  
 Se houver informações de chave primária, quaisquer linhas duplicadas serão reciclado e aparecer apenas uma vez no <xref:System.Data.DataTable> que corresponde do <xref:System.Data.DataSet>. Informações de chave primária podem ser definidas por meio de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, especificando o <xref:System.Data.DataTable.PrimaryKey%2A> propriedade do <xref:System.Data.DataTable>, ou definindo o <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> propriedade `AddWithKey`.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
> [!NOTE]
>  O `DataSet` não contém mais do que o número de registros indicado pelo `maxRecords`. No entanto, o conjunto de resultados inteiro gerado pela consulta ainda é retornado do servidor.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.OleDb.OleDbDataAdapter>, para preencher um <xref:System.Data.DataSet> com 15 linhas, começando na linha 10, do **categorias** tabela. Este exemplo supõe que você tenha criado um <xref:System.Data.OleDb.OleDbDataAdapter> e um <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Fill3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">O <see cref="T:System.Data.DataSet" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.  
  
 - ou -  
  
 A conexão é inválida.</exception>
        <exception cref="T:System.InvalidCastException">Não foi possível encontrar a conexão.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="startRecord" /> é menor que 0.  
  
 - ou -  
  
 O parâmetro <paramref name="maxRecords" /> é menor que 0.</exception>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataTable[] dataTables, int32 startRecord, int32 maxRecords, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Fill (dataTables As DataTable(), startRecord As Integer, maxRecords As Integer, command As IDbCommand, behavior As CommandBehavior) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables, int startRecord, int maxRecords, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTables">Os objetos <see cref="T:System.Data.DataTable" /> a preencher da fonte de dados.</param>
        <param name="startRecord">O número de registro baseado em zero pelo qual começar.</param>
        <param name="maxRecords">O número máximo de registros a serem obtidos.</param>
        <param name="command">O <see cref="T:System.Data.IDbCommand" /> executado para preencher os objetos <see cref="T:System.Data.DataTable" />.</param>
        <param name="behavior">Um dos valores de <see cref="T:System.Data.CommandBehavior" />.</param>
        <summary>Adiciona ou atualiza linhas em um intervalo especificado no <see cref="T:System.Data.DataSet" /> para corresponder àquelas na fonte de dados usando os nomes <see cref="T:System.Data.DataSet" /> e <see cref="T:System.Data.DataTable" />.</summary>
        <returns>O número de linhas adicionadas ao ou atualizadas nas tabelas de dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um `maxRecords` valor 0 obtém todos os registros encontrados após o registro de início. Se `maxRecords` é maior que o número de linhas restantes, somente as linhas restantes são retornadas e nenhum erro é emitido.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera os dados da fonte de dados usando uma instrução SELECT. O <xref:System.Data.IDbConnection> objeto associado com a instrução SELECT deve ser válido, mas ele não precisa ser aberta. Se o <xref:System.Data.IDbConnection> está fechado antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 Se um comando não retorna nenhuma linha, não há tabelas são adicionadas ao <xref:System.Data.DataSet>, mas nenhuma exceção é gerada.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> objeto encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele irá gerar nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante.  
  
 Quando a consulta especificada retorna vários resultados, cada conjunto de resultados é colocado em uma tabela separada. Os conjuntos de resultados adicionais são nomeados adicionando-se valores integrais ao nome da tabela especificado (por exemplo, "Tabela", "Tabela1", "Tabela2" e assim por diante). Já que nenhuma tabela foi criada para uma consulta que não retorna linhas, se você processar uma consulta insert seguida por uma consulta select, a tabela criada para a consulta select será chamada "Table", porque ele é a primeira tabela criada. Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.Fill%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Se um erro ou exceção é encontrada ao preencher as tabelas de dados, as linhas adicionadas antes da ocorrência do erro permanecem nas tabelas de dados. O restante da operação é anulado.  
  
 Quando a instrução SELECT é usada para popular o <xref:System.Data.DataTable> objetos retornar vários resultados, como um lote de instrução SQL, esteja ciente das seguintes opções:  
  
-   Durante o processamento de vários resultados de um lote de instrução SQL, `maxRecords` aplica-se somente para o primeiro resultado. O mesmo é verdadeiro para as linhas que contém resultados em capítulos (.NET Framework Data Provider para OLE DB apenas). O resultado de nível superior é limitado pelo `maxRecords`, mas todas as linhas filho serão adicionadas.  
  
-   Se um dos resultados contiver um erro, todos os resultados subsequentes serão ignorados.  
  
> [!NOTE]
>  O `DataSet` não contém mais do que o número de registros indicado pelo `maxRecords`. No entanto, todo o conjunto de resultados gerado pela consulta ainda é retornado do servidor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">O <see cref="T:System.Data.DataSet" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.  
  
 - ou -  
  
 A conexão é inválida.</exception>
        <exception cref="T:System.InvalidCastException">Não foi possível encontrar a conexão.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="startRecord" /> é menor que 0.  
  
 - ou -  
  
 O parâmetro <paramref name="maxRecords" /> é menor que 0.</exception>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet, int32 startRecord, int32 maxRecords, string srcTable, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Fill(System::Data::DataSet ^ dataSet, int startRecord, int maxRecords, System::String ^ srcTable, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="startRecord" Type="System.Int32" />
        <Parameter Name="maxRecords" Type="System.Int32" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">Um <see cref="T:System.Data.DataSet" /> a ser preenchido com registros e, se necessário, esquema.</param>
        <param name="startRecord">O número de registro baseado em zero pelo qual começar.</param>
        <param name="maxRecords">O número máximo de registros a serem obtidos.</param>
        <param name="srcTable">O nome da tabela de origem a ser usado para mapeamento de tabela.</param>
        <param name="command">A instrução SQL SELECT usada para recuperar linhas da fonte de dados.</param>
        <param name="behavior">Um dos valores de <see cref="T:System.Data.CommandBehavior" />.</param>
        <summary>Adiciona ou atualiza linhas em um intervalo especificado no <see cref="T:System.Data.DataSet" /> para corresponder àquelas na fonte de dados usando o <see cref="T:System.Data.DataSet" /> e nomes da tabela de origem, a cadeia de comando e o comportamento do comando.</summary>
        <returns>O número de linhas adicionadas com êxito a ou atualizadas no <see cref="T:System.Data.DataSet" />. Isso não inclui linhas afetadas por instruções que não retornam linhas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método recupera as linhas da fonte de dados usando a instrução SELECT especificada por um associado <xref:System.Data.IDbDataAdapter.SelectCommand%2A> propriedade. O objeto de conexão associado à instrução SELECT deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado, ele permanecerá aberto.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> operação, em seguida, adiciona as linhas ao destino <xref:System.Data.DataTable> objetos no <xref:System.Data.DataSet>, criando o <xref:System.Data.DataTable> objetos se eles ainda não existir. Ao criar <xref:System.Data.DataTable> objetos, o <xref:System.Data.Common.DbDataAdapter.Fill%2A> operação normalmente cria apenas os metadados de nome de coluna. No entanto, caso a propriedade <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> seja definida como `AddWithKey`, as chaves primárias apropriadas e as restrições também são criadas.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada. Os conjuntos de resultados adicionais são nomeados adicionando-se valores integrais ao nome da tabela especificado (por exemplo, "Tabela", "Tabela1", "Tabela2" e assim por diante). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.Common.DbDataAdapter.Fill%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.Fill%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.Fill(dataset, "aaa"); // Fills "aaa", which already exists in the DataSet.  
adapter.Fill(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.Fill%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.Fill(dataset, "AAA"); // Fills table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 Você pode usar o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método várias vezes no mesmo <xref:System.Data.DataTable>. Caso haja uma chave primária, as linhas de entrada são mescladas com linhas correspondentes já existentes. Caso não haja nenhuma chave primária, as linhas de entrada são acrescentadas ao <xref:System.Data.DataTable>.  
  
 Se o `SelectCommand` retornar os resultados de um OUTER JOIN, o `DataAdapter` não definirá um valor de <xref:System.Data.DataTable.PrimaryKey%2A> para o<xref:System.Data.DataTable> resultante. Você deve definir explicitamente a chave primária para garantir que as linhas duplicadas sejam resolvidas corretamente. Para obter mais informações, consulte [definindo chaves primárias](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.Fill%2A> e <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para dados do .NET Framework provedor recupera informações de esquema para apenas o primeiro resultado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="startRecord" /> é menor que 0.  
  
 - ou -  
  
 O parâmetro <paramref name="maxRecords" /> é menor que 0.</exception>
        <block subset="none" type="overrides">
          <para>Esta sobrecarga do <see cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" /> método é protegido e é projetado para uso por um provedor de dados do .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillCommandBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Data.CommandBehavior FillCommandBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.CommandBehavior FillCommandBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.FillCommandBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property FillCommandBehavior As CommandBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Data::CommandBehavior FillCommandBehavior { System::Data::CommandBehavior get(); void set(System::Data::CommandBehavior value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.CommandBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o comportamento do comando usado para preencher o adaptador de dados.</summary>
        <value>O <see cref="T:System.Data.CommandBehavior" /> do comando usado para preencher o adaptador de dados.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um <see cref="T:System.Data.DataTable" /> a um <see cref="T:System.Data.DataSet" /> e configura o esquema para corresponder ao existente na fonte de dados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">Um <see cref="T:System.Data.DataSet" /> para inserir o esquema.</param>
        <param name="schemaType">Um do valores <see cref="T:System.Data.SchemaType" /> que especificam como inserir o esquema.</param>
        <summary>Adiciona um <see cref="T:System.Data.DataTable" /> com o nome “Tabela” ao <see cref="T:System.Data.DataSet" /> especificado e configura o esquema para corresponder a eles na fonte de dados com base no <see cref="T:System.Data.SchemaType" /> especificado.</summary>
        <returns>Uma referência a uma coleção de objetos <see cref="T:System.Data.DataTable" /> que foram adicionados ao <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método recupera as informações de esquema de fonte de dados usando o <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 Um <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operação adiciona um <xref:System.Data.DataTable> para o destino <xref:System.Data.DataSet>. Em seguida, adiciona colunas para o <xref:System.Data.DataColumnCollection> do <xref:System.Data.DataTable>e configura o seguinte <xref:System.Data.DataColumn> propriedades se eles existirem na fonte de dados:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Você deve definir <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separadamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> também configura o <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> propriedades de acordo com as regras a seguir:  
  
-   Caso uma ou mais colunas de chave primária sejam retornadas pelo <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, elas são usadas como colunas de chave primária para o <xref:System.Data.DataTable>.  
  
-   Se não há colunas de chave primária são retornadas, mas são colunas exclusivas, as colunas exclusivas são usadas como chave primária se e somente se, todas as colunas exclusivas são não nulas. Caso qualquer uma das colunas seja anulável, um <xref:System.Data.UniqueConstraint> é adicionado ao <xref:System.Data.ConstraintCollection>, mas a propriedade <xref:System.Data.DataTable.PrimaryKey%2A> não é definida.  
  
-   Caso as colunas de chave primária e as colunas exclusivas sejam retornadas, as colunas de chave primária são usadas como as colunas de chave primária para o <xref:System.Data.DataTable>.  
  
 Observe que as chaves primárias e restrições exclusivas serão adicionadas para o <xref:System.Data.ConstraintCollection> acordo com as regras precedentes, mas outra restrição de tipos não são adicionados.  
  
 Se um índice agrupado exclusivo estiver definido em colunas em uma tabela do SQL Server e a restrição de chave primária estiver definida em um conjunto de colunas separado, os nomes das colunas no índice agrupado serão retornados. Para retornar o nome ou os nomes das colunas de chave primária, use uma dica de consulta com a instrução SELECT que especifica o nome do índice de chave primária. Para obter mais informações sobre como especificar dicas de consulta, consulte [a dica de consulta (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Informações de chave primária são usadas durante a <xref:System.Data.Common.DbDataAdapter.Fill%2A> para localizar e substituir quaisquer linhas cujas colunas de chave coincidem. Se isso não é o comportamento desejado, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> sem solicitar informações de esquema.  
  
 Se o <xref:System.Data.IDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada. Conjuntos de resultados adicionais são nomeados adicionando valores inteiros para o nome da tabela especificada (por exemplo, "Table", "Table1", "Tabela2", etc.). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.IDbConnection> objeto associado com o comando select deve ser válido, mas ele não precisa abrir. Se o <xref:System.Data.IDbConnection> está fechado antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é deixado em aberto.  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, o Provedor de Dados .NET Framework para SQL Server acrescenta uma cláusula FOR BROWSE à instrução executada. O usuário deve estar ciente de efeitos colaterais potenciais, como interferência no uso de instruções SET FMTONLY ON. Consulte os Manuais Online do SQL Server para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.SqlClient.SqlDataAdapter>, para preencher um <xref:System.Data.DataSet> com o esquema e retorna um <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataTable">O <see cref="T:System.Data.DataTable" /> a ser preenchido com o esquema da fonte de dados.</param>
        <param name="schemaType">Um dos valores de <see cref="T:System.Data.SchemaType" />.</param>
        <summary>Configura o esquema do <see cref="T:System.Data.DataTable" /> especificado com base no <see cref="T:System.Data.SchemaType" /> especificado.</summary>
        <returns>Um <see cref="T:System.Data.DataTable" /> que contém informações de esquema retornadas da fonte de dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> método recupera o esquema de fonte de dados usando o <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. O objeto de conexão associado ao <xref:System.Data.IDbDataAdapter.SelectCommand%2A> deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele permanecerá aberto.  
  
 Um <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operação retorna um <xref:System.Data.DataTable>. Em seguida, adiciona colunas para o <xref:System.Data.DataColumnCollection> do <xref:System.Data.DataTable>e configura o seguinte <xref:System.Data.DataColumn> propriedades se eles existirem na fonte de dados:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Você deve definir <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separadamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> também configura o <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> propriedades de acordo com as regras a seguir:  
  
-   Se um <xref:System.Data.DataTable.PrimaryKey%2A> já foi definido para o `DataTable`, ou o `DataTable` contém dados, o `PrimaryKey` propriedade não será definida.  
  
-   Caso uma ou mais colunas de chave primária sejam retornadas pelo <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, elas são usadas como colunas de chave primária para o `DataTable`.  
  
-   Se não há colunas de chave primária são retornadas, mas são colunas exclusivas, as colunas exclusivas são usadas como chave primária se e somente se, todas as colunas exclusivas são não nulas. Caso qualquer uma das colunas seja anulável, um <xref:System.Data.UniqueConstraint> é adicionado ao <xref:System.Data.ConstraintCollection>, mas a propriedade `PrimaryKey` não é definida.  
  
-   Caso as colunas de chave primária e as colunas exclusivas sejam retornadas, as colunas de chave primária são usadas como as colunas de chave primária para o `DataTable`.  
  
 Observe que as chaves primárias e restrições exclusivas serão adicionadas para o <xref:System.Data.ConstraintCollection> acordo com as regras precedentes, mas outra restrição de tipos não são adicionados. Esse processo pode exigir várias viagens ao servidor.  
  
 Se um índice agrupado exclusivo estiver definido em colunas em uma tabela do SQL Server e a restrição de chave primária estiver definida em um conjunto de colunas separado, os nomes das colunas no índice agrupado serão retornados. Para retornar o nome ou os nomes das colunas de chave primária, use uma dica de consulta com a instrução SELECT que especifica o nome do índice de chave primária. Para obter mais informações sobre como especificar dicas de consulta, consulte [a dica de consulta (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Se o <xref:System.Data.Common.DbDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada. Conjuntos de resultados adicionais são nomeados adicionando valores inteiros para o nome da tabela especificada (por exemplo, "Table", "Table1", "Tabela2", etc.). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> não retorna nenhuma linha. Use o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método para adicionar linhas a um <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, o Provedor de Dados .NET Framework para SQL Server acrescenta uma cláusula FOR BROWSE à instrução executada. O usuário deve estar ciente de efeitos colaterais potenciais, como interferência no uso de instruções SET FMTONLY ON. Consulte os Manuais Online do SQL Server para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.SqlClient.SqlDataAdapter>, para preencher um <xref:System.Data.DataSet> com o esquema e retorna um <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">Um <see cref="T:System.Data.DataSet" /> para inserir o esquema.</param>
        <param name="schemaType">Um do valores <see cref="T:System.Data.SchemaType" /> que especificam como inserir o esquema.</param>
        <param name="srcTable">O nome da tabela de origem a ser usado para mapeamento de tabela.</param>
        <summary>Adiciona um <see cref="T:System.Data.DataTable" /> ao <see cref="T:System.Data.DataSet" /> especificado e configura o esquema para corresponder à fonte de dados com base nos <see cref="T:System.Data.SchemaType" /> e <see cref="T:System.Data.DataTable" /> especificados.</summary>
        <returns>Uma referência a uma coleção de objetos <see cref="T:System.Data.DataTable" /> que foram adicionados ao <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método recupera as informações de esquema de fonte de dados usando o <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 Um <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operação adiciona um <xref:System.Data.DataTable> para o destino <xref:System.Data.DataSet>. Em seguida, adiciona colunas para o <xref:System.Data.DataColumnCollection> do <xref:System.Data.DataTable>e configura o seguinte <xref:System.Data.DataColumn> propriedades se eles existirem na fonte de dados:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Você deve definir <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separadamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> também configura o <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> propriedades de acordo com as regras a seguir:  
  
-   Caso uma ou mais colunas de chave primária sejam retornadas pelo <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, elas são usadas como colunas de chave primária para o <xref:System.Data.DataTable>.  
  
-   Se não há colunas de chave primária são retornadas, mas são colunas exclusivas, as colunas exclusivas são usadas como chave primária se e somente se, todas as colunas exclusivas são não nulas. Caso qualquer uma das colunas seja anulável, um <xref:System.Data.UniqueConstraint> é adicionado ao <xref:System.Data.ConstraintCollection>, mas a propriedade <xref:System.Data.DataTable.PrimaryKey%2A> não é definida.  
  
-   Caso as colunas de chave primária e as colunas exclusivas sejam retornadas, as colunas de chave primária são usadas como as colunas de chave primária para o <xref:System.Data.DataTable>.  
  
 Observe que as chaves primárias e restrições exclusivas serão adicionadas para o <xref:System.Data.ConstraintCollection> acordo com as regras precedentes, mas outra restrição de tipos não são adicionados.  
  
 Se um índice agrupado exclusivo estiver definido em colunas em uma tabela do SQL Server e a restrição de chave primária estiver definida em um conjunto de colunas separado, os nomes das colunas no índice agrupado serão retornados. Para retornar o nome ou os nomes das colunas de chave primária, use uma dica de consulta com a instrução SELECT que especifica o nome do índice de chave primária. Para obter mais informações sobre como especificar dicas de consulta, consulte [a dica de consulta (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Informações de chave primária são usadas durante a <xref:System.Data.Common.DbDataAdapter.Fill%2A> para localizar e substituir quaisquer linhas cujas colunas de chave coincidem. Se isso não é o comportamento desejado, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> sem solicitar informações de esquema.  
  
 Se o <xref:System.Data.Common.DbDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada. Conjuntos de resultados adicionais são nomeados adicionando valores inteiros para o nome da tabela especificada (por exemplo, "Table", "Table1", "Tabela2", etc.). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 O <xref:System.Data.IDbConnection> objeto associado com o comando select deve ser válido, mas ele não precisa abrir. Se o <xref:System.Data.IDbConnection> está fechado antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é deixado em aberto.  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, o Provedor de Dados .NET Framework para SQL Server acrescenta uma cláusula FOR BROWSE à instrução executada. O usuário deve estar ciente de efeitos colaterais potenciais, como interferência no uso de instruções SET FMTONLY ON. Consulte os Manuais Online do SQL Server para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.SqlClient.SqlDataAdapter>, para preencher um <xref:System.Data.DataSet> com o esquema e retorna um <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.FillSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uma tabela de origem na qual não possível encontrar o esquema.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable FillSchema(class System.Data.DataTable dataTable, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ FillSchema(System::Data::DataTable ^ dataTable, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataTable">O <see cref="T:System.Data.DataTable" /> a ser preenchido com o esquema da fonte de dados.</param>
        <param name="schemaType">Um dos valores de <see cref="T:System.Data.SchemaType" />.</param>
        <param name="command">A instrução SQL SELECT usada para recuperar linhas da fonte de dados.</param>
        <param name="behavior">Um dos valores de <see cref="T:System.Data.CommandBehavior" />.</param>
        <summary>Configura o esquema do <see cref="T:System.Data.DataTable" /> especificado com base no <see cref="T:System.Data.SchemaType" />, na cadeia de caracteres de comando e nos valores <see cref="T:System.Data.CommandBehavior" /> especificados.</summary>
        <returns>Um objeto <see cref="T:System.Data.DataTable" /> que contém informações de esquema retornadas da fonte de dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> método recupera o esquema de fonte de dados usando o <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. O objeto de conexão associado ao <xref:System.Data.IDbDataAdapter.SelectCommand%2A> deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele permanecerá aberto.  
  
 Um <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operação adiciona um <xref:System.Data.DataTable> para o destino <xref:System.Data.DataSet>. Em seguida, adiciona colunas para o <xref:System.Data.DataColumnCollection> do <xref:System.Data.DataTable>e configura o seguinte <xref:System.Data.DataColumn> propriedades se eles existirem na fonte de dados:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Você deve definir <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separadamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> também configura o <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> propriedades de acordo com as regras a seguir:  
  
-   Caso uma ou mais colunas de chave primária sejam retornadas pelo <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, elas são usadas como colunas de chave primária para o <xref:System.Data.DataTable>.  
  
-   Se não há colunas de chave primária são retornadas, mas são colunas exclusivas, as colunas exclusivas são usadas como chave primária se e somente se, todas as colunas exclusivas são não nulas. Caso qualquer uma das colunas seja anulável, um <xref:System.Data.UniqueConstraint> é adicionado ao <xref:System.Data.ConstraintCollection>, mas a propriedade <xref:System.Data.DataTable.PrimaryKey%2A> não é definida.  
  
-   Caso as colunas de chave primária e as colunas exclusivas sejam retornadas, as colunas de chave primária são usadas como as colunas de chave primária para o <xref:System.Data.DataTable>.  
  
 Observe que as chaves primárias e restrições exclusivas serão adicionadas para o <xref:System.Data.ConstraintCollection> acordo com as regras precedentes, mas outra restrição de tipos não são adicionados.  
  
 Se um índice agrupado exclusivo estiver definido em colunas em uma tabela do SQL Server e a restrição de chave primária estiver definida em um conjunto de colunas separado, os nomes das colunas no índice agrupado serão retornados. Para retornar o nome ou os nomes das colunas de chave primária, use uma dica de consulta com a instrução SELECT que especifica o nome do índice de chave primária. Para obter mais informações sobre como especificar dicas de consulta, consulte [a dica de consulta (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Se o <xref:System.Data.IDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada. Conjuntos de resultados adicionais são nomeados adicionando valores inteiros para o nome da tabela especificada (por exemplo, "Table", "Table1", "Tabela2", etc.). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> não retorna nenhuma linha. Use o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método para adicionar linhas a um <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, o Provedor de Dados .NET Framework para SQL Server acrescenta uma cláusula FOR BROWSE à instrução executada. O usuário deve estar ciente de efeitos colaterais potenciais, como interferência no uso de instruções SET FMTONLY ON. Consulte os Manuais Online do SQL Server para obter mais informações.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Essa implementação do <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> método é protegido e é projetado para uso por um provedor de dados do .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType, class System.Data.IDbCommand command, string srcTable, valuetype System.Data.CommandBehavior behavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType, System::Data::IDbCommand ^ command, System::String ^ srcTable, System::Data::CommandBehavior behavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
        <Parameter Name="command" Type="System.Data.IDbCommand" />
        <Parameter Name="srcTable" Type="System.String" />
        <Parameter Name="behavior" Type="System.Data.CommandBehavior" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see cref="T:System.Data.DataSet" /> a ser preenchido com o esquema da fonte de dados.</param>
        <param name="schemaType">Um dos valores de <see cref="T:System.Data.SchemaType" />.</param>
        <param name="command">A instrução SQL SELECT usada para recuperar linhas da fonte de dados.</param>
        <param name="srcTable">O nome da tabela de origem a ser usado para mapeamento de tabela.</param>
        <param name="behavior">Um dos valores de <see cref="T:System.Data.CommandBehavior" />.</param>
        <summary>Adiciona um <see cref="T:System.Data.DataTable" /> ao <see cref="T:System.Data.DataSet" /> especificado e configura o esquema para corresponder à fonte de dados com base no <see cref="T:System.Data.SchemaType" /> especificado.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Data.DataTable" /> que contém informações de esquema retornadas da fonte de dados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> método recupera o esquema de fonte de dados usando o <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. O objeto de conexão associado ao <xref:System.Data.IDbDataAdapter.SelectCommand%2A> deve ser válido, mas não precisa estar aberto. Se a conexão for fechada antes <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele é aberto para recuperar dados e fechado. Se a conexão está aberta antes de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado, ele permanecerá aberto.  
  
 Um <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> operação adiciona um <xref:System.Data.DataTable> para o destino <xref:System.Data.DataSet>. Em seguida, adiciona colunas para o <xref:System.Data.DataColumnCollection> do <xref:System.Data.DataTable>e configura o seguinte <xref:System.Data.DataColumn> propriedades se eles existirem na fonte de dados:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Você deve definir <xref:System.Data.DataColumn.AutoIncrementStep%2A> e <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separadamente.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> também configura o <xref:System.Data.DataTable.PrimaryKey%2A> e <xref:System.Data.DataTable.Constraints%2A> propriedades de acordo com as regras a seguir:  
  
-   Caso uma ou mais colunas de chave primária sejam retornadas pelo <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, elas são usadas como colunas de chave primária para o <xref:System.Data.DataTable>.  
  
-   Se não há colunas de chave primária são retornadas, mas são colunas exclusivas, as colunas exclusivas são usadas como chave primária se e somente se, todas as colunas exclusivas são não nulas. Caso qualquer uma das colunas seja anulável, um <xref:System.Data.UniqueConstraint> é adicionado ao <xref:System.Data.ConstraintCollection>, mas a propriedade <xref:System.Data.DataTable.PrimaryKey%2A> não é definida.  
  
-   Caso as colunas de chave primária e as colunas exclusivas sejam retornadas, as colunas de chave primária são usadas como as colunas de chave primária para o <xref:System.Data.DataTable>.  
  
 Observe que as chaves primárias e restrições exclusivas serão adicionadas para o <xref:System.Data.ConstraintCollection> acordo com as regras precedentes, mas outra restrição de tipos não são adicionados.  
  
 Se um índice agrupado exclusivo estiver definido em colunas em uma tabela do SQL Server e a restrição de chave primária estiver definida em um conjunto de colunas separado, os nomes das colunas no índice agrupado serão retornados. Para retornar o nome ou os nomes das colunas de chave primária, use uma dica de consulta com a instrução SELECT que especifica o nome do índice de chave primária. Para obter mais informações sobre como especificar dicas de consulta, consulte [a dica de consulta (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Se o <xref:System.Data.IDataAdapter> encontra colunas duplicadas ao preencher um <xref:System.Data.DataTable>, ele gera nomes para as colunas subsequentes, usando o padrão "*columnname*1", "*columnname*2","*columnname*3", e assim por diante. Se os dados de entrada contém colunas sem nome, eles são colocados no <xref:System.Data.DataSet> acordo com o padrão "Coluna1", "Coluna2" e assim por diante. Quando vários conjuntos de resultados são adicionados para o <xref:System.Data.DataSet> cada conjunto de resultados é colocado em uma tabela separada. Conjuntos de resultados adicionais são nomeados adicionando valores inteiros para o nome da tabela especificada (por exemplo, "Table", "Table1", "Tabela2", etc.). Aplicativos que usam nomes de coluna e tabela devem garantir que está em conflito com esses padrões de nomenclatura não ocorra.  
  
 O <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Em tais situações, <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e cria uma nova tabela, não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
dataset.Tables.Add("AAA");  
adapter.FillSchema(dataset, "aaa"); // Fills the schema of "aaa", which already exists in the DataSet.  
adapter.FillSchema(dataset, "Aaa"); // Adds a new table called "Aaa".  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
dataset.Tables.Add("aaa");  
adapter.FillSchema(dataset, "AAA"); // Fills the schema of table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> não retorna nenhuma linha. Use o <xref:System.Data.Common.DbDataAdapter.Fill%2A> método para adicionar linhas a um <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Ao lidar com instruções SQL em lotes que retornem vários resultados, a implementação de <xref:System.Data.Common.DbDataAdapter.FillSchema%2A> para o provedor de dados .NET Framework para OLE DB recupera informações de esquema para apenas o primeiro resultado. Para recuperar informações de esquema para vários resultados, use <xref:System.Data.Common.DbDataAdapter.Fill%2A> com o <xref:System.Data.MissingSchemaAction> definido como `AddWithKey`.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>, o Provedor de Dados .NET Framework para SQL Server acrescenta uma cláusula FOR BROWSE à instrução executada. O usuário deve estar ciente de efeitos colaterais potenciais, como interferência no uso de instruções SET FMTONLY ON. Consulte os Manuais Online do SQL Server para obter mais informações.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Essa implementação do <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" /> método é protegido e é projetado para uso por um provedor de dados do .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedParameter">
      <MemberSignature Language="C#" Value="protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.IDataParameter GetBatchedParameter(int32 commandIdentifier, int32 parameterIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedParameter (commandIdentifier As Integer, parameterIndex As Integer) As IDataParameter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::IDataParameter ^ GetBatchedParameter(int commandIdentifier, int parameterIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="parameterIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">O índice do comando do qual recuperar o parâmetro.</param>
        <param name="parameterIndex">O índice do parâmetro no comando.</param>
        <summary>Retorna um <see cref="T:System.Data.IDataParameter" /> de um dos comandos no lote atual.</summary>
        <returns>O <see cref="T:System.Data.IDataParameter" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em <xref:System.Data.Common.DbDataAdapter>, este método lança <xref:System.NotSupportedException>. Classes que herdam de <xref:System.Data.Common.DbDataAdapter> substituir esse método para fornecer suporte para lotes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O adaptador não dá suporte a lotes.</exception>
        <block subset="none" type="overrides">
          <para>Esse método é protegido e é projetado para uso por um provedor de dados do .NET Framework.  
  
 Se uma classe que herda de <see cref="T:System.Data.Common.DbDataAdapter" /> oferece suporte a lotes, classe substitui esse método para permitir que os usuários executar um lote. Usa uma implementação de <paramref name="commandIdentifier" /> fornecido para localizar o comando solicitado e, em seguida, usa o <paramref name="parameterIndex" /> fornecida para localizar o parâmetro solicitado. Por exemplo, um <paramref name="commandIdentifier" /> 0 e um <paramref name="parameterIndex" /> de 0 retorna o primeiro parâmetro do primeiro comando no lote.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBatchedRecordsAffected">
      <MemberSignature Language="C#" Value="protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetBatchedRecordsAffected(int32 commandIdentifier, [out] int32&amp; recordsAffected, [out] class System.Exception&amp; error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetBatchedRecordsAffected (commandIdentifier As Integer, ByRef recordsAffected As Integer, ByRef error As Exception) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GetBatchedRecordsAffected(int commandIdentifier, [Runtime::InteropServices::Out] int % recordsAffected, [Runtime::InteropServices::Out] Exception ^ % error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandIdentifier" Type="System.Int32" />
        <Parameter Name="recordsAffected" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="System.Exception&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="commandIdentifier">O ordinal da coluna com base em zero do comando individual dentro do lote.</param>
        <param name="recordsAffected">O número de linhas afetadas no repositório de dados pelo comando especificado no lote.</param>
        <param name="error">Um <see cref="T:System.Exception" /> lançado durante a execução do comando especificado. Retornará <see langword="null" /> (<see langword="Nothing" /> no Visual Basic) se nenhuma exceção for lançada.</param>
        <summary>Retorna informações sobre uma tentativa de atualização individual dentro de uma atualização em lote maior.</summary>
        <returns>Informações sobre uma tentativa de atualização individual dentro de uma atualização em lote maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Provedores de dados que oferecem suporte a lógica de atualização em lotes devem substituir uma série de métodos virtuais no <xref:System.Data.Common.DbDataAdapter> classe. `GetBatchedRecordsAffected` representa um desses métodos virtuais. O `DbDataAdapter` classe depende `GetBatchedRecordsAffected` para determinar o êxito ou falha de tentativas de atualização individual dentro de um lote, portanto, ele pode marcar cada correspondente <xref:System.Data.DataRow> adequadamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public override System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.GetFillParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os parâmetros definidos pelo usuário ao executar uma instrução SQL SELECT.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Data.IDataParameter" /> que contém os parâmetros definidos pelo usuário.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeBatching">
      <MemberSignature Language="C#" Value="protected virtual void InitializeBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.InitializeBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeBatching();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa o envio em lote para o <see cref="T:System.Data.Common.DbDataAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em <xref:System.Data.Common.DbDataAdapter>, este método lança <xref:System.NotSupportedException>. Classes que herdam de <xref:System.Data.Common.DbDataAdapter> substituir esse método para fornecer suporte para lotes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O adaptador não dá suporte a lotes.</exception>
        <block subset="none" type="overrides">
          <para>Esse método é protegido e é projetado para uso por um provedor de dados do .NET Framework.  
  
 Se uma classe que herda de <see cref="T:System.Data.Common.DbDataAdapter" /> oferece suporte a lotes, classe substitui esse método. Esse método fornece a classe a oportunidade de inicializar todos os recursos necessários para dar suporte ao envio em lote. Por exemplo, uma classe pode alocar uma estrutura de dados para conter o conjunto de comandos no lote.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="InsertCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.InsertCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property InsertCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ InsertCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um comando usado para inserir novos registros na fonte de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> usado durante <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> para inserir registros na fonte de dados das novas linhas no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante a <xref:System.Data.Common.DbDataAdapter.Update%2A>, se essa propriedade não está definida e informações de chave primária estão presentes no <xref:System.Data.DataSet>, o <xref:System.Data.IDbDataAdapter.InsertCommand%2A> será gerado automaticamente.  
  
   
  
## Examples  
 O exemplo a seguir cria a classe derivada <xref:System.Data.OleDb.OleDbDataAdapter> e define algumas de suas propriedades.  
  
 [!code-csharp[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.InsertCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdated">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdated(class System.Data.Common.RowUpdatedEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdated (value As RowUpdatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdated(System::Data::Common::RowUpdatedEventArgs ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">Um <see cref="T:System.Data.Common.RowUpdatedEventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see langword="RowUpdated" /> de um provedor de dados .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowUpdating">
      <MemberSignature Language="C#" Value="protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowUpdating(class System.Data.Common.RowUpdatingEventArgs value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowUpdating (value As RowUpdatingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowUpdating(System::Data::Common::RowUpdatingEventArgs ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Data.Common.RowUpdatingEventArgs" />
      </Parameters>
      <Docs>
        <param name="value">Um <see cref="T:System.Data.Common.RowUpdatingEventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see langword="RowUpdating" /> de um provedor de dados .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratamento e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe de bases <see cref="M:System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SelectCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.SelectCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ SelectCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um comando usado para selecionar registros na fonte de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> que é usado durante o <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> para selecionar registros da fonte de dados para posicionamento no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria a classe derivada <xref:System.Data.OleDb.OleDbDataAdapter> e define algumas de suas propriedades.  
  
 [!code-csharp[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.SelectCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.DeleteCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand" />
      <MemberSignature Language="VB.NET" Value=" Property DeleteCommand As IDbCommand Implements IDbDataAdapter.DeleteCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.DeleteCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.DeleteCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma instrução SQL para excluir registros do conjunto de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> usado durante a <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> para excluir registros na fonte de dados para linhas excluídas no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Common.DbDataAdapter> é convertida em uma interface de <xref:System.Data.IDbDataAdapter>.  
  
 Para obter mais informações, consulte <xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.InsertCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand" />
      <MemberSignature Language="VB.NET" Value=" Property InsertCommand As IDbCommand Implements IDbDataAdapter.InsertCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.InsertCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.InsertCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma instrução SQL usada para inserir novos registros na fonte de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> usado durante o <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> para inserir registros na fonte de dados para novas linhas no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Common.DbDataAdapter> é convertida em uma interface de <xref:System.Data.IDbDataAdapter>.  
  
 Para obter mais informações, consulte <xref:System.Data.IDbDataAdapter.InsertCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.SelectCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand" />
      <MemberSignature Language="VB.NET" Value=" Property SelectCommand As IDbCommand Implements IDbDataAdapter.SelectCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.SelectCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.SelectCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma instrução SQL usada para selecionar registros na fonte de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> que é usado durante <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> para selecionar registros da fonte de dados para posicionamento no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Common.DbDataAdapter> é convertida em uma interface de <xref:System.Data.IDbDataAdapter>.  
  
 Para obter mais informações, consulte <xref:System.Data.IDbDataAdapter.SelectCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Data.IDbDataAdapter.UpdateCommand">
      <MemberSignature Language="C#" Value="System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand" />
      <MemberSignature Language="VB.NET" Value=" Property UpdateCommand As IDbCommand Implements IDbDataAdapter.UpdateCommand" />
      <MemberSignature Language="C++ CLI" Value="property System::Data::IDbCommand ^ System.Data.IDbDataAdapter.UpdateCommand { System::Data::IDbCommand ^ get(); void set(System::Data::IDbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.IDbDataAdapter.UpdateCommand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma instrução SQL usada para atualizar registros na fonte de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> usado durante a <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" /> para atualizar registros na fonte de dados para linhas modificadas no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Common.DbDataAdapter> é convertida em uma interface de <xref:System.Data.IDbDataAdapter>.  
  
 Para obter mais informações, consulte <xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo objeto que é uma cópia da instância atual.</summary>
        <returns>Um novo objeto que é uma cópia dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Common.DbDataAdapter> é convertida em uma interface de <xref:System.ICloneable>.  
  
 Para obter mais informações, consulte <xref:System.ICloneable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TerminateBatching">
      <MemberSignature Language="C#" Value="protected virtual void TerminateBatching ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TerminateBatching() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.TerminateBatching" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TerminateBatching ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TerminateBatching();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Encerra o envio em lote para o <see cref="T:System.Data.Common.DbDataAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em <xref:System.Data.Common.DbDataAdapter>, este método lança <xref:System.NotSupportedException>. Classes que herdam de <xref:System.Data.Common.DbDataAdapter> substituir esse método para fornecer suporte para lotes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O adaptador não dá suporte a lotes.</exception>
        <block subset="none" type="overrides">
          <para>Esse método é protegido e é projetado para uso por um provedor de dados do .NET Framework.  
  
 Se uma classe que herda de <see cref="T:System.Data.Common.DbDataAdapter" /> oferece suporte a lotes, classe substitui esse método. Esse método de classe a oportunidade de descartar todos os recursos alocados para dar suporte a envio em lote. Por exemplo, a classe pode desalocar a estrutura de dados que contém os comandos em lote.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Atualiza os valores no banco de dados executando as respectivas instruções INSERT, UPDATE ou DELETE para cada linha inserida, atualizada ou excluída no <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataRow[] dataRows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataRow[] dataRows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (dataRows As DataRow()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="dataRows">Uma matriz de objetos <see cref="T:System.Data.DataRow" /> usada para atualizar a fonte de dados.</param>
        <summary>Atualiza os valores no banco de dados executando as respectivas instruções INSERT, UPDATE ou DELETE para cada linha inserida, atualizada ou excluída na matriz especificada no <see cref="T:System.Data.DataSet" />.</summary>
        <returns>O número de linhas atualizadas com êxito a partir do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um aplicativo chama o <xref:System.Data.Common.DbDataAdapter.Update%2A> método, o <xref:System.Data.Common.DbDataAdapter> examina o <xref:System.Data.DataRow.RowState%2A> propriedade e executa as instruções INSERT, UPDATE ou DELETE necessárias iterativamente para cada linha, com base na ordem de índices configurados no <xref:System.Data.DataSet>. Por exemplo, <xref:System.Data.Common.DbDataAdapter.Update%2A> pode executar uma instrução DELETE, seguida por uma instrução INSERT e, em seguida, outra instrução de exclusão, devido à ordem das linhas de <xref:System.Data.DataTable>.  
  
 Observe que essas instruções não são executadas como um processo em lote; cada linha é atualizada individualmente. Um aplicativo pode chamar o <xref:System.Data.DataSet.GetChanges%2A> método em situações em que você deve controlar a sequência de tipos de instrução (por exemplo, inserções antes de atualizações). Para obter mais informações, consulte [Atualizar fontes de dados com DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se as instruções INSERT, UPDATE ou DELETE não forem especificadas, o <xref:System.Data.Common.DbDataAdapter.Update%2A> método gera uma exceção. No entanto, é possível criar um objeto <xref:System.Data.SqlClient.SqlCommandBuilder> ou <xref:System.Data.OleDb.OleDbCommandBuilder> para gerar automaticamente instruções SQL para atualizações de tabela única caso você defina a propriedade `SelectCommand` de um provedor de dados do .NET Framework. Em seguida, qualquer instrução SQL adicional que você não defina é geradas pelo **CommandBuilder**. Esta lógica de geração requer que as informações da coluna principal estejam presente no <xref:System.Data.DataSet>. Para obter mais informações, consulte [gerar comandos com CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 O <xref:System.Data.Common.DbDataAdapter.Update%2A> método recupera linhas da tabela listada no mapeamento primeiro antes de executar uma atualização. O <xref:System.Data.Common.DbDataAdapter.Update%2A> , em seguida, atualiza a linha usando o valor de <xref:System.Data.IDbCommand.UpdatedRowSource%2A> propriedade. Todas as linhas adicionais retornadas são ignoradas.  
  
 Depois que todos os dados são recarregados no <xref:System.Data.DataSet>, o evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é acionado, permitindo que o usuário inspecione a linha <xref:System.Data.DataSet> reconciliada e todos os parâmetros de saída retornados pelo comando. Depois que uma linha é atualizada com êxito, as alterações feitas nessa linha são aceitas.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.Update%2A>, a ordem de execução é o seguinte:  
  
1.  Os valores no <xref:System.Data.DataRow> são movidos para os valores de parâmetro.  
  
2.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> é gerado.  
  
3.  O comando é executado.  
  
4.  Se o comando é definido como `FirstReturnedRecord`, a primeira retornou o resultado é colocado no <xref:System.Data.DataRow>.  
  
5.  Se não houver parâmetros de saída, eles são colocados no <xref:System.Data.DataRow>.  
  
6.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é gerado.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> é chamado.  
  
 Cada comando associado a <xref:System.Data.Common.DbDataAdapter> normalmente tem uma coleção de parâmetros associada a ele. Os parâmetros são mapeados para a linha atual por meio das propriedades `SourceColumn` e `SourceVersion` da classe `Parameter` de um provedor de dados do .NET Framework. `SourceColumn` refere-se a uma <xref:System.Data.DataTable> coluna que o <xref:System.Data.Common.DbDataAdapter> referências para obter valores de parâmetro para a linha atual.  
  
 `SourceColumn` refere-se ao nome da coluna não mapeado antes da aplicação de qualquer mapeamento de tabela. Caso `SourceColumn` refira-se a uma coluna inexistente, a ação tomada depende de um dos valores <xref:System.Data.MissingMappingAction> a seguir.  
  
|Valor de enumeração|Ação realizada|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Use os nomes de coluna de fonte e os nomes de tabela no <xref:System.Data.DataSet> caso nenhum mapeamento esteja presente.|  
|`MissingMappingAction.Ignore`|Um <xref:System.SystemException> é gerado. Quando os mapeamentos são definidos explicitamente, um mapeamento ausente para um parâmetro de entrada é normalmente o resultado de um erro.|  
|`MissingMappingAction.Error`|Um <xref:System.SystemException> é gerado.|  
  
 A propriedade `SourceColumn` também é usada para remapear o valor para parâmetros de saída ou de entrada/saída para o `DataSet`. Uma exceção será gerada se fizer referência a uma coluna inexistente.  
  
 O `SourceVersion` propriedade de um provedor de dados do .NET Framework `Parameter` classe determina se deve usar a versão Original, atual ou proposta do valor da coluna. Geralmente, esse recurso é usado para incluir valores originais na cláusula WHERE de uma instrução UPDATE para verificar se há violações de simultaneidade otimista.  
  
> [!NOTE]
>  Caso ocorra um erro durante a atualização de uma linha, uma exceção é lançada e a execução da atualização é descontinuada. Para continuar a operação de atualização sem gerar exceções quando um erro é encontrado, defina a propriedade <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> como `true` antes de chamar <xref:System.Data.Common.DbDataAdapter.Update%2A>. Você também pode responder a erros linha por linha dentro do evento `RowUpdated` de um DataAdapter. Para continuar a operação de atualização sem gerar uma exceção dentro evento `RowUpdated`, defina a propriedade <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> do <xref:System.Data.Common.RowUpdatedEventArgs> como <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.OleDb.OleDbDataAdapter>para atualizar a fonte de dados.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.DataSet" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <exception cref="T:System.SystemException">Não há nenhum <see cref="T:System.Data.DataRow" /> para atualização.  
  
 - ou -  
  
 Não há nenhum <see cref="T:System.Data.DataTable" /> para atualização.  
  
 - ou -  
  
 Não há nenhum <see cref="T:System.Data.DataSet" /> para ser usado como uma fonte.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Uma tentativa de executar uma instrução INSERT, UPDATE ou DELETE resultou em zero registro afetado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public override int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Update(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Data.IDataAdapter.Update(System.Data.DataSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see cref="T:System.Data.DataSet" /> usado para atualizar a fonte de dados.</param>
        <summary>Atualiza os valores no banco de dados executando as respectivas instruções INSERT, UPDATE ou DELETE para cada linha inserida, atualizada ou excluída no <see cref="T:System.Data.DataSet" /> especificado.</summary>
        <returns>O número de linhas atualizadas com êxito a partir do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um aplicativo chama o <xref:System.Data.Common.DbDataAdapter.Update%2A> método, o <xref:System.Data.Common.DbDataAdapter> examina o <xref:System.Data.DataRow.RowState%2A> propriedade e executa as instruções INSERT, UPDATE ou DELETE necessárias iterativamente para cada linha, com base na ordem de índices configurados no <xref:System.Data.DataSet>. Por exemplo, <xref:System.Data.Common.DbDataAdapter.Update%2A> pode executar uma instrução DELETE, seguida por uma instrução INSERT e, em seguida, outra instrução de exclusão, devido à ordem das linhas de <xref:System.Data.DataTable>.  
  
 Observe que essas instruções não são executadas como um processo em lote; cada linha é atualizada individualmente. Um aplicativo pode chamar o <xref:System.Data.DataSet.GetChanges%2A> método em situações em que você deve controlar a sequência de tipos de instrução (por exemplo, inserções antes de atualizações). Para obter mais informações, consulte [Atualizar fontes de dados com DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se as instruções INSERT, UPDATE ou DELETE não forem especificadas, o <xref:System.Data.Common.DbDataAdapter.Update%2A> método gera uma exceção. No entanto, é possível criar um objeto <xref:System.Data.SqlClient.SqlCommandBuilder> ou <xref:System.Data.OleDb.OleDbCommandBuilder> para gerar automaticamente instruções SQL para atualizações de tabela única caso você defina a propriedade `SelectCommand` de um provedor de dados do .NET Framework. Em seguida, qualquer instrução SQL adicional que você não defina é geradas pelo **CommandBuilder**. Esta lógica de geração requer que as informações da coluna principal estejam presente no <xref:System.Data.DataSet>. Para obter mais informações, consulte [gerar comandos com CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 O <xref:System.Data.Common.DbDataAdapter.Update%2A> método recupera linhas da tabela listada no mapeamento primeiro antes de executar uma atualização. O <xref:System.Data.Common.DbDataAdapter.Update%2A> , em seguida, atualiza a linha usando o valor de <xref:System.Data.IDbCommand.UpdatedRowSource%2A> propriedade. Todas as linhas adicionais retornadas são ignoradas.  
  
 Depois que todos os dados são recarregados no <xref:System.Data.DataSet>, o evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é acionado, permitindo que o usuário inspecione a linha <xref:System.Data.DataSet> reconciliada e todos os parâmetros de saída retornados pelo comando. Depois que uma linha é atualizada com êxito, as alterações feitas nessa linha são aceitas.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.Update%2A>, a ordem de execução é o seguinte:  
  
1.  Os valores no <xref:System.Data.DataRow> são movidos para os valores de parâmetro.  
  
2.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> é gerado.  
  
3.  O comando é executado.  
  
4.  Se o comando é definido como `FirstReturnedRecord`, a primeira retornado o resultado é colocado no <xref:System.Data.DataRow>.  
  
5.  Se não houver parâmetros de saída, eles são colocados no <xref:System.Data.DataRow>.  
  
6.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é gerado.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> é chamado.  
  
 Cada comando associado a <xref:System.Data.Common.DbDataAdapter> normalmente tem uma coleção de parâmetros associada a ele. Os parâmetros são mapeados para a linha atual por meio das propriedades `SourceColumn` e `SourceVersion` da classe `Parameter` de um provedor de dados do .NET Framework. `SourceColumn` refere-se a uma <xref:System.Data.DataTable> coluna que o <xref:System.Data.Common.DbDataAdapter> referências para obter valores de parâmetro para a linha atual.  
  
 `SourceColumn` refere-se ao nome da coluna não mapeado antes da aplicação de qualquer mapeamento de tabela. Caso `SourceColumn` refira-se a uma coluna inexistente, a ação tomada depende de um dos valores <xref:System.Data.MissingMappingAction> a seguir.  
  
|Valor de enumeração|Ação realizada|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Use os nomes de coluna de fonte e os nomes de tabela no <xref:System.Data.DataSet> caso nenhum mapeamento esteja presente.|  
|`MissingMappingAction.Ignore`|Um <xref:System.SystemException> é gerado. Quando os mapeamentos são definidos explicitamente, um mapeamento ausente para um parâmetro de entrada é normalmente o resultado de um erro.|  
|`MissingMappingAction.Error`|Um <xref:System.SystemException> é gerado.|  
  
 A propriedade `SourceColumn` também é usada para remapear o valor para parâmetros de saída ou de entrada/saída para o `DataSet`. Uma exceção será gerada se fizer referência a uma coluna inexistente.  
  
 O `SourceVersion` propriedade de um provedor de dados do .NET Framework `Parameter` classe determina se deve usar a versão Original, atual ou proposta do valor da coluna. Geralmente, esse recurso é usado para incluir valores originais na cláusula WHERE de uma instrução UPDATE para verificar se há violações de simultaneidade otimista.  
  
> [!NOTE]
>  Caso ocorra um erro durante a atualização de uma linha, uma exceção é lançada e a execução da atualização é descontinuada. Para continuar a operação de atualização sem gerar exceções quando um erro é encontrado, defina a propriedade <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> como `true` antes de chamar <xref:System.Data.Common.DbDataAdapter.Update%2A>. Você também pode responder a erros linha por linha dentro do evento `RowUpdated` de um DataAdapter. Para continuar a operação de atualização sem gerar uma exceção dentro evento `RowUpdated`, defina a propriedade <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> do <xref:System.Data.Common.RowUpdatedEventArgs> como <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.OleDb.OleDbDataAdapter>para atualizar a fonte de dados.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Uma tentativa de executar uma instrução INSERT, UPDATE ou DELETE resultou em zero registro afetado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataTable ^ dataTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">O <see cref="T:System.Data.DataTable" /> usado para atualizar a fonte de dados.</param>
        <summary>Atualiza os valores no banco de dados executando as respectivas instruções INSERT, UPDATE ou DELETE para cada linha inserida, atualizada ou excluída no <see cref="T:System.Data.DataTable" /> especificado.</summary>
        <returns>O número de linhas atualizadas com êxito a partir do <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um aplicativo chama o <xref:System.Data.Common.DbDataAdapter.Update%2A> método, o <xref:System.Data.Common.DbDataAdapter> examina o <xref:System.Data.DataRow.RowState%2A> propriedade e executa as instruções INSERT, UPDATE ou DELETE necessárias iterativamente para cada linha, com base na ordem de índices configurados no <xref:System.Data.DataSet>. Por exemplo, <xref:System.Data.Common.DbDataAdapter.Update%2A> pode executar uma instrução DELETE, seguida por uma instrução INSERT e, em seguida, outra instrução de exclusão, devido à ordem das linhas de <xref:System.Data.DataTable>.  
  
 Observe que essas instruções não são executadas como um processo em lote; cada linha é atualizada individualmente. Um aplicativo pode chamar o <xref:System.Data.DataSet.GetChanges%2A> método em situações em que você deve controlar a sequência de tipos de instrução (por exemplo, inserções antes de atualizações). Para obter mais informações, consulte [Atualizar fontes de dados com DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se as instruções INSERT, UPDATE ou DELETE não forem especificadas, o <xref:System.Data.Common.DbDataAdapter.Update%2A> método gera uma exceção. No entanto, é possível criar um objeto <xref:System.Data.SqlClient.SqlCommandBuilder> ou <xref:System.Data.OleDb.OleDbCommandBuilder> para gerar automaticamente instruções SQL para atualizações de tabela única caso você defina a propriedade `SelectCommand` de um provedor de dados do .NET Framework. Em seguida, qualquer instrução SQL adicional que você não defina é geradas pelo **CommandBuilder**. Esta lógica de geração requer que as informações da coluna principal estejam presente no <xref:System.Data.DataSet>. Para obter mais informações, consulte [gerar comandos com CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 O <xref:System.Data.Common.DbDataAdapter.Update%2A> método recupera linhas da tabela listada no mapeamento primeiro antes de executar uma atualização. O <xref:System.Data.Common.DbDataAdapter.Update%2A> , em seguida, atualiza a linha usando o valor de <xref:System.Data.IDbCommand.UpdatedRowSource%2A> propriedade. Todas as linhas adicionais retornadas são ignoradas.  
  
 Depois que todos os dados são recarregados no <xref:System.Data.DataSet>, o evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é acionado, permitindo que o usuário inspecione a linha <xref:System.Data.DataSet> reconciliada e todos os parâmetros de saída retornados pelo comando. Depois que uma linha é atualizada com êxito, as alterações feitas nessa linha são aceitas.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.Update%2A>, a ordem de execução é o seguinte:  
  
1.  Os valores no <xref:System.Data.DataRow> são movidos para os valores de parâmetro.  
  
2.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> é gerado.  
  
3.  O comando é executado.  
  
4.  Se o comando é definido como `FirstReturnedRecord`, a primeira retornado o resultado é colocado no <xref:System.Data.DataRow>.  
  
5.  Se não houver parâmetros de saída, eles são colocados no <xref:System.Data.DataRow>.  
  
6.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é gerado.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> é chamado.  
  
 Cada comando associado a <xref:System.Data.Common.DbDataAdapter> normalmente tem uma coleção de parâmetros associada a ele. Os parâmetros são mapeados para a linha atual por meio das propriedades `SourceColumn` e `SourceVersion` da classe `Parameter` de um provedor de dados do .NET Framework. `SourceColumn` refere-se a uma <xref:System.Data.DataTable> coluna que o <xref:System.Data.Common.DbDataAdapter> referências para obter valores de parâmetro para a linha atual.  
  
 `SourceColumn` refere-se ao nome da coluna não mapeado antes da aplicação de qualquer mapeamento de tabela. Caso `SourceColumn` refira-se a uma coluna inexistente, a ação tomada depende de um dos valores <xref:System.Data.MissingMappingAction> a seguir.  
  
|Valor de enumeração|Ação realizada|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Use os nomes de coluna de fonte e os nomes de tabela no <xref:System.Data.DataSet> caso nenhum mapeamento esteja presente.|  
|`MissingMappingAction.Ignore`|Um <xref:System.SystemException> é gerado. Quando os mapeamentos são definidos explicitamente, um mapeamento ausente para um parâmetro de entrada é normalmente o resultado de um erro.|  
|`MissingMappingAction.Error`|Um <xref:System.SystemException> é gerado.|  
  
 A propriedade `SourceColumn` também é usada para remapear o valor para parâmetros de saída ou de entrada/saída para o `DataSet`. Uma exceção será gerada se fizer referência a uma coluna inexistente.  
  
 O `SourceVersion` propriedade de um provedor de dados do .NET Framework `Parameter` classe determina se deve usar a versão Original, atual ou proposta do valor da coluna. Geralmente, esse recurso é usado para incluir valores originais na cláusula WHERE de uma instrução UPDATE para verificar se há violações de simultaneidade otimista.  
  
> [!NOTE]
>  Caso ocorra um erro durante a atualização de uma linha, uma exceção é lançada e a execução da atualização é descontinuada. Para continuar a operação de atualização sem gerar exceções quando um erro é encontrado, defina a propriedade <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> como `true` antes de chamar <xref:System.Data.Common.DbDataAdapter.Update%2A>. Você também pode responder a erros linha por linha dentro do evento `RowUpdated` de um DataAdapter. Para continuar a operação de atualização sem gerar uma exceção dentro evento `RowUpdated`, defina a propriedade <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> do <xref:System.Data.Common.RowUpdatedEventArgs> como <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.OleDb.OleDbDataAdapter>para atualizar a fonte de dados.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.DataSet" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <exception cref="T:System.SystemException">Não há nenhum <see cref="T:System.Data.DataRow" /> para atualização.  
  
 - ou -  
  
 Não há nenhum <see cref="T:System.Data.DataTable" /> para atualização.  
  
 - ou -  
  
 Não há nenhum <see cref="T:System.Data.DataSet" /> para ser usado como uma fonte.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Uma tentativa de executar uma instrução INSERT, UPDATE ou DELETE resultou em zero registro afetado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance int32 Update(class System.Data.DataRow[] dataRows, class System.Data.Common.DataTableMapping tableMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Update (dataRows As DataRow(), tableMapping As DataTableMapping) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual int Update(cli::array &lt;System::Data::DataRow ^&gt; ^ dataRows, System::Data::Common::DataTableMapping ^ tableMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataRows" Type="System.Data.DataRow[]" />
        <Parameter Name="tableMapping" Type="System.Data.Common.DataTableMapping" />
      </Parameters>
      <Docs>
        <param name="dataRows">Uma matriz de objetos <see cref="T:System.Data.DataRow" /> usada para atualizar a fonte de dados.</param>
        <param name="tableMapping">A coleção <see cref="P:System.Data.IDataAdapter.TableMappings" /> a ser usada.</param>
        <summary>Atualiza os valores no banco de dados executando as respectivas instruções INSERT, UPDATE ou DELETE para cada linha inserida, atualizada ou excluída na matriz de objetos <see cref="T:System.Data.DataSet" /> especificada.</summary>
        <returns>O número de linhas atualizadas com êxito a partir do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um aplicativo chama o <xref:System.Data.Common.DbDataAdapter.Update%2A> método, o <xref:System.Data.Common.DbDataAdapter> examina o <xref:System.Data.DataRow.RowState%2A> propriedade e executa as instruções INSERT, UPDATE ou DELETE necessárias iterativamente para cada linha, com base na ordem de índices configurados no <xref:System.Data.DataSet>. Por exemplo, <xref:System.Data.Common.DbDataAdapter.Update%2A> pode executar uma instrução DELETE, seguida por uma instrução INSERT e, em seguida, outra instrução de exclusão, devido à ordem das linhas de <xref:System.Data.DataTable>.  
  
 Observe que essas instruções não são executadas como um processo em lote; cada linha é atualizada individualmente. Um aplicativo pode chamar o <xref:System.Data.DataSet.GetChanges%2A> método em situações em que você deve controlar a sequência de tipos de instrução (por exemplo, inserções antes de atualizações). Para obter mais informações, consulte [Atualizar fontes de dados com DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se as instruções INSERT, UPDATE ou DELETE não forem especificadas, o <xref:System.Data.Common.DbDataAdapter.Update%2A> método gera uma exceção. No entanto, é possível criar um objeto <xref:System.Data.SqlClient.SqlCommandBuilder> ou <xref:System.Data.OleDb.OleDbCommandBuilder> para gerar automaticamente instruções SQL para atualizações de tabela única caso você defina a propriedade `SelectCommand` de um provedor de dados do .NET Framework. Em seguida, qualquer instrução SQL adicional que você não defina é geradas pelo **CommandBuilder**. Esta lógica de geração requer que as informações da coluna principal estejam presente no <xref:System.Data.DataSet>. Para obter mais informações, consulte [gerar comandos com CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 O <xref:System.Data.Common.DbDataAdapter.Update%2A> método recupera linhas da tabela listada no mapeamento primeiro antes de executar uma atualização. O <xref:System.Data.Common.DbDataAdapter.Update%2A> , em seguida, atualiza a linha usando o valor de <xref:System.Data.IDbCommand.UpdatedRowSource%2A> propriedade. Todas as linhas adicionais retornadas são ignoradas.  
  
 Depois que todos os dados são recarregados no <xref:System.Data.DataSet>, o evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é acionado, permitindo que o usuário inspecione a linha <xref:System.Data.DataSet> reconciliada e todos os parâmetros de saída retornados pelo comando. Depois que uma linha é atualizada com êxito, as alterações feitas nessa linha são aceitas.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.Update%2A>, a ordem de execução é o seguinte:  
  
1.  Os valores no <xref:System.Data.DataRow> são movidos para os valores de parâmetro.  
  
2.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> é gerado.  
  
3.  O comando é executado.  
  
4.  Se o comando é definido como `FirstReturnedRecord`, a primeira retornado o resultado é colocado no <xref:System.Data.DataRow>.  
  
5.  Se não houver parâmetros de saída, eles são colocados no <xref:System.Data.DataRow>.  
  
6.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é gerado.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> é chamado.  
  
 Cada comando associado a <xref:System.Data.Common.DbDataAdapter> normalmente tem uma coleção de parâmetros associada a ele. Os parâmetros são mapeados para a linha atual por meio das propriedades `SourceColumn` e `SourceVersion` da classe `Parameter` de um provedor de dados do .NET Framework. `SourceColumn` refere-se a uma <xref:System.Data.DataTable> coluna que o <xref:System.Data.Common.DbDataAdapter> referências para obter valores de parâmetro para a linha atual.  
  
 `SourceColumn` refere-se ao nome da coluna não mapeado antes da aplicação de qualquer mapeamento de tabela. Caso `SourceColumn` refira-se a uma coluna inexistente, a ação tomada depende de um dos valores <xref:System.Data.MissingMappingAction> a seguir.  
  
|Valor de enumeração|Ação realizada|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Use os nomes de coluna de fonte e os nomes de tabela no <xref:System.Data.DataSet> caso nenhum mapeamento esteja presente.|  
|`MissingMappingAction.Ignore`|Um <xref:System.SystemException> é gerado. Quando os mapeamentos são definidos explicitamente, um mapeamento ausente para um parâmetro de entrada é normalmente o resultado de um erro.|  
|`MissingMappingAction.Error`|Um <xref:System.SystemException> é gerado.|  
  
 A propriedade `SourceColumn` também é usada para remapear o valor para parâmetros de saída ou de entrada/saída para o `DataSet`. Uma exceção será gerada se fizer referência a uma coluna inexistente.  
  
 O `SourceVersion` propriedade de um provedor de dados do .NET Framework `Parameter` classe determina se deve usar a versão Original, atual ou proposta do valor da coluna. Geralmente, esse recurso é usado para incluir valores originais na cláusula WHERE de uma instrução UPDATE para verificar se há violações de simultaneidade otimista.  
  
> [!NOTE]
>  Caso ocorra um erro durante a atualização de uma linha, uma exceção é lançada e a execução da atualização é descontinuada. Para continuar a operação de atualização sem gerar exceções quando um erro é encontrado, defina a propriedade <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> como `true` antes de chamar <xref:System.Data.Common.DbDataAdapter.Update%2A>. Você também pode responder a erros linha por linha dentro do evento `RowUpdated` de um DataAdapter. Para continuar a operação de atualização sem gerar uma exceção dentro evento `RowUpdated`, defina a propriedade <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> do <xref:System.Data.Common.RowUpdatedEventArgs> como <xref:System.Data.UpdateStatus.Continue>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.DataSet" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <exception cref="T:System.SystemException">Não há nenhum <see cref="T:System.Data.DataRow" /> para atualização.  
  
 - ou -  
  
 Não há nenhum <see cref="T:System.Data.DataTable" /> para atualização.  
  
 - ou -  
  
 Não há nenhum <see cref="T:System.Data.DataSet" /> para ser usado como uma fonte.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Uma tentativa de executar uma instrução INSERT, UPDATE ou DELETE resultou em zero registro afetado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet, string srcTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Data.DataSet dataSet, string srcTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet, System::String ^ srcTable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="srcTable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSet">O <see cref="T:System.Data.DataSet" /> a ser usado para atualizar a fonte de dados.</param>
        <param name="srcTable">O nome da tabela de origem a ser usado para mapeamento de tabela.</param>
        <summary>Atualiza os valores no banco de dados executando as respectivas instruções INSERT, UPDATE ou DELETE para cada linha inserida, atualizada ou excluída no <see cref="T:System.Data.DataSet" /> com o nome <see cref="T:System.Data.DataTable" /> especificado.</summary>
        <returns>O número de linhas atualizadas com êxito a partir do <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um aplicativo chama o <xref:System.Data.Common.DbDataAdapter.Update%2A> método, o <xref:System.Data.Common.DbDataAdapter> examina o <xref:System.Data.DataRow.RowState%2A> propriedade e executa as instruções INSERT, UPDATE ou DELETE necessárias iterativamente para cada linha, com base na ordem de índices configurados no <xref:System.Data.DataSet>. Por exemplo, <xref:System.Data.Common.DbDataAdapter.Update%2A> pode executar uma instrução DELETE, seguida por uma instrução INSERT e, em seguida, outra instrução de exclusão, devido à ordem das linhas de <xref:System.Data.DataTable>.  
  
 Observe que essas instruções não são executadas como um processo em lote; cada linha é atualizada individualmente. Um aplicativo pode chamar o <xref:System.Data.DataSet.GetChanges%2A> método em situações em que você deve controlar a sequência de tipos de instrução (por exemplo, inserir antes da atualização). Para obter mais informações, consulte [Atualizar fontes de dados com DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Se as instruções INSERT, UPDATE ou DELETE não forem especificadas, o <xref:System.Data.Common.DbDataAdapter.Update%2A> método gera uma exceção. No entanto, é possível criar um objeto <xref:System.Data.SqlClient.SqlCommandBuilder> ou <xref:System.Data.OleDb.OleDbCommandBuilder> para gerar automaticamente instruções SQL para atualizações de tabela única caso você defina a propriedade `SelectCommand` de um provedor de dados do .NET Framework. Em seguida, qualquer instrução SQL adicional que você não defina é geradas pelo **CommandBuilder**. Esta lógica de geração requer que as informações da coluna principal estejam presente no <xref:System.Data.DataSet>. Para obter mais informações, consulte [gerar comandos com CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 O <xref:System.Data.Common.DbDataAdapter.Update%2A> método oferece suporte a cenários onde o <xref:System.Data.DataSet> contém várias <xref:System.Data.DataTable> objetos cujos nomes diferenciam somente maiusculas e minúsculas. Quando várias tabelas com o mesmo nome, mas as maiusculas/minúsculas diferentes, existem em um `DataSet`, <xref:System.Data.Common.DbDataAdapter.Update%2A> executa uma comparação diferencia maiusculas de minúsculas para localizar a tabela correspondente e gera uma exceção não se houver nenhuma correspondência exata. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet ds = new DataSet();  
 ds.Tables.Add("aaa");  
 ds.Tables.Add("AAA");  
 adapter.Update(ds, "aaa"); // Updates "aaa", which already exists in the DataSet.  
 adapter.Update(ds, "AAA"); // Updates "AAA", which already exists in the DataSet.  
    adapter.Update(ds, "Aaa"); // Results in an exception.  
```  
  
 Se <xref:System.Data.Common.DbDataAdapter.Update%2A> é chamado e o <xref:System.Data.DataSet> contém apenas um <xref:System.Data.DataTable> cujo nome difere somente no caso, que <xref:System.Data.DataTable> é atualizada. Nesse cenário, a comparação diferencia maiusculas de minúsculas. O código c# a seguir ilustra esse comportamento.  
  
```  
DataSet dataset = new DataSet();  
 dataset.Tables.Add("aaa");  
    adapter.Update(dataset, "AAA"); // Updates table "aaa" because only one similarly named table is in the DataSet.  
```  
  
 O <xref:System.Data.Common.DbDataAdapter.Update%2A> método recupera linhas da tabela listada no mapeamento primeiro antes de executar uma atualização. O <xref:System.Data.Common.DbDataAdapter.Update%2A> , em seguida, atualiza a linha usando o valor de <xref:System.Data.IDbCommand.UpdatedRowSource%2A> propriedade. Todas as linhas adicionais retornadas são ignoradas.  
  
 Depois que todos os dados são recarregados no <xref:System.Data.DataSet>, o evento <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é acionado, permitindo que o usuário inspecione a linha <xref:System.Data.DataSet> reconciliada e todos os parâmetros de saída retornados pelo comando. Depois que uma linha é atualizada com êxito, as alterações feitas nessa linha são aceitas.  
  
 Ao usar <xref:System.Data.Common.DbDataAdapter.Update%2A>, a ordem de execução é o seguinte:  
  
1.  Os valores no <xref:System.Data.DataRow> são movidos para os valores de parâmetro.  
  
2.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> é gerado.  
  
3.  O comando é executado.  
  
4.  Se o comando é definido como `FirstReturnedRecord`, a primeira retornado o resultado é colocado no <xref:System.Data.DataRow>.  
  
5.  Se não houver parâmetros de saída, eles são colocados no <xref:System.Data.DataRow>.  
  
6.  O <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> é gerado.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> é chamado.  
  
 Cada comando associado a <xref:System.Data.Common.DbDataAdapter> normalmente tem uma coleção de parâmetros associada a ele. Os parâmetros são mapeados para a linha atual por meio das propriedades `SourceColumn` e `SourceVersion` da classe `Parameter` de um provedor de dados do .NET Framework. `SourceColumn` refere-se a uma <xref:System.Data.DataTable> coluna que o <xref:System.Data.Common.DbDataAdapter> referências para obter valores de parâmetro para a linha atual.  
  
 `SourceColumn` refere-se ao nome da coluna não mapeado antes da aplicação de qualquer mapeamento de tabela. Caso `SourceColumn` refira-se a uma coluna inexistente, a ação tomada depende de um dos valores <xref:System.Data.MissingMappingAction> a seguir.  
  
|Valor de enumeração|Ação realizada|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Use os nomes de coluna de fonte e os nomes de tabela no <xref:System.Data.DataSet> caso nenhum mapeamento esteja presente.|  
|`MissingMappingAction.Ignore`|Um <xref:System.SystemException> é gerado. Quando os mapeamentos são definidos explicitamente, um mapeamento ausente para um parâmetro de entrada é normalmente o resultado de um erro.|  
|`MissingMappingAction.Error`|Um <xref:System.SystemException> é gerado.|  
  
 A propriedade `SourceColumn` também é usada para remapear o valor para parâmetros de saída ou de entrada/saída para o `DataSet`. Uma exceção será gerada se fizer referência a uma coluna inexistente.  
  
 O `SourceVersion` propriedade de um provedor de dados do .NET Framework `Parameter` classe determina se deve usar a versão Original, atual ou proposta do valor da coluna. Geralmente, esse recurso é usado para incluir valores originais na cláusula WHERE de uma instrução UPDATE para verificar se há violações de simultaneidade otimista.  
  
> [!NOTE]
>  Caso ocorra um erro durante a atualização de uma linha, uma exceção é lançada e a execução da atualização é descontinuada. Para continuar a operação de atualização sem gerar exceções quando um erro é encontrado, defina a propriedade <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> como `true` antes de chamar <xref:System.Data.Common.DbDataAdapter.Update%2A>. Você também pode responder a erros linha por linha dentro do evento `RowUpdated` de um DataAdapter. Para continuar a operação de atualização sem gerar uma exceção dentro evento `RowUpdated`, defina a propriedade <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> do <xref:System.Data.Common.RowUpdatedEventArgs> como <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 O exemplo a seguir usa a classe derivada, <xref:System.Data.OleDb.OleDbDataAdapter>para atualizar a fonte de dados.  
  
 [!code-csharp[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.Update3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="T:System.Data.DataSet" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">A tabela de origem é inválida.</exception>
        <exception cref="T:System.Data.DBConcurrencyException">Uma tentativa de executar uma instrução INSERT, UPDATE ou DELETE resultou em zero registro afetado.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateBatchSize">
      <MemberSignature Language="C#" Value="public virtual int UpdateBatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UpdateBatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property UpdateBatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int UpdateBatchSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que habilita ou desabilita o suporte ao processamento de lote e especifica o número de comandos que podem ser executadas em um lote.</summary>
        <value>O número de linhas a serem processadas por lote.  
  
 <list type="table"><listheader><term> O valor é  
  
 </term><description> Efeito  
  
 </description></listheader><item><term> 0  
  
 </term><description> Não há nenhum limite no tamanho do lote.  
  
 </description></item><item><term> 1  
  
 </term><description> Desabilita a atualização em lotes.  
  
 </description></item><item><term> &gt; 1  
  
 </term><description> As alterações são enviadas com o uso de lotes <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" /> operações por vez.  
  
 </description></item></list>  
  
 Ao definir isso como um valor diferente de 1, todos os comandos associados a <see cref="T:System.Data.Common.DbDataAdapter" /> devem ter seus <see cref="P:System.Data.IDbCommand.UpdatedRowSource" /> propriedade definida como **nenhum** ou **OutputParameters**. Caso contrário, uma exceção será gerada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.Common.DbDataAdapter.UpdateBatchSize%2A> propriedade para atualizar uma fonte de dados com as alterações de um <xref:System.Data.DataSet>. Se o provedor de dados oferece suporte a processamento em lotes, isso pode aumentar o desempenho do aplicativo, reduzindo o número de ida e volta ao servidor. No ADO.NET 2.0, essa propriedade é suportada por provedores de dados .NET para SQL Server (SqlClient) e Oracle (OracleClient).  
  
 Executar um lote extremamente grande pode diminuir o desempenho. Portanto, você deve testar para verificar qual é a melhor configuração de tamanho de lote antes de implementar seu aplicativo.  
  
 Um <xref:System.ArgumentOutOfRangeException> será lançada se o valor é definido como um número menor que zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateCommand">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbCommand UpdateCommand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbCommand UpdateCommand" />
      <MemberSignature Language="DocId" Value="P:System.Data.Common.DbDataAdapter.UpdateCommand" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateCommand As DbCommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbCommand ^ UpdateCommand { System::Data::Common::DbCommand ^ get(); void set(System::Data::Common::DbCommand ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um comando usado para atualizar registros na fonte de dados.</summary>
        <value>Um <see cref="T:System.Data.IDbCommand" /> usado durante <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" /> para atualizar registros na fonte de dados para linhas modificadas no conjunto de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante a <xref:System.Data.Common.DbDataAdapter.Update%2A>, se essa propriedade não está definida e informações de chave primária estão presentes no <xref:System.Data.DataSet>, o <xref:System.Data.IDbDataAdapter.UpdateCommand%2A> será gerado automaticamente.  
  
   
  
## Examples  
 O exemplo a seguir cria a classe derivada <xref:System.Data.OleDb.OleDbDataAdapter> e define algumas de suas propriedades.  
  
 [!code-csharp[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DbDataAdapter.UpdateCommand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>