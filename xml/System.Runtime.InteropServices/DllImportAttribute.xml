<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e5ad390ef6e55e1305d31c7f58b06c4d1ec9c02b" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39828250" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica que o método atribuído é exposto por uma DLL (biblioteca de vínculo dinâmico) não gerenciada como um ponto de entrada estático.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode aplicar esse atributo para métodos.  
  
 O <xref:System.Runtime.InteropServices.DllImportAttribute> atributo fornece as informações necessárias para chamar uma função exportada de uma DLL não gerenciada. Como um requisito mínimo, você deve fornecer o nome da DLL que contém o ponto de entrada.  
  
 Aplicar esse atributo diretamente ao c# e as definições de método do C++. No entanto, o compilador do Visual Basic emite esse atributo quando você usa o `Declare` instrução. Para obter definições de método complexo que incluem <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, ou <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campos, aplicar esse atributo diretamente para as definições de método do Visual Basic.  
  
 **Observação** JScript não oferece suporte a esse atributo. Você pode usar o c# ou classes de wrapper do Visual Basic para acessar os métodos da API não gerenciados de programas de JScript.  
  
 Para obter mais informações sobre como usar a plataforma de invocar o serviço para acesso de funções em DLLs não gerenciadas, consulte [consumindo funções de DLL não gerenciadas](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
> [!NOTE]
>  O <xref:System.Runtime.InteropServices.DllImportAttribute> não oferece suporte a marshaling de tipos genéricos.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para importar do Win32 `MessageBox` função.  O exemplo de código chama o método importado.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">O nome da DLL que contém o método não gerenciado. Isso pode incluir um nome de exibição do assembly se a DLL estiver incluída em um assembly.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> com o nome da DLL que contém o método a ser importado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um arquivo DLL não gerenciado está incluído em um assembly, por exemplo, usando o vinculador ou o `/linkresource` opção de compilador, você pode especificar o nome de exibição do assembly como parte do `dllName`. Por exemplo, se uma DLL não gerenciada denominada `unmanaged.dll` está incluído em um assembly gerenciado chamado `MyAssembly`, o atributo pode ser especificado conforme mostrado no código a seguir.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para importar do Win32 `MessageBox` função.  O exemplo de código chama o método importado.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Habilita ou desabilita o comportamento de mapeamento mais adequado ao converter caracteres Unicode em caracteres ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `true`, fallback de melhor ajuste o comportamento de mapeamento é habilitado, o mapeamento de melhor ajuste, caso contrário, está desabilitado. O <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo é `true` por padrão. As configurações para esse campo substituem as configurações para qualquer nível de <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> atributo.  
  
 O common language runtime converte em caracteres ANSI que qualquer gerenciado caracteres Unicode passados para um método não gerenciado em execução no Windows 98 ou Windows Me. Mapeamento de melhor ajuste permite que o marshaler de interoperabilidade fornecer um caractere de fechamento de correspondência quando não existe nenhuma correspondência exata. Por exemplo, o marshaler converte o caractere de direitos autorais de Unicode para o c para métodos não gerenciados que aceitam caracteres ANSI. Alguns caracteres não têm uma representação de melhor ajuste; Esses caracteres são chamados não mapeável. Caracteres não mapeável geralmente são convertidos para o padrão '?' Caractere ANSI.  
  
> [!CAUTION]
>  Determinados caracteres Unicode são convertidos em caracteres perigosas, como a barra invertida '\\' caractere, que pode alterar inadvertidamente um caminho. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo para `true`, você pode sinalizar a presença de um caractere não mapeável ao chamador lançando uma exceção.  
  
> [!CAUTION]
>  Você não pode alterar os valores padrão fornecidos pelo <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campos quando passar uma matriz gerenciada cujos elementos é caracteres ANSI ou LPSTRs para uma matriz segura não gerenciada. Mapeamento de melhor ajuste está sempre habilitado e nenhuma exceção é lançada. Lembre-se de que essa combinação pode comprometer seu modelo de segurança.  
  
   
  
## Examples  
 Em alguns casos, os desenvolvedores de Visual Basic usam a <xref:System.Runtime.InteropServices.DllImportAttribute>, em vez do `Declare` instrução, para definir uma função de DLL em código gerenciado. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> campo é um dos casos. O exemplo a seguir mostra como aplicar o mais rígida segurança de mapeamento de caractere para uma plataforma de invocar as definições de método, especificando o conjunto de caracteres ANSI, desabilitando o melhor comportamento de mapeamento de ajuste e gerar uma exceção em caracteres de Unicode não mapeados.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica a convenção de chamada de um ponto de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina esse campo para um do <xref:System.Runtime.InteropServices.CallingConvention> membros de enumeração. O valor padrão para o <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo é <xref:System.Runtime.InteropServices.CallingConvention.Winapi>, cujo padrão é por sua vez <xref:System.Runtime.InteropServices.CallingConvention.StdCall> convenção.  
  
 Para obter mais informações, consulte a convenção de chamada na biblioteca MSDN.  
  
   
  
## Examples  
 Em alguns casos, os desenvolvedores de Visual Basic usam a <xref:System.Runtime.InteropServices.DllImportAttribute>, em vez do `Declare` instrução, para definir uma função de DLL em código gerenciado. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> campo é um dos casos.  
  
 System.Runtime.InteropServices.DllImportAttribute#1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica como realizar marshaling de parâmetros de cadeia de caracteres para o método e a desconfiguração de nome de controles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse campo com um membro do <xref:System.Runtime.InteropServices.CharSet> enumeração para especificar o comportamento de marshaling de parâmetros de cadeia de caracteres e para especificar qual nome de ponto de entrada para invocar (o nome exato fornecido ou um nome que termina com "A" ou "W"). É o membro de enumeração padrão para c# e Visual Basic `CharSet.Ansi` e é o membro de enumeração padrão do C++ `CharSet.None`, que é equivalente a `CharSet.Ansi`. No Visual Basic, você deve usar o `Declare` instrução para especificar o `CharSet` campo.  
  
 O <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo influencia o comportamento do `CharSet` campo determinar qual nome de ponto de entrada para invocar. Para obter uma descrição detalhada e exemplos do marshaling de cadeia de caracteres e o nome de correspondência de comportamento associado com o `CharSet` campo, consulte [especificando um conjunto de caracteres](~/docs/framework/interop/specifying-a-character-set.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para importar do Win32 `MessageBox` função.  O exemplo de código chama o método importado.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o nome ou o ordinal do ponto de entrada DLL a ser chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar o nome do ponto de entrada, fornecendo uma cadeia de caracteres que indica o nome da DLL que contém o ponto de entrada, ou você pode identificar o ponto de entrada pelo seu ordinal. Ordinais são prefixados com o sinal #, por exemplo, #1. Se você omitir esse campo, o common language runtime usa o nome do método do.NET marcado com o <xref:System.Runtime.InteropServices.DllImportAttribute>.  
  
 Para obter mais informações, consulte [identificando funções em DLLs](~/docs/framework/interop/identifying-functions-in-dlls.md). Para obter exemplos que mostram como usar o <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> campo, consulte [especificando um ponto de entrada](~/docs/framework/interop/specifying-an-entry-point.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para importar do Win32 `MessageBox` função.  O exemplo de código usa o <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> propriedade para especificar a função a ser importado e, em seguida, altera o nome para `MyNewMessageBoxMethod`.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Controla se o campo <see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> faz com que a Common Language Runtime pesquise uma DLL não gerenciada quanto a nomes de ponto de entrada diferentes daquele especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `false`, o nome do ponto de entrada anexado com a letra A é invocado quando o <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo é definido como `CharSet.Ansi`, e o nome de ponto de entrada anexado com a letra W é invocado quando o <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> campo é definido como o `CharSet.Unicode`. Normalmente, os compiladores gerenciados defina esse campo.  
  
 A tabela a seguir mostra a relação entre o <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> e <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campos, com base nos valores padrão impostas pela linguagem de programação. Você pode substituir a configuração padrão, mas fazer isso com cuidado.  
  
|Idioma|ANSI|Unicode|Auto|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling: = True|ExactSpelling: = True|ExactSpelling: = False|  
|C#|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
|C++|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
  
   
  
## Examples  
 Em alguns casos, os desenvolvedores de Visual Basic usam a <xref:System.Runtime.InteropServices.DllImportAttribute>, em vez de usar o `Declare` instrução, para definir uma função de DLL em código gerenciado. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> campo é um dos casos.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se os métodos não gerenciados que têm valores retornados <see langword="HRESULT" /> ou <see langword="retval" /> são traduzidos diretamente ou se os valores retornados <see langword="HRESULT" /> e <see langword="retval" /> são convertidos automaticamente para exceções.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina a <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo para `true` a tradução diretamente de assinaturas não gerenciadas com `HRESULT` ou `retval` valores; defini-lo como `false` converter automaticamente `HRESULT` ou `retval` valores às exceções. Por padrão, o <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo é `true`.  
  
 Quando `true`, a assinatura resultante do método retorna um valor inteiro que contém o `HRESULT` valor.  Nesse caso, você deve inspecionar o valor de retorno e responder adequadamente manualmente em seu aplicativo.  
  
 Quando você define o <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo para `false`, a assinatura do método resultante contém um tipo de retorno nulo em vez de um número inteiro (`HRESULT`) tipo de retorno.  Quando o método não gerenciado gera uma `HRESULT`, o tempo de execução ignora automaticamente um valor de retorno de `S_OK` (ou 0) e não gerará uma exceção.  Para `HRESULT`s diferente `S_OK`, o tempo de execução gera automaticamente uma exceção que corresponde à `HRESULT`.  Observe que o <xref:System.Runtime.InteropServices.DllImportAttribute> atributo só executa essa conversão para métodos que retornam um `HRESULT`.  
  
 Você pode optar por alterar o comportamento a partir de relatório de erros de padrão `HRESULT`s às exceções em casos em que as exceções se ajuste melhor a estrutura do seu aplicativo de relatório de erros.  
  
 Esse campo é semelhante para o <xref:System.Runtime.InteropServices.PreserveSigAttribute>; no entanto, em contraste com o <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo, o valor padrão para o atributo é `false`.  
  
 Em alguns casos, os desenvolvedores de Visual Basic usam a <xref:System.Runtime.InteropServices.DllImportAttribute>, em vez de usar o `Declare` instrução, para definir uma função de DLL em código gerenciado. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo é um dos casos.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Runtime.InteropServices.DllImportAttribute> para importar não gerenciado `SHAutoComplete` função uma vez com o <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo definido como `true` e, novamente com o <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> campo definido como `false`.  Este exemplo de código faz com que o `SHAutoComplete` função para gerar erros com uma exceção, uma vez e um `HRESULT` a próxima.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o computador chamado chama a <see langword="SetLastError" /> função da API do Win32 antes de retornar do método atribuído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` para indicar que o receptor chamará `SetLastError`; caso contrário, `false`. O padrão é `false`.  
  
 A marshaler de tempo de execução chama `GetLastError` e armazena em cache o valor retornado para impedir que ele seja substituído por outras chamadas à API. Você pode recuperar o código de erro chamando <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>.  
  
   
  
## Examples  
 Em alguns casos, os desenvolvedores de Visual Basic usam a <xref:System.Runtime.InteropServices.DllImportAttribute>, em vez de usar o `Declare` instrução, para definir uma função de DLL em código gerenciado. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo é um dos casos.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Habilita ou desabilita a geração de uma exceção em um caractere Unicode não mapeável que é convertido em um caractere "?" ANSI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` para indicar que uma exceção é lançada sempre que o marshaler de interoperabilidade converte um caractere não mapeável; `false` para indicar que o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo será desabilitado. Este campo é `false` por padrão.  
  
 O common language runtime converte em caracteres ANSI que qualquer gerenciado caracteres Unicode passados para um método não gerenciado em execução no Windows 98 ou Windows Me. Mapeamento de melhor ajuste permite que o marshaler de interoperabilidade fornecer um caractere de fechamento de correspondência quando não existe nenhuma correspondência exata. Por exemplo, o marshaler converte o caractere de direitos autorais de Unicode para o c para métodos não gerenciados que aceitam caracteres ANSI. Alguns caracteres não têm uma representação de melhor ajuste; Esses caracteres são chamados não mapeável. Caracteres não mapeável geralmente são convertidos para o padrão '?' Caractere ANSI.  
  
> [!CAUTION]
>  Determinados caracteres Unicode são convertidos em caracteres perigosas, como a barra invertida '\\' caractere, que pode alterar inadvertidamente um caminho. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo para `true`, você pode sinalizar a presença de um caractere não mapeável ao chamador lançando uma exceção.  
  
> [!CAUTION]
>  Você não pode alterar os valores padrão fornecidos pelo <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> e <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campos quando passar uma matriz gerenciada cujos elementos é caracteres ANSI ou LPSTRs para uma matriz segura não gerenciada. Mapeamento de melhor ajuste está sempre habilitado e nenhuma exceção é lançada. Lembre-se de que essa combinação pode comprometer seu modelo de segurança.  
  
   
  
## Examples  
 Em alguns casos, os desenvolvedores de Visual Basic usam a <xref:System.Runtime.InteropServices.DllImportAttribute> para definir uma função de DLL em código gerenciado, em vez de usar o `Declare` instrução. Definindo o <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> campo é um dos casos. O exemplo a seguir mostra como aplicar o mais rígida segurança de mapeamento de caractere para uma plataforma de invocar as definições de método, especificando o conjunto de caracteres ANSI, desabilitando o melhor comportamento de mapeamento de ajuste e gerar uma exceção em caracteres de Unicode não mapeados.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do arquivo DLL que contém o ponto de entrada.</summary>
        <value>O nome do arquivo DLL que contém o ponto de entrada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode fornecer um caminho completo ou relativo. Se você não fornecer nenhum caminho, a DLL deve ser no caminho atual em tempo de execução, a menos que a DLL é carregada por outros meios. Lembre-se, no entanto, que usando um caminho totalmente qualificado pode introduzir imprecisão se a DLL é movida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>