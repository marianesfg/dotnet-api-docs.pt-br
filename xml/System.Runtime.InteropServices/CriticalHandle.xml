<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75db119abc6e44bc32148b4932aafa4b6e380d6e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36634094" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type CriticalHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="746ef-101">Represents a wrapper class for handle resources.</span>
      <span class="sxs-lookup">
        <span data-stu-id="746ef-101">Represents a wrapper class for handle resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-102">O <xref:System.Runtime.InteropServices.CriticalHandle> classe é semelhante do <xref:System.Runtime.InteropServices.SafeHandle> classe, exceto que <xref:System.Runtime.InteropServices.SafeHandle> implementa a contagem de referência.</span><span class="sxs-lookup"><span data-stu-id="746ef-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="746ef-103">Você pode usar <xref:System.Runtime.InteropServices.CriticalHandle> em vez de <xref:System.Runtime.InteropServices.SafeHandle> para as considerações de desempenho de endereços quando você pode fornecer a sincronização necessária mais eficiente por conta própria.</span><span class="sxs-lookup"><span data-stu-id="746ef-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="746ef-104">Porque o <xref:System.Runtime.InteropServices.CriticalHandle> classe não realiza a contagem de referência, ele não fornece proteção contra ataques de segurança de reciclagem de identificador.</span><span class="sxs-lookup"><span data-stu-id="746ef-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="746ef-105">Porque a referência de algoritmo de contagem implicitamente serializa as operações, uma determinada quantidade de acesso thread-safe também serão perdida.</span><span class="sxs-lookup"><span data-stu-id="746ef-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="746ef-106">Se você chamar o <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> método enquanto uma operação que está usando o identificador está pendente em outro thread, ou se você chamar <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> de dois threads ao mesmo tempo, os resultados são não determinísticas.</span><span class="sxs-lookup"><span data-stu-id="746ef-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="746ef-107">O <xref:System.Runtime.InteropServices.CriticalHandle> classe ainda fornece a finalização crítica garantida fornecida pelo <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe.</span><span class="sxs-lookup"><span data-stu-id="746ef-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="746ef-108">para confiança total de herdeiros.</span>
      <span class="sxs-lookup">
        <span data-stu-id="746ef-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="746ef-109">Este membro não pode ser herdado por código parcialmente confiável.</span>
      <span class="sxs-lookup">
        <span data-stu-id="746ef-109">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="746ef-110">requer confiança total para o chamador imediato.</span>
      <span class="sxs-lookup">
        <span data-stu-id="746ef-110">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="746ef-111">Essa classe não pode ser usada por código parcialmente confiável ou transparente.</span>
      <span class="sxs-lookup">
        <span data-stu-id="746ef-111">This class cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.CriticalHandle : nativeint -&gt; System.Runtime.InteropServices.CriticalHandle" Usage="new System.Runtime.InteropServices.CriticalHandle invalidHandleValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="746ef-112">The value of an invalid handle (usually 0 or -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-112">The value of an invalid handle (usually 0 or -1).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="746ef-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="746ef-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="746ef-115">para confiança total de herdeiros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-115">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="746ef-116">Este membro não pode ser herdado por código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-116">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="746ef-117">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-117">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="746ef-118">Essa classe não pode ser usada por código parcialmente confiável ou transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-118">This class cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="criticalHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="746ef-119">Marks the handle for releasing and freeing resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-119">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-120">Chamando o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método permite que os recursos sejam liberados.</span><span class="sxs-lookup"><span data-stu-id="746ef-120">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="746ef-121">Ao contrário de <xref:System.Runtime.InteropServices.SafeHandle> classe, isso acontecerá sempre imediatamente porque não há nenhuma contagem de referência para indicar que outro thread está usando esse identificador.</span><span class="sxs-lookup"><span data-stu-id="746ef-121">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="746ef-122">Portanto, você deve empregar um mecanismo de sincronização para garantir que ele é seguro chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="746ef-122">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="746ef-123">Embora a maioria das classes que usam o <xref:System.Runtime.InteropServices.CriticalHandle> classe não é necessário fornecer um finalizador, isso às vezes é necessário (por exemplo, para liberar os buffers de arquivo ou escrever alguns dados de volta para a memória).</span><span class="sxs-lookup"><span data-stu-id="746ef-123">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="746ef-124">Nesse caso, a classe pode fornecer um finalizador que sempre é executado antes do <xref:System.Runtime.InteropServices.CriticalHandle> executa finalizador crítico.</span><span class="sxs-lookup"><span data-stu-id="746ef-124">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="746ef-125">Chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método quando tiver terminado de usar o <xref:System.Runtime.InteropServices.CriticalHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="746ef-125">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="746ef-126">O <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método deixa o <xref:System.Runtime.InteropServices.CriticalHandle> objeto em um estado inutilizável.</span><span class="sxs-lookup"><span data-stu-id="746ef-126">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="746ef-127">**Observação** sempre chamada <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> antes de liberar sua última referência para o <xref:System.Runtime.InteropServices.CriticalHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="746ef-127">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="746ef-128">Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Runtime.InteropServices.CriticalHandle> do objeto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="746ef-128">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="746ef-129">Marks the handle for releasing and freeing resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-129">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="criticalHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="746ef-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-131">Chamando o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método permite que os recursos sejam liberados.</span><span class="sxs-lookup"><span data-stu-id="746ef-131">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="746ef-132">Ao contrário de <xref:System.Runtime.InteropServices.SafeHandle> classe, isso acontecerá sempre imediatamente porque não há nenhuma contagem de referência para indicar que outro thread está usando esse identificador.</span><span class="sxs-lookup"><span data-stu-id="746ef-132">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="746ef-133">Portanto, você deve empregar um mecanismo de sincronização para garantir que ele é seguro chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método.</span><span class="sxs-lookup"><span data-stu-id="746ef-133">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="746ef-134">Embora a maioria das classes que usam o <xref:System.Runtime.InteropServices.CriticalHandle> classe não é necessário fornecer um finalizador, isso às vezes é necessário (por exemplo, para liberar os buffers de arquivo ou escrever alguns dados de volta para a memória).</span><span class="sxs-lookup"><span data-stu-id="746ef-134">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="746ef-135">Nesse caso, a classe pode fornecer um finalizador que sempre é executado antes do <xref:System.Runtime.InteropServices.CriticalHandle> executa finalizador crítico.</span><span class="sxs-lookup"><span data-stu-id="746ef-135">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="746ef-136">Chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método quando tiver terminado de usar o <xref:System.Runtime.InteropServices.CriticalHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="746ef-136">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="746ef-137">O <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método deixa o <xref:System.Runtime.InteropServices.CriticalHandle> objeto em um estado inutilizável.</span><span class="sxs-lookup"><span data-stu-id="746ef-137">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="746ef-138">**Observação** sempre chamada a <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método antes de liberar sua última referência para o <xref:System.Runtime.InteropServices.CriticalHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="746ef-138">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="746ef-139">Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Runtime.InteropServices.CriticalHandle> do objeto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="746ef-139">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="criticalHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="746ef-140">
            <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-140">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="746ef-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-142">Você deve chamar nunca explicitamente o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método com o `disposing` parâmetro definido como `false`.</span><span class="sxs-lookup"><span data-stu-id="746ef-142">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="criticalHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="746ef-143">Frees all resources associated with the handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-143">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-144">O <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método é o destruidor para o <xref:System.Runtime.InteropServices.CriticalHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="746ef-144">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="746ef-145">Código do aplicativo não deve chamar este método diretamente.</span><span class="sxs-lookup"><span data-stu-id="746ef-145">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="746ef-146">Specifies the handle to be wrapped.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-146">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-147">Não exponha o identificador publicamente (ou seja, fora da classe derivada).</span><span class="sxs-lookup"><span data-stu-id="746ef-147">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="746ef-148">Gets a value indicating whether the handle is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-148">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="746ef-149">
            <see langword="true" /> se o identificador estiver fechado; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-149">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-150">O <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> método retorna um valor que indica se o <xref:System.Runtime.InteropServices.CriticalHandle> identificador do objeto não está mais associado um recurso nativo.</span><span class="sxs-lookup"><span data-stu-id="746ef-150">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="746ef-151">Isso é diferente da definição do <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade, que calcula se um determinado identificador sempre é considerado inválido.</span><span class="sxs-lookup"><span data-stu-id="746ef-151">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="746ef-152">O <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> método retorna um `true` valor nos seguintes casos:</span><span class="sxs-lookup"><span data-stu-id="746ef-152">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="746ef-153">O <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> método foi chamado.</span><span class="sxs-lookup"><span data-stu-id="746ef-153">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="746ef-154">O <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método ou <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método foi chamado e não houver nenhuma referência para o <xref:System.Runtime.InteropServices.CriticalHandle> objeto em outros threads.</span><span class="sxs-lookup"><span data-stu-id="746ef-154">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="746ef-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="746ef-156">
            <see langword="true" /> Se o identificador é válido. Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-156">
              <see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-157">Classes derivadas devem implementar a <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade para que o common language runtime pode determinar se a finalização crítica é necessária.</span><span class="sxs-lookup"><span data-stu-id="746ef-157">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="746ef-158">Classes derivadas devem fornecer uma implementação que se adapta ao tipo geral de identificador de dar suporte a eles (0 ou -1 é inválida).</span><span class="sxs-lookup"><span data-stu-id="746ef-158">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="746ef-159">Essas classes, em seguida, podem ser mais derivadas para tipos de identificador de segurança específico.</span><span class="sxs-lookup"><span data-stu-id="746ef-159">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="746ef-160">Ao contrário de <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> propriedade, que informa se o <xref:System.Runtime.InteropServices.CriticalHandle> objeto terminou de usar o identificador subjacente, o <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade calcula se o valor do identificador fornecido é sempre considerado inválido.</span><span class="sxs-lookup"><span data-stu-id="746ef-160">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="746ef-161">Portanto, o <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade sempre retorna o mesmo valor para qualquer valor de um identificador.</span><span class="sxs-lookup"><span data-stu-id="746ef-161">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="criticalHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="746ef-162">When overridden in a derived class, executes the code required to free the handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-162">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="746ef-163">
            <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-163">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="746ef-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-165">O <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método é garantido para ser chamado apenas uma vez, desde que você empregue mecanismos de sincronização adequada para garantir que apenas uma chamada para o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método é feito.</span><span class="sxs-lookup"><span data-stu-id="746ef-165">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="746ef-166">O <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método não será chamado se o <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> é de propriedade `true`.</span><span class="sxs-lookup"><span data-stu-id="746ef-166">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="746ef-167">Implementar esse método no seu <xref:System.Runtime.InteropServices.CriticalHandle> derivadas de classes para executar qualquer código que é necessário para liberar o identificador.</span><span class="sxs-lookup"><span data-stu-id="746ef-167">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="746ef-168">Porque uma das funções de <xref:System.Runtime.InteropServices.CriticalHandle> é garantir a prevenção de perda de recursos, o código em sua implementação de <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> nunca deve falhar.</span><span class="sxs-lookup"><span data-stu-id="746ef-168">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="746ef-169">O coletor de lixo chama <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> depois finalizadores normais foram executados para objetos que foram limpos ao mesmo tempo, e garante que os recursos para invocar e que ele não será interrompido enquanto ele está em andamento.</span><span class="sxs-lookup"><span data-stu-id="746ef-169">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="746ef-170">Esse método será preparado como uma região de execução restrita (CER) no tempo de construção da instância (junto com todos os métodos em seu gráfico de chamada estaticamente determinável).</span><span class="sxs-lookup"><span data-stu-id="746ef-170">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="746ef-171">Embora isso impede que as interrupções de anulação de thread, você ainda deve ter cuidado para não incluir todos os caminhos falhas no seu substituído <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método.</span><span class="sxs-lookup"><span data-stu-id="746ef-171">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="746ef-172">Em particular, se aplicam a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> a qualquer método que você chamar a partir de atributo <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="746ef-172">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="746ef-173">Na maioria dos casos, esse código deve ser:</span><span class="sxs-lookup"><span data-stu-id="746ef-173">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="746ef-174">Além disso, para limpeza simple (por exemplo, chamar a API do Win32 `CloseHandle` em um identificador de arquivo) você pode verificar o valor de retorno de chamada de invocação de plataforma única.</span><span class="sxs-lookup"><span data-stu-id="746ef-174">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="746ef-175">Para limpeza complexa, você pode ter muita lógica de programa e muitas chamadas de método, algumas das quais podem falhar.</span><span class="sxs-lookup"><span data-stu-id="746ef-175">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="746ef-176">Certifique-se de que sua lógica de programa tem código de retorno para cada um desses casos.</span><span class="sxs-lookup"><span data-stu-id="746ef-176">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="746ef-177">Se o <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método `false` por qualquer motivo, ele gera um [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistente de depuração gerenciada.</span><span class="sxs-lookup"><span data-stu-id="746ef-177">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="criticalHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="746ef-178">The pre-existing handle to use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-178">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="746ef-179">Sets the handle to the specified pre-existing handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-179">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-180">Use o <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> método somente se você precisar oferecer suporte a um identificador já existente (por exemplo, se o identificador é retornado em uma estrutura) porque a infraestrutura de interoperabilidade do .NET Framework COM não oferece suporte para marshaling trata-se em uma estrutura.</span><span class="sxs-lookup"><span data-stu-id="746ef-180">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="criticalHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="746ef-181">Marks a handle as invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="746ef-181">Marks a handle as invalid.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="746ef-182">Chamar o <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> método somente quando souber que o identificador é inválido e deseja marcá-la como tal.</span><span class="sxs-lookup"><span data-stu-id="746ef-182">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="746ef-183">Isso não altera o valor de <xref:System.Runtime.InteropServices.CriticalHandle.handle> campo; ela marca apenas o identificador como inválido.</span><span class="sxs-lookup"><span data-stu-id="746ef-183">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="746ef-184">O identificador, em seguida, pode conter um valor potencialmente obsoleto.</span><span class="sxs-lookup"><span data-stu-id="746ef-184">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="746ef-185">O efeito dessa chamada é que é feita nenhuma tentativa para liberar os recursos.</span><span class="sxs-lookup"><span data-stu-id="746ef-185">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="746ef-186">Assim como acontece com o <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> método, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> somente se você precisar oferecer suporte a um identificador já existente.</span><span class="sxs-lookup"><span data-stu-id="746ef-186">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>