<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c8d93b898d628b70967d33278c8cd9f33a66bf" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36479602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>A classe base abstrata que define as propriedades e métodos de um STS (serviço de token de segurança).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar um STS, você deve derivar do <xref:System.IdentityModel.SecurityTokenService> classe. Na sua classe personalizada você deve, no mínimo, substituir os <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> e <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> métodos. Com essas substituições, o STS criado usando a implementação padrão de todos os outros métodos definidos na classe é capaz de emitir tokens de segurança em resposta a segurança em solicitações de token (RST). Ou seja, a associação Issue definida na especificação de WS-Trust é implementada. Essa associação é implementada no <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método. Nenhuma das outras associações de WS-Trust (renovar, cancelar e validar) são implementadas no caso padrão e uma falha de apropriado é retornada ao chamador se um RST que corresponde a uma dessas vinculações for encontrado. Você pode, claro, substituir os métodos apropriados (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, e <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) para implementar essas associações em seu STS.  
  
> [!IMPORTANT]
>  Implementar um STS de produção envolve um planejamento cuidadoso e recursos consideráveis para atenuar possíveis riscos de segurança inerentes ao expor um serviço. A maioria dos desenvolvedores usando o Windows Identity Foundation (WIF) será desenvolver aplicativos que terceirizem o gerenciamento de identidade para um STS, em vez de desenvolver um STS em si. O WIF fornece uma extensão do Visual Studio, a ferramenta de identidade e acesso para Visual Studio 2012, para ajudar os desenvolvedores de soluções de teste no ambiente de desenvolvimento. Essa ferramenta inclui um STS, `LocalSTS`, que podem ser configurados para servir as declarações específicas para o aplicativo que você está desenvolvendo. Para obter mais informações sobre a ferramenta de identidade e acesso, consulte [ferramenta de identidade e acesso para Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). Em alguns cenários, `LocalSTS` pode não fornecer a funcionalidade necessária para testar adequadamente seu aplicativo; por exemplo, em um cenário que envolve o desenvolvimento de um manipulador de token personalizado para uso por um aplicativo. Nesses casos, você pode derivar de <xref:System.IdentityModel.SecurityTokenService> para criar um ou mais STSs simples que pode ser implantado em seu ambiente de desenvolvimento e que pode ser usado para testar esses recursos em seu aplicativo. O restante desta seção aborda os métodos expostos pela <xref:System.IdentityModel.SecurityTokenService> classe que permitem que você implemente um STS simples e estender o pipeline de emissão de token.  
  
 A lista a seguir fornece uma breve visão geral dos métodos de importância fundamental para o desenvolvedor para uso em um ambiente de teste ou desenvolvimento.  
  
-   O método <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>. Esse método retorna um <xref:System.IdentityModel.Scope> objeto que contém informações sobre a RP. Esse objeto é usado no restante do pipeline de emissão de token e inclui informações sobre a assinatura e as credenciais de criptografia para usar na resposta, bem como o `AppliesTo` e `ReplyTo` (se necessário) endereços. Você deve substituir esse método.  
  
-   O método <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>. Esse método retorna um <xref:System.Security.Claims.ClaimsIdentity> objeto que contém as declarações para retornar para a RP. Você deve substituir esse método.  
  
-   O método <xref:System.IdentityModel.SecurityTokenService.Issue%2A>. Esse método implementa o pipeline de solicitação de token, que processa uma solicitação de token de segurança (RST) entrada e retorna uma resposta (RSTR) para o chamador que contém um token que pode ser usado para autenticar com um RP. Muitos dos outros métodos definidos na <xref:System.IdentityModel.SecurityTokenService> classe são chamados desse método, incluindo o <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> e <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> métodos. Não é necessário substituir esse método, mas uma compreensão do pipeline de solicitação de token, que ele implementa pode ser úteis.  
  
 Um STS é configurado por meio de <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> classe.  
  
   
  
## Examples  
 Os exemplos de código que são usados na <xref:System.IdentityModel.SecurityTokenService> tópicos são tirados o `Custom Token` exemplo. Este exemplo fornece as classes personalizadas que permitem o processamento de Simple Web Tokens (SWT) e inclui uma implementação de um STS passivo que é capaz de atender a um token SWT. Para obter um exemplo de como implementar um STS ativo, você pode ver o `Federation Metadata` exemplo. Para obter informações sobre esses exemplos e outros exemplos disponíveis para o WIF e sobre onde baixá-los, consulte [índice de exemplo de código do WIF](~/docs/framework/security/wif-code-sample-index.md). O código a seguir mostra a implementação de um STS passivo usando o <xref:System.IdentityModel.SecurityTokenService> classe.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 O código a seguir mostra como invocar um STS passivo personalizado para processar uma solicitação do WS-Federation, chamando o <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> método no código por trás de `default.aspx.cs` arquivo.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Você deve substituir ambos os <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> e o <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> métodos.</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">Um <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> que contém as configurações para o STS.</param>
        <summary>Chamado de classes derivadas para inicializar a classe <see cref="T:System.IdentityModel.SecurityTokenService" /> usando as definições de configuração especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse construtor para inicializar o provedor de escopo e o certificado do emissor do token.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /> que recebe a notificação da conclusão da operação de cancelamento assíncrona.</param>
        <param name="state">Um objeto que contém as informações de estado associadas à operação de cancelamento assíncrono.</param>
        <summary>Quando substituído em uma classe derivada, inicia uma solicitação Cancel do WS-Trust assíncrona.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que faz referência à operação de cancelamento assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="scope">O <see cref="T:System.IdentityModel.Scope" /> que contém informações sobre a terceira parte confiável associada à solicitação.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /> que recebe a notificação da conclusão da operação assíncrona.</param>
        <param name="state">Um objeto que contém informações de estado associadas à operação assíncrona.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma chamada assíncrona para o método <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que faz referência à operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /> que recebe a notificação da conclusão da operação assíncrona.</param>
        <param name="state">Um objeto que contém informações de estado associadas à operação assíncrona.</param>
        <summary>Quando substituída em uma classe derivada, inicia uma chamada assíncrona para o método <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que faz referência à operação de cancelamento assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /> que recebe a notificação de conclusão da operação de emissão assíncrona.</param>
        <param name="state">Um objeto que contém informações de estado associadas à operação de emissão assíncrona.</param>
        <summary>Quando substituído em uma classe derivada, inicia uma solicitação Issue do WS-Trust assíncrona.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que faz referência à operação de emissão assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /> que recebe a notificação da conclusão da operação de renovação assíncrona.</param>
        <param name="state">Um objeto que contém informações de estado associadas à operação de renovação assíncrona.</param>
        <summary>Quando substituído em uma classe derivada, inicia uma solicitação Renew do WS-Trust assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à operação de renovação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /> que recebe a notificação da conclusão da operação de validação assíncrona.</param>
        <param name="state">Um objeto que contém informações de estado associadas à operação de validação assíncrona.</param>
        <summary>Quando substituído em uma classe derivada, inicia uma solicitação Validate do WS-Trust assíncrona.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que faz referência à operação de validação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <summary>Quando substituído em uma classe derivada, processa uma solicitação Cancel do WS-Trust.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">A solicitação de token de entrada.</param>
        <param name="scope">O objeto <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> retornado de <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Cria uma instância de um <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>O <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invocado durante a emissão de token após <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="scope" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O <see cref="T:System.IAsyncResult" /> que é retornado por uma chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Quando substituído em uma classe derivada, conclui a solicitação Cancel do WS-Trust assíncrona.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O <see cref="T:System.IAsyncResult" /> que é retornado por uma chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />.</param>
        <summary>Quando substituído em uma classe derivada, conclui a chamada assíncrona para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Um <see cref="T:System.Security.Claims.ClaimsIdentity" /> que contém a coleção de declarações que serão colocadas no token de segurança emitido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O <see cref="T:System.IAsyncResult" /> que é retornado por uma chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Quando substituído em uma classe derivada, conclui a chamada assíncrona para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Scope" /> que encapsula as informações de RP (terceira parte confiável) associadas à solicitação (RST) especificada na chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O <see cref="T:System.IAsyncResult" /> que é retornado por uma chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Quando substituído em uma classe derivada, conclui a solicitação Issue do WS-Trust assíncrona.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O <see cref="T:System.IAsyncResult" /> que é retornado por uma chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Quando substituído em uma classe derivada, conclui a solicitação Renew do WS-Trust assíncrona.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">O <see cref="T:System.IAsyncResult" /> que é retornado por uma chamada para o método <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Quando substituído em uma classe derivada, conclui a solicitação Validate do WS-Trust assíncrona.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o nome do STS (serviço de token de segurança).</summary>
        <returns>O nome do emissor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado do pipeline de emissão de token é implementado no padrão de <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 A implementação padrão retorna o <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> propriedade de configuração acessada por meio de <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <param name="scope">O <see cref="T:System.IdentityModel.Scope" /> que contém informações sobre a terceira parte confiável associada à solicitação. Este é o objeto <see cref="T:System.IdentityModel.Scope" /> que foi retornado pelo método <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Quando substituído em uma classe derivada, esse método retorna uma coleção de entidades de saída a serem incluídas no token emitido.</summary>
        <returns>Um <see cref="T:System.Security.Claims.ClaimsIdentity" /> que contém a coleção de declarações que serão colocadas no token de segurança emitido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> método é chamado do pipeline de emissão de token, que é implementado pelo <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método. Ele retorna um <xref:System.Security.Claims.ClaimsIdentity> que contém as declarações a serem incluídos no token de segurança emitido com base em que o solicitante do token (o `principal` parâmetro), o RST de entrada (o `request` parâmetro), e a terceira parte confiável para o qual o token é destinada ( o `scope` parâmetro). A lógica nesse método está principalmente focalizada respondendo às seguintes perguntas:  
  
-   **Que tipos de declaração devem ser incluídos na resposta com base no RP para o qual ele é destinado?** Normalmente isso é decidido por RP de listas de tipos de declaração exigidos para cada RP ou em uma base por solicitação, examinando o <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> propriedade da solicitação. No entanto, a lógica e os detalhes para determinar as declarações para incluir na resposta cabe completamente a sua implementação.  
  
-   **Valores de declaração que devem ser atribuídas às declarações na resposta?** Para um provedor de identidade (IP-STS) isso normalmente significa usar um ou mais declarações do solicitante <xref:System.Security.Claims.ClaimsPrincipal> (fornecido pelo `principal` parâmetro) para acessar um repositório (ou outra entidade) para retornar valores para os tipos de declaração exigidos. Para um provedor de Federação (R-STS) isso normalmente significa executar algum tipo de processamento em declarações de entrada do solicitante para atender à solicitação; talvez executar filtragem ou transformação em algumas declarações apresentadas pelo solicitante, passando a outras pessoas por meio de não modificado. É claro que, como no caso de decidir quais declarações para incluir na resposta, os detalhes e a lógica de como determinar os valores dessas declarações é até sua implementação.  
  
   
  
## Examples  
 O exemplo de código que é usado neste tópico é obtido a `Custom Token` exemplo. Este exemplo fornece as classes personalizadas que permitem o processamento de Simple Web Tokens (SWT) e inclui uma implementação de um STS passivo que é capaz de atender a um token SWT. Para obter um exemplo de como implementar um STS ativo, você pode ver o `Federation Metadata` exemplo. Para obter informações sobre esses exemplos e outros exemplos disponíveis para o WIF e sobre onde baixá-los, consulte [índice de exemplo de código do WIF](~/docs/framework/security/wif-code-sample-index.md). O código a seguir mostra como substituir o <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> declarações de método para retornar para seu STS. Neste exemplo, a mensagem de segurança de solicitação de Token (RST) será ignorada e será retornada uma coleção de declarações com base no usuário, como autenticado no STS.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir esse método em sua implementação do <see cref="T:System.IdentityModel.SecurityTokenService" /> classe.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação (RST) de token de entrada.</param>
        <param name="scope">A instância <see cref="T:System.IdentityModel.Scope" /> que encapsula informações sobre a terceira parte confiável.</param>
        <summary>Obtém o token de prova a ser incluído na resposta (RSTR).</summary>
        <returns>Um <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" /> que representa o descritor de prova recém-criado. O descritor de prova pode ser um descritor de prova assimétrico, um descritor de prova simétrico ou <see langword="null" /> no caso de token de portador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado do pipeline de emissão de token é implementado no padrão de <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 A implementação padrão retorna um descritor de prova ou gerará uma exceção apropriada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="scope" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação (RST) de token de entrada.</param>
        <summary>Obtém as credenciais de criptografia da prova do solicitante.</summary>
        <returns>Um objeto <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> que representa as credenciais de criptografia do solicitante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado do <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> método.  
  
 A implementação padrão fará o seguinte. Retorna `null` se não houver nenhum token de criptografia especificada na solicitação (o <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> é de propriedade `null`). Caso contrário, se ele pode obter o token como um <xref:System.IdentityModel.Tokens.X509SecurityToken>, ele retorna as credenciais com base nesse token. Se ele não puder resolver o token como um <xref:System.IdentityModel.Tokens.X509SecurityToken>, um <xref:System.IdentityModel.RequestFailedException> é gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">A RST que contém a solicitação de token.</param>
        <param name="tokenDescriptor">O descritor de token que contém as informações a serem usadas para o token emitido.</param>
        <summary>Cria a resposta (RSTR) que contém o token emitido usando a solicitação (RST) e o descritor de token de segurança solicitados.</summary>
        <returns>A resposta (RSTR) ou <see langword="null" /> se uma resposta não puder ser criada da solicitação e do descritor de token especificados. A implementação padrão retornará <see langword="null" /> se o parâmetro <paramref name="tokenDescriptor" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> método é chamado como a última etapa do pipeline de emissão de token, que é implementado pelo <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método. Ele cria e retorna a resposta (RSTR) usando a solicitação de entrada original (RST) e o descritor do token criado durante as etapas anteriores no pipeline de emissão de token.  
  
 A implementação padrão cria o RSTR, passando o RST especificado no parâmetro de solicitação para o <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> construtor, invocando o <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> método no descritor de token é passado para <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> para aplicar as propriedades para o recentemente criado o RSTR, configurar o <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> propriedade no RSTR usando o <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> propriedade no descritor de token e, finalmente, definindo o <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> propriedade no RSTR de acordo com a tabela a seguir:  
  
|Propriedade `RST.ReplyTo`|Propriedade <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>.|Propriedade `RSTR.ReplyTo`|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Set|Não definido|Não definido|  
|Set|Set|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|Não definido|Set|Não definido|  
|Não definido|Não definido|Não definido|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa o cliente fazendo a solicitação.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação (RST) de entrada.</param>
        <summary>Obtém um objeto <see cref="T:System.IdentityModel.Scope" /> que contém informações sobre a RP (terceira parte confiável) associada à solicitação (RST) especificada. Você deve substituir esse método em sua implementação da classe <see cref="T:System.IdentityModel.SecurityTokenService" />.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Scope" /> que encapsula as informações de RP associadas à solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> método é chamado do pipeline de emissão de token após o <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método e deve retornar um <xref:System.IdentityModel.Scope> objeto configurado para a solicitação de entrada. (O pipeline de emissão de token é implementado de <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.) O <xref:System.IdentityModel.Scope> objeto encapsula informações sobre a RP associada com a solicitação de token de segurança (RST). Isso inclui informações sobre as credenciais de criptografia e assinatura a ser usado com a RP e se deseja ou não criptografar todos os tokens emitidos e/ou chaves simétricas na resposta. Algumas tarefas comuns executadas no <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> método são:  
  
-   Determine se o RP para a qual o token destina é uma RP reconhecida. Como isso é feito depende de sua implementação. Se a RP pretendida não é uma RP válida para esse STS, então o método deve emitir uma <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Determinar o credenciais de assinatura a ser usada na resposta (RSTR) e definir o <xref:System.IdentityModel.Scope.SigningCredentials%2A> propriedade adequadamente.  
  
-   Determine se a resposta e/ou quaisquer chaves simétricas incluídos devem ser criptografados e as credenciais para ser usado para criptografia. Defina as <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, e <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> propriedades adequadamente.  
  
    > [!IMPORTANT]
    >  Por padrão, o <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> e <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> são definidas `true` para impedir que o STS de emissão de tokens que não são seguras. É recomendável que essas propriedades nunca ser definido como `false` em um ambiente de produção.  
  
-   Determine o endereço ao qual a resposta deve ser retornada. Definir as <xref:System.IdentityModel.Scope.AppliesToAddress%2A> ou <xref:System.IdentityModel.Scope.ReplyToAddress%2A> propriedade adequadamente.  
  
   
  
## Examples  
 O exemplo de código que é usado neste tópico é obtido a `Custom Token` exemplo. Este exemplo fornece as classes personalizadas que permitem o processamento de Simple Web Tokens (SWT) e inclui uma implementação de um STS passivo que é capaz de atender a um token SWT. Para obter um exemplo de como implementar um STS ativo, você pode ver o `Federation Metadata` exemplo. Para obter informações sobre esses exemplos e outros exemplos disponíveis para o WIF e sobre onde baixá-los, consulte [índice de exemplo de código do WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 O exemplo de código a seguir mostra uma implementação do <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> método. Essa implementação verifica que a RP é reconhecido pelo STS, valida o <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> endereço na solicitação e define o <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> propriedade da mesma forma, e define a assinatura e as credenciais de criptografia a ser usado com a RP com base nos certificados que são embutidos no arquivo.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir esse método em sua implementação do <see cref="T:System.IdentityModel.SecurityTokenService" /> classe.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Uma cadeia de caracteres que contém o URI do tipo de token solicitado.</param>
        <summary>Obtém o manipulador de token de segurança apropriado para emitir um token de segurança do tipo especificado.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> que representa o manipulador de token a ser usado para criar o token de segurança emitido. Retorna <see langword="null" /> se o tipo de token solicitado não é compatível (não há nenhum manipulador configurado para o tipo de token especificado).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na implementação padrão se `requestedTokenType` é `null` ou uma cadeia de caracteres vazia, o padrão de configuração de tipo de token é usado. Isso é especificado pela <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> propriedade do objeto de configuração de STS acessado por meio de <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> propriedade.  
  
 Esse método é chamado do pipeline de emissão de token é implementado no padrão de <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> que representa o tempo de vida solicitado.</param>
        <summary>Obtém o tempo de vida do token emitido.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> que representa o tempo de vida concedido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esse método é chamado com o tempo de vida que foi recebido no RST. Na implementação do padrão, o tempo de vida de token é calculado de acordo com a tabela a seguir.  
  
|Criado (in)|Expira (in)|Criado (in)|Expira (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Esse método é chamado do pipeline de emissão de token é implementado no padrão de <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <summary>Emite um token de segurança.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que contém o token de segurança emitido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método implementa a associação Issue definida na especificação de WS-Trust. A implementação padrão da <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método processa a solicitação de entrada (RST) por meio de um pipeline de emissão de token (emissão de declarações) e retorna qualquer uma resposta (RSTR) o que contém um token de segurança com as declarações apropriadas para autenticar o solicitante com a RP ou uma exceção apropriada. O pipeline de emissão de token na implementação padrão consiste em chamadas para os métodos a seguir (da <xref:System.IdentityModel.SecurityTokenService> classe).  
  
1.  O <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método para validar a solicitação (RST).  
  
2.  O <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> método para obter um <xref:System.IdentityModel.Scope> objeto que contém informações sobre a terceira parte confiável (RP) associado à solicitação. Você deve substituir esse método. Se <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> retorna `null`, um <xref:System.InvalidOperationException> é gerada.  
  
3.  O <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> método para retornar um descritor de token de segurança com base no RST e o <xref:System.IdentityModel.Scope> objeto retornado na etapa anterior. O descritor de token de segurança (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) contém informações sobre a solicitação em um formato que pode ser usado por um manipulador de token. O <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> estiver definida como o descritor retornado pela chamada. Se `null` é retornado ou se o <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> é de propriedade do descritor `null`, um <xref:System.InvalidOperationException> é gerada. A exceção também será gerada se o <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> é de propriedade `true` , mas o <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> é de propriedade no descritor retornado `null`.  
  
4.  O <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> método para obter o manipulador de token apropriado com base no tipo de token solicitado. Se `null` for retornado, um <xref:System.NotImplementedException> é gerada.  
  
5.  O <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> método para obter o nome do emissor do token. Gera uma <xref:System.InvalidOperationException> se o nome for `null` ou vazio; caso contrário, define o <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> o descritor de propriedade.  
  
6.  O <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> método para obter o tempo de vida para o token e define o <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> o descritor de propriedade.  
  
7.  O <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> método para obter o token de prova para incluir no token emitido e conjuntos de <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> o descritor de propriedade.  
  
8.  O <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> método para obter as declarações para incluir no token emitido e conjuntos de <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> o descritor de propriedade. Você deve substituir esse método.  
  
9. O <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> método para criar uma resposta (RSTR) que contém o token emitido.  
  
 Você pode substituir a <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método para implementar um pipeline de emissão de token personalizados; porém isso normalmente não é necessário em ambientes de desenvolvimento e teste para qual implementações mais personalizadas do <xref:System.IdentityModel.SecurityTokenService> classe destinam-se. Em muitos desses casos você substituir a <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> e <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> métodos e, opcionalmente, substituir o <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método para fornecer um STS de facilidade de manutenção para seu ambiente. Se ainda mais a personalização é necessária geralmente fornecem-lo, substituindo os métodos que implementam cada estágio do pipeline de emissão de tokens listado acima padrão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a entidade de segurança associada à instância atual.</summary>
        <value>Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a entidade atual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <summary>Quando substituído em uma classe derivada, processa uma solicitação Renew do WS-Trust.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a solicitação (RST) de token de segurança associada à instância atual.</summary>
        <value>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que contém a solicitação.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o escopo associado à instância atual.</summary>
        <value>Um <see cref="T:System.IdentityModel.Scope" /> que representa a configuração para a solicitação de emissão de token.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> associado à instância atual.</summary>
        <value>O descritor de segurança token que está associado com a instância atual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Ocorre uma tentativa de definir a propriedade para <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a instância de configuração de proprietário.</summary>
        <value>Um <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> que contém a configuração para a instância atual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">Um <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa a identidade do solicitante do token.</param>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação do token de segurança. Isso inclui a mensagem de solicitação, bem como outras informações relacionadas ao cliente, como o contexto de autorização.</param>
        <summary>Quando substituído em uma classe derivada, processa uma solicitação Validate do WS-Trust.</summary>
        <returns>Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa o RSTR a ser retornado para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão desse método lança um <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Um <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa a solicitação.</param>
        <summary>Valida a solicitação (RST) de token de segurança encapsulada por esta instância.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método é chamado do pipeline de emissão de token (o <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método) para validar o RST de entrada. O RST é validado em relação os requisitos (política) do STS e uma exceção apropriada é lançada se ele não é válido.  
  
 A implementação padrão do <xref:System.IdentityModel.SecurityTokenService> classe dá suporte a apenas o padrão de RST RSTR e apenas a associação Issue da especificação WS-Trust (o <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> propriedade da solicitação deve ser definida como <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). A implementação padrão desse método impõe esses requisitos (e outras pessoas observado na seção de exceções). Você pode substituir esse método se você deve impor requisitos de validação diferentes para seu STS personalizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> é <see langword="null" />.  
  
- ou - 
A propriedade <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> da solicitação não está definida como <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />.  
  
- ou - 
A propriedade <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> da solicitação não é <see langword="null" /> ou uma das constantes definidas na classe <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" />.  
  
- ou - 
O <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> da solicitação é <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> e o elemento <see langword="KeySize" /> está presente, mas seu valor não é igual a zero.</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">O STS não dá suporte ao tipo de token de solicitação (com base no valor da propriedade <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> da solicitação).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>