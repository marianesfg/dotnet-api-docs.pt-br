<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d35f198a40d02b4db5247591990a6baf3a363ab" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39972592" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type Publish = class&#xA;    interface IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publica interfaces COM para aplicativos COM+ habilitados para SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish> é usado internamente pelo .NET Framework. Você não precisará usá-lo diretamente no seu código.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.EnterpriseServices.Internal.Publish" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">A URL para o servidor de email raiz.</param>
        <param name="MailBox">A caixa de correio a ser criada.</param>
        <param name="SmtpName">Quando este método retornar, este parâmetro conterá o nome do servidor do protocolo SMTP que contém a caixa de correio.</param>
        <param name="Domain">Quando este método retornar, este parâmetro conterá o domínio do servidor SMTP.</param>
        <param name="PhysicalPath">Quando este método retornar, este parâmetro conterá o caminho do sistema de arquivos para caixa de correio.</param>
        <param name="Error">Quando este método retornar, este parâmetro conterá uma mensagem de erro se um problema for encontrado.</param>
        <summary>Cria uma caixa de correio de aplicativo COM+ habilitado para SOAP em uma URL especificada. Não foi totalmente implementado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não foi totalmente implementado; não cria uma caixa de correio. Retorna a mensagem de erro "COM+ SOAP serviços não há suporte para a publicação de SMTP".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">A operação a ser executada.</param>
        <param name="FullUrl">O endereço de URL completo para a raiz virtual.</param>
        <param name="BaseUrl">Quando este método retornar, este parâmetro conterá o endereço de URL base.</param>
        <param name="VirtualRoot">Quando este método retornar, este parâmetro conterá o nome da raiz virtual.</param>
        <param name="PhysicalPath">Quando este método retornar, este parâmetro conterá o caminho do arquivo para a raiz virtual.</param>
        <param name="Error">Quando este método retornar, este parâmetro conterá uma mensagem de erro se um problema for encontrado.</param>
        <summary>Cria uma raiz virtual de aplicativo COM+ habilitado para SOAP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É recomendável que <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> ser usada em vez de <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.  
  
- ou - 
O chamador não tem permissão para acessar as informações de DNS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Foi encontrado um erro ao resolver o nome do host local.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> está vazio.  
  
- ou - 
O esquema especificado em <paramref name="FullUrl" /> é inválido.  
  
- ou - 
 <paramref name="FullUrl" /> contém mais de duas barras “/” consecutivas.  
  
- ou - 
A senha especificada em <paramref name="FullUrl" /> é inválida.  
  
- ou - 
O nome do host especificado em <paramref name="FullUrl" /> é inválido.  
  
- ou - 
O nome do arquivo especificado em <paramref name="FullUrl" /> é inválido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para configuração da infraestrutura de comunicação remota. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit&#xA;override this.DeleteMailBox : string * string *  -&gt; unit" Usage="publish.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">A URL para o servidor de email raiz.</param>
        <param name="MailBox">A caixa de correio a ser excluída.</param>
        <param name="Error">Quando este método retornar, este parâmetro conterá uma mensagem de erro se um problema for encontrado.</param>
        <summary>Exclui uma caixa de correio de aplicativo COM+ habilitado para SOAP em uma URL especificada. Não foi totalmente implementado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não é totalmente implementado, não exclui a caixa de correio. Retorna a mensagem de erro "COM+ SOAP serviços não há suporte para a publicação de SMTP".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit&#xA;override this.DeleteVirtualRoot : string * string *  -&gt; unit" Usage="publish.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">O servidor Web raiz.</param>
        <param name="FullUrl">O endereço de URL completo para a raiz virtual.</param>
        <param name="Error">Quando este método retornar, este parâmetro conterá uma mensagem de erro se um problema for encontrado.</param>
        <summary>Exclui uma raiz virtual de aplicativo COM+ habilitado para SOAP. Não foi totalmente implementado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A funcionalidade para <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> ainda não está disponível.  
  
> [!CAUTION]
>  O método atualmente retorna sem erros, mas a raiz virtual não é excluída.  
  
 Quando a funcionalidade se torna disponível, o método recomendado será <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit&#xA;override this.GacInstall : string -&gt; unit" Usage="publish.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">O caminho do sistema de arquivos do assembly.</param>
        <summary>Instala um assembly no cache de assembly global.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit&#xA;override this.GacRemove : string -&gt; unit" Usage="publish.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">O caminho do sistema de arquivos do assembly.</param>
        <summary>Remove um assembly do cache de assembly global.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.  
  
- ou - 
O chamador não tem permissão de descoberta de caminho.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> está vazio.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> não é um assembly válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit&#xA;override this.GetAssemblyNameForCache : string *  -&gt; unit" Usage="publish.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">O caminho para o arquivo que contém a typelib.</param>
        <param name="CachePath">Quando este método retornar, este parâmetro conterá o nome do diretório SoapCache.</param>
        <summary>Retorna o caminho completo para um assembly assinado com nome forte gerado no diretório SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para um não gerenciado componente COM+ a ser publicado por meio de comunicação remota do .NET como um ponto de extremidade SOAP, um proxy precisa ser gerado para disponibilizar os componentes não gerenciados para o .NET Framework. Isso é feito por meio de programação executando as mesmas etapas importador da biblioteca (Tlbimp.exe), o [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] ferramenta que é usada para converter bibliotecas não gerenciadas COM+ tipo em assemblies de metadados de proxy. Para ativação do cliente por meio do SOAP seja bem-sucedida, no entanto, computadores cliente e servidor devem compartilhar os mesmo proxies de nome forte assinado metadados. Por esse motivo, quando um assembly de proxy gerenciado é gerado para um não gerenciado componente COM+, uma chave de nome forte é também gerada e usada para assinar o assembly de proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">O nome do arquivo está vazio, contém somente espaços em branco ou contém caracteres inválidos.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso a <paramref name="TypeLibPath" /> é negado.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> contém dois-pontos (:) no meio da cadeia de caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberSignature Language="F#" Value="static member GetClientPhysicalPath : bool -&gt; string" Usage="System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath CreateDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">Definido como <see langword="true" /> para criar o diretório ou <see langword="false" /> para retornar o caminho, mas não criar o diretório.</param>
        <summary>Retorna o caminho para o diretório para armazenar arquivos de configuração do cliente.</summary>
        <returns>O caminho para o diretório que contém os arquivos de configuração.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cria os diretórios "\com\SOAPAssembly\\" no diretório do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string&#xA;override this.GetTypeNameFromProgId : string * string -&gt; string" Usage="publish.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">O caminho do sistema de arquivos do assembly.</param>
        <param name="ProgId">O identificador programático da classe.</param>
        <summary>Reflete sobre um assembly e retorna o nome do tipo que corresponde ao ProgID.</summary>
        <returns>O nome do tipo que corresponde a ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberSignature Language="F#" Value="static member ParseUrl : string *  *  -&gt; unit" Usage="System.EnterpriseServices.Internal.Publish.ParseUrl (FullUrl, BaseUrl, VirtualRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">O endereço de URL completo para a raiz virtual.</param>
        <param name="BaseUrl">Quando este método retornar, este parâmetro conterá o endereço de URL base.</param>
        <param name="VirtualRoot">Quando este método retornar, este parâmetro conterá o nome da raiz virtual.</param>
        <summary>Analisa uma URL e retorna a URL base e partes da raiz virtual.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Foi encontrado um erro ao resolver o nome do host local.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem permissão para acessar as informações de DNS.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> está vazio.  
  
- ou - 
O esquema especificado em <paramref name="FullUrl" /> é inválido.  
  
- ou - 
 <paramref name="FullUrl" /> contém muitas barras “/”.  
  
- ou - 
A senha especificada em <paramref name="FullUrl" /> é inválida.  
  
- ou - 
O nome do host especificado em <paramref name="FullUrl" /> é inválido.  
  
- ou - 
O nome do arquivo especificado em <paramref name="FullUrl" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">O identificador programático da classe.</param>
        <param name="SrcTlbPath">O caminho para o arquivo que contém a typelib.</param>
        <param name="PhysicalPath">O diretório do aplicativo Web.</param>
        <param name="VRoot">O nome da raiz virtual.</param>
        <param name="BaseUrl">A URL base que contém a raiz virtual.</param>
        <param name="Mode">O modo de ativação.</param>
        <param name="Transport">Não usado. Especifique <see langword="null" /> para esse parâmetro.</param>
        <param name="AssemblyName">Quando este método retornar, este parâmetro conterá o nome de exibição do assembly.</param>
        <param name="TypeName">Quando este método retornar, este parâmetro conterá o nome do tipo totalmente qualificado do assembly.</param>
        <param name="Error">Quando este método retornar, este parâmetro conterá uma mensagem de erro se um problema for encontrado.</param>
        <summary>Processa uma biblioteca de tipos de cliente, criando um arquivo de configuração no cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado em uma importação de proxy de cliente para gerar um arquivo de configuração de comunicação remota.  
  
 Se o `Mode` parâmetro é "wellknownobject" ou uma cadeia de caracteres vazia (""), presume-se um objeto conhecido; Caso contrário, a ativação do cliente será assumida.  
  
 É recomendável que <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> ser usada em vez de <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, strAssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">O identificador programático da classe.</param>
        <param name="SrcTlbPath">O caminho para o arquivo que contém a biblioteca de tipos.</param>
        <param name="PhysicalPath">O diretório do aplicativo Web.</param>
        <param name="Operation">A operação a ser executada.</param>
        <param name="strAssemblyName">Quando este método retornar, este parâmetro conterá o nome de exibição do assembly.</param>
        <param name="TypeName">Quando este método retornar, este parâmetro conterá o nome do tipo totalmente qualificado do assembly.</param>
        <param name="Error">Quando este método retornar, este parâmetro conterá uma mensagem de erro se um problema for encontrado.</param>
        <summary>Processa uma biblioteca de tipos de servidor, adicionando ou excluindo entradas do componente para os arquivos Web.config e Default.disco. Gera um proxy, se necessário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A> Adiciona uma entrada para o arquivo de descoberta e o arquivo Web. config para os componentes em typelib, e gera ou copia um proxy para o diretório bin para componentes não gerenciados. Se `Operation` é igual a "excluir", em seguida, as entradas de componente são removidas dos arquivos Web. config e default.  
  
 É recomendável que <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> e <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> ser usado em vez de <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">O parâmetro <paramref name="SrcTlbPath" /> fez referência a scrobj.dll; portanto, não há suporte para publicação de SOAP de componentes de script.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit&#xA;override this.RegisterAssembly : string -&gt; unit" Usage="publish.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">O caminho do sistema de arquivos do assembly.</param>
        <summary>Registra um assembly para interoperabilidade COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A> usa a ferramenta de registro do Assembly (Regasm.exe) para registrar as classes criáveis no assembly. Para obter mais informações, consulte [Regasm.exe (ferramenta de registro de Assembly)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">O assembly de entrada não tem um nome forte.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.  
  
- ou - 
Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O <paramref name="AssemblyPath" /> não foi encontrado ou uma extensão de nome de arquivo não foi especificada.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> não é um assembly válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes com duas evidências diferentes ou o nome do assembly excede o tamanho máximo definido no sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Um método marcado com <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> não é <see langword="static" />.  
  
- ou - 
Há mais de um método marcado com <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> em determinado nível da hierarquia.  
  
- ou - 
A assinatura do método marcada com <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> não é válida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de acessar o registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para determinar o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit&#xA;override this.UnRegisterAssembly : string -&gt; unit" Usage="publish.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">O caminho do sistema de arquivos do assembly.</param>
        <summary>Cancela o registro de um assembly de interoperabilidade COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A> usa Regasm.exe para cancelar o registro das classes criáveis no assembly. Para obter mais informações, consulte [Regasm.exe (ferramenta de registro de Assembly)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Um chamador na cadeia de chamadas não tem permissão para acessar o código não gerenciado.  
  
- ou - 
Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> não foi encontrado ou uma extensão de nome de arquivo não foi especificada.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> não é um assembly válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes com duas evidências diferentes ou o nome do assembly excede o tamanho máximo definido no sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Um método marcado com <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> não é <see langword="static" />.  
  
- ou - 
Há mais de um método marcado com <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> em determinado nível da hierarquia.  
  
- ou - 
A assinatura do método marcada com <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> não é válida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">a capacidade de acessar o registro. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para determinar o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
  </Members>
</Type>