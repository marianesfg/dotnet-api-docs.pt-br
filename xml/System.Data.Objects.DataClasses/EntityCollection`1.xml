<Type Name="EntityCollection&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityCollection&lt;TEntity&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0c52cb13084751322889764807f28bf9eaff9d3e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37678685" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityCollection&lt;TEntity&gt; : System.Data.Objects.DataClasses.RelatedEnd, System.Collections.Generic.ICollection&lt;TEntity&gt;, System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityCollection`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.RelatedEnd implements class System.Collections.Generic.ICollection`1&lt;!TEntity&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityCollection(Of TEntity)&#xA;Inherits RelatedEnd&#xA;Implements ICollection(Of TEntity), IEnumerable(Of TEntity), IListSource" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityCollection sealed : System::Data::Objects::DataClasses::RelatedEnd, System::Collections::Generic::ICollection&lt;TEntity&gt;, System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource" />
  <TypeSignature Language="F#" Value="type EntityCollection&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    inherit RelatedEnd&#xA;    interface ICollection&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface seq&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IEnumerable&#xA;    interface IListSource" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.RelatedEnd</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TEntity">O tipo de entidade da coleção.</typeparam>
    <summary>Represents a collection of objects on the "many" end of a relationship.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.Objects.DataClasses.EntityCollection%601> é uma coleção de objetos de um tipo específico de entidade que representa o final "muitos" de uma relação um-para-muitos ou muitos-para-muitos.  
  
 Um <xref:System.Data.Objects.DataClasses.EntityCollection%601> é retornado por uma propriedade de navegação. Use o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método para carregar objetos relacionados em um <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para armazenar uma coleção relacionada de objetos de um tipo de entidade específica, como o resultado de uma <xref:System.Data.Objects.ObjectQuery%601>, use uma instância da <xref:System.Collections.Generic.List%601> classe.  
  
 Uma <xref:System.Data.Objects.DataClasses.EntityCollection%601> pode ter um correspondente <xref:System.Data.Objects.DataClasses.EntityReference%601>. Quando um <xref:System.Data.Objects.DataClasses.EntityCollection%601> e um <xref:System.Data.Objects.DataClasses.EntityReference%601> modelo oposto da mesma relação, a integridade da relação é mantida no nível do objeto. As duas classes serão sincronizadas automaticamente.  
  
 Essa classe não pode ser herdada.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: configurar manualmente um projeto do Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: definir manualmente os arquivos de modelo e mapeamento](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo faz o seguinte:  
  
1.  Cria dois novos `SalesOrderHeader` entidades e os adiciona para o `Contact` entidade.  
  
2.  Obtém todas relacionada termina do <xref:System.Data.Objects.DataClasses.RelationshipManager> que está associado com o `Contact` entidade.  
  
3.  Itera através da coleção de <xref:System.Data.Objects.DataClasses.IRelatedEnd>s.  
  
4.  Obtém o <xref:System.Data.Objects.DataClasses.EntityCollection%601> para cada extremidade relacionada.  
  
5.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método para remover uma das entidades da coleção.  
  
6.  Chamadas a <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> método para determinar se o objeto foi removido da coleção.  
  
7.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método para adicionar a entidade novamente.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor público para <xref:System.Data.Objects.DataClasses.EntityCollection%601> se destina a ser usado pelos serviços de objeto durante a desserialização de grafos de objeto. Você deve acessar uma instância de <xref:System.Data.Objects.DataClasses.EntityCollection%601> de uma propriedade de navegação, em vez de usar esse construtor.  
  
 Para armazenar uma coleção relacionada de objetos de um tipo de entidade específica, como o resultado de uma <xref:System.Data.Objects.ObjectQuery%601>, use uma instância do <xref:System.Collections.Generic.List%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Add : 'Entity -&gt; unit" Usage="entityCollection.Add entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">An object to add to the collection. <c>entity</c> must implement <see cref="T:System.Data.Objects.DataClasses.IEntityWithRelationships" />.</param>
        <summary>Adds an object to the collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método adiciona um objeto para um <xref:System.Data.Objects.DataClasses.EntityCollection%601> e cria uma relação entre os dois objetos. Quando o objeto de origem é anexado a um <xref:System.Data.Objects.ObjectContext> instância, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método também adiciona o objeto para o <xref:System.Data.Objects.ObjectContext>. Esta operação é convertida em uma operação de inserção dos dados de origem quando <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> é chamado. Para obter mais informações, consulte [Creating, adicionando, modificando e excluindo objetos](http://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método pode ser chamado várias vezes na mesma instância do objeto.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: configurar manualmente um projeto do Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: definir manualmente os arquivos de modelo e mapeamento](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo cria dois novos `SalesOrderHeader` entidades, adiciona-os para o `Contact` entidade e, depois de remover um objeto, usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método para adicionar o objeto para a coleção.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines a relationship between two attached objects in an object context.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Collections::Generic::IEnumerable&lt;TEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="override this.Attach : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="entityCollection.Attach entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities">Collection of objects in the object context that are related to the source object.</param>
        <summary>Defines relationships between an object and a collection of related objects in an object context.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.ObjectContext.Attach%2A> método é usado para definir relações entre um objeto e uma coleção de objetos relacionados quando o objeto de origem e a coleção de objetos relacionados já existem no contexto de objeto. Para anexar um objeto ou um gráfico de objeto em que as relações já estão definidas, chame o <xref:System.Data.Objects.ObjectContext.Attach%2A> método no <xref:System.Data.Objects.ObjectContext>. Para criar um novo objeto que está relacionado ao objeto de origem, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método no <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para obter mais informações, consulte [anexando e desanexando objetos](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Se a coleção é preenchida já ou parcialmente preenchida, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> método mescla entidades existentes com as entidades determinadas. As entidades de determinado não devem para ser o conjunto completo de entidades relacionadas.  
  
 Todas as entidades passadas devem estar na <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified> estado. Objetos no <xref:System.Data.EntityState.Deleted> estado são permitidos apenas quando o Gerenciador de estado já estiver rastreando a instância da relação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entities" /> collection is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The source object or an object in the <paramref name="entities" /> collection is <see langword="null" /> or is not in an <see cref="F:System.Data.EntityState.Unchanged" /> or <see cref="F:System.Data.EntityState.Modified" /> state.  -or-  The relationship cannot be defined based on the EDM metadata. This can occur when the association in the conceptual schema does not support a relationship between the two types.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Attach : 'Entity -&gt; unit" Usage="entityCollection.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">The object being attached.</param>
        <summary>Defines a relationship between two attached objects in an object context.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> método é usado para definir relações entre dois objetos quando ambos os objetos já existem no contexto de objeto. Para anexar um objeto ou um gráfico de objeto em que as relações já estão definidas, chame o <xref:System.Data.Objects.ObjectContext.Attach%2A> método no <xref:System.Data.Objects.ObjectContext>. Para criar um novo objeto que está relacionado ao objeto de origem, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método no <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para obter mais informações, consulte [anexando e desanexando objetos](http://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Se o <xref:System.Data.Objects.DataClasses.EntityCollection%601> já tiver carregado objetos, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> método mescla o objeto junto com os objetos existentes no <xref:System.Data.Objects.DataClasses.EntityCollection%601>.  
  
 O objeto anexado não deve para ser o conjunto completo de objetos de entidade relacionada.  
  
 O objeto associado a este <xref:System.Data.Objects.DataClasses.EntityCollection%601> e todos os objetos que está sendo anexados a ele devem estar em um <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified> estado.  
  
 Objetos na <xref:System.Data.EntityState.Deleted> estado só pode ser anexado quando o <xref:System.Data.Objects.ObjectStateManager> já estiver rastreando a instância da relação.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: configurar manualmente um projeto do Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: definir manualmente os arquivos de modelo e mapeamento](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo anexa a uma coleção de desanexado `SalesOrderDetail` objetos e um desanexadas `SalesOrderHeader` de objeto para um contexto de objeto e, em seguida, define as relações entre as `SalesOrderHeader` objeto e cada `SalesOrderDetail` objeto.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">When the <paramref name="entity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">When the <paramref name="entity" /> cannot be related to the source object. This can occur when the association in the conceptual schema does not support a relationship between the two types.  -or-  When either object is <see langword="null" /> or is not in an <see cref="F:System.Data.EntityState.Unchanged" /> or <see cref="F:System.Data.EntityState.Modified" /> state.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="override this.Clear : unit -&gt; unit" Usage="entityCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all entities from the collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Clear%2A> faz o seguinte:  
  
-   Define o <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> sinalizador como `false`.  
  
-   Remove todas as entidades da coleção.  
  
-   Desanexa a relações entre entidades removidas e o proprietário do <xref:System.Data.Objects.DataClasses.EntityCollection%601> do <xref:System.Data.Objects.ObjectStateManager>.  
  
-   Remove o proprietário do <xref:System.Data.Objects.DataClasses.EntityCollection%601> de entidades relacionadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(TEntity entity);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'Entity -&gt; bool&#xA;override this.Contains : 'Entity -&gt; bool" Usage="entityCollection.Contains entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">The object to locate in the <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</param>
        <summary>Determines whether a specific object exists in the collection.</summary>
        <returns>
          <see langword="true" /> if the object is found in the <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa o <xref:System.Object.Equals%2A?displayProperty=nameWithType> método para comparar o objeto especificado com os objetos na coleção.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: configurar manualmente um projeto do Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: definir manualmente os arquivos de modelo e mapeamento](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo faz o seguinte:  
  
1.  Cria dois novos `SalesOrderHeader` entidades e os adiciona para o `Contact` entidade.  
  
2.  Obtém as extremidades todas relacionadas do <xref:System.Data.Objects.DataClasses.RelationshipManager> que está associado com a entidade Contact.  
  
3.  Itera através da coleção de <xref:System.Data.Objects.DataClasses.IRelatedEnd>s.  
  
4.  Obtém o <xref:System.Data.Objects.DataClasses.EntityCollection%601> para cada extremidade relacionada.  
  
5.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método para remover uma das entidades da coleção.  
  
6.  Chamadas a <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> método para determinar se o objeto foi removido da coleção.  
  
7.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método para adicionar a entidade novamente.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (TEntity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!TEntity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As TEntity(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;TEntity&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'Entity[] * int -&gt; unit&#xA;override this.CopyTo : 'Entity[] * int -&gt; unit" Usage="entityCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TEntity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The array to copy to.</param>
        <param name="arrayIndex">The zero-based index in the array at which copying begins.</param>
        <summary>Copies all the contents of the collection to an array, starting at the specified index of the target array.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of objects that are contained in the collection.</summary>
        <value>O número de elementos que estão contidos no <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Count%2A> propriedade obtém o número de entidades atualmente na coleção local e não reflete o tamanho da coleção na fonte de dados. Uma contagem de zero não indica necessariamente que a coleção relacionada está vazia. Para determinar o tamanho da coleção na fonte de dados, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método ou incluir o objeto relacionado no caminho de consulta. Para obter mais informações, consulte [Carregando objetos relacionados](http://msdn.microsoft.com/library/452347d2-7b3b-44cd-9001-231299a28cb1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberSignature Language="F#" Value="override this.CreateSourceQuery : unit -&gt; System.Data.Objects.ObjectQuery&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.CreateSourceQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an object query that, when it is executed, returns the same set of objects that exists in the current collection.</summary>
        <returns>An <see cref="T:System.Data.Objects.ObjectQuery`1" /> that represents the entity collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é usada para obter uma nova instância da <xref:System.Data.Objects.ObjectQuery%601> que retorna o mesmo conjunto de objetos. Isso é útil como ponto de partida para uma junção mais complexa, união ou consulta filtrada, ou para retornar os mesmos objetos em um estado desanexado usando o <xref:System.Data.Objects.MergeOption.NoTracking> opção.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> é usado para filtrar os objetos em um <xref:System.Data.Objects.DataClasses.EntityCollection%601> para que você possa associar apenas os objetos de um tipo específico. Para obter mais informações, consulte [objetos de associação aos controles](http://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
   
  
## Examples  
 Este exemplo se baseia em uma versão modificada dos. Esta versão dá suporte a herança de tabela por tipo com `Course` como um tipo abstrato. Conclua o passo a passo para modificar o modelo de escola para suportar o exemplo de herança de tabela por tipo usado neste tópico.  
  
 Este exemplo mostra como usar <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> filtrar objetos em um <xref:System.Data.Objects.DataClasses.EntityCollection%601> e vincular somente a objetos de um tipo específico. Para obter uma versão completa deste exemplo, consulte [como: associar controles aos tipos derivados](http://msdn.microsoft.com/library/09730c14-3b7b-4563-af4a-7ecfa4e34bd5).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">When the object is in an <see cref="F:System.Data.EntityState.Added" /> state.  -or-  When the object is in a <see cref="F:System.Data.EntityState.Detached" /> state with a <see cref="T:System.Data.Objects.MergeOption" /> other than <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that is used to iterate through the objects in the collection.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> that iterates through the set of values cached by <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> is read-only.</summary>
        <value>Sempre retorna <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Data.Objects.MergeOption -&gt; unit" Usage="entityCollection.Load mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Specifies how the objects in this collection should be merged with the objects that might have been returned from previous queries against the same <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Loads related objects into the collection, using the specified merge option.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Este método chama o internal `RelatedEnd.ValidateLoad` método antes de carregar a coleção, que valida que uma chamada para <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> tem as condições corretas. O `RelatedEnd.ValidateLoad` método verifica se:

* Válido <xref:System.Data.Objects.ObjectContext> existe.
* A entidade não está em um <xref:System.Data.EntityState.Deleted> estado.
* <xref:System.Data.Objects.MergeOption> para <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> deve ser <xref:System.Data.Objects.MergeOption.NoTracking> somente se a entidade de origem foi <xref:System.Data.Objects.MergeOption.NoTracking>. Se a entidade de origem foi recuperada com qualquer outro <xref:System.Data.Objects.MergeOption>, o <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> pode ser qualquer coisa, exceto <xref:System.Data.Objects.MergeOption.NoTracking> (por exemplo, a entidade poderia ter sido carregada com <xref:System.Data.Objects.MergeOption.OverwriteChanges> e o <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> opção pode ser <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Se `mergeOption` está <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> não for chamado em uma entidade já carregada e <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> não é chamado em um não-vazio, não controlada <xref:System.Data.Objects.DataClasses.RelatedEnd>.
  
 Quando os objetos na coleção já estão carregados na <xref:System.Data.Objects.ObjectContext>, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método impõe a <xref:System.Data.Objects.MergeOption> especificado pelo `mergeOption` parâmetro. Para obter mais informações, consulte [resolução de identidade, gerenciamento de estado e controle de alterações](http://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 Para carregar explicitamente os objetos relacionados, você deve chamar o `Load` método na extremidade relacionada retornado pela propriedade de navegação. Para uma relação um-para-muitos, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método no <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para uma relação um para um, chame o <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> em <xref:System.Data.Objects.DataClasses.EntityReference%601>. Isso carrega os dados de objeto relacionado no contexto de objeto. Você pode enumerar através da coleção de resultados retornados usando um `foreach` loop (`For Each...Next` no Visual Basic) e chama condicionalmente a `Load` método no <xref:System.Data.Objects.DataClasses.EntityReference%601> e <xref:System.Data.Objects.DataClasses.EntityCollection%601> propriedades para cada entidade nos resultados.  
  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método carrega objetos relacionados da fonte de dados ou não <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> é `true`.  
  
> [!NOTE]
>  Quando você chama o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método durante uma `foreach` (c#) ou `For Each` enumeração (Visual Basic), serviços de objeto tenta abrir um novo leitor de dados. Esta operação falhará, a menos que você habilitou vários conjuntos de resultados ativos especificando `multipleactiveresultsets=true` na cadeia de conexão. Você também pode carregar o resultado da consulta em um <xref:System.Collections.Generic.List%601> coleção. Isso fecha o leitor de dados e permite que você enumere através da coleção para carregar os objetos referenciados.  
  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A?displayProperty=nameWithType> método está sincronizado com o <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: configurar manualmente um projeto do Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: definir manualmente os arquivos de modelo e mapeamento](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo carrega o relacionados `SalesOrderHeader` objetos para o `Contact` entidade.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithload)]
 [!code-vb[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithload)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionDeserialized">
      <MemberSignature Language="C#" Value="public void OnCollectionDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnCollectionDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnCollectionDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnCollectionDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnCollectionDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnCollectionDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnCollectionDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">The streaming context.</param>
        <summary>Used internally to deserialize entity objects.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnSerializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnSerializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">The streaming context.</param>
        <summary>Used internally to serialize entity objects.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Entity -&gt; bool" Usage="entityCollection.Remove entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">The object to remove from the collection.</param>
        <summary>Removes an object from the collection and marks the relationship for deletion.</summary>
        <returns>
          <see langword="true" /> if item was successfully removed; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método também exclui a relação entre o objeto de origem e o objeto que está sendo removido da coleção. Se a relação tem uma restrição de integridade referencial, chamando o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método em um objeto dependente marca a relação e o objeto dependente para exclusão. Isso ocorre porque a restrição indica que o objeto dependente não pode existir sem uma relação de pai. Para obter mais informações, consulte [ReferentialConstraint elemento (CSDL)](http://msdn.microsoft.com/library/24f96a80-85b5-4f2e-a14c-0e3eb6796fa0).  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> Retorna `false` quando o objeto especificado não está na coleção.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: configurar manualmente um projeto do Entity Framework](http://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: definir manualmente os arquivos de modelo e mapeamento](http://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método para remover uma das entidades da coleção e, em seguida, chama o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> método para determinar se o objeto foi removido da coleção.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entity" /> object is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <paramref name="entity" /> object is not attached to the same object context.  -or-  The <paramref name="entity" /> object does not have a valid relationship manager.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that is used to iterate through the set of values cached by <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> that iterates through the set of values cached by <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the related entity collection consists of collection objects.</summary>
        <value>Essa propriedade sempre retorna <see langword="false" /> porque o <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> contém objetos e coleções não.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Objects.DataClasses.EntityCollection%601> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the collection as an <see cref="T:System.Collections.IList" /> used for data binding.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> of entity objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Objects.DataClasses.EntityCollection%601> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 Esse método permite a vinculação de dados a um <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Ele é chamado pelo controle associado à coleção. Para obter mais informações, consulte [objetos de associação aos controles](http://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>