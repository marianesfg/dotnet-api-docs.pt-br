<Type Name="EntityCollection&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityCollection&lt;TEntity&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6e1d3b17c2b840737777cab20132ffeb54fe1d4" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53490369" /></Metadata><TypeSignature Language="C#" Value="public sealed class EntityCollection&lt;TEntity&gt; : System.Data.Objects.DataClasses.RelatedEnd, System.Collections.Generic.ICollection&lt;TEntity&gt;, System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityCollection`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.RelatedEnd implements class System.Collections.Generic.ICollection`1&lt;!TEntity&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityCollection(Of TEntity)&#xA;Inherits RelatedEnd&#xA;Implements ICollection(Of TEntity), IEnumerable(Of TEntity), IListSource" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityCollection sealed : System::Data::Objects::DataClasses::RelatedEnd, System::Collections::Generic::ICollection&lt;TEntity&gt;, System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource" />
  <TypeSignature Language="F#" Value="type EntityCollection&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    inherit RelatedEnd&#xA;    interface ICollection&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface seq&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IEnumerable&#xA;    interface IListSource" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.RelatedEnd</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TEntity">O tipo de entidade da coleção.</typeparam>
    <summary>Representa uma coleção de objetos no final “muitos” de uma relação.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Data.Objects.DataClasses.EntityCollection%601> é uma coleção de objetos de um tipo específico de entidade que representa o final "muitos" de uma relação um-para-muitos ou muitos-para-muitos.  
  
 Um <xref:System.Data.Objects.DataClasses.EntityCollection%601> é retornado por uma propriedade de navegação. Use o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método para carregar objetos relacionados em um <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para armazenar uma coleção relacionada de objetos de um tipo de entidade específica, como o resultado de uma <xref:System.Data.Objects.ObjectQuery%601>, use uma instância da <xref:System.Collections.Generic.List%601> classe.  
  
 Uma <xref:System.Data.Objects.DataClasses.EntityCollection%601> pode ter um correspondente <xref:System.Data.Objects.DataClasses.EntityReference%601>. Quando um <xref:System.Data.Objects.DataClasses.EntityCollection%601> e um <xref:System.Data.Objects.DataClasses.EntityReference%601> modelo oposto da mesma relação, a integridade da relação é mantida no nível do objeto. As duas classes serão sincronizadas automaticamente.  
  
 Essa classe não pode ser herdada.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: Configurar manualmente um projeto do Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: Definir o modelo e arquivos de mapeamento manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo faz o seguinte:  
  
1.  Cria dois novos `SalesOrderHeader` entidades e os adiciona para o `Contact` entidade.  
  
2.  Obtém todas relacionada termina do <xref:System.Data.Objects.DataClasses.RelationshipManager> que está associado com o `Contact` entidade.  
  
3.  Itera através da coleção de <xref:System.Data.Objects.DataClasses.IRelatedEnd>s.  
  
4.  Obtém o <xref:System.Data.Objects.DataClasses.EntityCollection%601> para cada extremidade relacionada.  
  
5.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método para remover uma das entidades da coleção.  
  
6.  Chamadas a <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> método para determinar se o objeto foi removido da coleção.  
  
7.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método para adicionar a entidade novamente.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor público para <xref:System.Data.Objects.DataClasses.EntityCollection%601> se destina a ser usado pelos serviços de objeto durante a desserialização de grafos de objeto. Você deve acessar uma instância de <xref:System.Data.Objects.DataClasses.EntityCollection%601> de uma propriedade de navegação, em vez de usar esse construtor.  
  
 Para armazenar uma coleção relacionada de objetos de um tipo de entidade específica, como o resultado de uma <xref:System.Data.Objects.ObjectQuery%601>, use uma instância do <xref:System.Collections.Generic.List%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Add : 'Entity -&gt; unit" Usage="entityCollection.Add entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Um objeto a ser adicionado à coleção. O <paramref name="entity" /> deve implementar <see cref="T:System.Data.Objects.DataClasses.IEntityWithRelationships" />.</param>
        <summary>Adiciona um objeto à coleção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método adiciona um objeto para um <xref:System.Data.Objects.DataClasses.EntityCollection%601> e cria uma relação entre os dois objetos. Quando o objeto de origem é anexado a um <xref:System.Data.Objects.ObjectContext> instância, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método também adiciona o objeto para o <xref:System.Data.Objects.ObjectContext>. Esta operação é convertida em uma operação de inserção dos dados de origem quando <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> é chamado. Para obter mais informações, consulte [Creating, adicionando, modificando e excluindo objetos](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método pode ser chamado várias vezes na mesma instância do objeto.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: Configurar manualmente um projeto do Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: Definir o modelo e arquivos de mapeamento manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo cria dois novos `SalesOrderHeader` entidades, adiciona-os para o `Contact` entidade e, depois de remover um objeto, usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método para adicionar o objeto para a coleção.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entity" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define uma relação entre dois objetos anexados a um contexto de objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Collections::Generic::IEnumerable&lt;TEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="override this.Attach : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="entityCollection.Attach entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities">Coleção de objetos no contexto de objeto relacionados ao objeto de origem.</param>
        <summary>Define as relações entre um objeto e uma coleção de objetos relacionados em um contexto de objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.ObjectContext.Attach%2A> método é usado para definir relações entre um objeto e uma coleção de objetos relacionados quando o objeto de origem e a coleção de objetos relacionados já existem no contexto de objeto. Para anexar um objeto ou um gráfico de objeto em que as relações já estão definidas, chame o <xref:System.Data.Objects.ObjectContext.Attach%2A> método no <xref:System.Data.Objects.ObjectContext>. Para criar um novo objeto que está relacionado ao objeto de origem, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método no <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para obter mais informações, consulte [anexando e desanexando objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Se a coleção é preenchida já ou parcialmente preenchida, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> método mescla entidades existentes com as entidades determinadas. As entidades de determinado não devem para ser o conjunto completo de entidades relacionadas.  
  
 Todas as entidades passadas devem estar na <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified> estado. Objetos no <xref:System.Data.EntityState.Deleted> estado são permitidos apenas quando o Gerenciador de estado já estiver rastreando a instância da relação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A coleção <paramref name="entities" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O objeto de origem ou um objeto na coleção <paramref name="entities" /> é <see langword="null" /> ou não está em um estado <see cref="F:System.Data.EntityState.Unchanged" /> ou <see cref="F:System.Data.EntityState.Modified" />.  
  
- ou - 
A relação não pode ser definida com base nos metadados de EDM. Isso pode ocorrer quando a associação no esquema conceitual não dá suporte a uma relação entre os dois tipos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Attach : 'Entity -&gt; unit" Usage="entityCollection.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">O objeto que está sendo anexado.</param>
        <summary>Define uma relação entre dois objetos anexados a um contexto de objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> método é usado para definir relações entre dois objetos quando ambos os objetos já existem no contexto de objeto. Para anexar um objeto ou um gráfico de objeto em que as relações já estão definidas, chame o <xref:System.Data.Objects.ObjectContext.Attach%2A> método no <xref:System.Data.Objects.ObjectContext>. Para criar um novo objeto que está relacionado ao objeto de origem, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método no <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para obter mais informações, consulte [anexando e desanexando objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Se o <xref:System.Data.Objects.DataClasses.EntityCollection%601> já tiver carregado objetos, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> método mescla o objeto junto com os objetos existentes no <xref:System.Data.Objects.DataClasses.EntityCollection%601>.  
  
 O objeto anexado não deve para ser o conjunto completo de objetos de entidade relacionada.  
  
 O objeto associado a este <xref:System.Data.Objects.DataClasses.EntityCollection%601> e todos os objetos que está sendo anexados a ele devem estar em um <xref:System.Data.EntityState.Unchanged> ou <xref:System.Data.EntityState.Modified> estado.  
  
 Objetos na <xref:System.Data.EntityState.Deleted> estado só pode ser anexado quando o <xref:System.Data.Objects.ObjectStateManager> já estiver rastreando a instância da relação.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: Configurar manualmente um projeto do Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: Definir o modelo e arquivos de mapeamento manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo anexa a uma coleção de desanexado `SalesOrderDetail` objetos e um desanexadas `SalesOrderHeader` de objeto para um contexto de objeto e, em seguida, define as relações entre as `SalesOrderHeader` objeto e cada `SalesOrderDetail` objeto.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Quando o <paramref name="entity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Quando o <paramref name="entity" /> não pode ser relacionado ao objeto de origem. Isso pode ocorrer quando a associação no esquema conceitual não dá suporte a uma relação entre os dois tipos.  
  
- ou - 
Quando um objeto é <see langword="null" /> ou não está em um estado <see cref="F:System.Data.EntityState.Unchanged" /> ou <see cref="F:System.Data.EntityState.Modified" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="override this.Clear : unit -&gt; unit" Usage="entityCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todas as entidades da coleção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Clear%2A> faz o seguinte:  
  
-   Define o <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> sinalizador como `false`.  
  
-   Remove todas as entidades da coleção.  
  
-   Desanexa a relações entre entidades removidas e o proprietário do <xref:System.Data.Objects.DataClasses.EntityCollection%601> do <xref:System.Data.Objects.ObjectStateManager>.  
  
-   Remove o proprietário do <xref:System.Data.Objects.DataClasses.EntityCollection%601> de entidades relacionadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(TEntity entity);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'Entity -&gt; bool&#xA;override this.Contains : 'Entity -&gt; bool" Usage="entityCollection.Contains entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">O objeto a ser localizado no <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</param>
        <summary>Determina se um objeto específico existe na coleção.</summary>
        <returns><see langword="true" /> se o objeto for encontrado no <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa o <xref:System.Object.Equals%2A?displayProperty=nameWithType> método para comparar o objeto especificado com os objetos na coleção.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: Configurar manualmente um projeto do Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: Definir o modelo e arquivos de mapeamento manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo faz o seguinte:  
  
1.  Cria dois novos `SalesOrderHeader` entidades e os adiciona para o `Contact` entidade.  
  
2.  Obtém as extremidades todas relacionadas do <xref:System.Data.Objects.DataClasses.RelationshipManager> que está associado com a entidade Contact.  
  
3.  Itera através da coleção de <xref:System.Data.Objects.DataClasses.IRelatedEnd>s.  
  
4.  Obtém o <xref:System.Data.Objects.DataClasses.EntityCollection%601> para cada extremidade relacionada.  
  
5.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método para remover uma das entidades da coleção.  
  
6.  Chamadas a <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> método para determinar se o objeto foi removido da coleção.  
  
7.  Usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> método para adicionar a entidade novamente.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (TEntity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!TEntity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As TEntity(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;TEntity&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'Entity[] * int -&gt; unit&#xA;override this.CopyTo : 'Entity[] * int -&gt; unit" Usage="entityCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TEntity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz para a qual copiar.</param>
        <param name="arrayIndex">O índice de base zero na matriz em que a cópia começa.</param>
        <summary>Copia todo o conteúdo da coleção para uma matriz, começando no índice especificado na matriz de destino.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de objetos contidos na coleção.</summary>
        <value>O número de elementos que estão contidos no <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Count%2A> propriedade obtém o número de entidades atualmente na coleção local e não reflete o tamanho da coleção na fonte de dados. Uma contagem de zero não indica necessariamente que a coleção relacionada está vazia. Para determinar o tamanho da coleção na fonte de dados, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método ou incluir o objeto relacionado no caminho de consulta. Para obter mais informações, consulte [Carregando objetos relacionados](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberSignature Language="F#" Value="override this.CreateSourceQuery : unit -&gt; System.Data.Objects.ObjectQuery&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.CreateSourceQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma consulta de objeto que, quando executada, retorna o mesmo conjunto de objetos existente na coleção atual.</summary>
        <returns>Um <see cref="T:System.Data.Objects.ObjectQuery`1" /> que representa a coleção de entidades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é usada para obter uma nova instância da <xref:System.Data.Objects.ObjectQuery%601> que retorna o mesmo conjunto de objetos. Isso é útil como ponto de partida para uma junção mais complexa, união ou consulta filtrada, ou para retornar os mesmos objetos em um estado desanexado usando o <xref:System.Data.Objects.MergeOption.NoTracking> opção.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> é usado para filtrar os objetos em um <xref:System.Data.Objects.DataClasses.EntityCollection%601> para que você possa associar apenas os objetos de um tipo específico. Para obter mais informações, consulte [objetos de associação aos controles](https://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
   
  
## Examples  
 Este exemplo se baseia em uma versão modificada dos. Esta versão dá suporte a herança de tabela por tipo com `Course` como um tipo abstrato. Conclua o passo a passo para modificar o modelo de escola para suportar o exemplo de herança de tabela por tipo usado neste tópico.  
  
 Este exemplo mostra como usar <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> filtrar objetos em um <xref:System.Data.Objects.DataClasses.EntityCollection%601> e vincular somente a objetos de um tipo específico. Para obter uma versão completa deste exemplo, consulte [como: Associar controles a tipos derivados](https://msdn.microsoft.com/library/09730c14-3b7b-4563-af4a-7ecfa4e34bd5).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Quando o objeto está em um estado <see cref="F:System.Data.EntityState.Added" />.  
  
- ou - 
Quando o objeto está em um estado <see cref="F:System.Data.EntityState.Detached" /> com um <see cref="T:System.Data.Objects.MergeOption" /> diferente de <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que é usado para iterar por meio dos objetos na coleção.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que itera por meio do conjunto de valores armazenados em cache por <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> é somente leitura.</summary>
        <value>Sempre retorna <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Data.Objects.MergeOption -&gt; unit" Usage="entityCollection.Load mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Especifica como os objetos nesta coleção devem ser mesclados com os objetos que podem ter sido retornados de consultas anteriores com o mesmo <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Carrega os objetos relacionados na coleção, usando a opção de mesclagem especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Este método chama o internal `RelatedEnd.ValidateLoad` método antes de carregar a coleção, que valida que uma chamada para <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> tem as condições corretas. O `RelatedEnd.ValidateLoad` método verifica se:

* Válido <xref:System.Data.Objects.ObjectContext> existe.
* A entidade não está em um <xref:System.Data.EntityState.Deleted> estado.
* <xref:System.Data.Objects.MergeOption> para <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> deve ser <xref:System.Data.Objects.MergeOption.NoTracking> somente se a entidade de origem foi <xref:System.Data.Objects.MergeOption.NoTracking>. Se a entidade de origem foi recuperada com qualquer outro <xref:System.Data.Objects.MergeOption>, o <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> pode ser qualquer coisa, exceto <xref:System.Data.Objects.MergeOption.NoTracking> (por exemplo, a entidade poderia ter sido carregada com <xref:System.Data.Objects.MergeOption.OverwriteChanges> e o <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> opção pode ser <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Se `mergeOption` está <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> não for chamado em uma entidade já carregada e <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> não é chamado em um não-vazio, não controlada <xref:System.Data.Objects.DataClasses.RelatedEnd>.
  
 Quando os objetos na coleção já estão carregados na <xref:System.Data.Objects.ObjectContext>, o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método impõe a <xref:System.Data.Objects.MergeOption> especificado pelo `mergeOption` parâmetro. Para obter mais informações, consulte [resolução de identidade, gerenciamento de estado e controle de alterações](https://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 Para carregar explicitamente os objetos relacionados, você deve chamar o `Load` método na extremidade relacionada retornado pela propriedade de navegação. Para uma relação um-para-muitos, chame o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método no <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para uma relação um para um, chame o <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> em <xref:System.Data.Objects.DataClasses.EntityReference%601>. Isso carrega os dados de objeto relacionado no contexto de objeto. Você pode enumerar através da coleção de resultados retornados usando um `foreach` loop (`For Each...Next` no Visual Basic) e chama condicionalmente a `Load` método no <xref:System.Data.Objects.DataClasses.EntityReference%601> e <xref:System.Data.Objects.DataClasses.EntityCollection%601> propriedades para cada entidade nos resultados.  
  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método carrega objetos relacionados da fonte de dados ou não <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> é `true`.  
  
> [!NOTE]
>  Quando você chama o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método durante uma `foreach` (c#) ou `For Each` enumeração (Visual Basic), serviços de objeto tenta abrir um novo leitor de dados. Esta operação falhará, a menos que você habilitou vários conjuntos de resultados ativos especificando `multipleactiveresultsets=true` na cadeia de conexão. Você também pode carregar o resultado da consulta em um <xref:System.Collections.Generic.List%601> coleção. Isso fecha o leitor de dados e permite que você enumere através da coleção para carregar os objetos referenciados.  
  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A?displayProperty=nameWithType> método está sincronizado com o <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: Configurar manualmente um projeto do Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: Definir o modelo e arquivos de mapeamento manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo carrega o relacionados `SalesOrderHeader` objetos para o `Contact` entidade.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithload)]
 [!code-vb[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithload)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionDeserialized">
      <MemberSignature Language="C#" Value="public void OnCollectionDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnCollectionDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnCollectionDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnCollectionDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnCollectionDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnCollectionDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnCollectionDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">O contexto de streaming.</param>
        <summary>Usado internamente para desserializar objetos de entidade.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnSerializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnSerializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">O contexto de streaming.</param>
        <summary>Usado internamente para serializar objetos de entidade.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Entity -&gt; bool" Usage="entityCollection.Remove entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">O objeto a ser removido da coleção.</param>
        <summary>Remove um objeto da coleção e marca a relação para exclusão.</summary>
        <returns><see langword="true" /> se o item foi removido com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método também exclui a relação entre o objeto de origem e o objeto que está sendo removido da coleção. Se a relação tem uma restrição de integridade referencial, chamando o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método em um objeto dependente marca a relação e o objeto dependente para exclusão. Isso ocorre porque a restrição indica que o objeto dependente não pode existir sem uma relação de pai. Para obter mais informações, consulte [ReferentialConstraint elemento (CSDL)](https://msdn.microsoft.com/library/24f96a80-85b5-4f2e-a14c-0e3eb6796fa0).  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> Retorna `false` quando o objeto especificado não está na coleção.  
  
   
  
## Examples  
 Este exemplo se baseia o. Para executar o código neste exemplo, você deve ter já adicionado o modelo de vendas AdventureWorks ao seu projeto e configurou seu projeto para usar o Entity Framework. Para fazer isso, conclua os procedimentos em [como: Configurar manualmente um projeto do Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) e [como: Definir o modelo e arquivos de mapeamento manualmente](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 Este exemplo usa o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> método para remover uma das entidades da coleção e, em seguida, chama o <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> método para determinar se o objeto foi removido da coleção.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O objeto <paramref name="entity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O objeto <paramref name="entity" /> não está anexado ao mesmo contexto de objeto.  
  
- ou - 
O objeto <paramref name="entity" /> não tem um gerenciador de relação válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que é usado para iterar por meio do conjunto de valores armazenados em cache por <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que itera por meio do conjunto de valores armazenados em cache por <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a coleção é uma coleção de entidades relacionada é composta por objetos da coleção.</summary>
        <value>Essa propriedade sempre retorna <see langword="false" /> porque o <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> contém objetos e coleções não.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Objects.DataClasses.EntityCollection%601> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a coleção como um <see cref="T:System.Collections.IList" /> usado para associação de dados.</summary>
        <returns>Um <see cref="T:System.Collections.IList" /> de objetos de entidade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Data.Objects.DataClasses.EntityCollection%601> é convertida em uma interface de <xref:System.ComponentModel.IListSource>.  
  
 Esse método permite a vinculação de dados a um <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Ele é chamado pelo controle associado à coleção. Para obter mais informações, consulte [objetos de associação aos controles](https://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>