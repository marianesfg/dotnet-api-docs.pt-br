<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ae997d3bdb19b9c463dc6854265ec7399b60179b" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57920113" /></Metadata><TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler" />
  <TypeSignature Language="F#" Value="type ScriptManager = class&#xA;    inherit Control&#xA;    interface IPostBackDataHandler&#xA;    interface IPostBackEventHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Gerencia arquivos de script e bibliotecas de script ASP.NET Ajax, renderização de página parcial e geração de classe de proxy do cliente para serviços e aplicativos e Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Neste tópico:  
  
-   [Introdução](#introduction)  
  
-   [Renderização parcial da página](#partial_page_rendering)  
  
-   [Usando o controle ScriptManager com páginas mestras, controles de usuário e outros componentes filho](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [Registro e gerenciamento de script](#script_management_and_registration)  
  
-   [Referências de serviço Web](#web_service_references)  
  
-   [Localização](#localization)  
  
-   [Tratamento de erro](#error_handling)  
  
-   [Sintaxe declarativa](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>Introdução  
 O <xref:System.Web.UI.ScriptManager> controle é fundamental para a funcionalidade Ajax no ASP.NET. O controle gerencia todos os recursos do ASP.NET Ajax em uma página. Isso inclui baixar scripts de biblioteca do Microsoft Ajax no navegador e coordenar as atualizações de página parcial são habilitadas usando <xref:System.Web.UI.UpdatePanel> controles. Além disso, o <xref:System.Web.UI.ScriptManager> controle permite que você faça o seguinte:  
  
-   Registre um script que é compatível com atualizações de página parcial. Para gerenciar as dependências entre seu script e a biblioteca principal, qualquer script que você registre é carregado após o script do Microsoft Ajax Library.  
  
-   Especifique se a versão ou scripts de depuração são enviados para o navegador.  
  
-   Fornecer acesso aos métodos do serviço Web de script, Registrando serviços da Web com o <xref:System.Web.UI.ScriptManager> controle.  
  
-   Fornecer acesso a autenticação do ASP.NET, função e perfil de serviços de aplicativos de script de cliente registrando esses serviços com o <xref:System.Web.UI.ScriptManager> controle.  
  
-   Habilite a exibição de específicas da cultura de ECMAScript (JavaScript) e funções no navegador.  
  
-   Acessar recursos de localização para arquivos de script incorporado ou para arquivos de script autônomo usando o <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> propriedade do <xref:System.Web.UI.ScriptReference> controle.  
  
-   Registrar controles de servidor que implementam o <xref:System.Web.UI.IExtenderControl> ou <xref:System.Web.UI.IScriptControl> faz interface com o <xref:System.Web.UI.ScriptManager> controlar de forma que o script necessário por componentes de cliente e comportamentos é renderizado.  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>Renderização de página parcial  
 A capacidade de uma página ASP.NET para dar suporte à renderização parcial da página é controlada pelos seguintes fatores:  
  
-   O <xref:System.Web.UI.ScriptManager> do controle <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriedade deve ser `true` (o valor padrão).  
  
-   Deve haver pelo menos um <xref:System.Web.UI.UpdatePanel> controle na página.  
  
-   O <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriedade deve ser `true` (o valor padrão). Se o <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> não está definida explicitamente, seu valor é baseado nos recursos do navegador.  
  
 Você pode substituir o valor da <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriedade em tempo de execução durante ou antes da página <xref:System.Web.UI.Control.Init> eventos. Se você tentar alterar esta propriedade após a página <xref:System.Web.UI.Control.Init> evento ocorreu, um <xref:System.InvalidOperationException> exceção é lançada.  
  
 Quando há suporte para a renderização parcial da página, o <xref:System.Web.UI.ScriptManager> controle renderiza o script para habilitar atualizações de página parcial e postbacks assíncronos. As regiões da página a ser atualizado são designadas usando <xref:System.Web.UI.UpdatePanel> controles. O <xref:System.Web.UI.ScriptManager> controle manipula os postbacks assíncronos e atualiza apenas as regiões da página que devem ser atualizados. Para obter mais informações sobre a renderização parcial da página, consulte [visão geral de renderização parcial da página](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49). Para obter mais informações sobre as condições que causam uma atualização, consulte [visão geral do controle UpdatePanel](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a).  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>Usando o controle ScriptManager com páginas mestre, controles de usuário e outros componentes filho  
 Uma página pode conter apenas um <xref:System.Web.UI.ScriptManager> controle em sua hierarquia. Para registrar os serviços e scripts para componentes, controles de usuário ou de páginas aninhadas quando a página pai já tem um <xref:System.Web.UI.ScriptManager> controlar, use o <xref:System.Web.UI.ScriptManagerProxy> controle. Para obter mais informações, consulte [usando o controle UpdatePanel com páginas mestras](https://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>Gerenciamento e registro de script  
 O <xref:System.Web.UI.ScriptManager> controle permite que você registre o script que é renderizado como parte da página. O <xref:System.Web.UI.ScriptManager> métodos de registro de controle podem ser divididos em três categorias a seguir:  
  
-   Métodos de registro que garantem que as dependências de script na biblioteca do Microsoft Ajax são mantidas.  
  
-   Métodos de registro que não são dependentes da Microsoft Ajax Library, mas que são compatíveis com <xref:System.Web.UI.UpdatePanel> controles.  
  
-   Métodos de registro que dá suporte ao trabalho com <xref:System.Web.UI.UpdatePanel> controles.  
  
 Para obter mais informações sobre como criar e usar o script Ajax no ASP.NET, consulte [Criando Script de cliente personalizado usando a biblioteca do Microsoft Ajax](https://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899).  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>Registrando o script que depende da Microsoft Ajax Library  
 Você pode usar os métodos a seguir para registrar os arquivos de script de forma que garante que todas as dependências na biblioteca do Microsoft Ajax sejam mantidas.  
  
|Método|Definição|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|Registra um controle de servidor que implementa o <xref:System.Web.UI.IScriptControl> interface que é usado para definir um objeto de cliente. O <xref:System.Web.UI.ScriptManager> controle renderiza um script que dá suporte ao objeto de cliente.|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|Registra um controle de servidor que implementa o <xref:System.Web.UI.IExtenderControl> interface que é usado para definir um objeto de cliente. O <xref:System.Web.UI.ScriptManager> controle renderiza um script que dá suporte ao objeto de cliente.|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>Registrando scripts compatíveis com atualização de página parcial  
 Você pode usar os métodos a seguir para registrar os arquivos de script que não são dependentes da Microsoft Ajax Library, mas que são compatíveis com <xref:System.Web.UI.UpdatePanel> controles. Esses métodos correspondem aos métodos semelhantes do <xref:System.Web.UI.ClientScriptManager> controle. Se você for o processamento de script para uso dentro de uma <xref:System.Web.UI.UpdatePanel> controlar, certifique-se de que você chame os métodos do <xref:System.Web.UI.ScriptManager> controle.  
  
|Método|Definição|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|Adiciona um valor para uma matriz de JavaScript. Se a matriz não existir, ele é criado.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|Renderiza uma `script` elemento após a abertura da página `<form>` marca. O script é especificado como um parâmetro de cadeia de caracteres.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|Renderiza uma `script` elemento após a abertura da página `<form>` marca. O conteúdo do script seja especificado definindo a `src` de atributo para uma URL que aponta para um arquivo de script.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|Renderiza uma `script` elemento após a abertura da página `<form>` marca. O conteúdo do script é especificado com um nome de recurso em um assembly. O `src` atributo é preenchido automaticamente com uma URL por uma chamada para um manipulador HTTP que recupera o script nomeado do assembly.|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|Renderiza um par de atributo de nome/valor personalizado (um expando) na marcação para um controle especificado.|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|Renderiza um campo oculto.|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|Registra um script que é executado em resposta à `form` do elemento `submit` eventos. O `onSubmit` atributo referencia o script especificado.|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|Renderiza um bloco de script de inicialização antes do fechamento da página `</form>` marca. O script a ser processado é especificado como um parâmetro de cadeia de caracteres.|  
  
 Quando você registra métodos, você pode especificar um par chave/tipo para esse script. Se um script com o mesmo par de chave/tipo já estiver registrado, um novo script não está registrado. Da mesma forma, se você registrar um script com um par de nome de tipo/recursos que já existir, o `script` elemento que referencia o recurso não é adicionado novamente. Quando você registra um atributo expando de um atributo registrado anteriormente, uma exceção é lançada. Registro duplicado dos valores de matriz é permitido.  
  
 Quando você chama o <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> ou o <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> método, evite registrando o script que executa funções embutidas. Em vez disso, registre o script que contém as definições de função como manipuladores de eventos ou definições de classe personalizada para seu aplicativo.  
  
### <a name="registration-methods-for-updatepanel-controls"></a>Métodos de registro para controle UpdatePanel  
 Você pode usar os métodos a seguir para personalizar atualizações parciais de página quando você usa <xref:System.Web.UI.UpdatePanel> controles.  
  
|Método|Definição|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|Registra um controle como um gatilho para postbacks assíncronos.|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|Envia dados personalizados para controles durante a renderização parcial da página.|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|Registra um script de descarte para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle. O script é executado quando o controle <xref:System.Web.UI.UpdatePanel> é atualizado ou excluído. O método dispose é usado para componentes de cliente que fazem parte da biblioteca do Microsoft Ajax e que têm que liberar recursos quando um componente não é mais usado.|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|Registra um controle como um gatilho para um postback completo. Esse método é usado para controles dentro de um <xref:System.Web.UI.UpdatePanel> controle que executaria postbacks assíncronos.|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>Referências de serviço Web  
 Você pode registrar um serviço Web a ser chamado do script de cliente com a criação de um <xref:System.Web.UI.ServiceReference> objeto e adicioná-lo para o <xref:System.Web.UI.ScriptManager.Services%2A> coleção do <xref:System.Web.UI.ScriptManager> controle. O ASP.NET gera um objeto de proxy de cliente para cada <xref:System.Web.UI.ServiceReference> do objeto no <xref:System.Web.UI.ScriptManager.Services%2A> coleção. Você pode adicionar programaticamente <xref:System.Web.UI.ServiceReference> objetos para o <xref:System.Web.UI.ScriptManager.Services%2A> coleção para registrar os serviços da Web em tempo de execução.  
  
 Para obter mais informações sobre como acessar serviços Web no script, consulte [expor serviços da Web para o Script de cliente no ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8) e [chamar serviços da Web de Script de cliente no ASP.NET AJAX](https://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0).  
  
<a name="localization"></a>   
## <a name="localization"></a>Localização  
 O <xref:System.Web.UI.ScriptManager> controle gera referências na página renderizada que apontam para os arquivos de script localizados apropriados, que são qualquer um dos arquivos de script inseridos em assemblies ou arquivos de script autônomo.  
  
 Quando o <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> estiver definida como `true`, o <xref:System.Web.UI.ScriptManager> controle recupera recursos localizados (como cadeias de caracteres localizadas) para a cultura atual, se eles existirem. O <xref:System.Web.UI.ScriptManager> controle fornece a seguinte funcionalidade para o uso de recursos localizados:  
  
-   **Arquivos de script que são inseridos em um assembly**. O <xref:System.Web.UI.ScriptManager> controle determina qual arquivo de script específicas da cultura ou cultura de fallback para enviar para o navegador. Ele faz isso usando a cultura específica <xref:System.Resources.NeutralResourcesLanguageAttribute> atributo de assembly, os recursos que acompanham o assembly e a cultura de interface do usuário do navegador (se houver).  
  
-   **Arquivos de script autônomo**. O <xref:System.Web.UI.ScriptManager> controle define a lista de culturas de interface do usuário que têm suporte usando o <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> propriedade do <xref:System.Web.UI.ScriptReference> objeto.  
  
-   **No modo de depuração**. O <xref:System.Web.UI.ScriptManager> controle tenta processar um arquivo de script específicos de cultura que contém informações de depuração. Por exemplo, se a página estiver no modo de depuração e a cultura atual é definida como en-MX, o controle processa um arquivo de script que tem um nome como `scriptname`.en MX.debug.js, se o arquivo existe. Se o arquivo não existir, o arquivo de depuração para a cultura de fallback apropriado é renderizado  
  
 Para obter mais informações sobre como localizar recursos, consulte [localizando recursos de visão geral do componente bibliotecas](https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb).  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>Tratamento de erros  
 Quando ocorre um erro de página durante postbacks assíncronos, o <xref:System.Web.UI.ScriptManager.AsyncPostBackError> é gerado. A maneira na qual os erros no servidor são enviados ao cliente depende de <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade, o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade e a seção de erros personalizados do arquivo Web. config. Para obter mais informações, consulte [Personalizando o tratamento de erros para os controles UpdatePanel](https://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0).  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>Sintaxe declarativa  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 Os exemplos a seguir mostram diferentes cenários para usar o <xref:System.Web.UI.ScriptManager> controle.  
  
 **Habilitar atualizações de página parcial**  
  
 O exemplo a seguir mostra como usar o <xref:System.Web.UI.ScriptManager> controle para habilitar atualizações de página parcial. Neste exemplo, uma <xref:System.Web.UI.WebControls.Calendar> e uma <xref:System.Web.UI.WebControls.DropDownList> controle estão dentro de um <xref:System.Web.UI.UpdatePanel> controle. Por padrão, o valor da <xref:System.Web.UI.UpdatePanel.UpdateMode%2A> é de propriedade <xref:System.Web.UI.UpdatePanelUpdateMode.Always>e o valor da <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> é de propriedade `true`. Portanto, os controles filho do painel de causam um postback assíncrono.  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **Tratamento de erros de atualização de página parcial e registrando o Script**  
  
 O exemplo a seguir mostra como fornecer tratamento durante atualizações parciais de página de erro personalizado. Por padrão, quando ocorre um erro durante atualizações parciais de página, é exibida uma caixa de mensagem do JavaScript. Este exemplo demonstra como usar tratamento personalizado, fornecendo um manipulador para o <xref:System.Web.UI.ScriptManager.AsyncPostBackError> evento e definindo o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade no manipulador de eventos. Você também pode definir o <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade para especificar como a seção de erros personalizados do arquivo Web. config é usada quando ocorrer um erro durante atualizações parciais de página. Neste exemplo, o valor padrão de <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade é usada. Isso significa que, se o arquivo Web. config contém um elemento, esse elemento determina como os erros são exibidos. Para obter mais informações, consulte [customErrors Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **Globalizando a data e hora que são exibidos no navegador**  
  
 O exemplo a seguir mostra como definir o <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> propriedade para que esse script de cliente possa exibir uma cultura específica data e hora no navegador. No exemplo, o `Culture` atributo o [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) diretiva for definida como `auto`. Como resultado, o primeiro idioma que é especificado nas configurações do navegador atual determina a cultura e cultura da interface do usuário para a página. Para obter mais informações, confira [Como: Definir a cultura e cultura da interface do usuário para globalização de página da Web do ASP.NET](https://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
    <related type="Article" href="https://msdn.microsoft.com/library/fceeb3c5-c59f-46a9-af4f-b0d7155a1efc">Classe PageRequestManager</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa os campos internos que são usados pelo <xref:System.Web.UI.ScriptManager> controle para acompanhar informações sobre a implantação, controle e página.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um ponto histórico e o adiciona à pilha histórica do navegador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essas sobrecargas de método permitem que você definir o estado do servidor e, opcionalmente, o título da entrada de histórico no navegador. Quando você cria um ponto de histórico, os dados serializados e criptografados são acrescentados à URL da página da Web e uma entrada é incluída na pilha de histórico do navegador. Você pode usar os dados de estado para recriar a página quando qualquer evento de navegação do servidor subsequente é gerado. Para obter mais informações, consulte [gerenciamento de controles de servidor usando do navegador histórico](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : System.Collections.Specialized.NameValueCollection * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (state, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">Uma coleção de pares chave-valor que contêm os dados do estado.</param>
        <param name="title">O texto que será adicionado à pilha de histórico do navegador como o título desse estado.</param>
        <summary>Cria um ponto histórico e o adiciona à pilha de histórico do navegador, usando a coleta de dados de estado e o título do estado especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um ponto de histórico quando você deseja salvar mais de um par chave/valor para os dados de estado. Quando você cria um ponto de histórico, os dados serializados e criptografados são acrescentados à URL da página da Web e uma entrada é incluída na pilha de histórico do navegador. Se o `title` parâmetro é `null`, o título da página da Web é usado como o título da entrada do estado da pilha de histórico.  
  
 Você pode usar os dados de estado para recriar a página quando qualquer evento de navegação do servidor subsequente é gerado. Para obter mais informações, consulte [gerenciamento de controles de servidor usando do navegador histórico](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">A parte chave do par chave-valor que identifica o estado da página da Web.</param>
        <param name="value">A parte valor do par chave-valor que identifica o estado da página da Web.</param>
        <summary>Cria um ponto histórico e o adiciona à pilha histórica do navegador, usando a chave e o valor de estado especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um ponto de histórico quando você desejar salvar um valor para identificar o estado. Quando você cria um ponto de histórico, os dados serializados e criptografados são acrescentados à URL da página da Web e uma entrada é incluída na pilha de histórico do navegador. O título da página da Web é usado como o título da entrada de estado na pilha de histórico.  
  
 Você pode usar os dados de estado para recriar a página quando qualquer evento de navegação do servidor subsequente é gerado. Para obter mais informações, consulte [gerenciamento de controles de servidor usando do navegador histórico](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">A parte chave do par chave-valor que identifica o estado da página da Web.</param>
        <param name="value">A parte valor do par chave-valor que identifica o estado da página da Web.</param>
        <param name="title">O texto que será adicionado à pilha de histórico do navegador como o título desse estado.</param>
        <summary>Cria um ponto histórico e o adiciona à pilha de histórico do navegador, usando a chave, o valor e o título de estado especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um ponto de histórico quando você deseja salvar um valor para identificar o estado e um título para o estado. Quando você cria um ponto de histórico, os dados serializados e criptografados são acrescentados à URL da página da Web e uma entrada é incluída na pilha de histórico do navegador. Se o `title` parâmetro é `null`, o título da página da Web é usado como o título da entrada do estado da pilha de histórico.  
  
 Você pode usar os dados de estado para recriar a página quando qualquer evento de navegação do servidor subsequente é gerado. Para obter mais informações, consulte [gerenciamento de controles de servidor usando do navegador histórico](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkAssembly : System.Reflection.Assembly" Usage="System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o assembly da estrutura Ajax que os componentes na página usam.</summary>
        <value>O assembly de estrutura Ajax.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkMode : System.Web.UI.AjaxFrameworkMode with get, set" Usage="System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica como os scripts do cliente da biblioteca de cliente do Microsoft Ajax serão incluídos no cliente.</summary>
        <value>Um valor de enumeração <see cref="T:System.Web.UI.AjaxFrameworkMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> propriedade para habilitar todos os arquivos de script de Microsoft Ajax, para desabilitar todos os arquivos de script do Microsoft Ajax, ou para incluir explicitamente os arquivos de script individuais.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir a <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> propriedade para `Explicit` para indicar que scripts podem ser especificados explicitamente.  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCustomErrorsRedirect : bool with get, set" Usage="System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que determina se a seção de erros personalizados do arquivo Web.config é usada ou não durante um erro em um postback assíncrono.</summary>
        <value><see langword="true" /> se a configuração de erros personalizados no arquivo Web.config é usada para determinar o comportamento de erros durante postbacks assíncronos; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.AsyncPostBackError> é gerado quando ocorre um erro de página durante postbacks assíncronos. Como os erros ocorridos no servidor são enviados para o cliente depende de <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade, o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade e a seção de erros personalizados do arquivo Web. config.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackError : EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " Usage="member this.AsyncPostBackError : System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando há um erro de página durante um postback assíncrono.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.AsyncPostBackError> é gerado quando ocorre um erro de página durante postbacks assíncronos. Como os erros ocorridos no servidor são enviados para o cliente depende de <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade, o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade e a seção de erros personalizados do arquivo Web. config.  
  
   
  
## Examples  
 O exemplo a seguir mostra como lidar com o <xref:System.Web.UI.ScriptManager.AsyncPostBackError> evento para definir o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade (que é enviada ao cliente) para a mensagem de erro de exceção de servidor.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackErrorMessage : string with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a mensagem de erro que é enviada ao cliente quando ocorre uma exceção sem tratamento do servidor durante um postback assíncrono.</summary>
        <value>A mensagem de erro. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.AsyncPostBackError> é gerado quando ocorre um erro de página durante postbacks assíncronos. Como os erros ocorridos no servidor são enviados para o cliente depende de <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade, o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade e a seção de erros personalizados do arquivo Web. config.  
  
   
  
## Examples  
 O exemplo a seguir mostra como lidar com o <xref:System.Web.UI.ScriptManager.AsyncPostBackError> evento para definir o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade (que é enviada ao cliente) para a mensagem de erro de exceção de servidor.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackSourceElementID : string" Usage="System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.AsyncPostBackSourceElementID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID exclusiva do controle que causou o postback assíncrono.</summary>
        <value>A ID exclusiva de um controle, se o controle tiver uma ID de; Caso contrário, uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A> propriedade contém o valor da ID de controle que causou o postback assíncrono, que pode ser um dos seguintes:  
  
-   Um postback de um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle cuja <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> estiver definida como `true` (o padrão).  
  
-   Um postback de um controle que é um gatilho para um <xref:System.Web.UI.UpdatePanel> controle.  
  
-   Um postback de um controle que está registrado com a chamada a <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> método da <xref:System.Web.UI.ScriptManager> controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackTimeout : int with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica o tempo, em segundos, antes que o tempo limite de postbacks assíncronos seja atingido, se nenhuma resposta é recebida.</summary>
        <value>Um inteiro que representa o tempo limite em segundos. O valor padrão é 90 segundos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationService : System.Web.UI.AuthenticationServiceManager" Usage="System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.UI.AuthenticationServiceManager" /> associado à instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</summary>
        <value>O objeto <see cref="T:System.Web.UI.AuthenticationServiceManager" /> da instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.AuthenticationServiceManager> objeto que é retornado por esta propriedade representa o serviço de autenticação que está registrado com a página. O serviço de autenticação pode ser definido na <xref:System.Web.UI.ScriptManager> controle ou em um tipo de <xref:System.Web.UI.ScriptManagerProxy> controle.  
  
 Você pode usar o serviço de autenticação do ASP.NET ou usar um serviço de autenticação personalizada. Você pode adicionar o serviço personalizado na marcação, incluindo uma `AuthenticationService` elemento dentro do `asp:ScriptManager` elemento na página, conforme mostrado no exemplo a seguir.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 Você pode configurar também programaticamente o <xref:System.Web.UI.AuthenticationServiceManager> objeto. Serviços são registrados com o <xref:System.Web.UI.ScriptManager> controle durante a página <xref:System.Web.UI.Control.PreRender> estágio do ciclo de vida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientNavigateHandler : string with get, set" Usage="System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do método que manipula o evento <see href="https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93">Sys.Application.navigate</see> no cliente.</summary>
        <value>O nome do método que manipula o [Navigate](https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) eventos no cliente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositeScript : System.Web.UI.CompositeScriptReference" Usage="System.Web.UI.ScriptManager.CompositeScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao script de composição que dá suporte à página da Web.</summary>
        <value>Uma referência ao script de composição.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [combinando os Scripts de cliente em um Script de composição](https://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EmptyPageUrl : string with get, set" Usage="System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma URL para uma página da Web em branco.</summary>
        <value>A URL a ser usado se a página da Web de destino está vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A> propriedade dá suporte a histórico de navegador do Ajax.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdn : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se a página atual carrega as referências de script de cliente de caminhos de CDN (Rede de Distribuição de Conteúdo).</summary>
        <value><see langword="true" /> se as referências de script de cliente são carregadas de caminhos CDN, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não defina essa propriedade como `true` se você definir <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> para `true` já.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdnFallback : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Permite que uma cópia local de um script seja carregada caso a CDN (Rede de Distribuição de Conteúdo) esteja indisponível.</summary>
        <value><see langword="true" /> Se o valor de fallback de CDN estiver habilitado; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHistory : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableHistory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a página da Web dá suporte ao gerenciamento de ponto histórico.</summary>
        <value><see langword="true" /> se a página da Web der suporte à adição de pontos históricos à pilha do histórico do navegador, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.EnableHistory%2A> propriedade para habilitar o gerenciamento de histórico em uma página da Web.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePageMethods : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os métodos de página estática pública em uma página do ASP.NET podem ser chamados por meio do script de cliente.</summary>
        <value><see langword="true" /> se os métodos de página estática em uma página do ASP.NET puderem ser chamados por meio de script de cliente como métodos da Web; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode adicionar métodos estáticos de página a uma página ASP.NET e marcá-los como métodos da Web. Em seguida, você pode chamar esses métodos de script como se fizessem parte de um serviço Web, mas sem criar um arquivo. asmx separado. Para criar métodos da Web em uma página, importe as <xref:System.Web.Services> namespace e adicione um <xref:System.Web.Services.WebMethodAttribute> de atributo para cada método estático que você deseja expor. Os métodos devem ser marcados como públicos.  
  
 Para obter mais informações, consulte [expor serviços da Web para o Script de cliente no ASP.NET AJAX](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que permite a renderização parcial de uma página, o que por sua vez permite que você atualize regiões da página individualmente usando controles <see cref="T:System.Web.UI.UpdatePanel" />.</summary>
        <value><see langword="true" /> se a renderização parcial estiver habilitada e as atualizações de página inteira estiverem suprimidas; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mesmo se o <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> é de propriedade `true`, renderização parcial da página poderá não ocorrer. O navegador pode não oferecer suporte a renderização parcial da página, ou o <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> estiver definida como `false`.  
  
 Você pode substituir o valor da <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> propriedade em tempo de execução durante ou antes da página <xref:System.Web.UI.Control.Init> eventos. Se você tentar alterar esta propriedade após a página <xref:System.Web.UI.Control.Init> evento ocorreu, um <xref:System.InvalidOperationException> exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> é definida após o evento <see cref="E:System.Web.UI.Control.Init" /> da página ocorrer.</exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptGlobalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle <see cref="T:System.Web.UI.ScriptManager" /> renderiza um script que dá suporte à análise e formatação de informações específicas de cultura.</summary>
        <value><see langword="true" /> se informações específicas de cultura podem ser exibidas; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> estiver definida como `true`, globalizado ECMAScript (JavaScript) funções, como o `Date.localeFormat` informações de cultura específica de exibição do método. A cultura pode ser definida no navegador, no código do servidor ou no arquivo de configuração do site da Web.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/69b34e6d-d590-4d03-a763-b7ae54b47d74">Localizando uma data usando o Script de cliente</related>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptLocalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle <see cref="T:System.Web.UI.ScriptManager" /> renderiza versões localizadas dos arquivos de script.</summary>
        <value><see langword="true" /> para renderizar os arquivos de script localizados; caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> estiver definida como `true`, o <xref:System.Web.UI.ScriptManager> objeto irá recuperar os arquivos de script para a cultura atual, se eles existirem. Por exemplo, uma página pode especificar um arquivo de script chamado CustomScript.js. Se a cultura é definida para fr-CA, o <xref:System.Web.UI.ScriptManager> objeto tentará recuperar um arquivo de script que é denominado CustomScript.fr-CA.  
  
> [!NOTE]
>  Para impedir que um arquivo de script que está sendo renderizada duas vezes, o <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> propriedade não deve ser modificada durante um postback assíncrono.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb">Localização de recursos de visão geral do componente bibliotecas</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSecureHistoryState : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a cadeia de caracteres de estado histórico deve ser criptografada.</summary>
        <value><see langword="true" /> Se a cadeia de caracteres do estado histórico deve ser criptografada; Caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Essa propriedade deve ***nunca*** ser definido como `false` em um site de produção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Web.UI.Page -&gt; System.Web.UI.ScriptManager" Usage="System.Web.UI.ScriptManager.GetCurrent page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">A instância de página da qual recuperar o <see cref="T:System.Web.UI.ScriptManager" />.</param>
        <summary>Obtém a instância <see cref="T:System.Web.UI.ScriptManager" /> para um determinado objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>A instância <see cref="T:System.Web.UI.ScriptManager" /> atual para o objeto <see cref="T:System.Web.UI.Page" /> selecionado ou <see langword="null" /> se não houver uma instância definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método estático para determinar se um <xref:System.Web.UI.ScriptManager> controle está em uma página ou para acessar as propriedades e métodos de um <xref:System.Web.UI.ScriptManager> controlar quando você não souber sua ID.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredArrayDeclarations : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;" Usage="scriptManager.GetRegisteredArrayDeclarations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de declarações da matriz ECMAScript (JavaScript) que foram anteriormente registradas com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Uma coleção genérica que contém as declarações de matriz.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredClientScriptBlocks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredClientScriptBlocks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de blocos de script de cliente que foram anteriormente registrados com o controle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <returns>Uma coleção genérica que contém blocos de script de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocos de script de cliente são registrados com o <xref:System.Web.UI.ScriptManager> controle para uso com um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredDisposeScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;" Usage="scriptManager.GetRegisteredDisposeScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de scripts <see langword="dispose" /> que foram anteriormente registrados com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Uma coleção genérica que contém scripts <see langword="dispose" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um `dispose` script executado quando o <xref:System.Web.UI.UpdatePanel> controle é atualizada ou excluída.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredExpandoAttributes : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;" Usage="scriptManager.GetRegisteredExpandoAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de atributos personalizados (expando) que foram anteriormente registrados com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Uma coleção genérica que contém atributos personalizados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um atributo personalizado é um par nome/valor que pode ser lido e definido pelo script de cliente.  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredHiddenFields : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;" Usage="scriptManager.GetRegisteredHiddenFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de campos ocultos que foram anteriormente registrados com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Uma coleção genérica que contém campos ocultos.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredOnSubmitStatements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredOnSubmitStatements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de instruções <see langword="onsubmit" /> que foram anteriormente registradas com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Uma coleção genérica que contém instruções <see langword="onsubmit" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um `onsubmit` instrução é ECMAScript (JavaScript) que é executado quando o formulário é enviado.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredStartupScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredStartupScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção somente leitura de scripts de inicialização que foram anteriormente registrados com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>Uma coleção genérica que contém scripts de inicialização.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um script de inicialização é o script de cliente que está associado um controle que é executado quando o controle é iniciado.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberSignature Language="F#" Value="member this.GetStateString : unit -&gt; string" Usage="scriptManager.GetStateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma cadeia de caracteres que contém pares chave-valor que representam o estado da página da Web.</summary>
        <returns>Uma cadeia de caracteres que contém pares chave-valor que representam o estado da página da Web.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsDebuggingEnabled</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se as versões de depuração das bibliotecas de script de cliente serão renderizadas.</summary>
        <value><see langword="true" /> Se a solicitação atual está em execução no modo de depuração; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> propriedade retorna `false` quando qualquer uma das seguintes condições for verdadeira:  
  
-   No [implantação](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) elemento do arquivo de configuração, o `retail` atributo é definido como `true`. Isso substitui todas as outras configurações.  
  
-   O <xref:System.Web.UI.ScriptManager.ScriptMode%2A> estiver definida como `Auto` ou a `Inherit`, e a depuração não está habilitada no `compilation` seção do arquivo Web. config raiz do aplicativo.  
  
-   A propriedade <xref:System.Web.UI.ScriptManager.ScriptMode%2A> é definida como `Release`.  
  
    > [!NOTE]
    >  O `debug` atributo o [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) diretiva não afeta os aplicativos habilitados para Ajax ASP.NET. O <xref:System.Web.UI.ScriptManager> controle usa apenas as configurações no arquivo Web. config e em seu <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> e <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriedades para determinar se deve processar scripts de depuração.  
  
 Para obter mais informações, consulte [depuração e rastreamento de visão geral de aplicativos Ajax](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInAsyncPostBack : bool" Usage="System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsInAsyncPostBack</InterfaceMember>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.IsInAsyncPostBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o postback atual está sendo executado no modo de renderização parcial.</summary>
        <value><see langword="true" /> se o postback atual estiver em execução no modo de renderização parcial. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> propriedade em combinação com o <xref:System.Web.UI.Page.IsPostBack%2A> propriedade para distinguir entre uma atualização de página inteira, uma atualização parcial de página e o carregamento da página inicial <xref:System.Web.UI.Control.Load>, <xref:System.Web.UI.Page.InitComplete>, ou <xref:System.Web.UI.Control.PreRender> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNavigating : bool" Usage="System.Web.UI.ScriptManager.IsNavigating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um evento <see cref="E:System.Web.UI.ScriptManager.Navigate" /> está sendo manipulado no momento.</summary>
        <value><see langword="true" /> Se o <see cref="E:System.Web.UI.ScriptManager.Navigate" /> está sendo manipulado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.IsNavigating%2A> propriedade para determinar se o <xref:System.Web.UI.ScriptManager.Navigate> evento foi gerado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberSignature Language="F#" Value="abstract member LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool&#xA;override this.LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool" Usage="scriptManager.LoadPostData (postDataKey, postCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">O identificador da chave do controle.</param>
        <param name="postCollection">A coleção de todos os dados de postagem de entrada.</param>
        <summary>Lê dados de formulário publicados do navegador no servidor e determina a origem do postback assíncrono.</summary>
        <returns><see langword="true" /> se o estado do controle <see cref="T:System.Web.UI.ScriptManager" /> tiver sido alterado como resultado de um postback; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.LoadPostData%2A> método é usado principalmente por desenvolvedores de controle para estender a funcionalidade do <xref:System.Web.UI.ScriptManager> controle.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadScriptsBeforeUI : bool with get, set" Usage="System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os scripts são carregados antes ou depois da marcação da interface do usuário da página ser carregada.</summary>
        <value><see langword="true" /> se os scripts forem carregados antes da marcação para a interface do usuário ser carregada, <see langword="false" /> se os scripts forem carregados depois da marcação para a interface do usuário ser carregada. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> propriedade determina como scripts no <xref:System.Web.UI.ScriptManager.Scripts%2A> coleta são carregados em relação a marcação da página da interface do usuário.  
  
 Quando o <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> é de propriedade `true`, um `script` elemento é processado antes que a marcação da página da interface do usuário seja carregada. Nesse cenário, se os elementos de interface do usuário são definidos em scripts, a interface do usuário será totalmente funcional ao ser carregado. No entanto, se o script acessa os elementos de interface do usuário na marcação para o qual instâncias ainda não tem sido criadas, pode ocorrer um erro. Para certificar-se de que os elementos de interface do usuário sejam carregados antes de você acessá-los, lidar com o `load` eventos do `Sys.Application` classe.  
  
 Quando o <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> é de propriedade `false`, um `script` elemento é renderizado depois que a marcação da página da interface do usuário é renderizada. Nesse cenário, a interface do usuário carregado mais rapidamente, mas pode não ser totalmente funcional se os scripts que definem os elementos adicionais da interface do usuário ainda não foi carregado.  
  
 Não defina essa propriedade como `true` se você definir <xref:System.Web.UI.ScriptManager.EnableCdn%2A> para `true` já.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " Usage="member this.Navigate : System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário clica no botão **Voltar** ou **Avançar** do navegador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um usuário clica o navegador **volta** botão, o navegador navega por meio de URLs exibidos anteriormente, o que podem incluir URLs que contêm dados de estado do ponto de histórico. Se o código do cliente na página da Web detectar que a URL contém dados de estado do histórico, ele faz uma solicitação para a página do servidor. Isso funciona como um evento de postback e o <xref:System.Web.UI.ScriptManagerProxy> controle de servidor gera o `Navigate` eventos. Você pode manipular esse evento e crie novamente a página conforme necessário no aplicativo Web usando os dados de estado que são passados com o evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit&#xA;override this.OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit" Usage="scriptManager.OnAsyncPostBackError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados de evento do erro.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.AsyncPostBackError> é gerado quando ocorre um erro de página durante postbacks assíncronos. Como os erros ocorridos no servidor são enviados para o cliente depende de <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> propriedade, o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade e a seção de erros personalizados do arquivo Web. config.  
  
   
  
## Examples  
 O exemplo a seguir mostra como lidar com o <xref:System.Web.UI.ScriptManager.AsyncPostBackError> evento para definir o <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> propriedade (que é enviada ao cliente) para a mensagem de erro de exceção de servidor.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="scriptManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Control.Init" /> e garante que apenas um controle <see cref="T:System.Web.UI.ScriptManager" /> exista na página.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Mais de uma instância de <see cref="T:System.Web.UI.ScriptManager" /> existe na página.</exception>
        <block subset="none" type="overrides"><para>Ao substituir esse método, chame a base <see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" /> , de modo que arquivos de script são tratados corretamente para renderização parcial da página.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Visão geral do ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="scriptManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Control.PreRender" /> e registra arquivos de script e serviços para obter atualizações parciais da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre o DOM, consulte a [especificação de nível 1 do modelo de objeto de documento (DOM)](https://go.microsoft.com/fwlink/?LinkId=73305) no site da World Wide Web Consortium (W3C).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O navegador que realizou a solicitação parcial de página não dá suporte a versões anteriores do Nível 1.0 do DOM.</exception>
        <block subset="none" type="overrides"><para>Ao substituir esse método, chame a base <see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" /> , de modo que serviços e blocos de script são tratados corretamente para renderização parcial da página.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Visão geral do ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveCompositeScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto que representa a referência de script de composição.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto que representa o script atual.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /> para cada referência de script gerenciada pelo controle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado pelo <xref:System.Web.UI.ScriptManager.OnPreRender%2A> manipulador de eventos, uma vez para cada <xref:System.Web.UI.ScriptReference> no <xref:System.Web.UI.ScriptManager.Scripts%2A> coleção.  
  
 O <xref:System.Web.UI.ScriptManager.ResolveScriptReference> é gerado depois que as entradas de script duplicadas foram resolvidas.  
  
 Substitua este método para afetar os comportamentos de blocos de script individuais em um postback ou durante atualizações parciais de página.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProfileService : System.Web.UI.ProfileServiceManager" Usage="System.Web.UI.ScriptManager.ProfileService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.UI.ProfileServiceManager" /> associado à instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</summary>
        <value>O objeto <see cref="T:System.Web.UI.ProfileServiceManager" /> da instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ProfileServiceManager> objeto que é retornado por esta propriedade representa o serviço de perfil que está registrado com a página. O serviço de perfil pode ser definido na <xref:System.Web.UI.ScriptManager> controle ou em um tipo de <xref:System.Web.UI.ScriptManagerProxy> controle.  
  
 Você pode usar o serviço de perfil do ASP.NET ou usar um serviço de perfil personalizado. Você pode adicionar o serviço personalizado na marcação, incluindo uma `ProfileService` elemento dentro do `asp:ScriptManager` elemento na página, conforme mostrado no exemplo a seguir.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 Você pode configurar também programaticamente o <xref:System.Web.UI.ProfileServiceManager> objeto. Serviços são registrados com o <xref:System.Web.UI.ScriptManager> controle durante a página <xref:System.Web.UI.Control.PreRender> estágio do ciclo de vida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : string -&gt; unit&#xA;override this.RaisePostBackEvent : string -&gt; unit" Usage="scriptManager.RaisePostBackEvent eventArgument" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Uma cadeia de caracteres de pares chave-valor que representam o estado histórico da página da Web.</param>
        <summary>Processa um evento de postback gerado pelo controle <see cref="T:System.Web.UI.ScriptManager" /> e carrega o estado histórico da página da Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberSignature Language="F#" Value="abstract member RaisePostDataChangedEvent : unit -&gt; unit&#xA;override this.RaisePostDataChangedEvent : unit -&gt; unit" Usage="scriptManager.RaisePostDataChangedEvent " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aciona eventos para o controle <see cref="T:System.Web.UI.ScriptManager" /> quando ele executa um postback para o servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A> método é usado principalmente por desenvolvedores de controle para estender a funcionalidade do <xref:System.Web.UI.ScriptManager> controle. Para a implementação padrão da <xref:System.Web.UI.ScriptManager> controle, nenhum evento é gerado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra uma declaração de matriz ECMAScript (JavaScript) no controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está dentro de um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona a matriz à página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (control, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando a matriz.</param>
        <param name="arrayName">O nome da matriz a ser registrada.</param>
        <param name="arrayValue">O valor ou valores da matriz a serem registrados.</param>
        <summary>Registra uma declaração de matriz ECMAScript (JavaScript) no controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está dentro de um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona a matriz à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> método para registrar uma matriz de script de cliente que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Esse método registra a matriz quando `control` representa um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle que está sendo atualizado. Para registrar uma matriz sempre que ocorre um postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você desejar registrar uma matriz que não pertencem a atualizações parciais de página e se você quiser registrar a matriz apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> método determina se uma matriz com o nome especificado no `arrayName` parâmetro já está registrado. Se assim, o método adiciona os valores especificados na `arrayValue`. Porque a matriz a ser registrado se baseia o <xref:System.Collections.ArrayList> classe, são permitidas duplicatas. Se uma matriz registrada com o nome no `arrayName` não existir, a matriz é criada e os valores no `arrayValue` são adicionados a ele.  
  
 Para incluir literais de cadeia de caracteres na matriz, use aspas simples (') ou aspas duplas de escape (\\") em `arrayValue`.  
  
 Observe que o JavaScript trata uma vírgula (,) como um delimitador em uma matriz. Você pode especificar vários valores de matriz, passando uma cadeia de caracteres delimitada por vírgulas em `arrayValue`. Separando os dois itens com uma vírgula na `arrayValue` é equivalente a chamar o <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> método duas vezes, uma vez para cada item.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (page, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">O objeto de página que está registrando a matriz.</param>
        <param name="arrayName">O nome da matriz a ser registrada.</param>
        <param name="arrayValue">O valor ou valores da matriz a serem registrados.</param>
        <summary>Registra uma declaração de matriz ECMAScript (JavaScript) no controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está dentro de um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona a matriz à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> método para registrar uma matriz de script de cliente que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Esse método registra a matriz sempre que um postback assíncrono ocorre. Para registrar uma matriz para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que a matriz é registrada somente quando o painel é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você desejar registrar uma matriz que não pertencem a atualizações parciais de página e se você quiser registrar a matriz apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterAsyncPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterAsyncPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle para se registrar para obter postbacks assíncronos.</param>
        <summary>Registra um controle como um gatilho para postbacks assíncronos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> método permite que você registre controles de servidor Web como gatilhos, para que eles executem um postback assíncrono em vez de um postback síncrono. Quando o <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> propriedade de um <xref:System.Web.UI.UpdatePanel> controle é definida como `true` (que é o padrão), controles dentro de postback de <xref:System.Web.UI.UpdatePanel> controle são automaticamente registrados como controles de postback assíncronos.  
  
 Use o <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> método para registrar controles externos um <xref:System.Web.UI.UpdatePanel> controle como disparadores para postbacks assíncronos e possivelmente para atualizar o conteúdo de um painel de atualização. Para atualizar uma <xref:System.Web.UI.UpdatePanel> controlar programaticamente, chame o <xref:System.Web.UI.UpdatePanel.Update%2A> método.  
  
 Você pode adicionar o gatilho declarativamente usando o `Triggers` elemento o <xref:System.Web.UI.UpdatePanel> controle. No Visual Studio, use o designer **Coleção UpdatePanelTrigger** caixa de diálogo.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar o <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> método para registrar um <xref:System.Web.UI.WebControls.Button> controlar de forma que faz com que uma atualização de um <xref:System.Web.UI.UpdatePanel> conteúdo do controle. O <xref:System.Web.UI.WebControls.Button> controle não está dentro do <xref:System.Web.UI.UpdatePanel> controle. Dois botões são mostrados: `Button1` e `Button2`. `Button1` atualiza o conteúdo do painel, e `Button2` atualiza a página inteira.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 O exemplo a seguir mostra como chamar o <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> método para registrar um usuário controle para que ele faz com que uma atualização de um <xref:System.Web.UI.UpdatePanel> conteúdo do controle. O primeiro exemplo mostra uma página usando o controle de usuário. O segundo exemplo mostra o controle de usuário.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A página é registrada como um controle de postback assíncrono.
- ou -

O controle registrado não implementa as interfaces <see cref="T:System.Web.UI.INamingContainer" />, <see cref="T:System.Web.UI.IPostBackDataHandler" /> ou <see cref="T:System.Web.UI.IPostBackEventHandler" />.</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um bloco de script de cliente com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está em um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona o bloco de script à página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o bloco de script de cliente.</param>
        <param name="type">O tipo de bloco de script de cliente. Geralmente, este parâmetro é especificado com o operador <see langword="typeof" /> (C#) ou <see langword="GetType" /> (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para o bloco de script.</param>
        <param name="script">O script.</param>
        <param name="addScriptTags"><see langword="true" /> para circunscrever o bloco de script nas marcas <see langword="&lt;script&gt;" /> e <see langword="&lt;/script&gt;" />; caso contrário, <see langword="false" />.</param>
        <summary>Registra um bloco de script de cliente com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está em um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona o bloco de script à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> método para registrar um bloco de script de cliente que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Blocos de script de cliente que são registrados por meio desse método são enviados para a página somente quando `control` representa um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle que está sendo atualizado. Para registrar um bloco de script sempre que ocorre um postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga desse método.  
  
 Se você quiser registrar um bloco de script que não pertencem a atualizações parciais de página e se você deseja registrar o bloco de script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 Se `addScriptTags` está `true`, o <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> método adiciona `<script>` marcas em torno do bloco de script. Passar `false` se você quiser criar `<script>` marcas por conta própria, como quando você deseja definir os atributos de determinado `<script>` marcas. Se `addScriptTags` está `false` e o `script` parâmetro contém vários blocos de script, uma exceção será lançada.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> método adiciona um bloco de script para a página após a abertura `<form>` marca. Os blocos de script não são garantidos para a saída na mesma ordem em que eles são registrados. Se a ordem dos blocos de script é importante, concatenar seus blocos de script em uma única cadeia de caracteres (por exemplo, usando o <xref:System.Text.StringBuilder> objeto) e, em seguida, registrá-los como um bloco de script de cliente único.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O bloco de script de cliente <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
O controle que está registrando o bloco de script é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O controle que está registrando o bloco de script não está na árvore de controle da página.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">O objeto da página que está registrando o bloco de script de cliente.</param>
        <param name="type">O tipo de bloco de script de cliente. Geralmente, este parâmetro é especificado com o operador <see langword="typeof" /> (C#) ou <see langword="GetType" /> (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para o bloco de script.</param>
        <param name="script">O script a ser registrado.</param>
        <param name="addScriptTags"><see langword="true" /> para circunscrever o bloco de script nas marcas <see langword="&lt;script&gt;" /> e <see langword="&lt;/script&gt;" />; caso contrário, <see langword="false" />.</param>
        <summary>Registra um bloco de script de cliente com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está em um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona o bloco de script à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você registra um bloco de script usando esse método, o script é processado cada vez que um postback assíncrono ocorre. Para registrar um bloco de script para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que o script é registrado somente quando o <xref:System.Web.UI.UpdatePanel> controle é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga desse método.  
  
 Se você quiser registrar um bloco de script que não pertencem a atualizações parciais de página e se você deseja registrar o bloco de script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O bloco de script <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
A página que está registrando o bloco de script é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um arquivo de script de cliente com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está em um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona uma referência de arquivo de script à página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (control, type, key, url)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o arquivo de script de cliente.</param>
        <param name="type">O tipo de arquivo de script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para o arquivo de script.</param>
        <param name="url">A URL do arquivo de script.</param>
        <summary>Registra um arquivo de script de cliente com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está em um controle <see cref="T:System.Web.UI.UpdatePanel" /> e adiciona uma referência de arquivo de script à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> método para registrar um arquivo de script de cliente para uma página ou parte de uma página que está participando no atualizações parciais de página. Arquivos de script de cliente que são registrados por meio desse método são enviados para a página somente quando o `control` representa um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle que está sendo atualizado. Para registrar um arquivo de script sempre que ocorre um postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar um bloco de script que não pertencem a atualizações parciais de página e se você deseja registrar o bloco de script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> método registra um arquivo de script de cliente na página por meio da renderização uma `script` elemento cuja marca de abertura contém um `src` atributo. O `url` parâmetro é usado para definir o `src` atributo. Para resolver URLs, use o <xref:System.Web.UI.Control.ResolveClientUrl%2A> método. Esse método usa o contexto da URL é chamado para resolver o caminho.  
  
 Tanto a <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> e <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> métodos processam arquivos de script para o navegador. Se um script com o mesmo tipo e a chave (para um arquivo de script) ou o mesmo tipo e o nome de recurso (para um recurso incorporado) já está renderizado, o script não será renderizado novamente.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O arquivo de script de cliente <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
O controle que está registrando o arquivo de script é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O controle que está registrando o arquivo de script não está na árvore de controle da página.  
  
- ou - 
 <paramref name="url" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="url" /> está vazio.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (page, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">O objeto da página que está registrando o arquivo de script de cliente.</param>
        <param name="type">O tipo de arquivo de script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para o arquivo de script.</param>
        <param name="url">A URL do arquivo de script.</param>
        <summary>Registra um script de cliente com o controle <see cref="T:System.Web.UI.ScriptManager" /> toda vez que um postback assíncrono ocorre e, em seguida, adiciona uma referência de arquivo de script à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você registra um arquivo de script com esse método, o script é processado cada vez que um postback assíncrono ocorre. Para registrar um arquivo de script para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que o script é registrado somente quando o <xref:System.Web.UI.UpdatePanel> controle é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar um bloco de script que não pertencem a atualizações parciais de página e se você deseja registrar o bloco de script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O arquivo de script de cliente <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
A página que está registrando o arquivo de script é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="url" /> está vazio.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra o script de cliente inserido em um assembly com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está participando da renderização parcial da página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Control * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (control, type, resourceName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o script.</param>
        <param name="type">O tipo do script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="resourceName">Um identificador para o recurso.</param>
        <summary>Registra o script de cliente inserido em um assembly com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está participando da renderização parcial da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> método para registrar um script que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Recursos de script que são registrados por meio desse método são registrados apenas quando `control` representa um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controle que é atualizado. Para registrar um script sempre que ocorre um postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga desse método.  
  
 Se você quiser registrar um bloco de script que não pertencem a atualizações parciais de página e se você deseja registrar o bloco de script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> método é usado quando recursos de assemblies são acessados por meio de um manipulador HTTP. Esse método inclui o conteúdo da URL do recurso em um `script` elemento.  
  
 Tanto a <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> e o <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> arquivos de script de carga do método para o navegador. Se um script com o mesmo tipo e a chave (para um arquivo de script) ou o mesmo tipo e o nome de recurso (para um recurso incorporado) já está carregado, o script não será recarregado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="type" /> do recurso do cliente é <see langword="null" />.  
  
- ou - 
O controle que está registrando o script é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O controle que está registrando o script não está na árvore de controle da página.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Page * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (page, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">O objeto de página que está registrando o script.</param>
        <param name="type">O tipo do script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="resourceName">Um identificador para o recurso.</param>
        <summary>Registra um arquivo de script de cliente inserido em um assembly com o controle <see cref="T:System.Web.UI.ScriptManager" /> sempre que um postback ocorre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você registra um arquivo de script com esse método, o script é processado cada vez que um postback assíncrono ocorre. Para registrar um script para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que o script é registrado somente quando o <xref:System.Web.UI.UpdatePanel> controle é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar um bloco de script que não pertencem a atualizações parciais de página e se você deseja registrar o bloco de script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="type" /> do recurso do cliente é <see langword="null" />.  
  
- ou - 
A página que está registrando o script é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envia dados personalizados para controles durante a renderização parcial da página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está recebendo os dados.</param>
        <param name="dataItem">Os dados enviados ao controle.</param>
        <summary>Envia dados personalizados a um controle durante a renderização de página parcial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método para enviar dados do servidor para o cliente durante postbacks assíncronos, independentemente de é o controle recebendo os dados dentro de um <xref:System.Web.UI.UpdatePanel> controle.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método pode ser chamado somente durante um postback assíncrono. Para determinar se um postback é assíncrono, use o <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> propriedade. Esse método chama a sobrecarga que utiliza um parâmetro denominado `isJsonSerialized` que é definido como `false`. Quando o `isJsonSerialized` parâmetro é definido como `false`, a cadeia de caracteres não é serializada como JSON JavaScript Object Notation (). Para obter mais informações sobre o formato JSON, consulte o [apresentando o JSON](https://go.microsoft.com/fwlink/?LinkId=77297) site da Web.  
  
 Os itens de dados que são registrados com o <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método pode ser acessado no script de cliente durante o `pageLoading`, `pageLoaded`, e `endRequest` eventos do `PageRequestManager` objeto. Quando você lidar com esses eventos, os dados personalizados são passados em um objeto de argumento do evento. Por exemplo, se você fornecer um manipulador para o `pageLoading` evento, em que os dados personalizados são passados a `PageLoadingEventArgs` classe, que expõe uma propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como enviar dados para dois <xref:System.Web.UI.WebControls.Label> controles em uma página durante um postback assíncrono. O <xref:System.Web.UI.WebControls.Label> controles não estão dentro um <xref:System.Web.UI.UpdatePanel> controle.  
  
> [!NOTE]
>  Os dados que são enviados neste exemplo são apenas para fins ilustrativos. Em um aplicativo do mundo real, você usaria o <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método para enviar dados personalizados do servidor.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> é chamado durante um postback.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="dataItem" /> já está registrado para <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string * bool -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem, isJsonSerialized)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">O controle de página que está recebendo os dados.</param>
        <param name="dataItem">Os dados enviados ao controle.</param>
        <param name="isJsonSerialized"><see langword="true" /> para indicar que <paramref name="dataItem" /> é serializado como JSON; caso contrário, <see langword="false" />.</param>
        <summary>Envia dados personalizados a um controle durante a renderização parcial da página e indica se os dados estão no formato JSON (JavaScript Object Notation).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método para enviar dados do servidor para o cliente durante postbacks assíncronos, independentemente de é o controle recebendo os dados dentro de um <xref:System.Web.UI.UpdatePanel> controle.  
  
 Se o `dataItem` parâmetro que você se registrar para `control` não é serializado como JSON, defina as `isJsonSerialized` parâmetro para `false`. Isso evita a necessidade de usar o `eval` função para cada cadeia de caracteres que é enviada ao cliente. Para obter mais informações sobre o formato JSON, consulte o [apresentando o JSON](https://go.microsoft.com/fwlink/?LinkId=77297) site da Web.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método pode ser chamado somente durante um postback assíncrono. Para determinar se um postback é assíncrono, use o <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> propriedade.  
  
 Os itens de dados que são registrados usando o <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método pode ser acessado no script de cliente durante o `pageLoading`, `pageLoaded`, e `endRequest` eventos do `PageRequestManager` objeto. Quando você lidar com esses eventos, os dados personalizados são passados em um objeto de argumento do evento. Por exemplo, se você fornecer um manipulador para o `pageLoading` evento, em que os dados personalizados são passados a `PageLoadingEventArgs` classe, que expõe uma propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como enviar dados para dois <xref:System.Web.UI.WebControls.Label> controles em uma página durante um postback assíncrono. O <xref:System.Web.UI.WebControls.Label> controles não estão dentro um <xref:System.Web.UI.UpdatePanel> controle. Este exemplo mostra a sobrecarga que não utilize o `isJsonSerialized` parâmetro. Caso contrário, o procedimento para recuperar o `dataItems` propriedade do `PageLoadingEventArgs` objeto é o mesmo como se você não usou essa sobrecarga.  
  
> [!NOTE]
>  Os dados que são enviados neste exemplo são apenas para fins ilustrativos. Em um aplicativo do mundo real, você usaria o <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> método para enviar dados personalizados do servidor. Por exemplo, você pode usar o item de dados para enviar informações sobre a possibilidade de ocultar ou mostrar elementos que não estão dentro de cliente um <xref:System.Web.UI.UpdatePanel> controle.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> é chamado durante um postback.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="dataItem" /> já está registrado para <paramref name="control" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberSignature Language="F#" Value="member this.RegisterDispose : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDispose (control, disposeScript)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle ao qual o script <see langword="dispose" /> se destina.</param>
        <param name="disposeScript">O script <see langword="dispose" />.</param>
        <summary>Registra um script <see langword="dispose" /> para um controle que está em um controle <see cref="T:System.Web.UI.UpdatePanel" />. O script é executado quando o controle <see cref="T:System.Web.UI.UpdatePanel" /> é atualizado ou excluído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> método para registrar `dispose` scripts para controles que estão dentro de um <xref:System.Web.UI.UpdatePanel> controle. Durante postbacks assíncronos, <xref:System.Web.UI.UpdatePanel> controles podem ser atualizados, excluídos ou criados. Quando um painel é atualizado ou excluído, qualquer `dispose` scripts que são registrados para controles que estão dentro do <xref:System.Web.UI.UpdatePanel> são chamados. Em cenários de desenvolvimento de página típico, você não precisa chamar o <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> método.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> método é destinado para uso por desenvolvedores de controle para registrar um script ou criar controles que herdam a <xref:System.Web.UI.IScriptControl> interface. Por exemplo, você pode usar um `dispose` se você desenvolver um controle de cliente usando a composição de script. Em seu controle, você deve implementar <xref:System.Web.UI.IScriptControl> e renderizar controles individuais. Registrar o `dispose` método de qualquer item que não correspondem a um componente de cliente definidos como `Sys.TextBox`. Se o seu controle personalizado compõe elementos que correspondem aos componentes do cliente no Microsoft Ajax Library, você não precisa registrar um `dispose` script, porque `dispose` é chamado automaticamente. Portanto, usar o <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> método para componentes de cliente que fazem parte da biblioteca do Microsoft Ajax e que têm que liberar recursos quando um componente não é mais usado.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> método pode ser chamado várias vezes para um controle. Vários scripts são agregados. A ordem das disposing scripts corresponde à ordem na qual os scripts foram registrados.  
  
 Se você registrar um `dispose` script para um controle que não está em um <xref:System.Web.UI.UpdatePanel> controle, uma exceção será lançada. O `dispose` script é chamado entre os `pageLoading` e `pageLoaded` eventos do `PageRequestManager` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="disposeScript" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="control" /> não foi encontrado na página.  
  
- ou - 
 O <paramref name="control" /> não está em um controle <see cref="T:System.Web.UI.UpdatePanel" />.</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="static member RegisterExpandoAttribute : System.Web.UI.Control * string * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterExpandoAttribute (control, controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o atributo expando.</param>
        <param name="controlId">O controle que contém o atributo personalizado na página.</param>
        <param name="attributeName">O nome do atributo personalizado a ser registrado.</param>
        <param name="attributeValue">O valor do atributo personalizado.</param>
        <param name="encode"><see langword="true" /> para codificar o atributo personalizado que está sendo registrado; caso contrário, <see langword="false" />.</param>
        <summary>Registra um par nome-valor no controle <see cref="T:System.Web.UI.ScriptManager" /> como um atributo personalizado (expando) de um controle especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> método para registrar uma propriedade personalizado (expando) para um controle que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> método registra um par nome/valor como um atributo personalizado para o controle especificado. A propriedade é definida dinamicamente do ECMAScript (JavaScript) para preservar a compatibilidade XHTML para marcação renderizado do controle. Definir `encode` para `true` se você tiver quaisquer caracteres no valor da propriedade dinâmica de escape.  
  
 Se o controle ao qual a propriedade dinâmica será adicionada não for encontrado, ocorrerá um erro de script.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> não está na árvore de controle da página.  
  
- ou - 
 <paramref name="controlId" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="controlId" /> está vazio.  
  
- ou - 
 <paramref name="attributeName" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="attributeName" /> está vazio.  
  
- ou - 
 O <paramref name="attributeName" /> já está registrado.</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)&#xA;override this.RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)" Usage="scriptManager.RegisterExtenderControl (extenderControl, targetControl)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterExtenderControl``1(``0,System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl">Um controle que implementa a interface do <see cref="T:System.Web.UI.IExtenderControl" />.</typeparam>
        <param name="extenderControl">O controle de extensão a ser registrado.</param>
        <param name="targetControl">O controle de script estendido pelo controle de extensão.</param>
        <summary>Registra um controle de extensão na instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é principalmente para uso por desenvolvedores de controle. Chame o <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> método em um controle de extensor ASP.NET Ajax personalizado durante seu `onInit` manipulador de eventos para registrar esse controle na página. Um controle de extensor do Ajax ASP.NET deve ser registrado para participar da renderização parcial da página.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> método adiciona o controle do extensor especificado para uma lista interna de controles de extensão e os controles de script de destino que estender. Essa lista é processada durante a <xref:System.Web.UI.Control.PreRender> eventos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extenderControl" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="targetControl" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um campo oculto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (control, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o campo oculto.</param>
        <param name="hiddenFieldName">O nome do campo oculto a ser registrado.</param>
        <param name="hiddenFieldInitialValue">O valor inicial do campo oculto.</param>
        <summary>Registra um campo oculto com o controle <see cref="T:System.Web.UI.ScriptManager" /> para um controle que está dentro de um controle <see cref="T:System.Web.UI.UpdatePanel" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> método para registrar um campo oculto que seja compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Esse método registra o campo oculto quando o controle que está registrando o campo está dentro de um <xref:System.Web.UI.UpdatePanel> controle que está sendo atualizado. Para registrar um campo oculto sempre que ocorre um postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar um campo oculto que não pertencem a atualizações parciais de página e se você deseja registrar o campo oculto apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> método cria oculto `input` elemento na página HTML renderizada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="hiddenFieldName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> não está na árvore de controle da página.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (page, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">O objeto de página que está registrando o campo oculto.</param>
        <param name="hiddenFieldName">O nome do campo oculto a ser registrado.</param>
        <param name="hiddenFieldInitialValue">O valor inicial do campo oculto.</param>
        <summary>Registra um campo oculto com o controle <see cref="T:System.Web.UI.ScriptManager" /> durante cada postback assíncrono.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> método para registrar um campo oculto que seja compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Esse método registra o campo oculto sempre que um postback assíncrono ocorre. Para registrar um campo oculto para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que o campo é registrado somente quando o painel é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar um campo oculto que não pertencem a atualizações parciais de página e se você deseja registrar o campo oculto apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="hiddenFieldName" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra o script de cliente por nome de recurso inserido em um assembly com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está participando da renderização parcial da página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Control * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (control, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o script.</param>
        <param name="resourceName">Um identificador para o recurso.</param>
        <summary>Registra o script de cliente por nome de recurso inserido em um assembly com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está participando da renderização parcial da página.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Page * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (page, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">O objeto de página que está registrando o script.</param>
        <param name="resourceName">Um identificador para o recurso.</param>
        <summary>Registra o script de cliente por nome de recurso inserido em um assembly com o controle <see cref="T:System.Web.UI.ScriptManager" /> para uso com um controle que está participando da renderização parcial da página.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra o código ECMAScript (JavaScript) executado quando o formulário é enviado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (control, type, key, script)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando a instrução <see langword="onsubmit" />.</param>
        <param name="type">O tipo da instrução de script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para a declaração do script.</param>
        <param name="script">O script a ser registrado.</param>
        <summary>Registra o código ECMAScript (JavaScript) com o controle <see cref="T:System.Web.UI.ScriptManager" /> para um controle usado com um controle <see cref="T:System.Web.UI.UpdatePanel" /> executado quando o formulário é enviado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> adiciona o script é executado antes que o formulário for enviado, que permite modificar o envio ou cancelá-la.  
  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> método para renderizar um `onsubmit` instrução que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. O código JavaScript que está registrado usando esse método é enviado para a página somente quando o controle que está registrando a instrução está dentro de um <xref:System.Web.UI.UpdatePanel> controle que está sendo atualizado. Para registrar o código com cada postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar o código JavaScript que não pertencem a atualizações parciais de página e se você deseja registrar o código apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 O *script* parâmetro do <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> método pode conter vários comandos de script que são delimitados usando ponto e vírgula (;).  
  
 Para obter mais informações sobre os formulários HTML e o `onsubmit` eventos, consulte a [World Wide Web Consortium (W3C) Web site](https://go.microsoft.com/fwlink/?linkid=37125).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> não está na árvore de controle da página.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (page, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">O objeto de página que está registrando a instrução <see langword="onsubmit" />.</param>
        <param name="type">O tipo da instrução de script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para a declaração do script.</param>
        <param name="script">O script a ser registrado.</param>
        <summary>Registra o código ECMAScript (JavaScript) com o controle <see cref="T:System.Web.UI.ScriptManager" /> para um controle usado com um controle <see cref="T:System.Web.UI.UpdatePanel" /> executado quando o formulário é enviado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registrar o código JavaScript com esse método faz com que o script a ser incluído sempre que um postback assíncrono ocorre.  
  
> [!NOTE]
>  Código de quaisquer postagens assíncronas anteriormente não é removido. Novas postagens assíncronas acrescentar o código a qualquer código existente para o `onsubmit` instrução.  
  
 Registrar o código para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que o código seja registrado somente quando o <xref:System.Web.UI.UpdatePanel> controle é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> sobrecarga desse método.  
  
 Se você quiser registrar o código JavaScript que não pertencem a atualizações parciais de página e se você deseja registrar o código apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="type" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle para se registrar para postbacks.</param>
        <summary>Registra um controle como um gatilho para um postback. Esse método é usado para configurar controles de postback dentro um controle <see cref="T:System.Web.UI.UpdatePanel" /> que executaria postbacks assíncronos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A> método para registrar os controles de postback dentro um <xref:System.Web.UI.UpdatePanel> controle como disparadores. Controles que são registrados usando esse método de atualização de uma página inteira em vez de atualizar apenas o <xref:System.Web.UI.UpdatePanel> conteúdo do controle. Registrando um controle de postback com esse método fora de um <xref:System.Web.UI.UpdatePanel> controle não tem nenhum efeito porque por padrão desses controles executa postbacks assíncronos.  
  
 Você pode adicionar o gatilho declarativamente usando o `Triggers` elemento o <xref:System.Web.UI.UpdatePanel> controle. No Visual Studio, use o designer **Coleção UpdatePanelTrigger** caixa de diálogo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)&#xA;override this.RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)" Usage="scriptManager.RegisterScriptControl scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptControl``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl">Um controle que implementa a interface do <see cref="T:System.Web.UI.IScriptControl" />.</typeparam>
        <param name="scriptControl">O controle de script a ser registrado.</param>
        <summary>Registra um controle de script com a instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é principalmente para uso por desenvolvedores de controle. Chame o <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> método em um controle de script ASP.NET Ajax personalizado durante seu `onInit` manipulador de eventos para registrar esse controle na página. Um controle de script do Ajax ASP.NET deve ser registrado para participar da renderização parcial da página.  
  
 O <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> método adiciona o controle do extensor especificado para uma lista interna de controles de script que são processados durante o <xref:System.Web.UI.Control.PreRender> eventos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scriptControl" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Instrui o controle <see cref="T:System.Web.UI.ScriptManager" /> a retornar a chamada para as classes <see cref="T:System.Web.UI.ScriptControl" /> ou <see cref="T:System.Web.UI.ExtenderControl" /> a fim de retornar scripts que dão suporte ao objeto de cliente que representa um controle, componente ou comportamento de cliente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors extenderControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">O controle do extensor para o qual os descritores de script serão registrados.</param>
        <summary>Retorna a chamada para uma classe <see cref="T:System.Web.UI.ExtenderControl" /> para retornar scripts de instância que devem ser renderizados para dar suporte ao objeto de cliente que representa um controle, componente ou comportamento de cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ExtenderControl> classe chamadas a <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> método no seu <xref:System.Web.UI.Control.Render%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você derivar do <see cref="T:System.Web.UI.ExtenderControl" /> de classe e substituir o <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método, mas você não chamar o método da classe base, você deve chamar o <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" /> método. Isso permite que o <see cref="T:System.Web.UI.ScriptManager" /> controle para renderizar os scripts de instância que dão suporte ao objeto de cliente que representa o controle.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IScriptControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">O controle de script para o qual os descritores de script serão registrados.</param>
        <summary>Chama uma classe <see cref="T:System.Web.UI.ScriptControl" /> para retornar scripts de instância que devem ser renderizados para dar suporte ao objeto de cliente que representa um controle, componente ou comportamento de cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptControl> classe chamadas a <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> método durante sua <xref:System.Web.UI.Control.Render%2A> evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Se você derivar do <see cref="T:System.Web.UI.ScriptControl" /> de classe e substituir o <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método, mas você não chamar o método da classe base, você deve chamar o <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" /> método. Isso permite que o <see cref="T:System.Web.UI.ScriptManager" /> controle para renderizar os scripts de instância que dão suporte ao objeto de cliente que representa o controle.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra um bloco de script de inicialização com o controle <see cref="T:System.Web.UI.ScriptManager" /> e adiciona o bloco de script à página.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">O controle que está registrando o bloco de script de cliente.</param>
        <param name="type">O tipo de bloco de script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para o bloco de script.</param>
        <param name="script">O script a ser registrado.</param>
        <param name="addScriptTags"><see langword="true" /> para circunscrever o bloco de script nas marcas <see langword="&lt;script&gt;" /> e <see langword="&lt;/script&gt;" />; caso contrário, <see langword="false" />.</param>
        <summary>Registra um bloco de script de inicialização para um controle que está dentro de um <see cref="T:System.Web.UI.UpdatePanel" /> usando o controle <see cref="T:System.Web.UI.ScriptManager" /> e adiciona o bloco de script à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa o <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> método para registrar um bloco de script de inicialização para uma página que é compatível com a renderização parcial da página e que não tem nenhuma dependência de biblioteca do Microsoft Ajax. Blocos de script de inicialização que são registrados por meio desse método são enviados para a página somente quando o controle que está registrando o bloco está dentro de um <xref:System.Web.UI.UpdatePanel> controle que está sendo atualizado. Para registrar um bloco de script de inicialização sempre que ocorre um postback assíncrono, use o <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga desse método.  
  
 Se você quiser registrar um script de inicialização que não pertencem a atualizações parciais de página e se você deseja registrar o script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 O bloco de script que é processado pelo <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> método é executado quando a página terminar de ser carregado, mas antes de cliente da página `onload` é gerado. Blocos de script de inicialização estão localizados na parte inferior da página ASP.NET processada imediatamente antes o `</form>` marca.  
  
 Blocos de script de inicialização que são registrados usando <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> não são garantidos para a saída na mesma ordem em que eles são registrados. Se a ordem dos blocos de script de inicialização é importante, use um <xref:System.Text.StringBuilder> para reunir os blocos de script em uma única cadeia de caracteres do objeto e, em seguida, registrá-los como um script de inicialização única.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" /> não está na árvore de controle da página.</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">O objeto da página que está registrando o bloco de script de cliente.</param>
        <param name="type">O tipo de bloco de script de cliente. Geralmente, este parâmetro é especificado com o operador typeof (C#) ou GetType (Visual Basic) para recuperar o tipo do controle que está registrando o script.</param>
        <param name="key">Um identificador exclusivo para o bloco de script.</param>
        <param name="script">O script a ser registrado.</param>
        <param name="addScriptTags"><see langword="true" /> para circunscrever o bloco de script nas marcas <see langword="&lt;script&gt;" /> e <see langword="&lt;/script&gt;" />; caso contrário, <see langword="false" />.</param>
        <summary>Registra um bloco de script de inicialização para cada postback assíncrono com o controle <see cref="T:System.Web.UI.ScriptManager" /> e adiciona o bloco de script à página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para registrar um bloco de script de inicialização que está incluído sempre que um postback assíncrono ocorre. Para registrar um bloco de script para um controle que está dentro de um <xref:System.Web.UI.UpdatePanel> controlar de forma que o bloco de script é registrado somente quando o <xref:System.Web.UI.UpdatePanel> controle é atualizado, use o <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga desse método.  
  
 Se você quiser registrar um script de inicialização que não pertencem a atualizações parciais de página e se você deseja registrar o script apenas uma vez durante a renderização de página inicial, use o <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método da <xref:System.Web.UI.ClientScriptManager> classe. Você pode obter uma referência para o <xref:System.Web.UI.ClientScriptManager> objeto o <xref:System.Web.UI.Page.ClientScript%2A> propriedade da página.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="scriptManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Um objeto que recebe o conteúdo do controle a ser gravado na página.</param>
        <summary>Renderiza o conteúdo do controle <see cref="T:System.Web.UI.ScriptManager" /> para o navegador usando o objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por desenvolvedores de controle para estender o <xref:System.Web.UI.ScriptManager> controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir esse método, chame a base <see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" /> método para que o cliente de script que define o `Sys.WebForms.PageRequestManager` classe é renderizado na página.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveCompositeScriptReference : EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " Usage="member this.ResolveCompositeScriptReference : System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um script de composição está registrado com o controle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveScriptReference : EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " Usage="member this.ResolveScriptReference : System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um membro da coleção <see cref="P:System.Web.UI.ScriptManager.Scripts" /> está registrado com o controle <see cref="T:System.Web.UI.ScriptManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado uma vez para cada membro do <xref:System.Web.UI.ScriptManager.Scripts%2A> coleção durante a página <xref:System.Web.UI.Control.PreRender> eventos. Use esse evento para executar todas as atualizações antes do script é processado para a página.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RoleService : System.Web.UI.RoleServiceManager" Usage="System.Web.UI.ScriptManager.RoleService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.UI.RoleServiceManager" /> associado à instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</summary>
        <value>O objeto <see cref="T:System.Web.UI.RoleServiceManager" /> da instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.RoleServiceManager> objeto que é retornado por esta propriedade representa o serviço de função que está registrado com a página. O serviço de função pode ser definido na <xref:System.Web.UI.ScriptManager> controle ou em um tipo de <xref:System.Web.UI.ScriptManagerProxy> controle. Você pode usar o serviço de função do ASP.NET ou usar um serviço de função personalizada. Você pode adicionar o serviço personalizado na marcação, incluindo uma `RoleService` elemento dentro do `asp:ScriptManager` elemento na página, conforme mostrado no exemplo a seguir:  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 Você pode configurar também programaticamente o <xref:System.Web.UI.RoleServiceManager> objeto. Serviços são registrados com o <xref:System.Web.UI.ScriptManager> controle durante a página <xref:System.Web.UI.Control.PreRender> estágio do ciclo de vida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptMode : System.Web.UI.ScriptMode with get, set" Usage="System.Web.UI.ScriptManager.ScriptMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se as versões de depuração ou lançamento das bibliotecas de script de cliente são renderizadas.</summary>
        <value>O valor de enumeração que indica o modo atual. O padrão é <see cref="F:System.Web.UI.ScriptMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriedade especifica se o <xref:System.Web.UI.ScriptManager> controle deve renderizar debug ou release versões das bibliotecas de script de cliente. Esse valor pode ser substituído por valores que são definidos no arquivo de configuração e a diretiva de página.  
  
 A tabela a seguir lista os valores válidos para essa propriedade.  
  
|Valor|Definição|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|Versões de depuração das bibliotecas são usadas na página da Web de script de cliente quando o `retail` atributo o [implantação](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) elemento de configuração é definido como `false`. Caso contrário, as versões de lançamento das bibliotecas de script de cliente são usadas.|  
|<xref:System.Web.UI.ScriptMode.Inherit>|Quando aplicado à <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriedade do <xref:System.Web.UI.ScriptManager> do objeto, esse valor é o mesmo que <xref:System.Web.UI.ScriptMode.Auto>.|  
|<xref:System.Web.UI.ScriptMode.Debug>|Versões de depuração de script de cliente bibliotecas são usadas na página da Web, a menos que o `retail` atributo o [implantação](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) elemento de configuração é definido como `true`.|  
|<xref:System.Web.UI.ScriptMode.Release>|Versões de lançamento das bibliotecas de script de cliente são usadas na página da Web, a menos que o `retail` atributo o [implantação](https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms228298(v%3dvs.100)) elemento de configuração é definido como `false`.|  
  
> [!NOTE]
>  O `debug` atributo o [@ Page](https://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) diretiva não afeta os aplicativos habilitados para Ajax ASP.NET. O <xref:System.Web.UI.ScriptManager> controle usa apenas as configurações no arquivo Web. config e em seu <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> e <xref:System.Web.UI.ScriptManager.ScriptMode%2A> propriedades para determinar se deve processar scripts de depuração.  
  
 Para obter mais informações, consulte [depuração e rastreamento de visão geral de aplicativos Ajax](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade <see cref="P:System.Web.UI.ScriptManager.ScriptMode" /> não é um dos valores <see cref="T:System.Web.UI.ScriptMode" />.</exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptPath : string with get, set" Usage="System.Web.UI.ScriptManager.ScriptPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o caminho raiz do local usado para criar os caminhos para arquivos de script personalizados e do ASP.NET Ajax.</summary>
        <value>O local em que os arquivos de script são armazenados. O valor padrão é uma cadeia de caracteres vazia (""), que é interpretado como um caminho relativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.ScriptPath%2A> propriedade permite que você especifique absoluta, relativa, ou bloqueia a URL relativa ao aplicativo para todos os scripts na página. Isso inclui blocos de script de terceiros e personalizados que são registrados com o atual <xref:System.Web.UI.ScriptManager> instância. O <xref:System.Web.UI.ScriptManager.ScriptPath%2A> propriedade normalmente é definida de forma declarativa como um atributo de um `ScriptManager` elemento na página, mas ele pode ser definido no código também.  
  
 Se o `path` atributo ou o <xref:System.Web.UI.ScriptReferenceBase.Path%2A> propriedade é definida para um <xref:System.Web.UI.ScriptReference> do objeto no <xref:System.Web.UI.ScriptManager.Scripts%2A> o valor do caminho de coleção, substitui o <xref:System.Web.UI.ScriptManager.ScriptPath%2A> valor para que <xref:System.Web.UI.ScriptReference> instância.  
  
 Se nenhum <xref:System.Web.UI.ScriptReferenceBase.Path%2A> valor for especificado, o <xref:System.Web.UI.ScriptManager> controle pesquisará o diretório que é definido pela <xref:System.Web.UI.ScriptManager.ScriptPath%2A> script de propriedade e resolve referências por seus <xref:System.Web.UI.ScriptReference.Name%2A> ou <xref:System.Web.UI.ScriptReference.Assembly%2A> propriedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScriptResourceMapping : System.Web.UI.ScriptResourceMapping" Usage="System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ScriptResourceMapping" />.</summary>
        <value>Um objeto <see cref="T:System.Web.UI.ScriptResourceMapping" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estático <xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A> propriedade retorna um <xref:System.Web.UI.ScriptResourceMapping> objeto que pode conter uma coleção de mapeamentos que representam o local do recurso de script (redirecionamento de script). Esta coleção de mapeamentos pode ser mapeada com base em nomes ou pares de nome/assembly, e ele pode apontar para um <xref:System.Web.UI.ScriptResourceDefinition> objeto.  
  
   
  
## Examples  
 Os exemplos a seguir mostra como adicionar um <xref:System.Web.UI.ScriptResourceDefinition> objeto que pode ser referenciado por um <xref:System.Web.UI.ScriptManager> objeto. Adicione o seguinte código para o arquivo global. asax no `Application_Start` eventos.  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 Na marcação para uma página de Web Forms do ASP.NET (arquivo. aspx), adicione a seguinte marcação dentro do `form` elemento e antes de todos os elementos ou código que usa o script do jQuery.  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scripts : System.Web.UI.ScriptReferenceCollection" Usage="System.Web.UI.ScriptManager.Scripts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ScriptReferenceCollection" /> que contém os objetos <see cref="T:System.Web.UI.ScriptReference" />, cada um dos quais representa um arquivo de script renderizado para o cliente.</summary>
        <value>O objeto <see cref="T:System.Web.UI.ScriptReferenceCollection" /> da instância de <see cref="T:System.Web.UI.ScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptReferenceCollection> objeto que é retornado por essa propriedade é uma coleção de <xref:System.Web.UI.ScriptReference> objetos, cada um deles representa um arquivo de script. A coleção inclui referências a todos os arquivos de script ASP.NET precisa para a funcionalidade do Ajax e para arquivos de script personalizado. Arquivos de script personalizado para renderizar podem ser definidos na <xref:System.Web.UI.ScriptManager> controle ou em um tipo de <xref:System.Web.UI.ScriptManagerProxy> controle.  
  
 Você pode adicionar arquivos de script à coleção na marcação adicionando `asp:ScriptReference` elementos a uma `Scripts` nó dentro de `asp:ScriptManager` elemento na página, conforme mostrado no exemplo a seguir.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 Você também pode adicionar um <xref:System.Web.UI.ScriptReference> do objeto para o <xref:System.Web.UI.ScriptManager.Scripts%2A> coleção programaticamente, usando o <xref:System.Collections.ObjectModel.Collection%601.Add%2A> método da <xref:System.Web.UI.ScriptReferenceCollection> classe.  
  
 O <xref:System.Web.UI.ScriptManager> controle registra arquivos de script durante o controle <xref:System.Web.UI.Control.PreRender> eventos.  
  
 O <xref:System.Web.UI.ScriptManager.Scripts%2A> a coleção não contém os scripts de biblioteca do Microsoft Ajax core. Os scripts na biblioteca do core são processados automaticamente. eles não precisarão ser registrados com o <xref:System.Web.UI.ScriptManager> controle. No entanto, se você quiser substituir um script core ou qualquer controle e substitua por uma versão diferente do script, você pode adicionar sua versão para o <xref:System.Web.UI.ScriptManager.Scripts%2A> coleção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Services : System.Web.UI.ServiceReferenceCollection" Usage="System.Web.UI.ScriptManager.Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ServiceReferenceCollection" /> que contém um objeto <see cref="T:System.Web.UI.ServiceReference" /> para cada serviço Web que o ASP.NET expõe no cliente para a funcionalidade do Ajax.</summary>
        <value>O objeto <see cref="T:System.Web.UI.ServiceReferenceCollection" /> da instância <see cref="T:System.Web.UI.ScriptManager" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ServiceReferenceCollection> objeto que é retornado por essa propriedade é uma coleção de <xref:System.Web.UI.ServiceReference> objetos, cada um deles representa um serviço Web que está registrado com o <xref:System.Web.UI.ScriptManager> controle. Você pode definir os serviços na <xref:System.Web.UI.ScriptManager> controle ou em um tipo de <xref:System.Web.UI.ScriptManagerProxy> controle.  
  
 Você pode adicionar serviços à coleção na marcação, adicionando um `asp:ServiceReference` elemento para um `Services` elemento dentro a `asp:ScriptManager` da instância na página, conforme mostrado no exemplo a seguir.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 Também programaticamente, você pode adicionar um <xref:System.Web.UI.ServiceReference> do objeto para o <xref:System.Web.UI.ScriptManager.Services%2A> coleção usando o <xref:System.Collections.ObjectModel.Collection%601.Add%2A> método da <xref:System.Web.UI.ServiceReferenceCollection> classe.  
  
 Serviços são registrados com o <xref:System.Web.UI.ScriptManager> durante a página <xref:System.Web.UI.Control.PreRender> estágio do ciclo de vida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define o foco do navegador para o controle especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="scriptManager.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">A ID do controle para receber o foco.</param>
        <summary>Define o foco do navegador como o controle especificado pela ID.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.SetFocus%2A> método funciona como o <xref:System.Web.UI.Page.SetFocus%2A> método para o <xref:System.Web.UI.Page> classe. Ambos os métodos de tornar o controle com a ID especificada do controle ativo na página da Web. O <xref:System.Web.UI.ScriptManager.SetFocus%2A> método da <xref:System.Web.UI.ScriptManager> classe é usada para definir o foco durante um postback assíncrono. Durante postbacks e quando a página é renderizada primeiro, o <xref:System.Web.UI.ScriptManager.SetFocus%2A> chamadas de método a <xref:System.Web.UI.Page.SetFocus%2A> método o <xref:System.Web.UI.Page> classe.  
  
 Se houver várias chamadas para o <xref:System.Web.UI.ScriptManager.SetFocus%2A> método, o controle na última chamada recebe o foco.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="scriptManager.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle a receber o foco.</param>
        <summary>Define o foco do navegador para o controle especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.ScriptManager.SetFocus%2A> método funciona como o <xref:System.Web.UI.Page.SetFocus%2A> método para o <xref:System.Web.UI.Page> classe. Ambos os métodos fazem o controle especificado o controle ativo na página da Web. O <xref:System.Web.UI.ScriptManager.SetFocus%2A> método da <xref:System.Web.UI.ScriptManager> classe é usada para definir o foco durante um postback assíncrono. Durante postbacks e quando a página é renderizada primeiro, o <xref:System.Web.UI.ScriptManager.SetFocus%2A> chamadas de método a <xref:System.Web.UI.Page.SetFocus%2A> método o <xref:System.Web.UI.Page> classe.  
  
 Se houver várias chamadas para o <xref:System.Web.UI.ScriptManager.SetFocus%2A> método, o controle especificado na última chamada recebe o foco.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o cliente dá suporte à renderização parcial da página.</summary>
        <value><see langword="true" /> se o cliente der suporte à renderização parcial da página; caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> estiver definida como `false`, o <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriedade retorna `false`.  
  
 Retorna a seleção padrão para determinar se a renderização parcial da página é suportada `true` quando as seguintes condições forem verdadeiras:  
  
-   O <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A> valor da propriedade deve ser maior que ou igual a 1,0.  
  
-   O <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A> valor da propriedade deve ser maior que ou igual a 1,0.  
  
-   O <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> o valor da propriedade deve ser definido como `true`.  
  
 Quando o <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriedade é definida explicitamente, essas verificações não são usadas.  
  
 Os desenvolvedores de controle devem usar o <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> propriedade para determinar se eles devem dar suporte a renderização parcial da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> é <see langword="false" /> e a propriedade <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> foi definida como <see langword="true" />.  
  
- ou - 
A propriedade <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> foi definida após o evento <see cref="E:System.Web.UI.Control.Init" />.</exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">O identificador de chave do controle.</param>
        <param name="postCollection">Uma coleção de todos os dados de postagem de entrada.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />.</summary>
        <returns><see langword="true" /> se o estado do controle <see cref="T:System.Web.UI.ScriptManager" /> tiver sido alterado como resultado de um postback; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.ScriptManager> é convertida em uma interface de <xref:System.Web.UI.IPostBackDataHandler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.ScriptManager> é convertida em uma interface de <xref:System.Web.UI.IPostBackDataHandler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">Uma cadeia de caracteres de pares chave-valor que representam o estado histórico da página da Web.</param>
        <summary>Permite que o controle <see cref="T:System.Web.UI.ScriptManager" /> processe um evento de postback e carregue o estado histórico da página da Web.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IScriptManager::IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManager.IsSecureConnection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterDispose(System.Web.UI.Control,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManager.SetFocusInternal(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.ScriptManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui a propriedade <see cref="P:System.Web.UI.Control.Visible" /> herdada da classe <see cref="T:System.Web.UI.Control" /> base para evitar a configuração desse valor.</summary>
        <value><see langword="true" /> em todos os casos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.Visible%2A> propriedade é substituída no <xref:System.Web.UI.ScriptManager> classe para evitar a definição desse valor. Um <xref:System.NotImplementedException> erro ocorrerá se um valor é atribuído a essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Um valor é atribuído à propriedade <see cref="P:System.Web.UI.ScriptManager.Visible" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>