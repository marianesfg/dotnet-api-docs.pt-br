<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c97ed15d4e5b783ad55660d3e61ce469293c9857" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55318608" /></Metadata><TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IUrlResolutionService&#xA;    interface IDataBindingsAccessor&#xA;    interface IControlBuilderAccessor&#xA;    interface IControlDesignerAccessor&#xA;    interface IExpressionsAccessor" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define as propriedades, os métodos e os eventos compartilhados por todos os controles de servidor ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta é a classe principal que você deriva ao desenvolver controles personalizados ASP.NET server. <xref:System.Web.UI.Control> não tem nenhum recurso específico de (UI) de interface do usuário. Se você estiver criando um controle que não tem uma interface do usuário, ou combina outros controles que processam sua própria interface do usuário, derive de <xref:System.Web.UI.Control>. Se você estiver criando um controle que tem uma interface do usuário, derivam <xref:System.Web.UI.WebControls.WebControl> ou qualquer controle no <xref:System.Web.UI.WebControls> o ponto de namespace que fornece um começando apropriado para seu controle personalizado.  
  
 O <xref:System.Web.UI.Control> classe é a classe base para todos os controles de servidor ASP.NET, incluindo páginas, controles de usuário e controles personalizados. Páginas ASP.NET são instâncias do <xref:System.Web.UI.Page> classe, que herda o <xref:System.Web.UI.Control> classe e que lidam com solicitações de arquivos que têm uma extensão. aspx.  
  
 O <xref:System.Web.UI.Control> classe pode direta ou indiretamente ser usada como parte da interface do usuário para sua Web, aplicativo e, portanto deve ser examinada para tornar-se de que as práticas recomendadas para escrever código seguro e proteger aplicativos sejam seguidas.  
  
 Para obter informações gerais sobre esses tópicos, consulte [visão geral do Web Application ameaças de segurança](https://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: Práticas recomendadas de política de segurança](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), e [conceitos principais de segurança](~/docs/standard/security/key-security-concepts.md). Para obter informações mais específicas, consulte [controles padrão protegendo](https://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [como: Exibir mensagens de erro seguras](https://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [como: Proteger contra explorações de Script em um aplicativo Web, aplicando a codificação HTML em cadeias de caracteres](https://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), e [Introdução aos controles de validação](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85)).  
  
   
  
## Examples  
 O exemplo a seguir demonstra um controle de servidor personalizado que deriva de <xref:System.Web.UI.Control> classe. O `InnerContent` substituições de classe a <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método, verifica se a classe tem todos os controles na página filho e determina se o primeiro filho do controle é um controle literal. Se estas duas condições forem atendidas, o método substituído grava a cadeia de caracteres HTML \<H2 > sua mensagem:, o conteúdo do controle literal e um fechamento \</H2 > marca para a página de Web Forms.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
    <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Desenvolvendo controles de servidores ASP.NET personalizados</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Adapter : System.Web.UI.Adapters.ControlAdapter" Usage="System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o adaptador específico de navegador para o controle.</summary>
        <value>Um <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> para esse controle. Se o navegador de destino não exigir um adaptador, retornará <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas da Web ASP.NET podem ser usadas em uma ampla variedade de dispositivos e navegadores que podem solicitar informações da Web. O <xref:System.Web.UI.Control.Adapter%2A> propriedade retorna o <xref:System.Web.UI.Adapters.ControlAdapter> objeto que renderiza o controle na tela do navegador ou dispositivo solicitante.  
  
 Para obter mais informações sobre os adaptadores, consulte [Arquitetural Visão geral do controle de comportamento adaptável](https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <related type="Article" href="https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)">Visão geral da arquitetura do comportamento de controle adaptável</related>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberSignature Language="F#" Value="abstract member AddedControl : System.Web.UI.Control * int -&gt; unit&#xA;override this.AddedControl : System.Web.UI.Control * int -&gt; unit" Usage="control.AddedControl (control, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">O <see cref="T:System.Web.UI.Control" /> que foi adicionado.</param>
        <param name="index">O índice do controle na coleção <see cref="P:System.Web.UI.Control.Controls" />.</param>
        <summary>Chamado após um controle filho ser adicionado à coleção <see cref="P:System.Web.UI.Control.Controls" /> do objeto <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.AddedControl%2A> método é chamado imediatamente depois que um controle é adicionado para o <xref:System.Web.UI.Control.Controls%2A> coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member AddParsedSubObject : obj -&gt; unit&#xA;override this.AddParsedSubObject : obj -&gt; unit" Usage="control.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um <see cref="T:System.Object" /> que representa o elemento analisado.</param>
        <summary>Notifica o controle de servidor de que um elemento, XML ou HTML, foi analisado e adiciona o elemento ao objeto <see cref="T:System.Web.UI.ControlCollection" /> do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que você substituí-la, esse método adiciona automaticamente <xref:System.Web.UI.LiteralControl> objetos para o controle de servidor <xref:System.Web.UI.ControlCollection> objeto. Essa coleção é acessível por meio de <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir é um controle de servidor personalizado que usa o <xref:System.Web.UI.Control.AddParsedSubObject%2A> método para determinar se os elementos declarados entre as marcas de abertura e fechamento desse controle são <xref:System.Web.UI.WebControls.TextBox> controles de servidor Web. Se elas forem, eles são adicionados a um <xref:System.Collections.ArrayList> objeto, `items`. Quando substituído <xref:System.Web.UI.Control.CreateChildControls%2A> método é chamado, ele itera por meio de <xref:System.Collections.ArrayList> e adiciona cada objeto em que ele o <xref:System.Web.UI.ControlCollection> do controle de servidor personalizado.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="abstract member ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit&#xA;override this.ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit" Usage="control.ApplyStyleSheetSkin page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">O <see cref="T:System.Web.UI.Page" /> que contém o controle.</param>
        <summary>Aplica as propriedades de estilo definidas na folha de estilos da página ao controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método define propriedades de estilo do controle com base nas propriedades de capa definidas em um diretório do tema. A capa aplicada é a capa padrão para o controle ou a capa especificada no <xref:System.Web.UI.Control.SkinID%2A> propriedade. O <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método é chamado pelo ASP.NET para controles declarativos colocados em uma página. Você deve chamar o <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método em todos os controles criada programaticamente no tempo de execução para estilo aparências de folha a ser aplicado ao controle. Aparências de tema são aplicadas automaticamente. Para obter mais informações sobre a diferença entre os temas e folhas de estilo em cascata, consulte [capas e temas do ASP.NET](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A folha de estilos já está aplicada.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeTemplateSourceDirectory : string with get, set" Usage="System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o diretório virtual relativo de aplicativo do objeto <see cref="T:System.Web.UI.Page" /> ou <see cref="T:System.Web.UI.UserControl" /> que contém este controle.</summary>
        <value>O diretório virtual relativo de aplicativo da página ou do controle de usuário que contém este controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriedade contém o caminho relativo do aplicativo para o página ou controle de usuário que contém o controle atual. Por exemplo, se a página da Web reside na http://www.contoso.com/application/subdirectory, o <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriedade retorna "~ / subdiretório".  
  
 Para retornar o caminho virtual ("/ subdiretório do aplicativo"), use o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.BeginRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.BeginRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto que grava dados de rastreamento.</param>
        <param name="traceObject">O objeto de rastreamento.</param>
        <summary>Inicia o rastreamento de tempo de design de dados de renderização.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o controle que contém a vinculação de dados desse controle.</summary>
        <value>O <see cref="T:System.Web.UI.Control" /> que contém a vinculação de dados desse controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.BindingContainer%2A> propriedade contém uma referência para o <xref:System.Web.UI.Control> objeto que contém as informações de associação de dados para o controle atual.  
  
 O <xref:System.Web.UI.Control.BindingContainer%2A> propriedade é o mesmo que o <xref:System.Web.UI.Control.NamingContainer%2A> propriedade, exceto quando o controle for parte de um modelo. Nesse caso, o <xref:System.Web.UI.Control.BindingContainer%2A> estiver definida como o <xref:System.Web.UI.Control> que define o modelo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberSignature Language="F#" Value="member this.BuildProfileTree : string * bool -&gt; unit" Usage="control.BuildProfileTree (parentId, calcViewState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">O identificador do pai do controle.</param>
        <param name="calcViewState">Um booliano que indica se o tamanho do estado de exibição é calculado.</param>
        <summary>Reúne informações sobre o controle de servidor e as envia para a propriedade <see cref="P:System.Web.UI.Page.Trace" /> para serem exibidas quando o rastreamento está habilitado para a página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade reúne as informações necessárias sobre a hierarquia de interface do usuário de uma página e o passa para a página [ &lt;rastreamento&gt; ](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md) propriedade. Quando você habilita o rastreamento, para uma página ou para seu aplicativo, essas informações são exibidas no `Control Tree` seção da saída de rastreamento. Saída de rastreamento para uma página é acrescentada ao final da página; enquanto a saída de rastreamento para um aplicativo pode ser exibida no Visualizador de rastreamento (Trace. axd arquivo) que é armazenado no diretório raiz do aplicativo. Para obter mais informações sobre rastreamento, consulte [visão geral de rastreamento do ASP.NET](https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChildControlsCreated : bool with get, set" Usage="System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os controles filho do controle de servidor foram criados.</summary>
        <value><see langword="true" /> se os controles filho tiverem sido criados; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra uma substituição do <xref:System.Web.UI.Control.OnDataBinding%2A> método de um personalizado <xref:System.Web.UI.WebControls.Repeater> controle. Para garantir que os controles filho não são criados até que a associação de dados ocorre novamente, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> estiver definida como `true` depois que o <xref:System.Web.UI.WebControls.RepeaterItem> objetos são criados e adicionados ao controle de <xref:System.Web.UI.ControlCollection> objeto.  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 O exemplo a seguir demonstra como usar o controle repeater personalizado em uma página da Web.  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedClientID : unit -&gt; unit" Usage="control.ClearCachedClientID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o valor <see cref="P:System.Web.UI.Control.ClientID" /> armazenado em cache como <see langword="null" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildControlState : unit -&gt; unit" Usage="control.ClearChildControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui as informações de estado de controle para os controles filho do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ClearChildControlState%2A> método é usado quando informações de estado do controle filho escritas para o estado de controle do controle pai foi substituídas conforme novos controles filho são criados, como quando controla a associação de dados filho em um controle de modelo de associação de dados de servidor. Chamar o <xref:System.Web.UI.Control.ClearChildControlState%2A> método aos controles filho vazio antes de chamar o <xref:System.Web.UI.Control.SaveControlState%2A> método reduz o tamanho das informações de estado de controle que devem ser armazenados ou transmitidos.  
  
 Ao recriar controles filho de um <xref:System.Web.UI.Control> do objeto, use o <xref:System.Web.UI.Control.ClearChildControlState%2A> método limpar o estado do controle filho para que ele não é aplicado a novos controles inadvertidamente.  
  
 Para desmarcar as, o estado do controle filho e o estado de exibição, use o <xref:System.Web.UI.Control.ClearChildState%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildState : unit -&gt; unit" Usage="control.ClearChildState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui as informações de estado de exibição e de estado de controle para todos os controles filho do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ClearChildState%2A> método limpa todas as informações de estado de exibição e estado de controle para controles filho. É equivalente a chamar tanto a <xref:System.Web.UI.Control.ClearChildViewState%2A> método e o <xref:System.Web.UI.Control.ClearChildControlState%2A> método.  
  
 Ao recriar controles filho de um <xref:System.Web.UI.Control> do objeto, use o <xref:System.Web.UI.Control.ClearChildState%2A> método Limpar estado filho para que ele não é aplicado a novos controles inadvertidamente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como substituir o <xref:System.Web.UI.Control.OnDataBinding%2A> método para um controle associado a dados modelo. Se a fonte de dados que o controle está associado é preenchida, o controle <xref:System.Web.UI.ControlCollection> coleção é esvaziada usando o <xref:System.Web.UI.ControlCollection.Clear%2A> método e o <xref:System.Web.UI.Control.ClearChildState%2A> método é usado para remover quaisquer informações de estado que tinham sido salvos para os controles filho.  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildViewState : unit -&gt; unit" Usage="control.ClearChildViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui as informações de estado de exibição para todos os controles filho do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método normalmente é usado quando você substituir o <xref:System.Web.UI.Control.DataBind%2A> método durante o desenvolvimento de controles de modelo de associação de dados de servidor. Se você não chamar esse método, informações de estado de exibição do controle filho podem ser gravadas para um controle de servidor pai, somente a ser substituído quando os dados serão associados.  
  
 Ao recriar controles filho de um <xref:System.Web.UI.Control>, use o <xref:System.Web.UI.Control.ClearChildViewState%2A> método limpar o estado de exibição filho para que ele não é aplicado a novos controles inadvertidamente.  
  
 Para obter mais informações sobre como usar esse método, consulte [como: Criar controles de usuário do ASP.NET com modelo](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <related type="Article" href="https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2">Como: Criar controles de usuário com modelo</related>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberSignature Language="F#" Value="member this.ClearEffectiveClientIDMode : unit -&gt; unit" Usage="control.ClearEffectiveClientIDMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define a propriedade <see cref="P:System.Web.UI.Control.ClientIDMode" /> da instância de controle atual e de quaisquer controles filho para <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID de controle de marcação HTML gerada pelo ASP.NET.</summary>
        <value>A ID do controle de marcação HTML gerada pelo ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um controle de servidor Web é renderizado como um elemento HTML, o `id` atributo do elemento HTML é definido como o valor da <xref:System.Web.UI.Control.ClientID%2A> propriedade. O <xref:System.Web.UI.Control.ClientID%2A> valor geralmente é usado para acessar o elemento HTML no script de cliente usando o `document.getElementById` método. A ID também geralmente é usada nas regras CSS para especificar elementos de estilo. Por exemplo, a seguinte regra de estilo CSS seleciona todos os `span` elementos que têm a `id` valor de atributo `ProductIDLabel` e define seus `background-color` atributo `white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 O ASP.NET fornece vários algoritmos para saber como gerar o <xref:System.Web.UI.Control.ClientID%2A> valor da propriedade. Selecione o algoritmo que será usado para um controle definindo sua <xref:System.Web.UI.Control.ClientIDMode%2A> propriedade. Os algoritmos são identificados pelo <xref:System.Web.UI.ClientIDMode> valores de enumeração que estão listados na tabela a seguir.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|O valor <xref:System.Web.UI.Control.ClientID%2A> é gerado concatenando os valores <xref:System.Web.UI.Control.ID%2A> de cada contêiner de nomenclatura pai com o valor <xref:System.Web.UI.Control.ID%2A> do controle. Em cenários com associação de dados em que várias instâncias de um controle são renderizadas, um valor incrementado é inserido na frente do valor <xref:System.Web.UI.Control.ID%2A> do controle. Cada segmento é separado por um caractere de sublinhado (_). Esse algoritmo foi usado em versões do ASP.NET anteriores ao ASP.NET 4.|  
|<xref:System.Web.UI.ClientIDMode.Static>|O valor <xref:System.Web.UI.Control.ClientID%2A> é definido como o valor da propriedade <xref:System.Web.UI.Control.ID%2A>. Se o controle for um contêiner de nomenclatura, ele será usado como a parte superior da hierarquia de contêineres de nomenclatura para todos os controles que contiver.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Esse algoritmo é usado para controles que estão em controles com associação de dados. O valor <xref:System.Web.UI.Control.ClientID%2A> é gerado concatenando o valor <xref:System.Web.UI.Control.ClientID%2A> do contêiner de nomenclatura pai com o valor <xref:System.Web.UI.Control.ID%2A> do controle. Se o controle for um controle associado a dados que gera várias linhas, o valor do campo de dados especificado na propriedade <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> será adicionado ao final. Para o controle <xref:System.Web.UI.WebControls.GridView>, vários campos de dados podem ser especificados. Se o <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriedade estiver vazia, um número sequencial será adicionado no final, em vez de um valor de campo de dados. Cada segmento é separado por um caractere de sublinhado (_).|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|O controle herda a configuração <xref:System.Web.UI.ClientIDMode> de seu controle <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para uma página é <xref:System.Web.UI.ClientIDMode.Predictable>. O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para um controle é <xref:System.Web.UI.ClientIDMode.Inherit>. Como é o padrão para controles <xref:System.Web.UI.ClientIDMode.Inherit>, a geração de padrão é modo <xref:System.Web.UI.ClientIDMode.Predictable>. (No entanto, se você usar o Visual Studio para converter um projeto Web em ASP.NET 4 de uma versão anterior, o Visual Studio automaticamente define o site padrão como <xref:System.Web.UI.ClientIDMode.AutoID> no arquivo Web. config.)  
  
 Para obter mais informações, consulte [ASP.NET Web Server Control Identification](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7) (Identificação de controles do servidor Web do ASP.NET).  
  
   
  
## Examples  
 Os exemplos a seguir mostram um controle de usuário da Web que está dentro de uma página de conteúdo para uma página mestra. O controle de usuário contém um <xref:System.Web.UI.WebControls.DropDownList> controle e um <xref:System.Web.UI.WebControls.Label> controle. O texto que é exibido na <xref:System.Web.UI.WebControls.Label> controle é determinado pelo valor que o usuário seleciona o <xref:System.Web.UI.WebControls.DropDownList> controle. O valor de texto é definido por meio de script de cliente para que a página da Web não precisa postar de volta para o servidor para definir esse valor. Para obter uma referência ao elemento HTML que é renderizado para o <xref:System.Web.UI.WebControls.Label> controle de script de cliente, você deve saber o valor do controle do <xref:System.Web.UI.Control.ClientID%2A> propriedade. No entanto, como o controle de usuário pode ser colocado em qualquer lugar em uma página da Web, é impossível saber com antecedência quais contêineres de nomenclatura conterá os controles. Para certificar-se de que o <xref:System.Web.UI.Control.ClientID%2A> valor será igual a <xref:System.Web.UI.Control.ID%2A> de valor, o código define o <xref:System.Web.UI.Control.ClientIDMode%2A> valor <xref:System.Web.UI.WebControls.ValidatorDisplay.Static>.  
  
 O exemplo a seguir mostra o controle de usuário.  
  
  
  
 O exemplo a seguir mostra a página de conteúdo que contém o controle de usuário.  
  
  
  
 O exemplo a seguir mostra a página mestra que contém a página de conteúdo.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">Identificação do controle do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">Como: Controles de acesso de JavaScript por ID</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">Passo a passo: Tornando controles ligados a dados mais fácil para o acesso do JavaScript</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">Passo a passo: Tornando controles localizados nos controles de usuário da Web mais fácil acessar do JavaScript</related>
        <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Script de cliente em páginas da Web ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDMode : System.Web.UI.ClientIDMode with get, set" Usage="System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o algoritmo usado para gerar o valor da propriedade <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Um valor que indica como a propriedade <see cref="P:System.Web.UI.Control.ClientID" /> é gerada. O padrão é <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET fornece vários algoritmos para saber como gerar o <xref:System.Web.UI.Control.ClientID%2A> valor da propriedade. Selecione o algoritmo que será usado para um controle definindo sua <xref:System.Web.UI.Control.ClientIDMode%2A> propriedade. Os algoritmos são identificados pelo <xref:System.Web.UI.ClientIDMode> valores de enumeração que estão listados na tabela a seguir.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|O valor <xref:System.Web.UI.Control.ClientID%2A> é gerado concatenando os valores <xref:System.Web.UI.Control.ID%2A> de cada contêiner de nomenclatura pai com o valor <xref:System.Web.UI.Control.ID%2A> do controle. Em cenários com associação de dados em que várias instâncias de um controle são renderizadas, um valor incrementado é inserido na frente do valor <xref:System.Web.UI.Control.ID%2A> do controle. Cada segmento é separado por um caractere de sublinhado (_). Esse algoritmo foi usado em versões do ASP.NET anteriores ao ASP.NET 4.|  
|<xref:System.Web.UI.ClientIDMode.Static>|O valor <xref:System.Web.UI.Control.ClientID%2A> é definido como o valor da propriedade <xref:System.Web.UI.Control.ID%2A>. Se o controle for um contêiner de nomenclatura, ele será usado como a parte superior da hierarquia de contêineres de nomenclatura para todos os controles que contiver.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Esse algoritmo é usado para controles que estão em controles com associação de dados. O valor <xref:System.Web.UI.Control.ClientID%2A> é gerado concatenando o valor <xref:System.Web.UI.Control.ClientID%2A> do contêiner de nomenclatura pai com o valor <xref:System.Web.UI.Control.ID%2A> do controle. Se o controle for um controle associado a dados que gera várias linhas, o valor do campo de dados especificado na propriedade <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> será adicionado ao final. Para o controle <xref:System.Web.UI.WebControls.GridView>, vários campos de dados podem ser especificados. Se o <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriedade estiver vazia, um número sequencial será adicionado no final, em vez de um valor de campo de dados. Esse número começa em zero e é incrementado em 1 para cada linha. Cada segmento é separado por um caractere de sublinhado (_).|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|O controle herda a configuração <xref:System.Web.UI.ClientIDMode> de seu controle <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para uma página é <xref:System.Web.UI.ClientIDMode.Predictable>. O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para um controle é <xref:System.Web.UI.ClientIDMode.Inherit>. Como é o padrão para controles <xref:System.Web.UI.ClientIDMode.Inherit>, a geração de padrão é modo <xref:System.Web.UI.ClientIDMode.Predictable>. (No entanto, se você usar o Visual Studio para converter um projeto Web em ASP.NET 4 de uma versão anterior, o Visual Studio automaticamente define o site padrão como <xref:System.Web.UI.ClientIDMode.AutoID> no arquivo Web. config.)  
  
 Para obter mais informações, consulte [ASP.NET Web Server Control Identification](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7) (Identificação de controles do servidor Web do ASP.NET).  
  
   
  
## Examples  
 A exemplo a seguir mostra <xref:System.Web.UI.WebControls.Label> controles que estão contidos em um <xref:System.Web.UI.WebControls.ListView> controle. No <xref:System.Web.UI.WebControls.ListView> controle, o <xref:System.Web.UI.Control.ClientIDMode%2A> estiver definida como <xref:System.Web.UI.ClientIDMode.Predictable> e o <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> estiver definida como `ProductID`. No HTML renderizado, isso cria três `span` elementos que correspondem aos três `ProductIDLabel` controles. Quando a página é executada, o `id` atributos para o `span` elementos serão definidos como os seguintes valores:  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">Identificação do controle do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">Como: Controles de acesso de JavaScript por ID</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">Passo a passo: Tornando controles ligados a dados mais fácil para o acesso do JavaScript</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">Passo a passo: Tornando controles localizados nos controles de usuário da Web mais fácil acessar do JavaScript</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDSeparator : char" Usage="System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor de caractere que representa o caractere separador usado na propriedade <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Sempre retorna o caractere de sublinhado (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ClientID%2A> valor é gerado concatenando o <xref:System.Web.UI.Control.ID%2A> o valor do controle e o <xref:System.Web.UI.Control.UniqueID%2A> valor do controle pai. Cada parte da gerado <xref:System.Web.UI.Control.ID%2A> propriedade é separada pelo <xref:System.Web.UI.Control.ClientIDSeparator%2A> valor da propriedade. O valor sempre retorna um caractere de sublinhado (_).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpContext" /> associado ao controle de servidor para a solicitação da Web atual.</summary>
        <value>O objeto <see cref="T:System.Web.HttpContext" /> especificado associado à solicitação atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade fornece acesso para o <xref:System.Web.HttpContext> objeto para a solicitação da Web atual. O objeto fornece propriedades que acessam o <xref:System.Web.HttpContext.Application%2A>, <xref:System.Web.HttpContext.Session%2A>, <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A> e outros objetos que contêm informações sobre a solicitação HTTP atual. Ele também fornece métodos que permitem que você obtenha informações de configuração e defina ou desmarque erros da solicitação.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ControlCollection" /> que representa os controles filho para um controle de servidor especificado na hierarquia de interface do usuário.</summary>
        <value>A coleção de controles filho para o controle de servidor especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em uma página ASP.NET, quando os controles são adicionados de forma declarativa entre as marcas de abertura e fechamento de um controle de servidor, ASP.NET adiciona automaticamente os controles para o controle de servidor contém <xref:System.Web.UI.ControlCollection>. Marcações HTML ou cadeias de caracteres de texto que não são processadas no servidor são tratadas como <xref:System.Web.UI.LiteralControl> objetos. Eles são adicionados à coleção, como outros controles de servidor.  
  
 O <xref:System.Web.UI.Control.Controls%2A> propriedade permite a você acesso programático à instância da <xref:System.Web.UI.ControlCollection> classe para qualquer controle de servidor. Você pode adicionar controles à coleção, remova os controles de coleção ou percorrer os controles de servidor na coleção.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar controles filho a um controle de servidor <xref:System.Web.UI.ControlCollection> do objeto por meio de seu <xref:System.Web.UI.Control.Controls%2A> propriedade.  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir a <see cref="P:System.Web.UI.Control.Controls" /> propriedade, certifique-se de chamar o <see cref="M:System.Web.UI.Control.EnsureChildControls" /> método. Além disso, se você estiver planejando adicionar controles à coleção de controles de forma programática, considere adicionar os controles em um substituído <see cref="M:System.Web.UI.Control.CreateChildControls" /> método.</para></block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="control.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamado pela estrutura de página do ASP.NET para notificar os controles do servidor que usam a implementação baseada em composição para criar os controles filho para preparar-se para um postback ou renderização.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao desenvolver um controle de composição ou modelo de servidor, você deve substituir esse método. Controles que substituem o <xref:System.Web.UI.Control.CreateChildControls%2A> método deve implementar o <xref:System.Web.UI.INamingContainer> interface para evitar conflitos de nomenclatura.  
  
 Para obter mais informações, consulte [modelos de controles de servidor Web](https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae) e [desenvolvendo controles de servidor de ASP.NET personalizados](https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef).  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma versão de substituição a <xref:System.Web.UI.Control.CreateChildControls%2A> método. Nessa implementação, o controle composto exibe um <xref:System.Web.UI.WebControls.TextBox> colocado entre dois controles de literais que renderizam o HTML do controle.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Desenvolvendo controles de servidores ASP.NET personalizados</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae">Modelos de controles de servidor Web do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection&#xA;override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="control.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo objeto <see cref="T:System.Web.UI.ControlCollection" /> para manter os controles filho (literal e servidor) do controle do servidor.</summary>
        <returns>Um objeto <see cref="T:System.Web.UI.ControlCollection" /> para conter controles de servidor filho do controle de servidor atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método em um controle de servidor personalizado, se você tiver criado um objeto de coleção que é derivado de <xref:System.Web.UI.ControlCollection> classe. Em seguida, você pode instanciar essa classe de coleção na substituição desse método.  
  
   
  
## Examples  
 Substituições de exemplo de código a seguir a <xref:System.Web.UI.Control.CreateControlCollection%2A> método para criar uma instância de um `CustomControlCollection` classe, que herda o <xref:System.Web.UI.ControlCollection> classe.  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Control.CreateControlCollection%2A> substituição de método em um controle de servidor personalizado do <xref:System.Web.UI.Control.CreateChildControls%2A> método. A nova coleção é criada e populada com dois controles filho, `firstControl` e `secondControl`.  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Associa uma fonte de dados ao controle de servidor chamado e a todos os seus controles filho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberSignature Language="F#" Value="abstract member DataBind : unit -&gt; unit&#xA;override this.DataBind : unit -&gt; unit" Usage="control.DataBind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Associa uma fonte de dados ao controle de servidor chamado e a todos os seus controles filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para associar dados de uma fonte para um controle de servidor. Normalmente, esse método é usado depois de recuperar um conjunto de dados por meio de uma consulta de banco de dados. A maioria dos controles executar dados de associação automaticamente, o que significa que você normalmente não precisa chamar esse método explicitamente.  
  
 Esse método normalmente é substituído quando você cria um controle de associação de dados de modelo personalizado. Para obter mais informações, confira [Como: Criar controles de usuário do ASP.NET com modelo](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2) e [desenvolvendo controles de servidor Web de associação de dados personalizado](https://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1). Quando chamado em um controle de servidor, esse método resolve todas as expressões de associação de dados no controle de servidor e em qualquer um dos seus controles filho.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.DataBind%2A> método em um controle de servidor ASP.NET personalizado. Ele começa chamando a base <xref:System.Web.UI.Control.OnDataBinding%2A> método e, em seguida, usa o <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> método para excluir todos os controles filho e o <xref:System.Web.UI.Control.ClearChildViewState%2A> método para excluir qualquer estado de exibição configurações salvas para esses controles filho. Por fim, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> estiver definida como `true` e o controle é instruído para acompanhar as alterações ao estado de exibição dos controles recém-criado com o <xref:System.Web.UI.Control.TrackViewState%2A> método. Isso é uma técnica comum quando a associação de dados a um controle para garantir que os novos dados não está em conflito com os dados armazenados na anterior <xref:System.Web.UI.Control.DataBind%2A> chamada de método.  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Desenvolvendo controles de servidores ASP.NET personalizados</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Visão geral do ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberSignature Language="F#" Value="abstract member DataBind : bool -&gt; unit&#xA;override this.DataBind : bool -&gt; unit" Usage="control.DataBind raiseOnDataBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding"><see langword="true" /> se o evento <see cref="E:System.Web.UI.Control.DataBinding" /> for gerado; caso contrário, <see langword="false" />.</param>
        <summary>Associa uma fonte de dados ao controle de servidor invocado e todos os seus controles filho com uma opção para gerar o evento <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método em um cenário quando seu controle personalizado substitui o <xref:System.Web.UI.Control.DataBind%2A> método e implementa o <xref:System.Web.UI.IDataItemContainer> interface. Nesse cenário, o controle personalizado chama o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método com `raiseOnDataBinding` definido como `false` para garantir que a classe base <xref:System.Web.UI.Control.DataBind%2A> método é chamado.  
  
 O <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> método invoca o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método com `raiseOnDataBinding` definido como `true`.  
  
> [!NOTE]
>  Chamar o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método com `raiseOnDataBinding` definido como `false` faz com que qualquer filho controles como os dados associados com o <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Visão geral do ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberSignature Language="F#" Value="abstract member DataBindChildren : unit -&gt; unit&#xA;override this.DataBindChildren : unit -&gt; unit" Usage="control.DataBindChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Associa uma fonte de dados aos controles filho do controle do servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.DataBindChildren%2A> método vincular uma fonte de dados aos controles filho de um controle de servidor.  
  
> [!NOTE]
>  Quando chamado em um controle de servidor, esse método não associar dados ao controle. Para associar um controle de servidor e todos os seus controles filho, chame o <xref:System.Web.UI.Control.DataBind%2A> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">Desenvolvendo controles de servidores ASP.NET personalizados</related>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberSignature Language="F#" Value="member this.DataBinding : EventHandler " Usage="member this.DataBinding : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é associado a uma fonte de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento notifica o controle de servidor para executar qualquer lógica de associação de dados que tenha sido escrita para ele.  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataItemContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao contêiner de nomenclatura se o contêiner de nomenclatura implementa o <see cref="T:System.Web.UI.IDataItemContainer" />.</summary>
        <value>O contêiner de nomenclatura. Em uma hierarquia de contêineres de nomenclatura que implementa <see cref="T:System.Web.UI.IDataItemContainer" />, essa propriedade retorna o contêiner de nomenclatura na parte superior da hierarquia ou <see langword="null" /> se o objeto <see cref="T:System.Web.UI.Control" /> atual não for um contêiner de nomenclatura que implementa <see cref="T:System.Web.UI.IDataItemContainer" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataKeysContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao contêiner de nomenclatura se o contêiner de nomenclatura implementa o <see cref="T:System.Web.UI.IDataKeysControl" />.</summary>
        <value>O contêiner de nomenclatura. Em uma hierarquia de contêineres de nomenclatura que implementa <see cref="T:System.Web.UI.IDataKeysControl" />, a propriedade retorna o contêiner de nomenclatura na parte superior da hierarquia ou <see langword="null" /> se o objeto <see cref="T:System.Web.UI.Control" /> atual não for um contêiner de nomenclatura que implementa <see cref="T:System.Web.UI.IDataKeysControl" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignMode : bool" Usage="System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um controle está sendo usado em uma superfície de design.</summary>
        <value><see langword="true" /> se o controle estiver sendo usado em um designer. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.DesignMode%2A> propriedade retorna `true` para indicar que o controle está sendo usado no contexto de um designer. Os controles personalizados podem usar essa propriedade quando o comportamento de tempo de design é diferente do comportamento de tempo de execução.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/wxh45wzs(v=vs.100)">Visão geral de Designers de controle do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="control.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que um controle de servidor execute a limpeza final antes do lançamento da memória.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame <xref:System.Web.UI.Control.Dispose%2A> quando tiver terminado de usar o <xref:System.Web.UI.Control>. O <xref:System.Web.UI.Control.Dispose%2A> método deixa o <xref:System.Web.UI.Control> em um estado inutilizável. Depois de chamar esse método, você deve liberar todas as referências para o controle para que a memória que ele estava ocupando pode ser recuperada pela coleta de lixo.  
  
   
  
## Examples  
 Substituições de exemplo de código a seguir a <xref:System.Web.UI.Control.Dispose%2A> método para fechar o <xref:System.Web.UI.HtmlTextWriter> objeto associado a um controle e a chamada a <xref:System.Web.UI.Control.Dispose%2A> método em uma <xref:System.Web.UI.WebControls.Button> controle, chamado `myButton`. Se um <xref:System.Exception> é lançada quando esta versão dos <xref:System.Web.UI.Control.Dispose%2A> método é chamado, o controle grava uma mensagem para a atual <xref:System.Web.HttpResponse> objeto.  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IComponent.Disposed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um controle de servidor é liberado da memória, que é o último estágio do ciclo de vida de controle de servidor quando uma página ASP.NET é solicitada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recursos que exigem muito tempo do processador, como conexões de banco de dados, devem ser liberados com esse evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os temas se aplicam a esse controle.</summary>
        <value><see langword="true" /> para usar temas; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.EnableTheming%2A> propriedade indica se os temas estão habilitados para um controle especificado. Quando o <xref:System.Web.UI.Control.EnableTheming%2A> é de propriedade `true`, diretório de tema do aplicativo é pesquisado aparências do controle a ser aplicado. Se nenhuma capa de controle específico existe no diretório do tema, capas não serão aplicadas.  
  
 Quando o <xref:System.Web.UI.Control.EnableTheming%2A> é de propriedade `false`, o diretório de tema não é pesquisado e o conteúdo do <xref:System.Web.UI.Control.SkinID%2A> propriedade não é usada.  
  
 Temas podem ser habilitados na página, no contêiner ou no nível de controle. Um controle pode substituir o <xref:System.Web.UI.Control.EnableTheming%2A> conjunto de valores ao seu controle pai ou ao conteúdo da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O evento <see langword="Page_PreInit" /> já ocorreu.  
  
- ou - 
O controle já foi adicionado à coleção <see langword="Controls" />.</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">Visão geral de temas do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle de servidor persiste seu estado de exibição e o estado de exibição de quaisquer controles filho que ele contém, para o cliente solicitante.</summary>
        <value><see langword="true" /> se o controle de servidor mantiver seu estado de exibição; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição permite que um controle de servidor manter seu estado em solicitações HTTP. Estado de exibição para um controle é habilitado se todas as seguintes condições forem atendidas:  
  
-   O <xref:System.Web.UI.Control.EnableViewState%2A> propriedade para a página é definida como `true`.  
  
-   O <xref:System.Web.UI.Control.EnableViewState%2A> propriedade para o controle é definida como `true`.  
  
-   O <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade para o controle é definida como <xref:System.Web.UI.ViewStateMode.Enabled> ou herda o <xref:System.Web.UI.ViewStateMode.Enabled> configuração.  
  
 Para obter mais informações, consulte a propriedade <xref:System.Web.UI.Control.ViewStateMode%2A>.  
  
 Estado de exibição de um controle de servidor é o acúmulo de todos os seus valores de propriedade. Para preservar esses valores em todas as solicitações HTTP, o ASP.NET usa uma instância da <xref:System.Web.UI.StateBag> classe para armazenar os valores de propriedade. Os valores são passados como uma variável para um campo oculto quando solicitações subsequentes são processadas. Para obter mais informações sobre o estado de exibição, consulte [visão geral do estado de exibição ASP.NET](https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818).  
  
 Há ocasiões em que é apropriado desabilitar o estado de exibição, particularmente para melhorar o desempenho do aplicativo. Por exemplo, se você estiver carregando uma solicitação de banco de dados em um controle de servidor, defina essa propriedade `false`. Se você não fizer isso, o tempo de processador será desperdiçado ao carregar o estado de exibição no controle de servidor que só será substituído pela consulta de banco de dados. Se <xref:System.Web.UI.Control.EnableViewState%2A> é `false`, você pode usar o estado do controle para manter as informações de propriedade que são específico a um controle e não podem ser desativadas como a propriedade de estado de exibição. Para obter mais informações sobre a diferença entre o estado do controle e estado de exibição, consulte [vs do estado do controle. Exemplo de estado de exibição](https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681).  
  
 Para obter informações sobre como habilitar ou desabilitar o estado de exibição de forma declarativa para uma página ASP.NET, consulte [ \@ página](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100)).
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade para `false`.  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Visão geral do gerenciamento de estado do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681">Estado de controle vs. Exemplo de estado de exibição</related>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.EndRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.EndRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto que grava dados de rastreamento.</param>
        <param name="traceObject">O objeto de rastreamento.</param>
        <summary>Encerra o rastreamento de tempo de design de dados de renderização.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberSignature Language="F#" Value="abstract member EnsureChildControls : unit -&gt; unit&#xA;override this.EnsureChildControls : unit -&gt; unit" Usage="control.EnsureChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determinará se o controle de servidor contiver controles filho. Se ele não contiver, ele criará controles filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método primeiro verifica o valor atual do <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriedade. Se esse valor for `false`, o <xref:System.Web.UI.Control.CreateChildControls%2A> método é chamado.  
  
 O <xref:System.Web.UI.Control.EnsureChildControls%2A> método normalmente é usado em controles de composição, que são controles que usam os controles filho para algumas ou todas as suas funcionalidades. O <xref:System.Web.UI.Control.EnsureChildControls%2A> método é chamado para certificar-se de que os controles filho foram criados e estão prontos para processar a entrada, para realizar a associação de dados ou executar outras tarefas.  
  
 O <xref:System.Web.UI.WebControls.GridView> controle é um exemplo de um controle de composição. Ele cria controles filho, como <xref:System.Web.UI.WebControls.Table>, <xref:System.Web.UI.WebControls.TableRow>, <xref:System.Web.UI.WebControls.TableCell>, <xref:System.Web.UI.WebControls.Label>, e <xref:System.Web.UI.WebControls.TextBox> controles, que são usados para renderizar o HTML de tabela que o <xref:System.Web.UI.WebControls.GridView> gera.  
  
 Na maioria dos casos, os desenvolvedores de controle de servidor personalizado não é necessário substituir esse método. Se você substituir esse método, usá-lo de forma semelhante ao comportamento padrão.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.EnsureChildControls%2A> método para garantir que o controle de servidor atual tem controles filho. Em seguida, obtém ou define um <xref:System.Web.UI.WebControls.TextBox.Text%2A> propriedade para uma criança <xref:System.Web.UI.WebControls.TextBox> controle em que o controle de servidor atual Web <xref:System.Web.UI.ControlCollection> objeto.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberSignature Language="F#" Value="member this.EnsureID : unit -&gt; unit" Usage="control.EnsureID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um identificador para controles que não têm um identificador atribuído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.EnsureID%2A> método gera um identificador para controles que estão contidos em outro controle. Identificadores são gerados somente para controles que não têm um valor atribuído ao <xref:System.Web.UI.Control.ID%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Events : System.ComponentModel.EventHandlerList" Usage="System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de delegados de manipulador de eventos para o controle. Esta propriedade é somente para leitura.</summary>
        <value>A lista de delegados de manipulador de eventos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é do tipo <xref:System.ComponentModel.EventHandlerList>, que usa um algoritmo de pesquisa linear para localizar entradas na lista de delegados. Um algoritmo de pesquisa linear é ineficiente quando estiver trabalhando com um grande número de entradas. Portanto, quando você tiver uma grande lista, localizando entradas com essa propriedade será lentas.  
  
   
  
## Examples  
 O exemplo a seguir cria um evento chamado `Click`, que adiciona e remove manipuladores do controle <xref:System.ComponentModel.EventHandlerList> coleção quando o evento é chamado de uma página.  
  
 **Observação** otimiza a este exemplo como um controle adiciona e remove os eventos da lista que mantém o controle. Se você cria um controle personalizado e quiser definir um evento, use um código semelhante a este. Essa técnica pode ser usada em c#, mas não no Visual Basic.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa o contêiner de nomenclatura atual para o controle de servidor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string -&gt; System.Web.UI.Control&#xA;override this.FindControl : string -&gt; System.Web.UI.Control" Usage="control.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O identificador do controle a ser encontrado.</param>
        <summary>Procura o atual contêiner de nomenclatura de um controle de servidor com o parâmetro <paramref name="id" /> especificado.</summary>
        <returns>O controle especificado, ou <see langword="null" />, se o controle especificado não existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Web.UI.Control.FindControl%2A> para um controle de acesso de uma função em uma página code-behind, para acessar um controle que está dentro de outro contêiner ou em outras circunstâncias em que o controle de destino não é diretamente acessível para o chamador. Este método encontrará um controle somente se o controle será contido diretamente pelo contêiner especificado; ou seja, o método não pesquisa em toda uma hierarquia de controles dentro de controles. Para obter informações sobre como localizar um controle quando você não souber seu contêiner de imediato, consulte [como: Controles de servidor por ID de acesso](https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3).  
  
   
  
## Examples  
 O exemplo a seguir define uma `Button1_Click` manipulador de eventos. Quando invocada, esse manipulador usa o <xref:System.Web.UI.Control.FindControl%2A> método para localizar um controle com um <xref:System.Web.UI.Control.ID%2A> propriedade de `TextBox2` no conteúdo da página. Se o controle for encontrado, seu pai é determinado usando o <xref:System.Web.UI.Control.Parent%2A> propriedade e do controle pai <xref:System.Web.UI.Control.ID%2A> é gravado para a página. Se `TextBox2` não for encontrado, "Controle não encontrado" é gravado para a página.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita entrada do usuário, que é uma potencial ameaça de segurança. Por padrão, as páginas da Web do ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [Visão geral de explorações de script](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3">Como: Controles de servidor de acesso por ID</related>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string * int -&gt; System.Web.UI.Control&#xA;override this.FindControl : string * int -&gt; System.Web.UI.Control" Usage="control.FindControl (id, pathOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">O identificador do controle a ser encontrado.</param>
        <param name="pathOffset">O número de controles da hierarquia de controle de página necessário para alcançar um contêiner de nomenclatura.</param>
        <summary>Procura o contêiner de nomenclatura atual para um controle de servidor com o <paramref name="id" /> especificado e um inteiro especificado no parâmetro <paramref name="pathOffset" />, que auxilia na pesquisa. Você não deve substituir esta versão do método <see cref="Overload:System.Web.UI.Control.FindControl" />.</summary>
        <returns>O controle especificado, ou <see langword="null" />, se o controle especificado não existir.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; unit&#xA;override this.Focus : unit -&gt; unit" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o foco de entrada para um controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.Focus%2A> método para definir o foco inicial da página da Web para o controle. A página será aberta no navegador com o controle selecionado.  
  
 O <xref:System.Web.UI.Control.Focus%2A> método faz com que uma chamada para o script de foco de página a ser emitido na página renderizada. Se a página não contém um controle com uma marca HTML `ID` atributo que corresponde ao controle que o <xref:System.Web.UI.Control.Focus%2A> método foi invocado em, em seguida, o foco de página não será definido. Um exemplo em que isso pode ocorrer é quando você definir o foco em um controle de usuário em vez de definir o foco em um controle filho do controle de usuário. Nesse cenário, você pode usar o <xref:System.Web.UI.Control.FindControl%2A> método para localizar o controle filho do controle de usuário e invocar seus <xref:System.Web.UI.Control.Focus%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberSignature Language="F#" Value="abstract member GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os dados de tempo de design para um controle.</summary>
        <returns>Um <see cref="T:System.Collections.IDictionary" /> que contém os dados de tempo de design para o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.GetDesignModeState%2A> método retorna dados de tempo de design para um controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>O <see cref="M:System.Web.UI.Control.GetDesignModeState" /> método retorna <see langword="null" /> por padrão. Você deve substituir esse método para fornecer os dados de tempo de design que requer que seu controle.</para></block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota e opcionalmente a um nome de rota.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. Ele é equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : obj -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. Ele é equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método. Este método converte o objeto que é passado `routeParameters` para um <xref:System.Web.Routing.RouteValueDictionary> objeto usando o <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> construtor.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar o <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType> método para obter a URL de uma rota que tem parâmetros que são nomeados `productid` e `category`. Este exemplo pressupõe que você tenha criado uma <xref:System.Web.UI.WebControls.HyperLink> controle denominado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. Ele é equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar esse método para obter a URL de uma rota que tem parâmetros que são nomeados `productid` e `category`. Este exemplo pressupõe que você tenha criado uma <xref:System.Web.UI.WebControls.HyperLink> controle denominado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * obj -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">O nome da rota.</param>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota e um nome de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota e ao nome de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. Ele é equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método. Este método converte o objeto que é passado `routeParameters` para um <xref:System.Web.Routing.RouteValueDictionary> objeto usando o <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> construtor.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar esse método para obter a URL de uma rota denominada `Product` e tem parâmetros que são nomeados `productid` e `category`. Este exemplo pressupõe que você tenha criado uma <xref:System.Web.UI.WebControls.HyperLink> controle denominado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">O nome da rota.</param>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota e um nome de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota e ao nome de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. Ele é equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar esse método para obter a URL de uma rota denominada `Product` e tem parâmetros que são nomeados `productid` e `category`. Este exemplo pressupõe que você tenha criado uma <xref:System.Web.UI.WebControls.HyperLink> controle denominado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Roteamento do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetUniqueIDRelativeTo : System.Web.UI.Control -&gt; string" Usage="control.GetUniqueIDRelativeTo control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Um controle que está em um contêiner de nomenclatura.</param>
        <summary>Retorna a parte prefixada da propriedade <see cref="P:System.Web.UI.Control.UniqueID" /> do controle especificado.</summary>
        <returns>A parte prefixada da propriedade <see cref="P:System.Web.UI.Control.UniqueID" /> do controle especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.UniqueID%2A> propriedade de um controle é gerada, adicionando um prefixo para o controle <xref:System.Web.UI.Control.ID%2A> propriedade. O prefixo é composto de <xref:System.Web.UI.Control.UniqueID%2A> contêiner concatenado com um caractere separador de nomes da propriedade do controle. Se o contêiner de nomenclatura é a página, não há nenhum prefixo. Esse método retorna a cadeia de caracteres de prefixo. Se não houver nenhuma cadeia de caracteres de prefixo, ele retorna o <xref:System.Web.UI.Control.UniqueID%2A> valor do controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.Control.NamingContainer" /> de <paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildViewState : bool" Usage="System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os controles filho do controle de servidor atual têm alguma configuração de estado de exibição salva.</summary>
        <value><see langword="true" /> Se todos os controles filho tem salvo as informações de estado de exibição; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode evitar chamadas desnecessárias para o <xref:System.Web.UI.Control.ClearChildViewState%2A> método usando essa propriedade para verificar que todos os controles filho do controle do servidor estão armazenando informações de estado de exibição.  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberSignature Language="F#" Value="abstract member HasControls : unit -&gt; bool&#xA;override this.HasControls : unit -&gt; bool" Usage="control.HasControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se o controle de servidor contém algum controle filho.</summary>
        <returns><see langword="true" /> se o controle contiver outros controles; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma vez que esse método simplesmente determina se todos os controles filho existirem, ele pode melhorar o desempenho, permitindo que você evite um desnecessárias <xref:System.Web.UI.ControlCollection.Count%2A> chamada de propriedade. Chamadas para essa propriedade requerem um <xref:System.Web.UI.ControlCollection> objeto a ser instanciado. Se não houver nenhum filho, a criação de objeto desperdiça recursos de servidor.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.HasControls%2A> método para determinar se todos os controles existem antes de usar o <xref:System.Web.UI.ControlCollection.Count%2A> propriedade para iterar por meio de um <xref:System.Web.UI.ControlCollection> objeto.  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>O <see cref="M:System.Web.UI.Control.HasControls" /> método deve ser substituído somente para alterar atributos de metadados, como <see cref="T:System.ComponentModel.EditorBrowsableAttribute" />. Para obter mais informações sobre como usar atributos, consulte [atributos](~/docs/standard/attributes/index.md).</para></block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberSignature Language="F#" Value="member this.HasEvents : unit -&gt; bool" Usage="control.HasEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se os eventos são registrados para o controle ou qualquer controle filho.</summary>
        <returns><see langword="true" /> se os eventos forem registrados; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador programático atribuído ao controle de servidor.</summary>
        <value>O identificador programático atribuído ao controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir essa propriedade em um controle de servidor fornece acesso programático aos métodos, eventos e propriedades do controle de servidor. Essa propriedade pode ser definida por desenvolvedores da Web, declarando um <xref:System.Web.UI.Control.ID%2A> atributo na marca de abertura de um controle de servidor ASP.NET.  
  
 Se essa propriedade não for especificada para um controle de servidor, de forma declarativa ou por meio de programação, você pode obter uma referência para o controle por meio do controle pai <xref:System.Web.UI.Control.Controls%2A> propriedade.  
  
> [!NOTE]
>  Apenas as combinações de caracteres alfanuméricos e o caractere de sublinhado (_) são valores válidos para essa propriedade. Incluindo espaços ou outros caracteres inválidos causará um erro de analisador de página ASP.NET.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caractere usado para separar identificadores de controle.</summary>
        <value>O caractere separador. O padrão é “$”.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caractere contido no <xref:System.Web.UI.Control.IdSeparator%2A> propriedade é usada para separar os identificadores de controle para controles filho. O caractere separador de ID é acrescentado ao <xref:System.Web.UI.Control.ID%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberSignature Language="F#" Value="member this.Init : EventHandler " Usage="member this.Init : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é inicializado, que é a primeira etapa do ciclo de vida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor devem executar as etapas de inicialização que são necessárias para criar e configurar uma instância. Não é possível usar as informações de estado de exibição dentro desse evento; ele não é preenchido ainda. Você não deve acessar outro controle de servidor durante esse evento, independentemente de ser um filho ou pai para esse controle. Outros controles de servidor não tiver certeza, ser criado e estará pronto para acesso. Para obter mais informações sobre eventos de controle de servidor, consulte [modelo de evento de controle ASP.NET Web Forms Server](https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
   
  
## Examples  
 O exemplo a seguir atribui um manipulador de eventos personalizados `Calendar_Init`, para o `Init` eventos de um <xref:System.Web.UI.WebControls.Calendar> controle.  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsChildControlStateCleared : bool" Usage="System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os controles contidos dentro deste controle têm estado de controle.</summary>
        <value><see langword="true" /> Se os filhos deste controle não usar o estado do controle; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberSignature Language="F#" Value="member this.IsLiteralContent : unit -&gt; bool" Usage="control.IsLiteralContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se o controle de servidor contém apenas o conteúdo literal.</summary>
        <returns><see langword="true" /> se o controle de servidor contiver somente conteúdo literal, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando este método retorna `true`, coleção de controle de servidor contém um único controle literal.  
  
   
  
## Examples  
 O exemplo a seguir verifica se a página que contém os controles de servidor foi postado novamente. Em caso positivo, ele chama o <xref:System.Web.UI.Control.IsLiteralContent%2A> método para determinar se o controle contiver conteúdo literal apenas, ou é um controle pai para outros controles de servidor. Se ele contiver somente conteúdo literal, o <xref:System.Web.UI.Control.UniqueID%2A> propriedade do <xref:System.Web.UI.LiteralControl> que representa que o conteúdo é gravado na resposta.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTrackingViewState : bool" Usage="System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o controle de servidor está salvando alterações no estado de exibição.</summary>
        <value><see langword="true" /> se o controle estiver marcado para salvar seu estado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para um controle de servidor personalizado de exemplo que usa essa propriedade, consulte [exemplo com modelo de controle de servidor](https://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.DataBind%2A> método em um controle de servidor ASP.NET personalizado. Ele começa chamando a base <xref:System.Web.UI.Control.OnDataBinding%2A> método e, em seguida, usa o `ControlCollection` objeto. <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> método para excluir todos os controles filho e o <xref:System.Web.UI.Control.ClearChildViewState%2A> método para excluir qualquer estado de exibição configurações salvas para esses controles filho. Por fim, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> estiver definida como `true`. O controle, em seguida, usa o <xref:System.Web.UI.Control.IsTrackingViewState%2A> propriedade para determinar se o estado de exibição de controle de alterações está habilitada para o controle. Se não estiver habilitado, o <xref:System.Web.UI.Control.TrackViewState%2A> método é chamado.  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsViewStateEnabled : bool" Usage="System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o estado de exibição está habilitado para esse controle.</summary>
        <value><see langword="true" /> se o estado de exibição estiver habilitado para o controle; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição pode ser habilitado no nível de controle, contêiner ou página. Quando o estado de exibição está desabilitado no nível de página ou um contêiner, o estado de exibição está desabilitado para todos os controles contidos por página ou do contêiner. O <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriedade indica se o estado de exibição está habilitado por páginas, contêineres ou controles.  
  
 É possível que o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade e o <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriedade seja diferente. Por exemplo, se o <xref:System.Web.UI.Page> que contém o controle tem o estado de exibição desabilitado, o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade pode ser `true` enquanto o <xref:System.Web.UI.Control.IsViewStateEnabled%2A> é de propriedade `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Os desenvolvedores de páginas serão definido o <see cref="P:System.Web.UI.Control.EnableViewState" /> propriedade e o <see cref="P:System.Web.UI.Control.ViewStateMode" /> propriedade para indicar se eles estão usando o estado de exibição com seu controle. Use o <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> propriedade e o <see cref="P:System.Web.UI.Control.ViewStateMode" /> propriedade em seu código para determinar se o estado de exibição está habilitado para o seu controle e para todos os contêineres.</para></block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é carregado no objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notifica o controle de servidor para executar as etapas de processamento que são definidas para ocorrer em cada solicitação de página. Você pode acessar informações de estado de exibição e dados de POSTAGEM de formulário de Web desse evento. Você também pode acessar outros controles de servidor na hierarquia de controle da página.  
  
> [!NOTE]
>  Se você definir um modelo personalizado em um controle durante o `Page_Load` eventos, os valores de texto de controles filho no modelo personalizado serão perdidos. Isso ocorre porque os valores de formulário já foram carregados.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadControlState : obj -&gt; unit&#xA;override this.LoadControlState : obj -&gt; unit" Usage="control.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Um <see cref="T:System.Object" /> que representa o estado de controle a ser restaurado.</param>
        <summary>Restaura informações de estado de controle de uma solicitação de página anterior que foi salva pelo método <see cref="M:System.Web.UI.Control.SaveControlState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método quando você precisa especificar como um controle de servidor personalizado restaura o estado de controle. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).  
  
   
  
## Examples  
 O seguinte código de exemplo substitui o <xref:System.Web.UI.Control.LoadControlState%2A> método em um controle ASP.NET personalizado. Quando este método é chamado, ele determina se o estado do controle foi salvo anteriormente para o controle e, nesse caso, define a propriedade interna `currentIndex` para o valor salvo.  
  
 O <xref:System.Web.UI.Control.OnInit%2A> método é substituído para chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método o <xref:System.Web.UI.Control.Page%2A> para indicar que o controle personalizado usa estado de controle.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadViewState : obj -&gt; unit&#xA;override this.LoadViewState : obj -&gt; unit" Usage="control.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Um <see cref="T:System.Object" /> que representa o estado de controle a ser restaurado.</param>
        <summary>Restaura informações de estado de exibição de uma solicitação de página anterior salva pelo método <see cref="M:System.Web.UI.Control.SaveViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado principalmente pela infraestrutura do .NET Framework e não se destina a ser usado diretamente do seu código. No entanto, os desenvolvedores de controle podem substituir este método para especificar como um controle de servidor personalizado restaura o estado de exibição. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.LoadViewState%2A> método para um controle de servidor ASP.NET personalizado. Ele cria um <xref:System.Object> matriz para conter as informações de estado de exibição passadas a `savedState` parâmetro e, em seguida, chama a implementação base do <xref:System.Web.UI.Control.LoadViewState%2A> método para o primeiro local de índice da matriz. Ele atribui os valores armazenados nos próximos dois locais de índice a variáveis nomeadas `UserText` e `PasswordText`, respectivamente.  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadViewStateByID : bool" Usage="System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o controle participa do carregamento do estado de exibição por <see cref="P:System.Web.UI.Control.ID" /> em vez do índice.</summary>
        <value><see langword="true" /> se o controle carregar seu estado de exibição pelo <see cref="P:System.Web.UI.Control.ID" />; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, quando um controle pai carrega o estado de exibição em controles filho que ele cria, ele faz isso pela posição de cada controle filho no controle do pai <xref:System.Web.UI.Control.Controls%2A> coleção. Quando o estado de exibição inicialmente é aplicado, todos os controles filho podem não ter sido criados. Nesse caso, o estado de exibição para controles que ainda não criada é salvo e aplicado quando os controles filho são criados posteriormente.  
  
 Para um controle pai aplicar o estado de exibição para seus controles filho, duas condições devem ser atendidas:  
  
-   No postback, o controle pai deve criar o controles filho na exatamente a mesma ordem que a solicitação anterior para que a ordem dos controles permaneça consistente.  
  
-   Após o postback, todos os controles filho criados devem ser adicionados ao final do controle pai <xref:System.Web.UI.Control.Controls%2A> coleção.  
  
 Se estas duas condições não forem atendidas, como no caso da criação de atrasada de um controle filho, o controle pai pode carregar o estado de exibição usando <xref:System.Web.UI.Control.ID%2A>. Para definir a <xref:System.Web.UI.Control.LoadViewStateByID%2A> propriedade para `true`, use o <xref:System.Web.UI.ViewStateModeByIdAttribute> atributo de metadados para o controle pai.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPathSecure : string -&gt; string" Usage="control.MapPathSecure virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Uma URL relativa ou relativa raiz.</param>
        <summary>Recupera o caminho físico para o qual um caminho virtual é mapeado, relativo ou virtual.</summary>
        <returns>O caminho físico para o arquivo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método só pode ser usado por controles de servidor que tem permissões para ler arquivos e que fazem parte dos arquivos. dll totalmente confiável, como dll. Isso ajuda a impedir violações de segurança.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.MapPathSecure%2A> método para obter o caminho físico de um diretório virtual do que contém <xref:System.Web.UI.Page> ou <xref:System.Web.UI.UserControl> objeto.  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao contêiner de nomenclatura do controle do servidor, que cria um namespace exclusivo para diferenciar entre os controles de servidor com o mesmo valor da propriedade <see cref="P:System.Web.UI.Control.ID" />.</summary>
        <value>O controle de servidor do contêiner de nomenclatura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada página em um aplicativo Web ASP.NET contém uma hierarquia de controles. Essa hierarquia não é dependente se um controle gera a interface do usuário visível para o usuário. O contêiner de nomeação para um determinado controle é o controle pai acima na hierarquia que implementa o <xref:System.Web.UI.INamingContainer> interface. Um controle de servidor que implementa essa interface cria um namespace exclusivo para o <xref:System.Web.UI.Control.ID%2A> valores de propriedade de seus controles de servidor filho. Você pode usar o <xref:System.Web.UI.Control.NamingContainer%2A> propriedade do controle filho de um contêiner de nomenclatura para obter uma referência ao seu contêiner pai.  
  
 Criar um namespace exclusivo para controles de servidor é particularmente importante quando você associa os controles de servidor Web a dados, como o <xref:System.Web.UI.WebControls.Repeater> e <xref:System.Web.UI.WebControls.DataList> controles de servidor. Quando várias entradas na fonte de dados criam várias instâncias de um controle de servidor que é um filho do controle de repetição, o contêiner de nomenclatura garante que cada instância desses controles filho tenham <xref:System.Web.UI.Control.UniqueID%2A> valores de propriedade que não entrem em conflito. O contêiner de nomenclatura padrão para uma página é a instância da <xref:System.Web.UI.Page> classe que é gerada quando essa página é solicitada.  
  
 O <xref:System.Web.UI.Control.ClientID%2A> propriedade contém o valor que é processado como o elemento `id` atributo na marcação HTML. Dependendo do valor que você atribui à <xref:System.Web.UI.Control.ClientIDMode%2A> propriedade, o valor que é gerado para o <xref:System.Web.UI.Control.ClientID%2A> propriedade pode incluir a ID do <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Quando você define <xref:System.Web.UI.Control.ClientIDMode%2A> à <xref:System.Web.UI.ClientIDMode.Static>, o <xref:System.Web.UI.Control.ClientID%2A> valor não inclui a ID do <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Quando você define <xref:System.Web.UI.Control.ClientIDMode%2A> para um <xref:System.Web.UI.ClientIDMode.AutoID> ou <xref:System.Web.UI.ClientIDMode.Predictable>, o <xref:System.Web.UI.Control.ClientID%2A> valor incluirá a ID do <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Para obter mais informações, consulte [ASP.NET Web Server Control Identification](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7) (Identificação de controles do servidor Web do ASP.NET).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Web.UI.Control.NamingContainer%2A> propriedade.  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBubbleEvent : obj * EventArgs -&gt; bool&#xA;override this.OnBubbleEvent : obj * EventArgs -&gt; bool" Usage="control.OnBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">A fonte do evento.</param>
        <param name="args">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Determina se o evento do controle de servidor é passado um nível acima da hierarquia de controle de servidor da interface do usuário da página.</summary>
        <returns><see langword="true" /> se o evento tiver sido cancelado; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor ASP.NET, como o <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> e <xref:System.Web.UI.WebControls.GridView> Web podem conter controles filho que geram eventos. Por exemplo, cada linha em um <xref:System.Web.UI.WebControls.GridView> controle pode conter um ou mais botões criados dinamicamente por modelos. Em vez de cada botão disparar um evento individualmente, eventos dos controles aninhados são "transferidos" – ou seja, elas são enviadas para o contêiner de nomenclatura. O contêiner de nomenclatura por sua vez dispara um evento genérico chamado <xref:System.Web.UI.WebControls.GridView.RowCommand> com valores de parâmetro. Esses valores permitem que você determine qual controle individual que gerou o evento original. Respondendo a este evento único, você pode evitar ter que escrever métodos de manipulação de eventos individuais para controles filho.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.OnBubbleEvent%2A> método em um controle de servidor ASP.NET personalizado, `ParentControl`. Esse método é invocado quando um controle filho `ParentControl` chama o <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método. Quando isso acontece, o `ParentControl` classe grava duas cadeias de caracteres para a página ASP.NET recipiente, a primeira informando que sua <xref:System.Web.UI.Control.OnBubbleEvent%2A> método foi chamado, a segunda que identifica o controle de fonte do <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataBinding : EventArgs -&gt; unit&#xA;override this.OnDataBinding : EventArgs -&gt; unit" Usage="control.OnDataBinding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método notifica um controle de servidor para executar qualquer lógica de associação de dados que está associados ele.  
  
 Se você quiser manipular o <xref:System.Web.UI.Control.DataBinding> evento, você deve substituir esse método de manipulação de eventos. Isso garante que todos os delegados anexado para o <xref:System.Web.UI.Control.DataBinding> eventos são invocados.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como substituir o <xref:System.Web.UI.Control.OnDataBinding%2A> método para adicionar controles filho para o controle pai de uma fonte de dados.  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Visão geral do ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="control.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Init" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.Init> eventos. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnInit%2A> método para notificar assinantes no evento.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="control.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Load" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.Load> eventos. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnLoad%2A> método para notificar assinantes no evento.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="control.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.PreRender" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.PreRender> eventos. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnPreRender%2A> método para notificar assinantes no evento.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="control.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Unload" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.Unload> eventos. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnUnload%2A> método para notificar assinantes no evento.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string -&gt; System.IO.Stream" Usage="control.OpenFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo desejado.</param>
        <summary>Obtém um <see cref="T:System.IO.Stream" /> usado para ler um arquivo.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> que faz referência ao arquivo desejado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.OpenFile%2A> método retorna um <xref:System.IO.Stream> que pode ser usado para ler o conteúdo do arquivo especificado no objeto o `path` parâmetro. O parâmetro de caminho pode ser qualquer um parente ou URL raiz sem um protocolo (como "~ / mySite/myFile.txt), ou um caminho físico, um local ("c:\mySite\myFile.txt") ou UNC ("\\\myServer\myFile.txt ").  
  
 O <xref:System.Web.UI.Control.OpenFile%2A> método usa segurança de acesso de arquivo para controlar o acesso ao arquivo especificado. Se o usuário atual do ASP.NET não tem acesso ao arquivo, em seguida, o arquivo não está aberto e um <xref:System.Web.HttpException> exceção é gerada para indicar que o acesso foi negado. Se o `path` parâmetro especificado um caminho relativo, a exceção não inclui informações sobre o caminho físico para o arquivo solicitado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Acesso negado ao arquivo especificado.</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page with get, set" Usage="System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência para a instância <see cref="T:System.Web.UI.Page" /> que contém o controle de servidor.</summary>
        <value>A instância <see cref="T:System.Web.UI.Page" /> que contém o controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Valor da propriedade reflete o nome do arquivo. aspx que contém o controle de servidor.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método. Ele usa o <xref:System.Web.UI.Page> propriedade para acessar o <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType> propriedade e determinar se a página que contém este controle apenas foi carregada pela primeira vez ou é o resultado de um postback.  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Web.UI.Control" Usage="System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao controle pai do controle de servidor na hierarquia de controle da página.</summary>
        <value>Uma referência ao controle pai do controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sempre que uma página é solicitada, uma hierarquia de controles de servidor nessa página é criada. Essa propriedade permite que você determine o controle pai do controle de servidor atual nessa hierarquia e ao programa em relação a ela.  
  
   
  
## Examples  
 O exemplo a seguir define uma nova <xref:System.Web.UI.Control> objeto em uma página `myControl1`, para o controle especificado em um <xref:System.Web.UI.Control.FindControl%2A> chamada de método. Se a chamada retorna um controle, o código usa o <xref:System.Web.UI.Control.Parent%2A> propriedade para identificar o controle que contém `myControl1`. Se o controle pai se existir, a cadeia de caracteres "o pai da caixa de texto é" é concatenado com o <xref:System.Web.UI.Control.ID%2A> propriedade do controle pai e gravado o <xref:System.Web.UI.Control.Page%2A>. Se nenhum controle pai for encontrado, a cadeia de caracteres "controle não encontrado" é gravado.  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberSignature Language="F#" Value="member this.PreRender : EventHandler " Usage="member this.PreRender : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que o objeto <see cref="T:System.Web.UI.Control" /> é carregado, mas antes da renderização.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse evento para executar todas as atualizações antes do controle de servidor é renderizado para a página. As alterações no estado de exibição do controle de servidor podem ser salvos durante esse evento. Tais alterações feitas na fase de renderização não serão salvas.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.RaiseBubbleEvent : obj * EventArgs -&gt; unit" Usage="control.RaiseBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">A fonte do evento.</param>
        <param name="args">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Atribui quaisquer fontes de evento e suas informações para o pai do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor ASP.NET, como o <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> e <xref:System.Web.UI.WebControls.GridView> Web podem conter controles filho que geram eventos. Por exemplo, cada linha em um <xref:System.Web.UI.WebControls.GridView> controle pode conter um ou mais botões criados dinamicamente por modelos. Em vez de cada botão disparar um evento individualmente, eventos dos controles aninhados são "transferidos" – ou seja, elas são enviadas para o pai do controle. O pai por sua vez dispara um evento genérico chamado <xref:System.Web.UI.WebControls.GridView.RowCommand> com valores de parâmetro. Esses valores permitem que você determine qual controle individual que gerou o evento original. Respondendo a este evento único, você pode evitar ter que escrever métodos de manipulação de eventos individuais para controles filho.  
  
 Enquanto você não pode substituir esse método, controles você cria podem manipular ou gerar eventos de bolhas, substituindo o <xref:System.Web.UI.Control.OnBubbleEvent%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstram como criar uma classe personalizada, `ChildControl`, substituindo o <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType> método para chamar o <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método envia o <xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType> eventos ao seu pai do controle de servidor ASP.NET. Quando o usuário clica em um botão em uma página ASP.NET que inclui uma instância do `ChildControl`, ele gera a <xref:System.Web.UI.Control.OnBubbleEvent%2A> método no controle pai que contém a instância de `ChildControl` e grava a cadeia de caracteres "ChildControl classe OnClick método é chamado"para a página.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RemovedControl : System.Web.UI.Control -&gt; unit&#xA;override this.RemovedControl : System.Web.UI.Control -&gt; unit" Usage="control.RemovedControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O <see cref="T:System.Web.UI.Control" /> que foi removido.</param>
        <summary>Chamado após um controle filho ser removido da coleção <see cref="P:System.Web.UI.Control.Controls" /> do objeto <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.RemovedControl%2A> método é chamado imediatamente após a remoção de um controle a <xref:System.Web.UI.Control.Controls%2A> coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle do servidor.</param>
        <summary>Envia o conteúdo do controle de servidor para um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido, que grava o conteúdo a ser renderizado no cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao desenvolver controles de servidor personalizado, você pode substituir esse método para gerar o conteúdo de uma página ASP.NET.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra substituindo o <xref:System.Web.UI.Control.Render%2A> método. O <xref:System.Web.UI.Control.HasControls%2A> método é usado para determinar se o controle de servidor tem todos os controles filho armazenados em seu <xref:System.Web.UI.ControlCollection> objeto, que é acessível por meio de <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propriedade. Se <xref:System.Web.UI.Control.HasControls%2A> retorna true e o primeiro controle de servidor na coleção é texto literal, em seguida, o texto literal é acrescentado a uma cadeia de caracteres HTML.  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo renderizado.</param>
        <summary>Gera o conteúdo de filhos de um controle de servidor a um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido, que grava o conteúdo a ser renderizado no cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método notifica o ASP.NET para processar qualquer código de Active Server Pages (ASP) na página. Se nenhum código ASP existir na página, este método renderiza qualquer filho controles para o controle de servidor. Esse método é chamado pelo <xref:System.Web.UI.Control.Render%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.RenderChildren%2A> método em um controle de servidor personalizado. Ele determina se o controle atual tem todos os controles filho em sua <xref:System.Web.UI.ControlCollection> objeto. Em caso afirmativo, ele usa o <xref:System.Web.UI.ControlCollection.Count%2A> propriedade para iterar pela coleção. Quando ele encontra cada controle filho, ele usa o <xref:System.Web.UI.Control.RenderControl%2A> método para renderizar o pai controle e todos os seus controles filho, para o conteúdo da página.  
  
 Substituído <xref:System.Web.UI.Control.Render%2A> , em seguida, chamadas de método substituído <xref:System.Web.UI.Control.RenderChildren%2A> método.  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gera o conteúdo do controle de servidor e armazena informações de rastreamento sobre o controle caso o rastreamento esteja habilitado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle.</param>
        <summary>Gera o conteúdo do controle de servidor para um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido e armazena informações de rastreamento sobre o controle caso o rastreamento esteja habilitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um controle de servidor <xref:System.Web.UI.Control.Visible%2A> estiver definida como `true`, este método determina se o rastreamento está habilitado para a página. Nesse caso, ele armazena informações de rastreamento associadas ao controle e renderiza o conteúdo do controle de servidor para a página.  
  
 Esse método é chamado automaticamente pela página durante o processamento, mas pode ser substituído por desenvolvedores de controle personalizado.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.RenderChildren%2A> método em um controle de servidor personalizado. Ele determina se o controle atual tem todos os controles filho em sua <xref:System.Web.UI.ControlCollection> objeto. Em caso afirmativo, ele usa o <xref:System.Web.UI.ControlCollection.Count%2A> propriedade para iterar pela coleção. Quando ele encontra cada controle filho, ele usa o <xref:System.Web.UI.Control.RenderControl%2A> método para renderizar o filho, controle e todos os seus controles filho, para o conteúdo da página. O <xref:System.Web.UI.XhtmlTextWriter> objeto que é passado para esse método é instanciado pelo <xref:System.Web.UI.Page.Render%2A> método.  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter * System.Web.UI.Adapters.ControlAdapter -&gt; unit" Usage="control.RenderControl (writer, adapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle.</param>
        <param name="adapter">O <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> que define a renderização.</param>
        <summary>Gera o conteúdo do controle de servidor a um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido usando um objeto <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas da Web ASP.NET podem ser usadas em uma ampla variedade de dispositivos e navegadores que podem solicitar informações da Web. O <xref:System.Web.UI.Control.Adapter%2A> propriedade retorna o <xref:System.Web.UI.Adapters.ControlAdapter> objeto que renderiza o controle na tela do navegador ou dispositivo solicitante.  
  
 Para obter mais informações sobre os adaptadores, consulte [Arquitetural Visão geral do controle de comportamento adaptável](https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)).  
  
 Se um controle de servidor <xref:System.Web.UI.Control.Visible%2A> estiver definida como `true` e rastreamento está habilitado para a página, em seguida, sejam capturadas informações de rastreamento associadas ao controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ao substituir o <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> método em controles personalizados, chame o método de classe base para garantir que informações de rastreamento sejam capturadas corretamente.</para></block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
        <related type="Article" href="https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)">Visão geral da arquitetura do comportamento de controle adaptável</related>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingCompatibility : Version with get, set" Usage="System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica a versão do ASP.NET com a qual o HTML renderizado será compatível.</summary>
        <value>A versão do ASP.NET com a qual um HTML renderizado será compatível.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET define essa propriedade como o valor da `controlRenderingCompatibilityVersion` atributo do `pages` elemento no arquivo Web. config. Se o `controlRenderingCompatibilityVersion` atributo não estiver definido no arquivo Web. config, o valor padrão é a versão atual do ASP.NET.  
  
> [!CAUTION]
>  Há um acessador de conjunto público para essa propriedade, mas o acessador set dá suporte à infraestrutura do .NET Framework e não se destina a ser usado diretamente do seu código. Se você definir esse valor em seu código, o efeito é imprevisível.  
  
 Cada versão do ASP.NET pode renderizar HTML de forma diferente de versões anteriores. Por exemplo, no ASP.NET 3.5, se o <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> propriedade de um <xref:System.Web.UI.WebControls.Label> controle é `false`, por padrão, o ASP.NET processa uma `span` elemento cujo `disabled` atributo é definido como "desabilitado". No ASP.NET 4, por padrão, o `span` elemento é renderizado com uma folha de estilos em cascata (CSS) `class` do atributo em vez do `disabled` atributo. Isso permite que você especifique a aparência desativada do controle e evita a renderização HTML inválido. (Em HTML 4.0 e XHTML 1.1, o `span` elemento não oferece suporte a `disabled` atributo.)  
  
 Um aplicativo Web pode incluir código que não funcionariam corretamente se altera de renderização HTML. Para evitar esse problema, você pode definir as `controlRenderingCompatibilityVersion` atributo do `pages` elemento no arquivo Web. config para indicar que deseja manter a compatibilidade com versão anterior. Por exemplo, se você definir a <xref:System.Web.UI.Control.RenderingCompatibility%2A> propriedade para `3.5`, desabilitado <xref:System.Web.UI.WebControls.Label> controle renderizará um `disabled` atributo e não uma classe CSS.  
  
> [!NOTE]
>  É a versão mais antiga que você pode definir essa propriedade para `3.5`.  
  
 Para manter a compatibilidade com versões anteriores, quando você usa o Visual Studio para atualizar um projeto da Web para ASP.NET 4 de uma versão anterior, o Visual Studio define automaticamente a `controlRenderingCompatibilityVersion` atributo no arquivo Web. config para `3.5`. Se você quiser um site da Web atualizado para renderizar HTML usando o algoritmo que foi introduzido no ASP.NET 4, você pode alterar ou remover o `controlRenderingCompatibilityVersion` atributo.  
  
 Na maioria das vezes, o comportamento controlado por esta propriedade é automático e não é necessário verificar o <xref:System.Web.UI.Control.RenderingCompatibility%2A> propriedade em seu código. No entanto, se você estiver programando um controle personalizado, você talvez precise incluir código que altera o comportamento do controle com base na configuração dessa propriedade. Por exemplo, um controle personalizado para ASP.NET 4 pode ser composto <xref:System.Web.UI.WebControls.Label> e o controle personalizado podem especificar a aparência desabilitada do controle por meio da geração de código JavaScript que altera o `aspNetDisabled` classe. Isso funcionará como esperado se <xref:System.Web.UI.Control.RenderingCompatibility%2A> é `4.0` ou posterior. Mas, para obter o mesmo efeito quando <xref:System.Web.UI.Control.RenderingCompatibility%2A> está `3.5`, o código do controle personalizado deve definir o controle `CssClass` propriedade como "aspNetDisabled" quando o <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> é de propriedade `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberSignature Language="F#" Value="abstract member ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter&#xA;override this.ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter" Usage="control.ResolveAdapter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o adaptador de controle responsável por renderizar o controle especificado.</summary>
        <returns>Um <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> que renderizará o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas da Web do ASP.NET são visíveis em uma ampla variedade de dispositivos que são capazes de solicitando páginas da Web. O <xref:System.Web.UI.Control.ResolveAdapter%2A> método retorna o adaptador de controle responsável para renderizar o controle no navegador específico ou dispositivo que solicitou a página ASP.NET.  
  
 O tipo de adaptador específico retornado depende do tipo descendente do <xref:System.Web.UI.Control> classe que está sendo renderizado.  
  
 Para obter mais informações sobre os adaptadores, consulte [Arquitetural Visão geral do controle de comportamento adaptável](https://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="abstract member ResolveClientUrl : string -&gt; string&#xA;override this.ResolveClientUrl : string -&gt; string" Usage="control.ResolveClientUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">Uma URL relativa à da atual.</param>
        <summary>Obtém uma URL que pode ser usada pelo navegador.</summary>
        <returns>Uma URL totalmente qualificada para o recurso especificado, adequada para uso no navegador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.ResolveClientUrl%2A> método para retornar uma cadeia de caracteres de URL adequado para uso pelo cliente para acessar recursos no servidor Web, como arquivos de imagem, links para páginas adicionais e assim por diante.  
  
> [!NOTE]
>  A URL retornada por esse método é relativo à pasta que contém o arquivo de origem no qual o controle é instanciado. Controles que herdam essa propriedade, tal como <xref:System.Web.UI.UserControl> e <xref:System.Web.UI.MasterPage>, retornará uma URL totalmente qualificada relativos ao controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="member this.ResolveUrl : string -&gt; string" Usage="control.ResolveUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">A URL associada à propriedade <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" />.</param>
        <summary>Converte uma URL em uma que possa ser usada no cliente solicitante.</summary>
        <returns>A URL convertida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `relativeUrl` parâmetro contém uma URL absoluta, a URL será retornada inalterada. Se o `relativeUrl` parâmetro contém uma URL relativa, que a URL é alterada para uma URL relativa que está correta para o caminho da solicitação atual, para que o navegador possa resolver a URL.  
  
 Por exemplo, considere o seguinte cenário:  
  
-   Um cliente solicitou uma página ASP.NET que contém um controle de usuário que tenha uma imagem associada a ele.  
  
-   A página do ASP.NET está localizada em /Store/page1.aspx.  
  
-   O controle de usuário está localizado em /Store/UserControls/UC1.ascx.  
  
-   O arquivo de imagem está localizado em /UserControls/Images/Image1.jpg.  
  
 Se o controle de usuário passa o caminho relativo para a imagem (ou seja, /Store/UserControls/Images/Image1.jpg) para o <xref:System.Web.UI.Control.ResolveUrl%2A> método, o método retornará o valor/images/Image1.jpg.  
  
 Esse método usa o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade a ser resolvida para a URL absoluta. A URL retornada é para uso do cliente.  
  
 Para obter mais informações sobre caminhos de recurso em um site da Web, consulte [caminhos de projeto do ASP.NET Web](https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd).  
  
> [!NOTE]
>  Para páginas da Web móveis, se seu aplicativo se baseia em sessões sem cookies ou pode receber solicitações de navegadores para dispositivos móveis que exigem sessões sem cookies, usando um til ("\~") em um caminho pode resultar em inadvertidamente criando uma nova sessão e potencial perda de dados da sessão. Para definir uma propriedade com um caminho como "\~/*caminho"*, resolver o caminho chamando o <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> com um argumento, como "\~/*caminho"* antes de atribuí-lo à propriedade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Web.UI.WebControls.Image> Web o objeto de controle de servidor e usa o <xref:System.Web.UI.Control.ResolveUrl%2A> método para definir o caminho para a imagem, que é armazenada pelo <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> propriedade.  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ocorrerá se o parâmetro <paramref name="relativeUrl" /> contiver <see langword="null" />.</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
        <related type="Article" href="https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd">Caminhos de Site da Web do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveControlState : unit -&gt; obj&#xA;override this.SaveControlState : unit -&gt; obj" Usage="control.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva as alterações de estado do controle de servidor que ocorreram desde a hora em que ocorreu o postback da página no servidor.</summary>
        <returns>Retorna o estado atual do controle de servidor. Se não houver nenhum estado associado ao controle, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.SaveControlState%2A> método para salvar informações de estado necessárias para a operação de um controle específico. Esses dados de estado de controle são armazenados separadamente dos dados de estado de exibição do controle.  
  
 Controles personalizados usando o estado do controle devem chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método no <xref:System.Web.UI.Control.Page%2A> antes de salvar o estado do controle.  
  
   
  
## Examples  
 O seguinte código de exemplo substitui o <xref:System.Web.UI.Control.SaveControlState%2A> método em um controle ASP.NET personalizado. Quando este método é invocado, ele determina se a propriedade interna `currentIndex` é definido como um valor não padrão e, nesse caso, salva o valor para o estado do controle.  
  
 O <xref:System.Web.UI.Control.OnInit%2A> método é substituído para chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método o <xref:System.Web.UI.Control.Page%2A> para indicar que o controle personalizado usa estado de controle.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quando o estado do controle é salvo, um objeto de cadeia de caracteres é retornado ao cliente como uma variável que é armazenada em um HTML <see langword="HIDDEN" /> elemento. Substitua este método para extrair as informações de estado para usar em seu controle.  
  
Estado do controle se destina a pequenas quantidades de dados críticos, como um índice de página ou uma palavra-chave. Usando o estado do controle para grandes quantidades de dados pode afetar adversamente o desempenho da página. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).</para></block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Visão geral do gerenciamento de estado do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveViewState : unit -&gt; obj&#xA;override this.SaveViewState : unit -&gt; obj" Usage="control.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva alterações de estado de exibição do controle de servidor que ocorreram desde a hora em que ocorreu o postback da página no servidor.</summary>
        <returns>Retorna o estado de exibição atual do controle de servidor. Se não houver um estado de exibição associado ao controle, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição é o acúmulo dos valores de propriedades de um controle de servidor. Esses valores são colocados automaticamente no controle de servidor <xref:System.Web.UI.Control.ViewState%2A> propriedade, que é uma instância do <xref:System.Web.UI.StateBag> classe. Valor desta propriedade é persistido em um objeto de cadeia de caracteres depois de salvar o estágio do ciclo de vida de controle de servidor de estado. Para obter mais informações, consulte [visão geral do ciclo de vida de página ASP.NET](https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 Quando o estado de exibição é salvo, esse objeto de cadeia de caracteres é retornado ao cliente como uma variável que é armazenada em um HTML `HIDDEN` elemento. Quando você cria um controle de servidor personalizado com um estado de exibição personalizado, o estado de exibição pode ser gerenciado explicitamente com o <xref:System.Web.UI.Control.SaveViewState%2A> e <xref:System.Web.UI.Control.LoadViewState%2A> métodos. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)). Para obter informações sobre como implementar um provedor de estado de sessão personalizado, consulte [implementando um provedor de estado de sessão Store](https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.SaveViewState%2A> método em um controle de servidor ASP.NET personalizado. Quando este método é chamado, ele determina se o controle tem todos os controles filho e se a que contém <xref:System.Web.UI.Page> objeto é o resultado de um postback. Se ambos forem verdadeiros, ele altera o <xref:System.Web.UI.WebControls.Label.Text%2A> propriedade de um <xref:System.Web.UI.WebControls.Label> controle de servidor para ler Web `Custom Control Has Saved State`. Ele salva o estado de exibição do controle como uma matriz de objetos, chamados `allStates`.  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Visão geral do gerenciamento de estado do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66">Implementando um provedor de estado de sessão Store</related>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">Um <see cref="T:System.Collections.IDictionary" /> que contém os dados de tempo de design para o controle.</param>
        <summary>Define os dados de tempo de design para um controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.SetDesignModeState%2A> método salva dados de tempo de design para um controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Você deve substituir esse método para salvar os dados de tempo de design que requer que seu controle.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberSignature Language="F#" Value="member this.SetRenderMethodDelegate : System.Web.UI.RenderMethod -&gt; unit" Usage="control.SetRenderMethodDelegate renderMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">As informações necessárias para passar para o delegado para que ele possa renderizar o controle de servidor.</param>
        <summary>Atribui um delegado do manipulador de eventos para renderizar o controle de servidor e seu conteúdo em seu controle pai.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é fornecido para fins de implementação. Você nunca chame-o diretamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define os dados de rastreamento para o rastreamento de tempo de design de dados de renderização.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj -&gt; unit" Usage="control.SetTraceData (traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">A chave de dados de rastreamento.</param>
        <param name="traceDataValue">O valor de dados de rastreamento.</param>
        <summary>Define os dados de rastreamento para o rastreamento de tempo de design dos dados de renderização, usando a chave e o valor de dados de rastreamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj * obj -&gt; unit" Usage="control.SetTraceData (tracedObject, traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">O objeto rastreado.</param>
        <param name="traceDataKey">A chave de dados de rastreamento.</param>
        <param name="traceDataValue">O valor de dados de rastreamento.</param>
        <summary>Define os dados de rastreamento para o rastreamento de tempo de design dos dados de renderização, usando o objeto rastreado, a chave e o valor de dados de rastreamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém informações sobre o contêiner que hospeda o controle atual quando renderizados em uma superfície de design.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISite" /> que contém informações sobre o contêiner em que o controle é hospedado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associa um site de uma <xref:System.ComponentModel.Component> do objeto para um <xref:System.ComponentModel.Container> do objeto e permite a comunicação entre os dois. Ele também fornece uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a capa a ser aplicada ao controle.</summary>
        <value>O nome da capa a ser aplicada ao controle. O padrão é <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Disponível para um controle de capas estão contidas em um ou mais arquivos de capa em um diretório do tema. O <xref:System.Web.UI.Control.SkinID%2A> propriedade especifica qual essas capas a ser aplicado ao controle. Uma capa é específica para um controle específico. é possível compartilhar configurações de aparência entre os controles de tipos diferentes.  
  
 Se você não definir o <xref:System.Web.UI.Control.SkinID%2A> propriedade, um controle usa a capa padrão se um for definido. Por exemplo, se uma capa sem uma ID é definida para um <xref:System.Web.UI.WebControls.Image> controlar, em seguida, aquela aparência se aplica a todos os <xref:System.Web.UI.WebControls.Image> controles que não fazem referência explícita uma capa por ID e que não são definidos para desabilitar a temas. Se uma capa com uma ID é definida para um <xref:System.Web.UI.WebControls.Image> controlar, em seguida, aquela aparência se aplica apenas ao <xref:System.Web.UI.WebControls.Image> controla cuja <xref:System.Web.UI.Control.SkinID%2A> estiver definida como essa ID.  
  
 Se os arquivos de capa em um diretório de tema não contêm uma capa com especificado <xref:System.Web.UI.Control.SkinID%2A> propriedade, um <xref:System.ArgumentException> exceção é gerada em tempo de execução.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A folha de estilos já foi aplicada.  
  
- ou - 
O evento <see langword="Page_PreInit" /> já ocorreu.  
  
- ou - 
O controle já foi adicionado à coleção <see langword="Controls" />.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">Visão geral de temas do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System::Web::UI::IControlBuilderAccessor::ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />.</summary>
        <value>O <see cref="T:System.Web.UI.ControlBuilder" /> que o controle criado; caso contrário, <see langword="null" /> se nenhum construtor foi usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlBuilderAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />.</summary>
        <returns>Um <see cref="T:System.Collections.IDictionary" /> do estado do controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">Um <see cref="T:System.Collections.IDictionary" /> que contém os dados de tempo de design para o controle.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">O proprietário do controle.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 O <xref:System.Web.UI.IControlDesignerAccessor> interface é usada por um designer de controle para executar ações de tempo de design do controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="owner" /> é definido para o controle atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System::Web::UI::IControlDesignerAccessor::UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />.</summary>
        <value>Um <see cref="T:System.Collections.IDictionary" /> que contém informações sobre o controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System::Web::UI::IDataBindingsAccessor::DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />.</summary>
        <value>A coleção de associações de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IDataBindingsAccessor::HasDataBindings { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />.</summary>
        <value><see langword="true" /> Se o controle contiver a lógica de associação de dados; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System::Web::UI::IExpressionsAccessor::Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />.</summary>
        <value>Uma <see cref="T:System.Web.UI.ExpressionBindingCollection" /> contendo <see cref="T:System.Web.UI.ExpressionBinding" /> objetos que representam as propriedades e expressões para um controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IExpressionsAccessor::HasExpressions { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />.</summary>
        <value><see langword="true" /> Se o controle tem propriedades definidas por expressões; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a adicionar.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IParserAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TemplateControl : System.Web.UI.TemplateControl with get, set" Usage="System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma referência ao modelo que contém este controle.</summary>
        <value>A instância <see cref="T:System.Web.UI.TemplateControl" /> que contém esse controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Web.UI.Control> instância faz parte de um modelo de controle, o <xref:System.Web.UI.Control.TemplateControl%2A> propriedade contém uma referência para o controle recipiente. Para obter mais informações, consulte o <xref:System.Web.UI.TemplateControl?displayProperty=nameWithType> documentação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplateSourceDirectory : string" Usage="System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o diretório virtual do <see cref="T:System.Web.UI.Page" /> ou <see cref="T:System.Web.UI.UserControl" /> que contém o controle do servidor atual.</summary>
        <value>O diretório virtual do controle de usuário ou página que contém o controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade especifica o caminho para o página ou controle de usuário que contém o controle atual. Por exemplo, se a página da Web reside na http://www.contoso.com/application/subdirectory, o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade retorna "application/subdiretório".  
  
 Para retornar o caminho virtual do relativo do aplicativo ("~ / subdiretório"), use o <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade duas vezes. Na primeira vez que ele é usado em um <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType> chamada de método para obter o caminho para o diretório no qual reside o controle. Na segunda vez que ele está em um <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> chamada de método para obter a lista de todos os arquivos contidos nessa pasta.  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberSignature Language="F#" Value="abstract member TrackViewState : unit -&gt; unit&#xA;override this.TrackViewState : unit -&gt; unit" Usage="control.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causa o acompanhamento das alterações de estado de exibição para o controle de servidor, para que elas possam ser armazenadas no objeto <see cref="T:System.Web.UI.StateBag" /> do controle de servidor. Esse objeto é acessível por meio da propriedade <see cref="P:System.Web.UI.Control.ViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado automaticamente no final o <xref:System.Web.UI.Control.Init> eventos no ciclo de vida do controle de servidor.  
  
 Invocar esse método quando você desenvolve controles de associação de dados modelo. Esse método alertas ASP.NET para monitorar alterações ao estado de exibição de um controle de servidor, que é necessário quando você substitui o <xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.DataBind%2A> método em um controle de servidor ASP.NET personalizado. Ele começa chamando a base <xref:System.Web.UI.Control.OnDataBinding%2A> método e, em seguida, usa o <xref:System.Web.UI.ControlCollection.Clear%2A> método para excluir todos os controles filho e o <xref:System.Web.UI.Control.ClearChildViewState%2A> método para excluir qualquer estado de exibição configurações salvas para esses controles filho. Por fim, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> estiver definida como `true`. O controle, em seguida, usa o <xref:System.Web.UI.Control.IsTrackingViewState%2A> propriedade para determinar se o estado de exibição de controle de alterações está habilitada para o controle. Se não estiver habilitado, o <xref:System.Web.UI.Control.TrackViewState%2A> método é chamado.  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueID : string" Usage="System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo, qualificado segundo a hierarquia, para o controle de servidor.</summary>
        <value>O identificador totalmente qualificado para o controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é diferente do <xref:System.Web.UI.Control.ID%2A> propriedade, em que o <xref:System.Web.UI.Control.UniqueID%2A> propriedade inclui o identificador para o contêiner de nomenclatura do controle de servidor. Esse identificador é gerado automaticamente quando uma solicitação de página é processada.  
  
 Essa propriedade é particularmente importante na diferenciação de controles de servidor contidos em um controle de servidor de ligação de dados que se repete. O controle de repetição, que são <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList>, <xref:System.Web.UI.WebControls.DetailsView>, <xref:System.Web.UI.WebControls.FormView>, e <xref:System.Web.UI.WebControls.GridView> Web controles de servidor (ou quaisquer controles de servidor personalizado criado por você que incluem a funcionalidade de repetição quando os dados associados) serve como o contêiner de nomenclatura para seu filho controles. Isso significa que ele cria um namespace exclusivo para seu filho controles para que seus <xref:System.Web.UI.Control.ID%2A> valores de propriedade não entrem em conflito.  
  
 Por exemplo, se você incluir um ASP.NET <xref:System.Web.UI.WebControls.Label> controle de servidor na Web uma <xref:System.Web.UI.WebControls.Repeater> controle de servidor e atribuir a <xref:System.Web.UI.WebControls.Label> controle um <xref:System.Web.UI.Control.ID%2A> valor da propriedade de `MyLabel`e o <xref:System.Web.UI.WebControls.Repeater> um <xref:System.Web.UI.Control.ID%2A> de `MyRepeater`. Se você associar dados à <xref:System.Web.UI.WebControls.Repeater> para um <xref:System.Collections.ArrayList> objeto com três entradas, resultante <xref:System.Web.UI.Control.UniqueID%2A> propriedades para cada instância das <xref:System.Web.UI.WebControls.Label> controles de servidor são `MyRepeater$ctl00$MyLabel`, `MyRepeater$ctl01$MyLabel`, e `MyRepeater$ctl02$MyLabel`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma <xref:System.Collections.ArrayList> do objeto e preenche-o com três cadeias de caracteres de texto, em seguida, associa um <xref:System.Web.UI.WebControls.Repeater> controle de servidor para os dados na Web a <xref:System.Collections.ArrayList> quando a página é carregada. O código obtém o <xref:System.Web.UI.Control.UniqueID%2A> propriedade para cada controle filho gerado durante a vinculação de dados. O código gera três versões dos <xref:System.Web.UI.WebControls.Label> controle e grava seus `UniqueID` valores de propriedade para a página.  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : EventHandler " Usage="member this.Unload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é descarregado da memória.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor devem executar qualquer limpeza final, como fechar arquivos, conexões de banco de dados e descartar os objetos, durante esse estágio do ciclo de vida do controle antes da instância é descarregada.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">Introdução ao ciclo de vida de página ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle verifica a entrada do cliente do navegador para valores potencialmente perigosos.</summary>
        <value>Um valor que determina se o controle verifica a entrada do cliente. Os valores podem incluir <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />, <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />, e <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />. O padrão é <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />, que significa que o controle obtém o valor de seu pai.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a validação de solicitação, consulte <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewState : System.Web.UI.StateBag" Usage="System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um dicionário de informações de estado que permite salvar e restaurar o estado de exibição de um controle de servidor em várias solicitações para a mesma página.</summary>
        <value>Uma instância da classe <see cref="T:System.Web.UI.StateBag" /> que contém informações de estado de exibição do controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição de um controle de servidor é o acúmulo de todos os seus valores de propriedade. Para preservar esses valores em todas as solicitações HTTP, controles de servidor ASP.NET usam essa propriedade, que é uma instância do <xref:System.Web.UI.StateBag> classe para armazenar os valores de propriedade. Os valores são passados como uma variável para um elemento de entrada oculto HTML quando solicitações subsequentes são processadas. Para obter mais informações sobre como salvar o estado de exibição de controle de servidor, consulte [visão geral do gerenciamento de estado ASP.NET](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)).  
  
 Estado de exibição está habilitado para todos os controles de servidor por padrão, mas há circunstâncias em que você queira desabilitá-lo. Para obter mais informações, consulte [visão geral de desempenho do ASP.NET](https://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b).  
  
 Para obter informações sobre dicionários e como usá-los, consulte [coleções e estruturas de dados](~/docs/standard/collections/index.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como implementar uma `Text` propriedade que armazena e recupera seu valor de seu controle <xref:System.Web.UI.Control.ViewState%2A> propriedade.  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Visão geral do gerenciamento de estado do ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateIgnoresCase : bool" Usage="System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto <see cref="T:System.Web.UI.StateBag" /> não diferencia maiúsculas de minúsculas.</summary>
        <value><see langword="true" /> se a instância <see cref="T:System.Web.UI.StateBag" /> não diferenciar maiúsculas de minúsculas; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método se você criar um controle de servidor personalizado que salva seu estado de exibição sem levar o caso em consideração. Quando você fizer, portanto, vários objetos com a mesma chave, mas com maiusculas e minúsculas diferentes, podem ser armazenados na <xref:System.Web.UI.StateBag> associados a <xref:System.Web.UI.Control.ViewState%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como substituir a <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A> propriedade para retornar `true`.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateMode : System.Web.UI.ViewStateMode with get, set" Usage="System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo de estado de exibição deste controle.</summary>
        <value>O modo de estado de exibição desse controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade para habilitar o estado de exibição para um controle individual, mesmo se o estado de exibição está desabilitado para a página. Para obter mais informações sobre o estado de exibição e estado de controle, consulte o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade.  
  
 Para desativar o estado de exibição para uma página e habilitá-la para um controle específico na página, defina a <xref:System.Web.UI.Control.EnableViewState%2A> propriedade da página e o controle para `true`, defina o <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade da página para <xref:System.Web.UI.ViewStateMode.Disabled>e defina o <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade das o controle para <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 O valor padrão de <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade para uma página é <xref:System.Web.UI.ViewStateMode.Enabled>. O valor padrão de <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade para um controle de servidor Web em uma página é <xref:System.Web.UI.ViewStateMode.Inherit>. Como resultado, se você não definir essa propriedade na página ou o nível de controle, o valor da <xref:System.Web.UI.Control.EnableViewState%2A> propriedade determina o comportamento de estado de exibição.  
  
 O <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade de uma página ou controle tem somente-se um efeito a <xref:System.Web.UI.Control.EnableViewState%2A> estiver definida como `true`. Se o <xref:System.Web.UI.Control.EnableViewState%2A> estiver definida como `false`, estado de exibição será desativado até mesmo se o <xref:System.Web.UI.Control.ViewStateMode%2A> estiver definida como <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentativa de definir esta propriedade com um valor que não está na enumeração de <see cref="T:System.Web.UI.ViewStateMode" />.</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">Visão geral do gerenciamento de estado do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818">Visão geral do estado de exibição do ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/en-us/library/C90FA3D7-788A-47D2-A80F-138122A1D8EE">Controlando o estado de exibição</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se um controle de servidor é renderizado como uma interface do usuário na página.</summary>
        <value><see langword="true" /> se o controle estiver visível na página; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade for `false`, o controle de servidor não é renderizado. Você deve levar isso em conta ao organizar o layout da página.  
  
> [!NOTE]
>  Se um controle de contêiner não é processado, todos os controles que ela contém não serão renderizados, mesmo que você defina as <xref:System.Web.UI.Control.Visible%2A> propriedade de um controle individual para `true`. Nesse caso, retorna o controle individual `false` para o <xref:System.Web.UI.Control.Visible%2A> propriedade mesmo se você tiver definido isso explicitamente `true`. (Ou seja, se o `Visible` do controle pai estiver definida como `false`, o controle filho herdará essa configuração e a configuração terá precedência sobre nenhuma configuração local.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>