<Type Name="SqlFileStream" FullName="System.Data.SqlTypes.SqlFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0516599dd46f28677cc07a02600fa694df7bf95a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30390220" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlFileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlFileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlTypes.SqlFileStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlFileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlFileStream sealed : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Expõe dados do SQL Server que são armazenados com o atributo de coluna FILESTREAM como uma sequência de bytes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Data.SqlTypes.SqlFileStream> classe é usada para trabalhar com `varbinary(max)` dados armazenados com o atributo FILESTREAM em um banco de dados do SQL Server 2008. Você deve instalar o .NET Framework 3.5 SP1 (ou posterior) para usar <xref:System.Data.SqlTypes.SqlFileStream> para trabalhar com dados FILESTREAM.  
  
 Especificando o FILESTREAM de atributo em um `varbinary(max)` coluna faz com que o SQL Server para armazenar os dados em que o sistema de arquivos NTFS local em vez de no arquivo de banco de dados. Instruções Transact-SQL fornecem recursos de manipulação de dados no servidor e interfaces de sistema de arquivos do Win32 fornecem acesso de streaming aos dados.  
  
> [!NOTE]
>  Arquivos individuais armazenados em uma coluna FILESTREAM não podem ser abertos diretamente do sistema de arquivos NTFS. Fluxo de dados FILESTREAM funciona apenas no contexto de uma transação do SQL Server.  
  
 O <xref:System.Data.SqlTypes.SqlFileStream> classe é derivada do <xref:System.IO.Stream> classe que representa uma abstração de uma sequência de bytes de alguma origem de dados arbitrários como um arquivo ou um bloco de memória. Você pode ler de um FILESTREAM por meio da transferência de dados de um fluxo em uma estrutura de dados como uma matriz de bytes. Você pode gravar em um FILESTREAM transferindo dados de uma estrutura de dados em um fluxo. Você também pode pesquisar dentro do fluxo, o que lhe permite consultar e modificar dados na posição atual dentro do fluxo.  
  
 Para documentação conceitual e exemplos de código, consulte [dados FILESTREAM](~/docs/framework/data/adonet/sql/filestream-data.md).  
  
 Para obter a documentação sobre como definir e configurar dados FILESTREAM no SQL Server, consulte [Projetando e implementando armazenamento de FILESTREAM](http://go.microsoft.com/fwlink/?LinkId=121499) nos Manuais Online do SQL Server 2008.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as permissões de CAS (segurança) de acesso do código que todos os chamadores na pilha devem ter para usar o `SqlFileStream` construtores.  
  
|Acesso a arquivos|Permissão|  
|-----------------|----------------|  
|Ler|<xref:System.Security.Permissions.FileIOPermissionAccess.Read>|  
|Write|<xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
|ReadWrite|<xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
  
 Para obter mais informações sobre as ACS, consulte [Code Access Security e ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">O caminho lógico para o arquivo. O caminho pode ser recuperado usando a função Transact-SQL Pathname na coluna FILESTREAM subjacente da tabela.</param>
        <param name="transactionContext">O contexto de transação para o objeto <see langword="SqlFileStream" />. Os aplicativos devem retornar uma matriz de bytes retornada com uma chamada ao método GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">O modo de acesso a ser usado ao abrir o arquivo. Os valores de enumeração <see cref="T:System.IO.FileAccess" /> com suporte são <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> e <see cref="F:System.IO.FileAccess.ReadWrite" />.  
  
 Ao usar <see langword="FileAccess.Read" />, o objeto <see langword="SqlFileStream" /> pode ser usado para ler todos os dados existentes.  
  
 Ao usar <see langword="FileAccess.Write" />, o <see langword="SqlFileStream" /> aponta para um arquivo de zero byte. Os dados existentes serão substituídos quando o objeto for fechado e a transação for confirmada.  
  
 Ao usar <see langword="FileAccess.ReadWrite" />, o <see langword="SqlFileStream" /> aponta para um arquivo que tem todos os dados existentes. O identificador está posicionado no início do arquivo. É possível usar um dos métodos <see langword="System.IO" /><see langword="Seek" /> para mover a posição do identificador no arquivo para gravar ou anexar novos dados.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma exceção for lançada, qualquer transação aberta deve ser revertida. Caso contrário, pode ocorrer perda de dados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é uma referência nula ou <paramref name="transactionContext" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 <paramref name="path" /> começa com "\\\\.\\", por exemplo, "\\\\.\PHYSICALDRIVE0 ".  
  
 O identificador retornado pela chamada a NTCreateFile não é do tipo FILE_TYPE_DISK.  
  
 <paramref name="options" /> contém um valor sem suporte.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O <paramref name="path" /> especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso solicitado não é permitido pelo sistema operacional para o caminho especificado. Isso ocorre quando o acesso Write ou ReadWrite é especificado e o arquivo ou diretório está configurado para o acesso somente leitura.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile falha com o código de erro definido como ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access, System.IO.FileOptions options, long allocationSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access, valuetype System.IO.FileOptions options, int64 allocationSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess,System.IO.FileOptions,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess, options As FileOptions, allocationSize As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access, System::IO::FileOptions options, long allocationSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="allocationSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">O caminho lógico para o arquivo. O caminho pode ser recuperado usando a função Transact-SQL Pathname na coluna FILESTREAM subjacente da tabela.</param>
        <param name="transactionContext">O contexto de transação para o objeto <see langword="SqlFileStream" />. Quando definido como nulo, uma transação implícita será usada para o objeto <see langword="SqlFileStream" />. Os aplicativos devem retornar uma matriz de bytes retornada com uma chamada ao método GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">O modo de acesso a ser usado ao abrir o arquivo. Os valores de enumeração <see cref="T:System.IO.FileAccess" /> com suporte são <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> e <see cref="F:System.IO.FileAccess.ReadWrite" />.  
  
 Ao usar <see langword="FileAccess.Read" />, o objeto <see langword="SqlFileStream" /> pode ser usado para ler todos os dados existentes.  
  
 Ao usar <see langword="FileAccess.Write" />, o <see langword="SqlFileStream" /> aponta para um arquivo de zero byte. Os dados existentes serão substituídos quando o objeto for fechado e a transação for confirmada.  
  
 Ao usar <see langword="FileAccess.ReadWrite" />, o <see langword="SqlFileStream" /> aponta para um arquivo que tem todos os dados existentes. O identificador está posicionado no início do arquivo. É possível usar um dos métodos <see langword="System.IO" /><see langword="Seek" /> para mover a posição do identificador no arquivo para gravar ou anexar novos dados.</param>
        <param name="options">Especifica a opção a usar ao abrir o arquivo. Os valores de <see cref="T:System.IO.FileOptions" /> compatíveis são <see cref="F:System.IO.FileOptions.Asynchronous" />, <see cref="F:System.IO.FileOptions.WriteThrough" />, <see cref="F:System.IO.FileOptions.SequentialScan" /> e <see cref="F:System.IO.FileOptions.RandomAccess" />.</param>
        <param name="allocationSize">O tamanho de alocação a usar ao criar um arquivo. Se definido como 0, o valor padrão será usado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma exceção for lançada, qualquer transação aberta deve ser revertida. Caso contrário, pode ocorrer perda de dados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é uma referência nula ou <paramref name="transactionContext" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 <paramref name="path" /> começa com "\\\\.\\", por exemplo, "\\\\.\PHYSICALDRIVE0 ".  
  
 O identificador retornado pela chamada para NTCreateFile não é do tipo FILE_TYPE_DISK.  
  
 <paramref name="options" /> contém um valor sem suporte.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O <paramref name="path" /> especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O acesso solicitado não é permitido pelo sistema operacional para o caminho especificado. Isso ocorre quando o acesso Write ou ReadWrite é especificado e o arquivo ou diretório está configurado para o acesso somente leitura.</exception>
        <exception cref="T:System.InvalidOperationException">NtCreateFile falha com o código de erro definido como ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para ler os dados.</param>
        <param name="offset">O deslocamento de bytes no <c>buffer</c> em que se começa a gravar os dados lidos do fluxo.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando a leitura for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de leitura assíncrona específica de outras solicitações</param>
        <summary>Inicia uma operação de leitura assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de leitura assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O fluxo não é compatível com leitura de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer do qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de bytes no <c>buffer</c> do qual iniciar a gravação.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a operação de gravação for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de gravação assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a gravação assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O fluxo não é compatível com gravação de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte à leitura.</summary>
        <value>
          <see langword="true" /> Se o fluxo atual oferece suporte à leitura; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte à busca.</summary>
        <value>
          <see langword="true" /> Se o fluxo atual oferece suporte à busca; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual pode atingir o tempo limite.</summary>
        <value>
          <see langword="true" /> Se o fluxo atual pode atingir o tempo limite; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte à gravação.</summary>
        <value>
          <see langword="true" /> Se o fluxo atual oferece suporte à gravação; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A referência à solicitação assíncrona pendente a ser concluída.</param>
        <summary>Espera a leitura assíncrona pendente ser concluída.</summary>
        <returns>O número de bytes lidos do fluxo, entre zero (0) e o número de bytes solicitado. Os fluxos retornam zero (0) somente no final do fluxo, caso contrário, eles devem ser bloqueados até que pelo menos um byte esteja disponível.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O objeto <see cref="T:System.IAsyncResult" /> não veio do método <see langword="BeginRead" /> correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Encerra uma operação de gravação assíncrona.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O objeto <see cref="T:System.IAsyncResult" /> não veio do método <see langword="BeginWrite" /> correspondente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SqlFileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SqlFileStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa todos os buffers nesse fluxo e faz com que os dados armazenados em buffer sejam gravados no dispositivo subjacente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o comprimento do fluxo atual em bytes.</summary>
        <value>Um <see cref="T:System.Int64" /> que indica o comprimento do fluxo atual em bytes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho lógico do <see cref="T:System.Data.SqlTypes.SqlFileStream" /> transmitido ao construtor.</summary>
        <value>Um valor de cadeia de caracteres que indica o nome do <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição no fluxo atual.</summary>
        <value>A posição atual dentro do <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes. Quando esse método é retornado, o buffer conterá a matriz de bytes especificada com os valores entre deslocamento e (deslocamento + contagem - 1) substituídos pelos bytes lidos da origem atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero no buffer no qual começar a armazenar os dados lidos do fluxo atual.</param>
        <param name="count">O número máximo de bytes a serem lidos no fluxo atual.</param>
        <summary>Lê uma sequência de bytes do fluxo atual e avança a posição no fluxo até o número de bytes lidos.</summary>
        <returns>O número total de bytes lidos do buffer. Isso poderá ser menor que o número de bytes solicitado se esses muitos bytes não estiverem disponíveis no momento, ou zero (0) se o final do fluxo tiver sido atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto não dá suporte à leitura de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um byte do fluxo e avança a posição no fluxo em um byte ou retorna -1 caso esteja no final do fluxo.</summary>
        <returns>O byte sem sinal convertido em um <see cref="T:System.Int32" /> ou -1 se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto não dá suporte à leitura de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor, em milissegundos, que determina por quanto tempo o fluxo tentará realizar a leitura antes do tempo limite.</summary>
        <value>Um valor, em milissegundos, que determina quanto tempo o fluxo de tentativa de leitura antes do tempo limite.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento de bytes relativo ao parâmetro <c>origem</c></param>
        <param name="origin">Um valor do tipo <see cref="T:System.IO.SeekOrigin" /> indicando o ponto de referência usado para obter a nova posição</param>
        <summary>Define a posição no fluxo atual.</summary>
        <returns>A nova posição dentro do fluxo atual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O tamanho desejado do fluxo atual em bytes.</param>
        <summary>Define o comprimento do fluxo atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto não dá suporte à leitura de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionContext">
      <MemberSignature Language="C#" Value="public byte[] TransactionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] TransactionContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionContext As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ TransactionContext { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o contexto de transação para este objeto <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <value>O <paramref name="transactionContext" /> matriz passado para o construtor para este <see cref="T:System.Data.SqlTypes.SqlFileStream" /> objeto.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes. Esse método copia os bytes de <c>contagem</c> do <c>buffer</c> para o fluxo atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero no <c>buffer</c> no qual será iniciada a cópia de bytes para o fluxo atual.</param>
        <param name="count">O número de bytes a serem gravados no fluxo atual.</param>
        <summary>Grava uma sequência de bytes no fluxo atual e avança a posição atual dentro desse fluxo pelo número de bytes gravados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto não é compatível com gravação de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O byte a ser gravado no fluxo.</param>
        <summary>Grava um byte na posição atual no fluxo e avança a posição dentro no fluxo em um byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O objeto não é compatível com gravação de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor, em milissegundos, que determina por quanto tempo o fluxo tentará realizar a gravação antes do tempo limite.</summary>
        <value>Um valor, em milissegundos, que determina quanto tempo o fluxo tentará gravar antes do tempo limite.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>