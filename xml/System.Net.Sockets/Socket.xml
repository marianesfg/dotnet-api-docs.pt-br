<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="aed81-101">Implementa a interface de soquetes Berkeley.</span><span class="sxs-lookup"><span data-stu-id="aed81-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-102">O <xref:System.Net.Sockets.Socket> classe fornece um conjunto rico de métodos e propriedades para as comunicações de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="aed81-103">O <xref:System.Net.Sockets.Socket> classe permite que você execute ambos síncrona e transferência de dados assíncrona usando qualquer um dos protocolos de comunicação listados no <xref:System.Net.Sockets.ProtocolType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="aed81-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="aed81-104">O <xref:System.Net.Sockets.Socket> classe segue o padrão de nomenclatura do .NET Framework para métodos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="aed81-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="aed81-105">Por exemplo, o síncrona <xref:System.Net.Sockets.Socket.Receive%2A> método corresponde à assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="aed81-106">Se seu aplicativo requer apenas um thread durante a execução, use os métodos a seguir, que são projetados para o modo de operação síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="aed81-107">Se você estiver usando um protocolo orientado a conexão como TCP, o servidor pode escutar conexões usando o <xref:System.Net.Sockets.Socket.Listen%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="aed81-108">O <xref:System.Net.Sockets.Socket.Accept%2A> processos de método solicitações de qualquer conexão de entrada e retorna um <xref:System.Net.Sockets.Socket> que você pode usar para se comunicar dados com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="aed81-109">Use este retornado <xref:System.Net.Sockets.Socket> para chamar o <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="aed81-110">Chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método antes de chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método se você deseja especificar o número de porta e endereço IP local.</span><span class="sxs-lookup"><span data-stu-id="aed81-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="aed81-111">Use um número de porta de zero se quiser que o provedor de serviço subjacente para atribuir uma porta disponível para você.</span><span class="sxs-lookup"><span data-stu-id="aed81-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="aed81-112">Se você quiser se conectar a um host de escutando, chame o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-113">Para se comunicar dados, chame o <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="aed81-114">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa escutar conexões em todos os.</span><span class="sxs-lookup"><span data-stu-id="aed81-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="aed81-115">Chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método para aceitar a entrada datagramas.</span><span class="sxs-lookup"><span data-stu-id="aed81-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="aed81-116">Use o <xref:System.Net.Sockets.Socket.SendTo%2A> método enviar datagramas para um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="aed81-117">Para processar comunicações usando threads separados durante a execução, use os métodos a seguir, que são projetados para o modo de operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="aed81-118">Se você estiver usando um protocolo orientado a conexão como TCP, use o <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, e <xref:System.Net.Sockets.Socket.EndConnect%2A> métodos para se conectar com um host de escutando.</span><span class="sxs-lookup"><span data-stu-id="aed81-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="aed81-119">Use o <xref:System.Net.Sockets.Socket.BeginSend%2A> e <xref:System.Net.Sockets.Socket.EndSend%2A> ou <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos para se comunicar dados de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="aed81-120">Solicitações de conexão de entrada podem ser processadas usando <xref:System.Net.Sockets.Socket.BeginAccept%2A> e <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="aed81-121">Se você estiver usando um protocolo sem-conexão como UDP, você pode usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.EndSendTo%2A> para enviar datagramas, e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> e <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> para receber datagramas.</span><span class="sxs-lookup"><span data-stu-id="aed81-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="aed81-122">Se você executar várias operações assíncronas em um soquete, não sejam necessariamente concluídas na ordem em que eles são iniciados.</span><span class="sxs-lookup"><span data-stu-id="aed81-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="aed81-123">Quando tiver terminado de enviar e receber dados, use o <xref:System.Net.Sockets.Socket.Shutdown%2A> método para desativar o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-124">Depois de chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos os recursos associados a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="aed81-125">O <xref:System.Net.Sockets.Socket> classe permite que você configure seu <xref:System.Net.Sockets.Socket> usando o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="aed81-126">Recuperar essas configurações usando o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-127">Se você estiver escrevendo um aplicativo relativamente simples e não requerem desempenho máximo, considere o uso de <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, e <xref:System.Net.Sockets.UdpClient>.</span><span class="sxs-lookup"><span data-stu-id="aed81-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="aed81-128">Essas classes fornecem uma interface simples e mais amigável para <xref:System.Net.Sockets.Socket> comunicações.</span><span class="sxs-lookup"><span data-stu-id="aed81-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-129">O seguinte exemplo de código mostra como o <xref:System.Net.Sockets.Socket> classe pode ser usada para enviar dados para um servidor HTTP e receber a resposta.</span><span class="sxs-lookup"><span data-stu-id="aed81-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="aed81-130">Este exemplo bloqueia até que a página inteira seja recebida.</span><span class="sxs-lookup"><span data-stu-id="aed81-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-131">para estabelecer uma conexão de saída ou aceitar uma solicitação de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="aed81-132">As instâncias dessa classe serão thread-safe.</span><span class="sxs-lookup"><span data-stu-id="aed81-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-133">Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-133">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="aed81-134">As informações de soquete retornadas por <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-134">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="aed81-135">Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" />, usando o valor especificado de <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-135">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-136">Se você chamar o <xref:System.Net.Sockets.Socket.%23ctor%2A> construtor várias vezes com a mesma matriz de bytes como o argumento para cada chamada, você criará vários gerenciado <xref:System.Net.Sockets.Socket>s com o mesmo soquete subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-136">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="aed81-137">Essa prática é altamente desaconselhável.</span><span class="sxs-lookup"><span data-stu-id="aed81-137">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="aed81-138">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-138">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="aed81-139">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-139">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-140">Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" /> usando o tipo de soquete e o protocolo especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-140">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-141">O `socketType` parâmetro especifica o tipo do <xref:System.Net.Sockets.Socket> classe e o `protocolType` parâmetro especifica o protocolo usado pelo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-141">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-142">Os dois parâmetros não são independentes.</span><span class="sxs-lookup"><span data-stu-id="aed81-142">The two parameters are not independent.</span></span> <span data-ttu-id="aed81-143">Geralmente o <xref:System.Net.Sockets.Socket> tipo está implícito no protocolo.</span><span class="sxs-lookup"><span data-stu-id="aed81-143">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="aed81-144">Se a combinação de <xref:System.Net.Sockets.Socket> tipo e o protocolo digite resultados inválido <xref:System.Net.Sockets.Socket>, este construtor lança um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-144">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-145">Se este construtor lança um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-145">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-146">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-146">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-147">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-147">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-148">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-148">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-149">A combinação de <paramref name="socketType" /> e <paramref name="protocolType" /> resulta em um soquete inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-149">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="aed81-150">Um dos valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-150">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="aed81-151">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-151">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="aed81-152">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-152">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-153">Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" /> usando a família de endereços, o tipo de soquete e o protocolo especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-153">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-154">O `addressFamily` parâmetro especifica o esquema de endereçamento que o <xref:System.Net.Sockets.Socket> classe usos, o `socketType` parâmetro especifica o tipo do <xref:System.Net.Sockets.Socket> classe e o `protocolType` parâmetro especifica o protocolo usado pelo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-154">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-155">Os três parâmetros não são independentes.</span><span class="sxs-lookup"><span data-stu-id="aed81-155">The three parameters are not independent.</span></span> <span data-ttu-id="aed81-156">Algumas famílias de endereço restringem quais protocolos podem ser usados com eles e geralmente o <xref:System.Net.Sockets.Socket> tipo está implícito no protocolo.</span><span class="sxs-lookup"><span data-stu-id="aed81-156">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="aed81-157">Se a combinação de família de endereço, <xref:System.Net.Sockets.Socket> tipo e resultados de tipo inválido do protocolo <xref:System.Net.Sockets.Socket>, este construtor lança um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-157">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-158">Se este construtor lança um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-158">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-159">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-159">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-160">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-160">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-161">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-161">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-162">O exemplo de código a seguir demonstra como criar uma instância do <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="aed81-162">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-163">A combinação de <paramref name="addressFamily" />, <paramref name="socketType" /> e <paramref name="protocolType" /> resulta em um soquete inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-163">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aed81-164">Cria um novo <see cref="T:System.Net.Sockets.Socket" /> para uma conexão recém-criada.</span><span class="sxs-lookup"><span data-stu-id="aed81-164">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="aed81-165">Um <see cref="T:System.Net.Sockets.Socket" /> para uma conexão recém-criada.</span><span class="sxs-lookup"><span data-stu-id="aed81-165">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-166"><xref:System.Net.Sockets.Socket.Accept%2A> modo síncrono extrai a primeira solicitação de conexão pendente da fila de solicitações de conexão de soquete de escuta e, em seguida, cria e retorna um novo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-166"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-167">Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais.</span><span class="sxs-lookup"><span data-stu-id="aed81-167">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="aed81-168">No entanto, você pode chamar o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> método retornado <xref:System.Net.Sockets.Socket> para identificar o número de porta e endereço de rede do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-168">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="aed81-169">No modo de bloqueio, <xref:System.Net.Sockets.Socket.Accept%2A> bloqueia até que uma tentativa de conexão de entrada está na fila.</span><span class="sxs-lookup"><span data-stu-id="aed81-169">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="aed81-170">Depois que uma conexão é aceita, o original <xref:System.Net.Sockets.Socket> continua a conexão de enfileiramento de mensagens de entrada solicitações até que você feche-lo.</span><span class="sxs-lookup"><span data-stu-id="aed81-170">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="aed81-171">Se você chamar este método usando sem bloqueio <xref:System.Net.Sockets.Socket>e nenhuma conexão solicitações são enfileiradas, <xref:System.Net.Sockets.Socket.Accept%2A> lança um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-171">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-172">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-172">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-173">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-173">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-174">Antes de chamar o <xref:System.Net.Sockets.Socket.Accept%2A> método, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-174">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-175">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-176">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-177">O exemplo de código a seguir aceita um simples <xref:System.Net.Sockets.Socket> conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-177">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-178">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-178">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-179">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-179">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-180">O soquete de aceitação não está escutando conexões.</span><span class="sxs-lookup"><span data-stu-id="aed81-180">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="aed81-181">É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-181">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-182">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-182">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-183">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-183">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="aed81-184">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-184">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-185">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-185">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-186">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-186">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-187">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será acionado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-187">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-188">Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> tentativas de método para processar a conexão de entrada de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-188">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="aed81-189">Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-189">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="aed81-190">Antes de chamar o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-190">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="aed81-191">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e associá-lo para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="aed81-191">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="aed81-192">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias:</span><span class="sxs-lookup"><span data-stu-id="aed81-192">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-193">O chamador pode especificar opcionalmente um existente <xref:System.Net.Sockets.Socket> a ser usado para a conexão de entrada, especificando o <xref:System.Net.Sockets.Socket> para usar com o <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-193">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="aed81-194">Se o <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriedade for nula, uma nova <xref:System.Net.Sockets.Socket> é construído com o mesmo <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, e <xref:System.Net.Sockets.Socket.ProtocolType%2A> atual <xref:System.Net.Sockets.Socket> e defina como o <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-194">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="aed81-195">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-195">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-196">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-196">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-197">Opcionalmente, um buffer pode ser fornecido no qual deseja receber o bloco inicial de dados no soquete após o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método for bem-sucedido.</span><span class="sxs-lookup"><span data-stu-id="aed81-197">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="aed81-198">Nesse caso, o <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriedade deve ser definida para o buffer que contém os dados para receber e <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade precisa ser definido como o número máximo de bytes de dados para o buffer de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-198">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="aed81-199">Essas propriedades podem ser definidas usando o <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-199">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aed81-200">Parte do buffer transmitido será consumido internamente para uso pela chamada de Winsock AcceptEx subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-200">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="aed81-201">Isso significa que a quantidade de dados retornados será sempre menor que o valor da <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade o <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instância fornecida.</span><span class="sxs-lookup"><span data-stu-id="aed81-201">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="aed81-202">A quantidade de buffer usado internamente varia de acordo com a família de endereços do soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-202">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="aed81-203">O tamanho de buffer mínimo necessário é 288 bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-203">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="aed81-204">Se um tamanho de buffer maior for especificado, o <xref:System.Net.Sockets.Socket> esperam que alguns dados adicionais que não sejam os dados de endereço recebidos pela chamada Winsock AcceptEx e aguardará até que esses dados extras são recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-204">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="aed81-205">Se ocorrer uma expiração, a conexão será redefinida.</span><span class="sxs-lookup"><span data-stu-id="aed81-205">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="aed81-206">Então se dados extras esperados de um valor específico, o tamanho do buffer deve ser definido para o tamanho do buffer mínimo mais esse valor.</span><span class="sxs-lookup"><span data-stu-id="aed81-206">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="aed81-207">O método de retorno de chamada de conclusão deve examinar o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> para determinar se o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> a operação foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="aed81-207">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="aed81-208">O <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento pode ocorrer em alguns casos, quando nenhuma conexão foi aceito e fazer com que o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propriedade a ser definida <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span><span class="sxs-lookup"><span data-stu-id="aed81-208">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="aed81-209">Isso pode ocorrer como resultado da verificação de portas com uma verificação de tipo entreaberto sin (um SYN -> SYN ACK-> sequência da primeira).</span><span class="sxs-lookup"><span data-stu-id="aed81-209">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="aed81-210">Aplicativos que usam o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método deve estar preparado para tratar essa condição.</span><span class="sxs-lookup"><span data-stu-id="aed81-210">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-211">Um argumento não é válido.</span><span class="sxs-lookup"><span data-stu-id="aed81-211">An argument is not valid.</span></span> <span data-ttu-id="aed81-212">Essa exceção ocorre se o buffer fornecido não for grande o suficiente.</span><span class="sxs-lookup"><span data-stu-id="aed81-212">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="aed81-213">O buffer deve ter pelo menos 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-213">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
 <span data-ttu-id="aed81-214">Essa exceção também ocorre se vários buffers forem especificados e a propriedade <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> não for nula.</span><span class="sxs-lookup"><span data-stu-id="aed81-214">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-215">Um argumento está fora do intervalo.</span><span class="sxs-lookup"><span data-stu-id="aed81-215">An argument is out of range.</span></span> <span data-ttu-id="aed81-216">A exceção ocorre se o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> for menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-216">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-217">Uma operação inválida foi solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-217">An invalid operation was requested.</span></span> <span data-ttu-id="aed81-218">Essa exceção ocorre se o <see cref="T:System.Net.Sockets.Socket" /> aceito não estiver escutando conexões ou se o soquete aceito estiver associado.</span><span class="sxs-lookup"><span data-stu-id="aed81-218">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
 <span data-ttu-id="aed81-219">Você deve chamar o método <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar o método <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-219">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
 <span data-ttu-id="aed81-220">Essa exceção também ocorre se o soquete já estiver conectado ou se uma operação de soquete já estivesse em andamento usando o parâmetro <paramref name="e" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-220">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-221">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-221">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-222">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-222">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-223">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-223">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-224">Obtém a família de endereços do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-224">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-225">Um dos valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-225">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-226">O <xref:System.Net.Sockets.AddressFamily> Especifica o esquema de endereçamento que uma instância do <xref:System.Net.Sockets.Socket> pode usar a classe.</span><span class="sxs-lookup"><span data-stu-id="aed81-226">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="aed81-227">Essa propriedade é somente leitura e é definida quando o <xref:System.Net.Sockets.Socket> é criado.</span><span class="sxs-lookup"><span data-stu-id="aed81-227">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-228">O código a seguir exemplo exibe o <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> para o console.</span><span class="sxs-lookup"><span data-stu-id="aed81-228">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-229">Obtém a quantidade de dados recebidos da rede e disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-229">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="aed81-230">O número de bytes de dados recebidos da rede e disponíveis para serem lidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-230">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-231">Se você estiver usando sem bloqueio <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> é uma boa maneira de determinar se a dados está na fila para leitura, antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-231">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-232">Os dados disponíveis serão a quantidade total de dados no buffer de rede para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-232">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="aed81-233">Se nenhum dado é enfileirado no buffer de rede, <xref:System.Net.Sockets.Socket.Available%2A> retornará 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-233">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="aed81-234">Se o host remoto é desligado ou fecha a conexão, <xref:System.Net.Sockets.Socket.Available%2A> pode lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-234">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-235">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-235">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-236">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-236">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-237">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-237">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-238">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-238">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-239">O exemplo de código a seguir compara os resultados da chamada IOControl com FIONREAD e a propriedade disponível.</span><span class="sxs-lookup"><span data-stu-id="aed81-239">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-240">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-240">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-241">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-241">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-242">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-242">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="aed81-243">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-243">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-244">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-244">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-245">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-245">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="aed81-246">Um <see cref="T:System.IAsyncResult" /> que faz referência à criação assíncrona do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-246">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-247">Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> tentativas de método para processar a conexão de entrada de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-247">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="aed81-248">Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-248">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="aed81-249">Antes de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-249">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="aed81-250">Você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-250">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-251">Para fazer isso, no mínimo, você deve passar a escuta <xref:System.Net.Sockets.Socket> do objeto para <xref:System.Net.Sockets.Socket.BeginAccept%2A> por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-251">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="aed81-252">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-252">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-253">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-253">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-254">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-254">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="aed81-255">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndAccept%2A> até que uma conexão pendente seja recuperada.</span><span class="sxs-lookup"><span data-stu-id="aed81-255">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="aed81-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> Retorna um novo <xref:System.Net.Sockets.Socket> do objeto que você pode usar para enviar e receber dados com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-256"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="aed81-257">Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais.</span><span class="sxs-lookup"><span data-stu-id="aed81-257">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="aed81-258">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-258">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-259">Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-259">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="aed81-260">O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-260">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="aed81-261">Nesse caso, o <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornado <xref:System.IAsyncResult> será definida para indicar que o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método concluído de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-261">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="aed81-262">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-262">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-263">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-263">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-264">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-264">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="aed81-265">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndAccept%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-265">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-266">Você pode usar o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade retornado <xref:System.Net.Sockets.Socket> para identificar o número de porta e endereço de rede do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-266">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-267">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-267">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-268">Depois de obter esse código, consulte a Windows Sockets versão 2 API documentação códigos de erro no MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-268">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-269">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-269">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-270">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-270">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-271">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-271">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-272">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-272">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-273">O exemplo de código a seguir tenta receber uma conexão de entrada de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-273">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-274">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-274">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-275">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-275">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-276">O soquete de aceitação não está escutando conexões.</span><span class="sxs-lookup"><span data-stu-id="aed81-276">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="aed81-277">É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-277">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="aed81-278">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-278">-or-</span></span>  
  
 <span data-ttu-id="aed81-279">O soquete aceito está associado.</span><span class="sxs-lookup"><span data-stu-id="aed81-279">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-280"><paramref name="receiveSize" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-280"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-281">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-281">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="aed81-282">O número de bytes a serem aceitos do remetente.</span><span class="sxs-lookup"><span data-stu-id="aed81-282">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-283">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-283">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-284">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-284">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-285">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada e recebe o primeiro bloco de dados enviado pelo aplicativo cliente.</span><span class="sxs-lookup"><span data-stu-id="aed81-285">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="aed81-286">Um <see cref="T:System.IAsyncResult" /> que faz referência à criação assíncrona do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-286">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-287">Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> tentativas de método para processar a conexão de entrada de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-287">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="aed81-288">Aceitando conexões de forma assíncrona permite enviar e receber dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-288">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="aed81-289">Essa sobrecarga permite que você especifique o número de bytes para aceitar a transferência inicial no `receiveSize` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-289">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="aed81-290">Antes de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-290">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="aed81-291">Você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-291">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-292">Para fazer isso, no mínimo, você deve passar a escuta <xref:System.Net.Sockets.Socket> do objeto para <xref:System.Net.Sockets.Socket.BeginAccept%2A> por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-292">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="aed81-293">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-293">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-294">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-294">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-295">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-295">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="aed81-296">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndAccept%2A> até que uma conexão pendente seja recuperada.</span><span class="sxs-lookup"><span data-stu-id="aed81-296">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="aed81-297"><xref:System.Net.Sockets.Socket.EndAccept%2A> Retorna um novo <xref:System.Net.Sockets.Socket> que você pode usar para enviar e receber dados com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-297"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="aed81-298">Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais.</span><span class="sxs-lookup"><span data-stu-id="aed81-298">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="aed81-299">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-299">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-300">Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-300">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="aed81-301">O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-301">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="aed81-302">Nesse caso, o <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornado <xref:System.IAsyncResult> será definida para indicar que o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método concluído de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-302">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="aed81-303">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-303">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-304">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-304">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="aed81-305">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-305">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="aed81-306">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndAccept%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-306">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-307">Você pode chamar o uso de <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade retornado <xref:System.Net.Sockets.Socket> objeto para identificar o número de porta e endereço de rede do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-307">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-308">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-308">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-309">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-309">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-310">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-310">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-311">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-311">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-312">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-312">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-313">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-313">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-314">O exemplo de código a seguir abre um soquete e aceita uma conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-314">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="aed81-315">Neste exemplo, o soquete aceita inicias 10 bytes de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-315">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="aed81-316">O número de bytes recebidos e os dados são exibidos no console, o representante de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-316">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="aed81-317">Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obter uma descrição de como os dados restantes são recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-317">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-318">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-318">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-319">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-319">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-320">O soquete de aceitação não está escutando conexões.</span><span class="sxs-lookup"><span data-stu-id="aed81-320">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="aed81-321">É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-321">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="aed81-322">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-322">-or-</span></span>  
  
 <span data-ttu-id="aed81-323">O soquete aceito está associado.</span><span class="sxs-lookup"><span data-stu-id="aed81-323">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-324"><paramref name="receiveSize" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-324"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-325">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-325">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="aed81-326">O objeto <see cref="T:System.Net.Sockets.Socket" /> aceito.</span><span class="sxs-lookup"><span data-stu-id="aed81-326">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="aed81-327">Este valor pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-327">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="aed81-328">O número máximo de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-328">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-329">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-329">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-330">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-330">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-331">Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada de um soquete especificado e recebe o primeiro bloco de dados enviado pelo aplicativo cliente.</span><span class="sxs-lookup"><span data-stu-id="aed81-331">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="aed81-332">Um objeto <see cref="T:System.IAsyncResult" /> que faz referência à criação do objeto <see cref="T:System.Net.Sockets.Socket" /> assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-332">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-333">Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> tentativas de método para processar a conexão de entrada de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-333">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="aed81-334">Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-334">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="aed81-335">Essa sobrecarga permite que você especifique o soquete aceito o `acceptSocket` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-335">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="aed81-336">Se esse parâmetro for `null`, o soquete aceito é criado pelo <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-336">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-337">Você pode especificar o número de bytes para aceitar a transferência inicial no `receiveSize` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-337">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="aed81-338">Antes de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-338">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="aed81-339">Você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-339">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-340">Para fazer isso, no mínimo, você deve passar a escuta <xref:System.Net.Sockets.Socket> do objeto para <xref:System.Net.Sockets.Socket.BeginAccept%2A> por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-340">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="aed81-341">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-341">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-342">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-342">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-343">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-343">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="aed81-344">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndAccept%2A> até que uma conexão pendente seja recuperada.</span><span class="sxs-lookup"><span data-stu-id="aed81-344">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="aed81-345"><xref:System.Net.Sockets.Socket.EndAccept%2A> Retorna um novo <xref:System.Net.Sockets.Socket> do objeto que você pode usar para enviar e receber dados com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-345"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="aed81-346">Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais.</span><span class="sxs-lookup"><span data-stu-id="aed81-346">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="aed81-347">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-347">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-348">Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-348">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="aed81-349">O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-349">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="aed81-350">Nesse caso, o <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornado <xref:System.IAsyncResult> será definida para indicar que o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método concluído de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-350">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="aed81-351">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-351">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-352">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-352">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-353">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-353">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="aed81-354">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndAccept%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-354">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-355">Você pode usar o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade retornado <xref:System.Net.Sockets.Socket> objeto para identificar o número de porta e endereço de rede do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-355">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-356">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-356">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-357">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-357">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-358">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-359">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-360">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-360">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-361">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-361">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-362">O exemplo de código a seguir abre um soquete e aceita uma conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-362">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="aed81-363">Neste exemplo, o soquete aceita inicias 10 bytes de dados e o `acceptSocket` parâmetro é `null`, que força o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método para criar o soquete aceito.</span><span class="sxs-lookup"><span data-stu-id="aed81-363">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="aed81-364">O número de bytes recebidos e os dados são exibidos no console, o representante de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-364">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="aed81-365">Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obter uma descrição de como os dados restantes são recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-365">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-366">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-366">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-367">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-367">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-368">O soquete de aceitação não está escutando conexões.</span><span class="sxs-lookup"><span data-stu-id="aed81-368">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="aed81-369">É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-369">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
 <span data-ttu-id="aed81-370">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-370">-or-</span></span>  
  
 <span data-ttu-id="aed81-371">O soquete aceito está associado.</span><span class="sxs-lookup"><span data-stu-id="aed81-371">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-372"><paramref name="receiveSize" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-372"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-373">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-373">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-374">Inicia uma solicitação assíncrona para uma conexão de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-374">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback"><span data-ttu-id="aed81-375">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-375">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-376">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-376">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-377">Inicia uma solicitação assíncrona para uma conexão de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-377">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="aed81-378">Um <see cref="T:System.IAsyncResult" /> que faz referência à conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-378">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-379">Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método inicia uma solicitação assíncrona para uma conexão para o `remoteEP` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-379">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="aed81-380">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.BeginConnect%2A> estabelece um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-380">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="aed81-381">Conectar ou configurar o host remoto padrão assincronamente fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-381">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-382">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-382">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="aed81-383">No mínimo, você deve passar o <xref:System.Net.Sockets.Socket> para <xref:System.Net.Sockets.Socket.BeginConnect%2A> por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-383">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="aed81-384">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket>e as outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-384">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="aed81-385">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-385">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-386">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-386">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="aed81-387">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndConnect%2A> até que o <xref:System.Net.Sockets.Socket> se conecta com êxito ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-387">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="aed81-388">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-388">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="aed81-389">Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-389">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-390">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-390">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-391">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-391">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-392">Você pode usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> para se comunicar com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-392">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="aed81-393">Se você chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-393">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-394">Se você deseja definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e defina a transmissão para `true`.</span><span class="sxs-lookup"><span data-stu-id="aed81-394">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="aed81-395">Se não for possível, <xref:System.Net.Sockets.Socket.BeginConnect%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-395">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-396">Se você estiver usando um protocolo orientado a conexão e não chame <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-396">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="aed81-397">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até que você chame o <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-397">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-398">Se você quiser alterar o host remoto padrão, chame o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-398">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="aed81-399">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-399">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-400">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-400">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="aed81-401">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-401">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-402">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-402">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-403">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-403">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-404">Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-404">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="aed81-405">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-405">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-406">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-406">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-407">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-407">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-408">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-408">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-409">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-409">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-410">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-410">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-411"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-411"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-412">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-412">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-413">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-413">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-414">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-414">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-415">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> ou uma operação assíncrona já está em andamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-415">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="aed81-416">O <see cref="T:System.Net.IPAddress" /> do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-416">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="aed81-417">O número da porta do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-417">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="aed81-418">Um objeto definido pelo usuário que contém informações sobre a operação de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-418">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="aed81-419">Este objeto é passado para o delegado <c>requestCallback</c> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-419">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-420">Inicia uma solicitação assíncrona para uma conexão de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-420">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="aed81-421">O host é especificado por um <see cref="T:System.Net.IPAddress" /> e um número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-421">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="aed81-422">Um <see cref="T:System.IAsyncResult" /> que faz referência à conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-422">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-423">O assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-423">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="aed81-424">Normalmente, o método é invocado pelo `requestCallback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-424">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-425">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-425">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-426">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas de método ou <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-426">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-427">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-427">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-428">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-428">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="aed81-429">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-429">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="aed81-430">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="aed81-430">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-431">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-431">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-432">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-432">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-433">Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-433">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="aed81-434">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-434">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="aed81-435">Também o <xref:System.Net.EndPoint> que é usado deve ser diferente.</span><span class="sxs-lookup"><span data-stu-id="aed81-435">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-436">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-436">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-437">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-437">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-438">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-438">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-439">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-439">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-440">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-440">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-441"><paramref name="address" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-441"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-442">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-442">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-443">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-443">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-444">O <see cref="T:System.Net.Sockets.Socket" /> não está na família do soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-444">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-445">O número da porta é inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-445">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-446">O comprimento de <paramref name="address" /> é zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-446">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-447">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> ou uma operação assíncrona já está em andamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-447">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="aed81-448">Pelo menos um <see cref="T:System.Net.IPAddress" />, designando o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-448">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="aed81-449">O número da porta do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-449">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="aed81-450">Um objeto definido pelo usuário que contém informações sobre a operação de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-450">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="aed81-451">Este objeto é passado para o delegado <c>requestCallback</c> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-451">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-452">Inicia uma solicitação assíncrona para uma conexão de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-452">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="aed81-453">O host é especificado por uma matriz <see cref="T:System.Net.IPAddress" /> e um número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-453">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="aed81-454">Um <see cref="T:System.IAsyncResult" /> que faz referência a conexões assíncronas.</span><span class="sxs-lookup"><span data-stu-id="aed81-454">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-455">O assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-455">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="aed81-456">Normalmente, o método é invocado pelo `requestCallback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-456">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-457">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-457">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-458">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="aed81-458">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="aed81-459">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-459">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-460">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-460">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="aed81-461">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-461">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="aed81-462">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-462">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-463">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-463">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-464">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-464">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-465">Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-465">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="aed81-466">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-466">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="aed81-467">Também o <xref:System.Net.EndPoint> que é usado deve ser diferente.</span><span class="sxs-lookup"><span data-stu-id="aed81-467">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-468">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-468">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-469">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-469">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-470">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-470">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-471">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-471">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-472">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-472">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-473"><paramref name="addresses" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-473"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-474">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-474">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-475">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-475">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-476">Este método é válido para soquetes que usam <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-476">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-477">O número da porta é inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-477">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-478">O comprimento de <paramref name="address" /> é zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-478">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-479">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> ou uma operação assíncrona já está em andamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-479">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="aed81-480">O nome do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-480">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="aed81-481">O número da porta do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-481">The port number of the remote host.</span></span></param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state"><span data-ttu-id="aed81-482">Um objeto definido pelo usuário que contém informações sobre a operação de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-482">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="aed81-483">Este objeto é passado para o delegado <c>requestCallback</c> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-483">This object is passed to the <c>requestCallback</c> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-484">Inicia uma solicitação assíncrona para uma conexão de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-484">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="aed81-485">O host é especificado por um nome do host e um número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-485">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="aed81-486">Um <see cref="T:System.IAsyncResult" /> que faz referência à conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-486">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-487">O assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-487">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="aed81-488">Normalmente, o método é invocado pelo `requestCallback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-488">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-489">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-489">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-490">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="aed81-490">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="aed81-491">Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-491">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-492">Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="aed81-492">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="aed81-493">Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.</span><span class="sxs-lookup"><span data-stu-id="aed81-493">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="aed81-494">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="aed81-494">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-495">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-495">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-496">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-496">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-497">Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-497">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="aed81-498">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-498">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="aed81-499">Também o <xref:System.Net.EndPoint> que é usado deve ser diferente.</span><span class="sxs-lookup"><span data-stu-id="aed81-499">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-500">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-500">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-501">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-501">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-502">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-502">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-503">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-503">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-504">O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-504">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-505"><paramref name="host" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-505"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-506">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-506">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-507">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-507">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-508">O número da porta é inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-508">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-509">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> ou uma operação assíncrona já está em andamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-509">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="aed81-510"><see langword="true" /> se o soquete puder ser reutilizado após a conexão ser fechada; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-510"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-511">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-511">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-512">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-512">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-513">Inicia uma solicitação assíncrona para se desconectar de um ponto de extremidade remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-513">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-514">Um objeto <see cref="T:System.IAsyncResult" /> que faz referência à operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-514">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-515">Se você estiver usando um protocolo orientado a conexão, você pode chamar o <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método para solicitar uma desconexão de um ponto de extremidade remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-515">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="aed81-516">Se `reuseSocket` é `true`, você pode reutilizar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-516">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="aed81-517">O <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método usa um thread separado para invocar o método de retorno de chamada especificada.</span><span class="sxs-lookup"><span data-stu-id="aed81-517">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="aed81-518">O <xref:System.Net.Sockets.Socket.EndDisconnect%2A> blocos de método até a desconexão pendente é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-518">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="aed81-519">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-519">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-520">Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-520">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-521">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-521">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-522">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-522">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-523">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-523">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-524">O exemplo de código a seguir cria um soquete para comunicação assíncrona e envia alguns dados para um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-524">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="aed81-525">Quando os dados foram enviados, <xref:System.Net.Sockets.Socket.Shutdown%2A> é chamado para parar o envio e a atividade de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-525">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="aed81-526">Em seguida, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> é chamado para iniciar uma solicitação de desconexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-526">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="aed81-527">Quando a solicitação é concluída, o <xref:System.Net.Sockets.Socket.Connected%2A> propriedade será consultada para testar se o soquete está desconectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-527">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-528">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</span><span class="sxs-lookup"><span data-stu-id="aed81-528">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-529">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-529">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-530">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-530">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-531">Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-531">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-532">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-532">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-533">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-533">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-534">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-534">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-535">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-535">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="aed81-536">Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-536">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-537">Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-537">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-538">Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-538">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-539">O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-539">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="aed81-540">Normalmente, o método é invocado pelo `callback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-540">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-541">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-541">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-542">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="aed81-542">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="aed81-543">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-543">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-544">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-544">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-545">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-545">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-546">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-546">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-547">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-547">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-548">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-548">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-549">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-549">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-550">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-550">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-551">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-551">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-552">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-552">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-553">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-553">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-554"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-554"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-555">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-555">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="aed81-556">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-556"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-557">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-557">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-558">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-558">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-559">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-559">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-560">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-560">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-561">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-561">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="aed81-562">Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-562">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-563">Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-563">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-564">Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-564">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-565">O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-565">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="aed81-566">Normalmente, o método é invocado pelo `callback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-566">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-567">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-567">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-568">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="aed81-568">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="aed81-569">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-569">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-570">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-570">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-571">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-571">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-572">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-572">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-573">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-573">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-574">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-574">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-575">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-575">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-576">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-576">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-577">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-577">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-578">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-578">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-579">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-579">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-580"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-580"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-581">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-581">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="aed81-582">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-582"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-583">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-583">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-584">A posição baseada em zero no parâmetro <c>buffer</c> no qual armazenar os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-584">The zero-based position in the <c>buffer</c> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-585">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-585">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><span data-ttu-id="aed81-586">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-586">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-587">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-587">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="aed81-588">Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-588">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-589">Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-589">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-590">Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-590">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-591">O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-591">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="aed81-592">Normalmente, o método é invocado pelo `callback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-592">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-593">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-593">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-594">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="aed81-594">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="aed81-595">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-595">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-596">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-596">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-597">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-597">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-598">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-598">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-599">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-599">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-600">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-600">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-601">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-601">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-602">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-602">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-603">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-603">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-604">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-604">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-605">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-605">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-606">O exemplo de código a seguir começa assincronamente receba dados de um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-606">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-607"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-607"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-608">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-608">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="aed81-609">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-609"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-610"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-610"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-611">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-611">-or-</span></span>  
  
 <span data-ttu-id="aed81-612"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-612"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-613">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-613">-or-</span></span>  
  
 <span data-ttu-id="aed81-614"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-614"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-615">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-615">-or-</span></span>  
  
 <span data-ttu-id="aed81-616"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-616"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-617">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-617">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-618">O local no <c>buffer</c> para armazenar os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-618">The location in <c>buffer</c> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-619">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-619">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback"><span data-ttu-id="aed81-620">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-620">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-621">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-621">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="aed81-622">Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-622">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="aed81-623">Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-623">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-624">Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-624">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-625">O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-625">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="aed81-626">Normalmente, o método é invocado pelo `callback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-626">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-627">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-627">This method does not block until the operation is complete.</span></span> <span data-ttu-id="aed81-628">Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.</span><span class="sxs-lookup"><span data-stu-id="aed81-628">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="aed81-629">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-629">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-630">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-630">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-631">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-631">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-632">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-632">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-633">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-633">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-634">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-634">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-635">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-635">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-636">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-636">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-637">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-637">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-638">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-638">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-639">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-639">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-640"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-640"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-641">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-641">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="aed81-642">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-642"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-643"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-643"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-644">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-644">-or-</span></span>  
  
 <span data-ttu-id="aed81-645"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-645"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-646">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-646">-or-</span></span>  
  
 <span data-ttu-id="aed81-647"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-647"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-648">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-648">-or-</span></span>  
  
 <span data-ttu-id="aed81-649"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-649"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-650">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-650">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-651">A posição baseada em zero no parâmetro <c>buffer</c> no qual armazenar os dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-651">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-652">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-652">The number of bytes to receive.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><span data-ttu-id="aed81-653">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-653">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-654">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-654">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-655">Começa a receber dados de um dispositivo de rede especificado de maneira assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-655">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="aed81-656">Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-656">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-657">O <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método inicia de forma assíncrona lendo datagramas sem conexão de um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-657">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="aed81-658">Chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método lhe oferece a capacidade de receber dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-658">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-659">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-659">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-660">Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-660">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="aed81-661">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-661">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-662">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-662">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-663">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-663">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-664">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e ela bloqueará <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> até que o <xref:System.Net.Sockets.Socket> lê os dados ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-664">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="aed81-665">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-665">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-666">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-666">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-667">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-667">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-668">Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método, ou <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-668">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-669">Esse método lê os dados para o `buffer` parâmetro e capturas de ponto de extremidade do qual os dados são enviados de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-669">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="aed81-670">Para obter informações sobre como recuperar esse ponto de extremidade, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-670">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="aed81-671">Esse método é mais útil se você pretende assincronamente receber datagramas sem conexão de um host desconhecido ou vários hosts.</span><span class="sxs-lookup"><span data-stu-id="aed81-671">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="aed81-672">Nesses casos, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-672">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="aed81-673">Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-673">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-674">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</span><span class="sxs-lookup"><span data-stu-id="aed81-674">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="aed81-675">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método com um buffer grande o suficiente.</span><span class="sxs-lookup"><span data-stu-id="aed81-675">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="aed81-676">Para garantir que o ponto de extremidade do host remoto é sempre retornado, um aplicativo deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método e em seguida, chame o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método com o `optionLevel` parâmetro definido como <xref:System.Net.Sockets.SocketOptionLevel.IP> ou <xref:System.Net.Sockets.SocketOptionLevel.IPv6> conforme apropriado, o `optionName` parâmetro definido como <xref:System.Net.Sockets.SocketOptionName.PacketInformation>e o `optionValue` parâmetro para habilitar essa opção antes de chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-676">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-677">Caso contrário, é possível que o ponto de extremidade do host remoto para não ser retornado quando o remetente enviou um número de datagramas antes que o destinatário tem o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-677">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-678">Embora <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</span><span class="sxs-lookup"><span data-stu-id="aed81-678">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="aed81-679">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> método ou aceitar uma solicitação de conexão de entrada ao chamar o <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-679">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-680">Se você chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método antes de estabelecer ou aceitar uma conexão, você obterá um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-680">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-681">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-681">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-682">Em ambos os casos, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-682">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-683">Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lerá a quantidade de dados está disponível até o número de bytes especificado pelo `size` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-683">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="aed81-684">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-684">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-685">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-685">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-686">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-686">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-687">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-687">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-688">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-688">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-689">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-689">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-690">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-690">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-691">O exemplo de código a seguir recebe de maneira assíncrona datagramas sem conexão de um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-691">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-692"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-692"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-693">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-693">-or-</span></span>  
  
 <span data-ttu-id="aed81-694"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-694"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-695">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-695">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-696"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-696"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-697">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-697">-or-</span></span>  
  
 <span data-ttu-id="aed81-698"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-698"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-699">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-699">-or-</span></span>  
  
 <span data-ttu-id="aed81-700"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-700"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-701">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-701">-or-</span></span>  
  
 <span data-ttu-id="aed81-702"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-702"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-703">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-703">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-704">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-704">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-705">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-705">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-706">A posição baseada em zero no parâmetro <c>buffer</c> no qual armazenar os dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-706">The zero-based position in the <c>buffer</c> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-707">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-707">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-708">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-708">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-709">Um <see cref="T:System.Net.EndPoint" /> que representa a fonte de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-709">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-710">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-710">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-711">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-711">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-712">Inicia o recebimento de forma assíncrona do número especificado de bytes de dados no local especificado do buffer de dados, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena as informações de ponto de extremidade e de pacote.</span><span class="sxs-lookup"><span data-stu-id="aed81-712">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information..</span></span></summary>
        <returns><span data-ttu-id="aed81-713">Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-713">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-714">Operação de recebimento assíncronos devem ser concluídas por chamar o <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-714">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="aed81-715">Normalmente, o método é invocado pelo `asyncCallback` delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-715">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="aed81-716">Esse método não bloqueia até que a operação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-716">This method does not block until the operation completes.</span></span> <span data-ttu-id="aed81-717">Para bloquear até a conclusão da operação, use o <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-717">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-718">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-718">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-719">Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="aed81-719">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="aed81-720">Esse método lê os dados para o `buffer` parâmetro e capturas de ponto de extremidade do qual os dados são enviados de host remoto, bem como informações sobre o pacote recebido.</span><span class="sxs-lookup"><span data-stu-id="aed81-720">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="aed81-721">Para obter informações sobre como recuperar esse ponto de extremidade, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-721">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="aed81-722">Esse método é mais útil se você pretende assincronamente receber datagramas sem conexão de um host desconhecido ou vários hosts.</span><span class="sxs-lookup"><span data-stu-id="aed81-722">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-723">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-723">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-724">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-724">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-725">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-725">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-726">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-726">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-727">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-727">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-728">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-728">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-729"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-729"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-730">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-730">-or-</span></span>  
  
 <span data-ttu-id="aed81-731"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-731"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-732">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-732">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-733"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-733"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-734">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-734">-or-</span></span>  
  
 <span data-ttu-id="aed81-735"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-735"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-736">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-736">-or-</span></span>  
  
 <span data-ttu-id="aed81-737"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-737"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-738">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-738">-or-</span></span>  
  
 <span data-ttu-id="aed81-739"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-739"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-740">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-740">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-741">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</span><span class="sxs-lookup"><span data-stu-id="aed81-741">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-742">Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-742">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-743">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-743">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-744">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-744">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-745">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-745">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-746">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-746">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-747">Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-747">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-748">Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-748">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-749">O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-749">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-750"><xref:System.Net.Sockets.Socket.BeginSend%2A> lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-750"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-751">Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-751">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-752">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-752">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="aed81-753">Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-753">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="aed81-754">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-754">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-755">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-755">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-756">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-756">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="aed81-757">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-757">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="aed81-758">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-758">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aed81-759">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-759">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-760">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-760">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-761">Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-761">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-762">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-762">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="aed81-763">É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-763">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-764">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-764">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-765">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-765">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-766">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-766">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-767">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-767">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-768">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-768">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-769">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-769">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-770">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-770">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-771">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-771">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-772">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-772">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-773">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-773">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-774">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-774">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-775">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-775">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-776">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-776">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-777">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-777">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-778">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-778">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-779"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-779"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-780"><paramref name="buffers" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-780"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-781">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-781">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-782">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-782">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-783">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-783">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-784">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-784">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-785">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-785">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-786">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-786">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-787">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-787">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-788">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-788">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-789">Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-789">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-790">Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-790">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-791">O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-791">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-792"><xref:System.Net.Sockets.Socket.BeginSend%2A> lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-792"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-793">Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-793">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-794">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-794">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="aed81-795">Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-795">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="aed81-796">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-796">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-797">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-797">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-798">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-798">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="aed81-799">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-799">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="aed81-800">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-800">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aed81-801">Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-801">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-802">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-802">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-803">Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-803">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-804">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-804">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="aed81-805">É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-805">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-806">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-806">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-807">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-807">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-808">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-808">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-809">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-809">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-810">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-810">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-811">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-811">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-812">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-812">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-813">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-813">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-814">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-814">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-815">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-816">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-817">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-818">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-819">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-819">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-820">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-820">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-821"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-821"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-822"><paramref name="buffers" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-822"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-823">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-823">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-824">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-824">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-825">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-825">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-826">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-826">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-827">A posição baseada em zero no parâmetro <c>buffer</c> no qual começar a enviar dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-827">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-828">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-828">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-829">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-829">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-830">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-830">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-831">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-831">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-832">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-832">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-833">Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-833">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-834">Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-834">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-835">O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-835">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-836"><xref:System.Net.Sockets.Socket.BeginSend%2A> lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-836"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-837">Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-837">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-838">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-838">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="aed81-839">Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-839">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="aed81-840">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-840">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-841">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-841">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-842">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-842">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="aed81-843">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-843">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="aed81-844">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-844">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aed81-845">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-845">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-846">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-846">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-847">Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-847">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-848">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-848">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="aed81-849">É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-849">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-850">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-850">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-851">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-851">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-852">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-852">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-853">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-853">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-854">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-854">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-855">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-855">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-856">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-856">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-857">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-857">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-858">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-858">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-859">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-859">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-860">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-860">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-861">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-861">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-862">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-862">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-863">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-863">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-864">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-864">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-865"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-865"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-866">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-866">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-867">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-867">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-868"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-868"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-869">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-869">-or-</span></span>  
  
 <span data-ttu-id="aed81-870"><paramref name="offset" /> é menor que o tamanho de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-870"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-871">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-871">-or-</span></span>  
  
 <span data-ttu-id="aed81-872"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-872"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-873">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-873">-or-</span></span>  
  
 <span data-ttu-id="aed81-874"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-874"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-875">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-875">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-876">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-876">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-877">A posição baseada em zero no parâmetro <c>buffer</c> no qual começar a enviar dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-877">The zero-based position in the <c>buffer</c> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-878">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-878">The number of bytes to send.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback"><span data-ttu-id="aed81-879">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-879">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-880">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-880">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-881">Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-881">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-882">Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-882">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-883">O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-883">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="aed81-884"><xref:System.Net.Sockets.Socket.BeginSend%2A> lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-884"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-885">Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-885">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-886">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-886">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="aed81-887">Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-887">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="aed81-888">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-888">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-889">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-889">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-890">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-890">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="aed81-891">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-891">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="aed81-892">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-892">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aed81-893">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-893">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-894">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-894">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-895">Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-895">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-896">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-896">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="aed81-897">É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-897">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-898">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-898">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-899">Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-899">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-900">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-900">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-901">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-901">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-902">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-902">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-903">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-903">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-904">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-904">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-905">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-905">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-906">`state` é uma instanciação de uma classe definida pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-906">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-907">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-907">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-908">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-908">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-909">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-909">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-910">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-910">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-911">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-911">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-912">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-912">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-913">O exemplo de código a seguir começa assincronamente enviar dados para um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-913">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-914"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-914"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-915">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-915">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-916">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-916">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-917"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-917"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-918">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-918">-or-</span></span>  
  
 <span data-ttu-id="aed81-919"><paramref name="offset" /> é menor que o tamanho de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-919"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-920">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-920">-or-</span></span>  
  
 <span data-ttu-id="aed81-921"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-921"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-922">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-922">-or-</span></span>  
  
 <span data-ttu-id="aed81-923"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-923"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-924">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-924">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-925">Envia um arquivo de forma assíncrona para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-925">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="aed81-926">Uma cadeia de caracteres que contém o caminho e o nome do arquivo a ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-926">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="aed81-927">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-927">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-928">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-928">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-929">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-929">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-930">Envia o arquivo <paramref name="fileName" /> para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado usando o sinalizador <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-930">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="aed81-931">Um objeto <see cref="T:System.IAsyncResult" /> que representa o envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-931">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-932">Essa sobrecarga envia o arquivo `fileName` para o soquete conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-932">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="aed81-933">Se `fileName` está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-933">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="aed81-934">Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados.</span><span class="sxs-lookup"><span data-stu-id="aed81-934">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="aed81-935">Se o arquivo não for encontrado, a exceção <xref:System.IO.FileNotFoundException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="aed81-935">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="aed81-936">Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aed81-936">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="aed81-937">Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-937">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="aed81-938">O <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-938">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="aed81-939"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> gera uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-939"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-940">Chamar o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método permite que você envie um arquivo em um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-940">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-941">Para concluir a operação, você pode criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegar o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-941">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="aed81-942">Para fazer isso, no mínimo, o `state` parâmetro deve conter o <xref:System.Net.Sockets.Socket> do objeto que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-942">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="aed81-943">Se o retorno de chamada precisa de mais informações, você pode criar uma classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-943">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-944">Passar uma instância do objeto personalizado para o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-944">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-945">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSendFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-945">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="aed81-946">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndSendFile%2A> até que o <xref:System.Net.Sockets.Socket> envia todo o arquivo ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-946">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="aed81-947">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-947">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-948">Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-948">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-949">Com protocolos sem conexão, você deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-949">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-950">Se isso acontecer, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-950">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-951">Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-951">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-952">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-952">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-953">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-953">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-954">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-954">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-955">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-955">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-956">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-956">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-957">O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-957">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="aed81-958">Primeiro, o arquivo "Test.txt" é enviado de forma assíncrona ao host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-958">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="aed81-959">O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndSendFile%2A> para concluir a transmissão.</span><span class="sxs-lookup"><span data-stu-id="aed81-959">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-960">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-960">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-961">O soquete não está conectado a um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-961">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="aed81-962">O arquivo <paramref name="fileName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="aed81-962">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-963">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-963">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-964">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-964">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="aed81-965">Uma cadeia de caracteres que contém o caminho e o nome do arquivo a ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-965">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="aed81-966">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-966">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="aed81-967">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados antes de o arquivo ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-967">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="aed81-968">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-968">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="aed81-969">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados depois de o arquivo ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-969">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="aed81-970">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-970">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="aed81-971">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-971">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="aed81-972">Um delegado <see cref="T:System.AsyncCallback" /> a ser invocado quando a operação for concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-972">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="aed81-973">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-973">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-974">Um objeto definido pelo usuário que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-974">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="aed81-975">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-975">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="aed81-976">Envia um arquivo e buffers de dados de forma assíncrona para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-976">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="aed81-977">Um objeto <see cref="T:System.IAsyncResult" /> que representa a operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-977">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-978">Essa sobrecarga requer o nome do arquivo que deseja enviar e uma combinação bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-978">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="aed81-979">O `preBuffer` parâmetro contiver dados deve preceder o arquivo.</span><span class="sxs-lookup"><span data-stu-id="aed81-979">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="aed81-980">`postBuffer` contém dados que você deseja que execute o arquivo.</span><span class="sxs-lookup"><span data-stu-id="aed81-980">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="aed81-981">Se `fileName` está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-981">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="aed81-982">Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados.</span><span class="sxs-lookup"><span data-stu-id="aed81-982">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="aed81-983">Se o arquivo não for encontrado, a exceção <xref:System.IO.FileNotFoundException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="aed81-983">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="aed81-984">O `flags` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos.</span><span class="sxs-lookup"><span data-stu-id="aed81-984">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="aed81-985">Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="aed81-985">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="aed81-986">Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aed81-986">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="aed81-987">Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-987">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="aed81-988">O <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-988">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="aed81-989"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> gera uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-989"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="aed81-990">Chamar o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método lhe oferece a capacidade de enviar um arquivo em um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-990">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-991">Para concluir a operação, você pode criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegar o parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-991">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="aed81-992">Para fazer isso, no mínimo, o `state` parâmetro deve conter o <xref:System.Net.Sockets.Socket> do objeto que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-992">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="aed81-993">Se o retorno de chamada precisa de mais informações, você pode criar uma classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-993">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="aed81-994">Passar uma instância do objeto personalizado para o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-994">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-995">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSendFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-995">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="aed81-996">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndSendFile%2A> até que o <xref:System.Net.Sockets.Socket> envia todo o arquivo ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-996">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="aed81-997">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-997">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-998">Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-998">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-999">Com protocolos sem conexão, você também deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-999">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-1000">Se isso acontecer, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-1000">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1001">Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1001">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1002">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1002">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1003">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1003">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1004">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1004">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1005">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1005">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-1006">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-1006">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1007">O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona e começa a enviar o arquivo "Test.txt" assincronamente para o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1007">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="aed81-1008">Neste exemplo, um `preBuffer` e um `postBuffer` de dados é criado para enviar o arquivo e o padrão <xref:System.Net.Sockets.TransmitFileOptions> valor é usado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1008">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="aed81-1009">O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndSendFile%2A> para concluir a transmissão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1009">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1010">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1010">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1011">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1011">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-1012">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1012">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1013">O sistema operacional não é o Windows NT ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aed81-1013">The operating system is not Windows NT or later.</span></span>  
  
 <span data-ttu-id="aed81-1014">\- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1014">\- or -</span></span>  
  
 <span data-ttu-id="aed81-1015">O soquete não está conectado a um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1015">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="aed81-1016">O arquivo <paramref name="fileName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1016">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-1017">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1017">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-1018">A posição baseada em zero no <c>buffer</c> em que se começa a enviar dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1018">The zero-based position in <c>buffer</c> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-1019">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1019">The number of bytes to send.</span></span></param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback"><span data-ttu-id="aed81-1020">O delegado <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1020">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="aed81-1021">Um objeto que contém informações de estado para essa solicitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1021">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="aed81-1022">Envia dados de maneira assíncrona para um host remoto específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1022">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="aed81-1023">Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1023">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1024">O <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método inicia uma operação de envio assíncrono para o host remoto especificado no `remoteEP` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1024">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="aed81-1025">Chamar o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1025">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="aed81-1026">Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funciona com protocolos sem conexão e orientada a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1026">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="aed81-1027">Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1027">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="aed81-1028">Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1028">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="aed81-1029">Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket>e as outras informações necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-1029">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="aed81-1030">Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método por meio de `state` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1030">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="aed81-1031">O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1031">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="aed81-1032">Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSendTo%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-1032">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="aed81-1033">Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1033">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aed81-1034">Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1034">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="aed81-1035">Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1035">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="aed81-1036">Se você estiver usando um protocolo orientado a conexão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, ou <xref:System.Net.Sockets.Socket.BeginSendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1036">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1037"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignorará a `remoteEP` parâmetro e enviar dados para o <xref:System.Net.EndPoint> estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1037"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1038">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1038">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-1039">Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1039">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="aed81-1040">Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1040">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="aed81-1041">Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1041">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-1042">Nesse caso, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1042">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="aed81-1043">Use um número de porta de zero se quiser que o provedor de serviço subjacente para selecionar uma porta livre.</span><span class="sxs-lookup"><span data-stu-id="aed81-1043">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="aed81-1044">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.EndSendTo%2A> concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1044">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="aed81-1045">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1045">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-1046">-Você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1046">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-1047">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.EndSendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1047">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-1048">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1048">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1049">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1050">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1050">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1051">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1052">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1053">O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1053">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="aed81-1054">Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-1054">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1055">O exemplo de código a seguir assincronamente envia dados para o host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1055">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1056"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1056"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-1057">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1057">-or-</span></span>  
  
 <span data-ttu-id="aed81-1058"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1058"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1059">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1059">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-1060"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-1060"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-1061">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1061">-or-</span></span>  
  
 <span data-ttu-id="aed81-1062"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1062"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-1063">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1063">-or-</span></span>  
  
 <span data-ttu-id="aed81-1064"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-1064"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-1065">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1065">-or-</span></span>  
  
 <span data-ttu-id="aed81-1066"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1066"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1067">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1067">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1068">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1068">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="aed81-1069">O local <see cref="T:System.Net.EndPoint" /> para associar ao <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1069">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="aed81-1070">Associa um <see cref="T:System.Net.Sockets.Socket" /> a um ponto de extremidade local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1070">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1071">Use o <xref:System.Net.Sockets.Socket.Bind%2A> método se você precisa usar um ponto de extremidade local específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1071">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="aed81-1072">Você deve chamar <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1072">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="aed81-1073">Você não precisa chamar <xref:System.Net.Sockets.Socket.Bind%2A> antes de usar o <xref:System.Net.Sockets.Socket.Connect%2A> método, a menos que você precisa usar um ponto de extremidade local específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1073">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="aed81-1074">Você pode usar o <xref:System.Net.Sockets.Socket.Bind%2A> método nos protocolos sem conexão e orientada a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1074">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="aed81-1075">Antes de chamar <xref:System.Net.Sockets.Socket.Bind%2A>, você deve primeiro criar o local <xref:System.Net.IPEndPoint> do qual você pretende comunicação de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1075">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="aed81-1076">Se você não fizer a qual o endereço local é atribuído, você pode criar um <xref:System.Net.IPEndPoint> usando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> como o parâmetro de endereço e o serviço subjacente provedor atribuirá o endereço de rede mais apropriado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1076">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="aed81-1077">Isso pode ajudar a simplificar seu aplicativo, se você tiver várias interfaces de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1077">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="aed81-1078">Se você não fizer a porta local é usada, você pode criar um <xref:System.Net.IPEndPoint> usar 0 como o número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1078">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="aed81-1079">Nesse caso, o provedor de serviços atribuirá um número de porta entre 1024 e 5000.</span><span class="sxs-lookup"><span data-stu-id="aed81-1079">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="aed81-1080">Se você usar a abordagem acima, você pode descobrir o número de porta e endereço de rede local foi atribuído ao chamar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1080">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="aed81-1081">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> não retornará o endereço de rede atribuído localmente até depois que você fez uma chamada para o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.EndConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1081">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="aed81-1082">Se você estiver usando um protocolo sem-conexão, você não terá acesso a essas informações até que você concluiu um envio ou recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1082">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="aed81-1083">Se um soquete UDP deseja receber informações de interface em pacotes recebidos, o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método deve ser chamado explicitamente com a opção de soquete definida como <xref:System.Net.Sockets.SocketOptionName.PacketInformation> imediatamente depois de chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1083">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1084">Se você pretende receber datagramas multicast, você deve chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método com um número de porta de multicast.</span><span class="sxs-lookup"><span data-stu-id="aed81-1084">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1085">Você deve chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método se desejar receber datagramas sem conexão usando o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1085">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1086">Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1086">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1087">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1087">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1088">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1088">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1089">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1089">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1090">O código a seguir exemplo associa um <xref:System.Net.Sockets.Socket> usando o ponto de extremidade local especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1090">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1091"><paramref name="localEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1091"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1092">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1092">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1093">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1093">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1094">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1094">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-1095">para aceitar conexões de host definidos por <paramref name="localEP" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1095">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="aed81-1096">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="aed81-1096">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1097">Obtém ou define um valor que indica se o <see cref="T:System.Net.Sockets.Socket" /> está no modo de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1097">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1098"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> for bloqueado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1098"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="aed81-1099">O padrão é <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1099">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1100">O <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade indica se um <xref:System.Net.Sockets.Socket> está no modo de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1100">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="aed81-1101">Se você estiver no modo de bloqueio, e você faz com que um método de chamada que não for concluída imediatamente, seu aplicativo bloqueará a execução até que a operação solicitada seja concluída.</span><span class="sxs-lookup"><span data-stu-id="aed81-1101">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="aed81-1102">Se você deseja que a execução continuar mesmo que a operação solicitada não foi concluída, altere o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1102">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="aed81-1103">O <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade não tem efeito sobre os métodos assíncronos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1103">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="aed81-1104">Se você for enviar e receber dados de forma assíncrona e para bloquear a execução, use o <xref:System.Threading.ManualResetEvent> classe.</span><span class="sxs-lookup"><span data-stu-id="aed81-1104">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1105">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1105">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1106">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1106">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1107">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1107">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1108">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1108">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1109">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1109">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1110">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1110">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-1111">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> usado para solicitar a conexão com o host remoto chamando um dos métodos <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1111">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="aed81-1112">Cancela uma solicitação assíncrona de uma conexão de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1112">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1113">O <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> método cancela uma solicitação assíncrona para uma conexão do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1113">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-1114">O parâmetro <paramref name="e" /> e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não podem ser nulos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1114">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1115">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1115">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1116">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1117">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1117">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1118">Fecha a conexão <see cref="T:System.Net.Sockets.Socket" /> e libera todos os recursos associados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1118">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aed81-1119">Fecha a conexão <see cref="T:System.Net.Sockets.Socket" /> e libera todos os recursos associados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1119">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1120">O <xref:System.Net.Sockets.Socket.Close%2A> método fecha a conexão do host remoto e versões de todos os recursos gerenciados e associados a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1120">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1121">No fechamento, a <xref:System.Net.Sockets.Socket.Connected%2A> está definida como `false`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1121">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="aed81-1122">Para protocolos orientados a conexão, é recomendável que você chamar <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de chamar o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1122">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="aed81-1123">Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1123">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="aed81-1124">Se você precisar chamar <xref:System.Net.Sockets.Socket.Close%2A> sem primeiro chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, você pode garantir que dados na fila de transmissão de saída será enviada, definindo o <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opção para `false` e especificando um intervalo de tempo-limite diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-1124">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="aed81-1125"><xref:System.Net.Sockets.Socket.Close%2A> em seguida, bloqueia até que esses dados são enviados ou expira o tempo limite especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1125"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="aed81-1126">Se você definir <xref:System.Net.Sockets.SocketOptionName.DontLinger> para `false` e especificar um zero intervalo de tempo limite, <xref:System.Net.Sockets.Socket.Close%2A> libera a conexão e descarta automaticamente os dados na fila de saída.</span><span class="sxs-lookup"><span data-stu-id="aed81-1126">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1127">Para definir o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para `false`, criar um <xref:System.Net.Sockets.LingerOption>, defina a propriedade enabled como `true`e defina o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade para o período de tempo limite desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1127">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="aed81-1128">Use este <xref:System.Net.Sockets.LingerOption> juntamente com o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1128">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1129">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1129">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1130">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1130">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1131">O código a seguir exemplo fecha um <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1131">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="aed81-1132">Aguarde até o <c>tempo limite</c> em segundos para enviar quaisquer dados restantes e, em seguida, feche o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1132">Wait up to <c>timeout</c> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="aed81-1133">Fecha a conexão de <see cref="T:System.Net.Sockets.Socket" /> e libera todos os recursos associados com um tempo limite especificado para permitir que os dados em fila sejam enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1133">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1134">O <xref:System.Net.Sockets.Socket.Close%2A> método fecha a conexão do host remoto e versões de todos os recursos gerenciados e associados a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1134">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1135">No fechamento, a <xref:System.Net.Sockets.Socket.Connected%2A> está definida como `false`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1135">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="aed81-1136">Para protocolos orientados a conexão, é recomendável que você chamar <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de chamar <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1136">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="aed81-1137">Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1137">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="aed81-1138">Se você precisar chamar <xref:System.Net.Sockets.Socket.Close%2A> sem primeiro chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, você pode garantir que dados na fila de transmissão de saída será enviada, definindo o <xref:System.Net.Sockets.SocketOptionName.DontLinger> opção para `false` e especificando um intervalo de tempo-limite diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-1138">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="aed81-1139"><xref:System.Net.Sockets.Socket.Close%2A> em seguida, bloqueia até que esses dados são enviados ou expira o tempo limite especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1139"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="aed81-1140">Se você definir <xref:System.Net.Sockets.SocketOptionName.DontLinger> para `false` e especificar um zero intervalo de tempo limite, <xref:System.Net.Sockets.Socket.Close%2A> libera a conexão e descarta automaticamente os dados na fila de saída.</span><span class="sxs-lookup"><span data-stu-id="aed81-1140">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1141">Para definir o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para `false`, criar um <xref:System.Net.Sockets.LingerOption>, defina a propriedade enabled como `true`e defina o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade para o período de tempo limite desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1141">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="aed81-1142">Use este <xref:System.Net.Sockets.LingerOption> juntamente com o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1142">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1143">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1143">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1144">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1144">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1145">O exemplo de código a seguir demonstra como fechar uma <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1145">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1146">Estabelece uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1146">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="aed81-1147">Um <see cref="T:System.Net.EndPoint" /> que representa o dispositivo remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1147">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="aed81-1148">Estabelece uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1148">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1149">Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o ponto de extremidade remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1149">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="aed81-1150">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1150">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="aed81-1151">Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1151">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1152">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1152">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-1153">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1153">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="aed81-1154">Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1154">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-1155">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1155">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1156">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1156">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1157">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1157">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="aed81-1158">O <xref:System.Net.Sockets.Socket.Connect%2A> método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1158">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-1159">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1159">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="aed81-1160">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1160">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="aed81-1161">Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1161">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1162">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1162">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="aed81-1163">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1163">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="aed81-1164">Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1164">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1165">Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1165">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="aed81-1166">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1166">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="aed81-1167">Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1167">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1168">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1168">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="aed81-1169">Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1169">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="aed81-1170">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1170">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1171">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1171">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1172">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1172">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1173">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1173">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1174"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1174"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1175">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1175">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1176">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1176">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1177">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1177">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1178">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1178">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-1179">para conectar-se ao host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1179">for connecting to the remote host.</span></span> <span data-ttu-id="aed81-1180">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="aed81-1180">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="aed81-1181">O endereço IP do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1181">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="aed81-1182">O número da porta do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1182">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="aed81-1183">Estabelece uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1183">Establishes a connection to a remote host.</span></span> <span data-ttu-id="aed81-1184">O host é especificado por um endereço IP e um número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1184">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1185">Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o ponto de extremidade remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1185">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="aed81-1186">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1186">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="aed81-1187">Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A> você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1187">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1188">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1188">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-1189">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1189">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="aed81-1190">Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1190">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-1191">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1191">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1192">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1192">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1193">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1193">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="aed81-1194"><xref:System.Net.Sockets.Socket.Connect%2A> método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1194"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-1195">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1195">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="aed81-1196">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1196">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="aed81-1197">Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1197">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1198">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1198">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="aed81-1199">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1199">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="aed81-1200">Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1200">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1201">Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1201">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="aed81-1202">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1202">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="aed81-1203">Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1203">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1204">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1204">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="aed81-1205">Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1205">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="aed81-1206">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1206">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1207">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1207">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1208">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1208">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1209">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1209">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1210"><paramref name="address" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1210"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-1211">O número da porta é inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1211">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1212">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1212">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1213">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1213">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1214">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1214">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-1215">O comprimento de <paramref name="address" /> é zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-1215">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1216">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1216">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="aed81-1217">Os endereços IP do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1217">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="aed81-1218">O número da porta do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1218">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="aed81-1219">Estabelece uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1219">Establishes a connection to a remote host.</span></span> <span data-ttu-id="aed81-1220">O host é especificado por uma matriz de endereços IP e um número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1220">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1221">Esse método é geralmente usado imediatamente após uma chamada para <xref:System.Net.Dns.GetHostAddresses%2A>, que pode retornar vários endereços IP para um único host.</span><span class="sxs-lookup"><span data-stu-id="aed81-1221">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="aed81-1222">Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o ponto de extremidade remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1222">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="aed81-1223">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1223">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="aed81-1224">Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A> você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1224">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1225">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1225">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-1226">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1226">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="aed81-1227">Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1227">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-1228">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1228">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1229">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1229">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1230">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1230">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="aed81-1231"><xref:System.Net.Sockets.Socket.Connect%2A> método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1231"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-1232">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1232">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="aed81-1233">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1233">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="aed81-1234">Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1234">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1235">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1235">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="aed81-1236">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1236">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="aed81-1237">Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1237">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1238">Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1238">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="aed81-1239">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1239">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="aed81-1240">Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1240">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1241">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1241">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="aed81-1242">Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1242">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="aed81-1243">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1243">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1244">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1244">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1245">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1245">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1246">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1246">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1247"><paramref name="addresses" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1247"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-1248">O número da porta é inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1248">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1249">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1249">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1250">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1250">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1251">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1251">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-1252">O comprimento de <paramref name="address" /> é zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-1252">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1253">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1253">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="aed81-1254">O nome do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1254">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="aed81-1255">O número da porta do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1255">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="aed81-1256">Estabelece uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1256">Establishes a connection to a remote host.</span></span> <span data-ttu-id="aed81-1257">O host é especificado por um nome do host e um número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1257">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1258">Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1258">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="aed81-1259">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1259">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="aed81-1260">Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A> você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1260">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1261">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1261">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-1262">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1262">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="aed81-1263">Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1263">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-1264">Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1264">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1265">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1265">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1266">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1266">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="aed81-1267"><xref:System.Net.Sockets.Socket.Connect%2A> método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1267"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-1268">Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1268">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="aed81-1269">Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1269">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="aed81-1270">Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1270">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1271">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1271">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="aed81-1272">Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1272">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="aed81-1273">Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1273">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="aed81-1274">Se o IPv6 estiver habilitado e o <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> método é chamado para se conectar a um host que resolve para ambos IPv6 e endereços IPv4, a conexão do IPv6 endereço será tentada primeiro antes do endereço IPv4.</span><span class="sxs-lookup"><span data-stu-id="aed81-1274">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="aed81-1275">Isso pode ter o efeito do atraso de tempo para estabelecer a conexão, se o host não está escutando no endereço IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-1275">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1276">Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1276">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="aed81-1277">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1277">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="aed81-1278">Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1278">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1279">Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1279">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="aed81-1280">Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar.</span><span class="sxs-lookup"><span data-stu-id="aed81-1280">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="aed81-1281">Essa é uma limitação do provedor subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1281">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1282">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1282">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1283">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1283">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1284">O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1284">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1285"><paramref name="host" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1285"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-1286">O número da porta é inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1286">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1287">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1287">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1288">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1288">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1289">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1289">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1290">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1290">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1291">Inicia uma solicitação assíncrona para uma conexão com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1291">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-1292">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1292">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1293">Inicia uma solicitação assíncrona para uma conexão com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1293">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="aed81-1294">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1294">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-1295">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1295">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-1296">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1296">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-1297">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1297">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1298">Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicia uma solicitação assíncrona para uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1298">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="aed81-1299">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> estabelece um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="aed81-1300">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1300">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="aed81-1301">O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto para se conectar ao.</span><span class="sxs-lookup"><span data-stu-id="aed81-1301">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="aed81-1302">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1302">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-1303">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-1303">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-1304">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1304">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-1305">Você pode usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para se comunicar com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1305">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="aed81-1306">Se você chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1306">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-1307">Se você quiser alterar o host remoto padrão, chame o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1307">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="aed81-1308">Se você deseja definir o host remoto padrão para um endereço de difusão, você deve primeiro chamar <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e defina a transmissão para `true`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1308">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="aed81-1309">Se isso não for feito, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1309">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-1310">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias:</span><span class="sxs-lookup"><span data-stu-id="aed81-1310">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-1311">Opcionalmente, um buffer pode ser fornecido que será enviado atomicamente no soquete após o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método for bem-sucedido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1311">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="aed81-1312">Nesse caso, o <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriedade deve ser definida para o buffer que contém os dados para enviar e <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade precisa ser definido como o número de bytes de dados para enviar do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-1312">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="aed81-1313">Quando uma conexão é estabelecida, esse buffer de dados é enviada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1313">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="aed81-1314">Se você estiver usando um protocolo orientado a conexão e não chame <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1314">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="aed81-1315">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço IP do local de rede até que você chame o <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1315">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="aed81-1316">O <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lança <xref:System.NotSupportedException> se a família de endereços do <xref:System.Net.Sockets.Socket> e <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> não são da mesma família de endereço.</span><span class="sxs-lookup"><span data-stu-id="aed81-1316">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1317">Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar esse método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1317">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1318">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1318">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-1319">Um argumento não é válido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1319">An argument is not valid.</span></span> <span data-ttu-id="aed81-1320">Essa exceção ocorrerá se vários buffers forem especificados e a propriedade <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> não for nula.</span><span class="sxs-lookup"><span data-stu-id="aed81-1320">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-1321">O parâmetro <paramref name="e" /> e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não podem ser nulos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1321">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1322">O <see cref="T:System.Net.Sockets.Socket" /> está escutando ou uma operação de soquete já estava em andamento usando o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1322">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1323">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1323">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1324">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1324">Windows XP or later is required for this method.</span></span> <span data-ttu-id="aed81-1325">Essa exceção também ocorrerá se o ponto de extremidade local e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não forem da mesma família de endereços.</span><span class="sxs-lookup"><span data-stu-id="aed81-1325">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1326">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1327">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1327">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="aed81-1328">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1328">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="aed81-1329">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1329">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="aed81-1330">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1330">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1331">Inicia uma solicitação assíncrona para uma conexão com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1331">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="aed81-1332">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1332">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-1333">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1333">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-1334">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1334">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-1335">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1335">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1336">Se você estiver usando um protocolo orientado a conexão, o método M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) inicia uma solicitação assíncrona para uma conexão com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1336">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="aed81-1337">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> estabelece um host remoto padrão especificado pelo `socketType` e `protocolType` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="aed81-1337">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="aed81-1338">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1338">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="aed81-1339">O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto para se conectar ao.</span><span class="sxs-lookup"><span data-stu-id="aed81-1339">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="aed81-1340">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1340">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-1341">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-1341">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-1342">Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar e receber dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1342">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="aed81-1343">Você pode usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para se comunicar com um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1343">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="aed81-1344">Se você chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1344">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="aed81-1345">Se você quiser alterar o host remoto padrão, chame o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método novamente com o ponto de extremidade desejado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1345">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="aed81-1346">Se você deseja definir o host remoto padrão para um endereço de difusão, você deve primeiro chamar <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e defina a transmissão para `true`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1346">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="aed81-1347">Se isso não for feito, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1347">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-1348">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias:</span><span class="sxs-lookup"><span data-stu-id="aed81-1348">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-1349">Opcionalmente, um buffer pode ser fornecido que será enviado atomicamente no soquete após o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método for bem-sucedido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1349">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="aed81-1350">Nesse caso, o <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriedade deve ser definida para o buffer que contém os dados para enviar e <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade precisa ser definido como o número de bytes de dados para enviar do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-1350">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="aed81-1351">Quando uma conexão é estabelecida, esse buffer de dados é enviada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1351">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="aed81-1352">Se você estiver usando um protocolo orientado a conexão e não chame <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1352">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="aed81-1353">Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço IP do local de rede até que você chame o <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1353">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="aed81-1354">O <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lança <xref:System.NotSupportedException> se a família de endereços do <xref:System.Net.Sockets.Socket> e <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> não são da mesma família de endereço.</span><span class="sxs-lookup"><span data-stu-id="aed81-1354">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1355">Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar esse método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1355">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1356">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1356">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-1357">Um argumento não é válido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1357">An argument is not valid.</span></span> <span data-ttu-id="aed81-1358">Essa exceção ocorrerá se vários buffers forem especificados e a propriedade <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> não for nula.</span><span class="sxs-lookup"><span data-stu-id="aed81-1358">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-1359">O parâmetro <paramref name="e" /> e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não podem ser nulos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1359">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1360">O <see cref="T:System.Net.Sockets.Socket" /> está escutando ou uma operação de soquete já estava em andamento usando o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1360">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1361">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1361">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1362">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1362">Windows XP or later is required for this method.</span></span> <span data-ttu-id="aed81-1363">Essa exceção também ocorrerá se o ponto de extremidade local e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não forem da mesma família de endereços.</span><span class="sxs-lookup"><span data-stu-id="aed81-1363">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1364">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1365">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1365">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1366">Obtém um valor que indica se um <see cref="T:System.Net.Sockets.Socket" /> está conectado a um host remoto desde a última operação <see cref="Overload:System.Net.Sockets.Socket.Send" /> ou <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1366">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1367"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> tiver sido conectado a um recurso remoto desde a operação mais recente; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1367"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1368">O `Connected` propriedade obtém o estado de conexão do <xref:System.Net.Sockets.Socket> desde a última operação de e/s.</span><span class="sxs-lookup"><span data-stu-id="aed81-1368">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="aed81-1369">Quando ele retorna `false`, o <xref:System.Net.Sockets.Socket> nunca foi conectado ou não está mais conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1369">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="aed81-1370">O valor de <xref:System.Net.Sockets.Socket.Connected%2A> propriedade reflete o estado da conexão a partir da operação mais recente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1370">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="aed81-1371">Se você precisar determinar o estado atual da conexão, fazer com que um envio sem bloqueio, zero bytes chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1371">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="aed81-1372">Se a chamada retorna com êxito ou gera um código de erro WAEWOULDBLOCK (10035), o soquete ainda está conectado; Caso contrário, o soquete não está mais conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1372">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="aed81-1373">Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> em um soquete do protocolo UDP (User Datagram), o <xref:System.Net.Sockets.Socket.Connected%2A> propriedade sempre retorna `true`; no entanto, essa ação não altera a natureza sem-conexão inerente de UDP.</span><span class="sxs-lookup"><span data-stu-id="aed81-1373">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1374">O exemplo de código a seguir se conecta a um ponto de extremidade remoto, as verificações de <xref:System.Net.Sockets.Socket.Connected%2A> propriedade e verifica o estado atual da conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1374">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <span data-ttu-id="aed81-1375"><see langword="true" /> se o soquete puder ser reutilizado após a conexão atual ser fechada; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1375"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="aed81-1376">Fecha a conexão de soquete e permite a reutilização do soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1376">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1377">Se você estiver usando um protocolo orientado a conexão, você pode usar esse método para fechar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1377">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="aed81-1378">Este termina de método de conexão e os conjuntos de <xref:System.Net.Sockets.Socket.Connected%2A> propriedade para `false`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1378">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="aed81-1379">No entanto, se `reuseSocket` é `true`, você pode reutilizar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1379">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="aed81-1380">Para garantir que todos os dados são enviadas e recebidas antes do fechamento de soquete, você deve chamar <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de chamar o <xref:System.Net.Sockets.Socket.Disconnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1380">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1381">Se você precisar chamar <xref:System.Net.Sockets.Socket.Disconnect%2A> sem primeiro chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, você pode definir o <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opção para `false` e especificar um intervalo de tempo limite diferente de zero para garantir que dados na fila de transmissão de saída é enviada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1381">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="aed81-1382"><xref:System.Net.Sockets.Socket.Disconnect%2A> em seguida, bloqueia até que os dados são enviados ou expira o tempo limite especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1382"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="aed81-1383">Se você definir <xref:System.Net.Sockets.SocketOptionName.DontLinger> para `false` e especificar um zero intervalo de tempo limite, <xref:System.Net.Sockets.Socket.Close%2A> libera a conexão e descarta automaticamente os dados na fila de saída.</span><span class="sxs-lookup"><span data-stu-id="aed81-1383">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1384">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1384">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1385">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1385">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1386">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1386">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1387">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1387">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1388">O exemplo de código a seguir cria um soquete para comunicação síncrona e envia alguns dados para um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1388">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="aed81-1389">Depois, ele chama <xref:System.Net.Sockets.Socket.Shutdown%2A>, para parar o envio e recebimento de atividade, e <xref:System.Net.Sockets.Socket.Disconnect%2A>para fechar a conexão de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1389">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="aed81-1390">Esse método requer o Windows 2000 ou anterior, ou a exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1390">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1391">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1391">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1392">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1392">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-1393">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1393">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1394">Inicia uma solicitação assíncrona para se desconectar de um ponto de extremidade remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1394">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-1395">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1395">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-1396">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1396">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-1397">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1397">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-1398">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1398">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1399">Ao usar um protocolo orientado a conexão, chamar o <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> método solicita uma desconexão de um ponto de extremidade remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1399">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="aed81-1400">Se você definir <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> para `true` no `e` parâmetro, o soquete pode ser reutilizado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1400">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-1401">O parâmetro <paramref name="e" /> não pode ser nulo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1401">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1402">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1402">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1403">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1403">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1404">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1404">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1405">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1405">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1406">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1406">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aed81-1407">Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1407">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1408">Chamar `Dispose` quando tiver terminado de usar o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1408">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1409">O `Dispose` método deixa o <xref:System.Net.Sockets.Socket> em um estado inutilizável.</span><span class="sxs-lookup"><span data-stu-id="aed81-1409">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="aed81-1410">Depois de chamar `Dispose`, você deve liberar todas as referências para o <xref:System.Net.Sockets.Socket> para o coletor de lixo possa recuperar a memória que o <xref:System.Net.Sockets.Socket> estava ocupando.</span><span class="sxs-lookup"><span data-stu-id="aed81-1410">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="aed81-1411">Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1411">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1412">Sempre chamar `Dispose` antes de liberar sua última referência para o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1412">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1413">Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Net.Sockets.Socket> do objeto `Finalize` método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1413">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="aed81-1414"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1414"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="aed81-1415">Libera os recursos não gerenciados usados pelo <see cref="T:System.Net.Sockets.Socket" /> e, opcionalmente, descarta os recursos gerenciados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1415">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1416">Este método é chamado pelo método público `Dispose()` e pelo método <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1416">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="aed81-1417">`Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1417">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="aed81-1418"><xref:System.Object.Finalize%2A> invoca `Dispose` com `disposing` definido como `false`.</span><span class="sxs-lookup"><span data-stu-id="aed81-1418"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="aed81-1419">Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Net.Sockets.Socket> referências.</span><span class="sxs-lookup"><span data-stu-id="aed81-1419">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="aed81-1420">Este método invoca o método `Dispose()` de cada objeto referenciado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1420">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1421">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1421">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1422">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1422">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="aed81-1423"><see langword="Dispose" /> pode ser chamado várias vezes por outros objetos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1423"><see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="aed81-1424">Ao substituir <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, tome cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see langword="Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1424">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="aed81-1425">Para obter mais informações sobre como implementar <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1425">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
 <span data-ttu-id="aed81-1426">Para obter mais informações sobre <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [substituindo o método Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span><span class="sxs-lookup"><span data-stu-id="aed81-1426">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1427">Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> permite que datagramas de protocolo IP sejam fragmentados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1427">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1428"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> permite a fragmentação de datagramas; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1428"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="aed81-1429">O padrão é <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1429">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1430">Datagramas requerem fragmentação quando seu tamanho excede a transferência de unidade máxima (MTU) da mídia de transmissão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1430">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="aed81-1431">Datagramas podem ser fragmentadas, o host de envio (todas as versões de protocolo de Internet) ou um roteador intermediário (protocolo IP versão 4 somente).</span><span class="sxs-lookup"><span data-stu-id="aed81-1431">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="aed81-1432">Se um datagrama deve ser fragmentado e o <xref:System.Net.Sockets.Socket.DontFragment%2A> opção for definida, o datagrama é descartado e uma mensagem de erro de protocolo de mensagem de controle da Internet (ICMP) é enviada para o remetente do datagrama.</span><span class="sxs-lookup"><span data-stu-id="aed81-1432">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="aed81-1433">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1433">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1434">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.DontFragment%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1434">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1435">Essa propriedade pode ser definida apenas para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1435">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1436">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1436">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1437">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1437">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1438">Obtém ou define um valor de <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> é um soquete de modo duplo, usado para IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-1438">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1439"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> for um soquete de modo duplo; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1439"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="aed81-1440">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1440">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="aed81-1441">A ID do processo de destino em que uma duplicata da referência de soquete é criada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1441">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="aed81-1442">Duplica a referência de soquete para o processo de destino e fecha o soquete para esse processo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1442">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="aed81-1443">A referência de soquete a ser passada para o processo de destino.</span><span class="sxs-lookup"><span data-stu-id="aed81-1443">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1444">O processo de destino deve usar <xref:System.Net.Sockets.Socket.%23ctor%2A> para criar a instância de soquete duplicada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1444">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="aed81-1445">Se você chamar o <xref:System.Net.Sockets.Socket.%23ctor%2A> construtor várias vezes com a mesma matriz de bytes como o argumento para cada chamada, você criará vários gerenciado <xref:System.Net.Sockets.Socket> instâncias com o mesmo soquete subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1445">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="aed81-1446">Essa prática é altamente desaconselhável.</span><span class="sxs-lookup"><span data-stu-id="aed81-1446">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="aed81-1447">Se o processo de criar o soquete usa métodos assíncronos (<xref:System.Net.Sockets.Socket.BeginReceive%2A> ou <xref:System.Net.Sockets.Socket.BeginSend%2A>), o processo deve primeiro definir a <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> propriedade como true; caso contrário, o soquete está associado à porta de conclusão do processo de criação, que pode causar um <xref:System.ArgumentNullException> seja gerada no processo de destino.</span><span class="sxs-lookup"><span data-stu-id="aed81-1447">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-1448"><paramref name="targetProcessID" /> não é uma ID de processo válida.</span><span class="sxs-lookup"><span data-stu-id="aed81-1448"><paramref name="targetProcessID" /> is not a valid process id.</span></span>  
  
 <span data-ttu-id="aed81-1449">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1449">-or-</span></span>  
  
 <span data-ttu-id="aed81-1450">Falha na duplicação de referência do soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1450">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1451">Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> pode enviar ou receber pacotes de difusão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1451">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1452"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> permitir pacotes de difusão; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1452"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="aed81-1453">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1453">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1454">Difusão é limitada a uma sub-rede específica e deve usar o protocolo de datagrama de usuário (UDP). Protocolo IP versão 4, você pode transmitir a sua sub-rede local, enviando um pacote para 255.255.255.255; ou você pode usar o endereço de difusão direcionado, o que é a parte da rede de um endereço IP (Internet Protocol) com todos os bits definidos na parte do host.</span><span class="sxs-lookup"><span data-stu-id="aed81-1454">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="aed81-1455">Por exemplo, se seu endereço IP é 192.168.1.40 (um endereço de classe C, com uma máscara de rede de 255.255.255.0 – a parte de rede tem os três primeiros octetos e a parte do host é o último octeto), seu endereço de difusão direcionado é 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="aed81-1455">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="aed81-1456">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1456">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1457">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1457">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1458">Essa opção é válida apenas para um soquete de datagrama.</span><span class="sxs-lookup"><span data-stu-id="aed81-1458">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1459">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1459">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1460">Aceita de forma assíncrono uma tentativa de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1460">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-1461">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os bytes transferidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1461">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="aed81-1462">Um objeto <see cref="T:System.IAsyncResult" /> que armazena as informações de estado dessa operação assíncrona, bem como os dados definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-1462">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="aed81-1463">Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1463">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="aed81-1464">Esse método retorna um buffer que contém os dados iniciais transferidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1464">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="aed81-1465">Um objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1465">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1466"><xref:System.Net.Sockets.Socket.EndAccept%2A> conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1466"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="aed81-1467">Antes de chamar <xref:System.Net.Sockets.Socket.BeginAccept%2A>, você precisa criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1467">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1468">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <xref:System.Net.Sockets.Socket.BeginAccept%2A> método retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1468">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="aed81-1469">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o `asyncResult` parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita.</span><span class="sxs-lookup"><span data-stu-id="aed81-1469">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="aed81-1470">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método concluído com êxito a tentativa de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1470">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="aed81-1471">O `buffer` parâmetro essa sobrecarga contém os dados que foram recebidos na chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A> e `bytesTransferred` parâmetro contém o número de bytes que foram transferidos na chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1471">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="aed81-1472">O <xref:System.Net.Sockets.Socket.EndAccept%2A> método bloqueia até que uma conexão está pendente na fila de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1472">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="aed81-1473">O <xref:System.Net.Sockets.Socket.EndAccept%2A> método aceita a conexão de entrada e retorna um novo <xref:System.Net.Sockets.Socket> que pode ser usado para enviar e receber dados do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1473">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1474">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1474">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1475">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1475">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1476">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1476">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1477">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1477">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1478">O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para criar e conectar-se a um soquete e aceitar inicias 10 bytes de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1478">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="aed81-1479">O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndAccept%2A> para encerrar a solicitação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1479">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="aed81-1480">O número de bytes transmitidos e os dados são retornados no `buffer` e `bytesTransferred` parâmetros desse método e são exibidos no console.</span><span class="sxs-lookup"><span data-stu-id="aed81-1480">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1481">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1481">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1482">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1482">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1483"><paramref name="asyncResult" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1483"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1484">O <paramref name="asyncResult" /> não foi criado por uma chamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1484"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1485">O método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> foi chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1485"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1486">Ocorreu um erro ao tentar acessar o <see cref="T:System.Net.Sockets.Socket" /></span><span class="sxs-lookup"><span data-stu-id="aed81-1486">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary><span data-ttu-id="aed81-1487">Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1487">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="aed81-1488">Um <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1488">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1489"><xref:System.Net.Sockets.Socket.EndAccept%2A> conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1489"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="aed81-1490">Antes de chamar <xref:System.Net.Sockets.Socket.BeginAccept%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1490">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1491">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <xref:System.Net.Sockets.Socket.BeginAccept%2A> método retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1491">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="aed81-1492">Ele deve aceitar o `asyncResult` parâmetro retornado do <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1492">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1493">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o `asyncResult` parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita.</span><span class="sxs-lookup"><span data-stu-id="aed81-1493">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="aed81-1494">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método concluído com êxito a tentativa de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1494">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="aed81-1495">O <xref:System.Net.Sockets.Socket.EndAccept%2A> método bloqueia até que uma conexão está pendente na fila de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1495">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="aed81-1496">O <xref:System.Net.Sockets.Socket.EndAccept%2A> método aceita a conexão de entrada e retorna um novo <xref:System.Net.Sockets.Socket> que pode ser usado para enviar e receber dados do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1496">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1497">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1497">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1498">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1498">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1499">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1499">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1500">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1500">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1501">O exemplo de código a seguir encerra uma solicitação assíncrona e cria um novo <xref:System.Net.Sockets.Socket> para aceitar uma solicitação de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1501">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="aed81-1502">Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte [exemplos de código do soquete](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1502">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1503"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1503"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1504">O <paramref name="asyncResult" /> não foi criado por uma chamada para <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1504"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1505">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1505">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-1506">Consulte a seção Comentários para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="aed81-1506">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1507">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1507">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1508">O método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> foi chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1508"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1509">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1509">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-1510">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os bytes transferidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1510">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="aed81-1511">O número de bytes transferidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1511">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="aed81-1512">Um objeto <see cref="T:System.IAsyncResult" /> que armazena as informações de estado dessa operação assíncrona, bem como os dados definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-1512">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="aed81-1513">Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações de host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1513">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="aed81-1514">Esse método retorna um buffer que contém os dados iniciais e o número de bytes transferidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1514">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="aed81-1515">Um objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1515">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1516"><xref:System.Net.Sockets.Socket.EndAccept%2A> conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1516"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="aed81-1517">Antes de chamar <xref:System.Net.Sockets.Socket.BeginAccept%2A>, você precisa criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1517">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1518">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <xref:System.Net.Sockets.Socket.BeginAccept%2A> método retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1518">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="aed81-1519">Ele deve aceitar o `asyncResult` parâmetro retornado do <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1519">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1520">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o `asyncResult` parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita.</span><span class="sxs-lookup"><span data-stu-id="aed81-1520">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="aed81-1521">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método concluído com êxito a tentativa de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1521">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="aed81-1522">O `buffer` parâmetro essa sobrecarga contém os dados que foram recebidos na chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A> e `bytesTransferred` parâmetro contém o número de bytes que foram transferidos na chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1522">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="aed81-1523">O <xref:System.Net.Sockets.Socket.EndAccept%2A> método bloqueia até que uma conexão está pendente na fila de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1523">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="aed81-1524">O <xref:System.Net.Sockets.Socket.EndAccept%2A> método aceita a conexão de entrada e retorna um novo <xref:System.Net.Sockets.Socket> que pode ser usado para enviar e receber dados do host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1524">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1525">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1525">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1526">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1526">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1527">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1527">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1528">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1528">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1529">O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para criar e conectar-se a um soquete e aceitar inicias 10 bytes de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1529">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="aed81-1530">O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndAccept%2A> para encerrar a solicitação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1530">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="aed81-1531">O número de bytes transmitidos e os dados são retornados no `buffer` e `bytesTransferred` parâmetros desse método e são exibidos no console.</span><span class="sxs-lookup"><span data-stu-id="aed81-1531">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1532">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1532">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1533">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1533">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1534"><paramref name="asyncResult" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1534"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1535">O <paramref name="asyncResult" /> não foi criado por uma chamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1535"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1536">O método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> foi chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1536"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1537">Ocorreu um erro ao tentar acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1537">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary><span data-ttu-id="aed81-1538">Encerra uma solicitação de conexão assíncrona pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1538">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1539"><xref:System.Net.Sockets.Socket.EndConnect%2A> é um método de bloqueio que conclui a solicitação de conexão do host remoto assíncrono iniciado no <xref:System.Net.Sockets.Socket.BeginConnect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1539"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1540">Antes de chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1540">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1541">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginConnect%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1541">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="aed81-1542">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginConnect%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1542">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1543">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita.</span><span class="sxs-lookup"><span data-stu-id="aed81-1543">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="aed81-1544">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndConnect%2A> método concluído com êxito a tentativa de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1544">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1545">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1545">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1546">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1546">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1547">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1547">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1548">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1548">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1549">O exemplo de código a seguir encerra a tentativa de conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1549">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="aed81-1550">Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte [exemplos de código do soquete](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1550">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1551"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1551"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1552"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1552"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1553"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> foi chamado anteriormente para a conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1553"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1554">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1554">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1555">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1555">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="aed81-1556">Um objeto <see cref="T:System.IAsyncResult" /> que armazena as informações de estado e os dados definidos pelo usuário para esta operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1556">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1557">Encerra uma solicitação de desconexão assíncrona pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1557">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1558"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1558"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="aed81-1559">O <xref:System.Net.Sockets.Socket.EndDisconnect%2A> método bloqueia até que seja concluída a desconexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1559">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="aed81-1560">Para obter informações sobre as operações assíncronas, consulte o tópico de visão de geral de programação assíncrona na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-1560">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1561">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1561">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1562">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1562">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1563">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1563">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1564">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1564">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1565">O exemplo de código a seguir cria um soquete para comunicação assíncrona e envia alguns dados para um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1565">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="aed81-1566">Quando os dados foram enviados, <xref:System.Net.Sockets.Socket.Shutdown%2A> é chamado para parar o envio e a atividade de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1566">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="aed81-1567">Em seguida, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> é chamado para iniciar uma solicitação de desconexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1567">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="aed81-1568">O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndDisconnect%2A> para encerrar a solicitação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1568">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="aed81-1569">Quando a solicitação é concluída, o <xref:System.Net.Sockets.Socket.Connected%2A> propriedade será consultada para testar se o soquete está desconectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1569">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1570">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</span><span class="sxs-lookup"><span data-stu-id="aed81-1570">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1571">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1571">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1572"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1572"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1573"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1573"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1574"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> foi chamado anteriormente para a conexão assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1574"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1575">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1575">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="aed81-1576">A solicitação de desconexão atingiu o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-1576">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1577">Encerra uma leitura assíncrona pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1577">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary><span data-ttu-id="aed81-1578">Encerra uma leitura assíncrona pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1578">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="aed81-1579">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1579">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1580">O <xref:System.Net.Sockets.Socket.EndReceive%2A> a operação de leitura assíncrona iniciada conclusão do método de <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1580">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1581">Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceive%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1581">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1582">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceive%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1582">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="aed81-1583">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1583">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1584">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> para obter o objeto de estado passado para o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1584">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="aed81-1585">Extrair o recebimento <xref:System.Net.Sockets.Socket> deste objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1585">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="aed81-1586">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndReceive%2A> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1586">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="aed81-1587">O <xref:System.Net.Sockets.Socket.EndReceive%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-1587">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-1588">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndReceive%2A> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1588">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="aed81-1589">Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método lerá a quantidade de dados está disponível até o número de bytes especificado no `size` parâmetro o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1589">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="aed81-1590">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1590">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-1591">Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult>e extraia o buffer contido no objeto de estado resultante.</span><span class="sxs-lookup"><span data-stu-id="aed81-1591">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="aed81-1592">Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1592">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1593">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1593">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1594">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1594">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1595">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-1595">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-1596">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1596">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1597">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1597">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1598">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1598">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1599">O exemplo de código a seguir encerra uma leitura assíncrona pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1599">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="aed81-1600">Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte [exemplos de código do soquete](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1600">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1601"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1601"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1602"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1602"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1603"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> foi chamado anteriormente para a leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1603"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1604">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1604">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1605">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1605">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="aed81-1606">Um <see cref="T:System.IAsyncResult" /> que armazena informações de estado e dados definidos pelo usuário para essa operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1606">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-1607">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1607">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="aed81-1608">Encerra uma leitura assíncrona pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1608">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="aed81-1609">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1609">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1610">O <xref:System.Net.Sockets.Socket.EndReceive%2A> a operação de leitura assíncrona iniciada conclusão do método de <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1610">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1611">Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceive%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1611">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1612">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceive%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1612">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="aed81-1613">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1613">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1614">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> para obter o objeto de estado passado para o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1614">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="aed81-1615">Extrair o recebimento <xref:System.Net.Sockets.Socket> deste objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1615">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="aed81-1616">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndReceive%2A> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1616">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="aed81-1617">O <xref:System.Net.Sockets.Socket.EndReceive%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-1617">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-1618">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndReceive%2A> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1618">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="aed81-1619">Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método lerá a quantidade de dados está disponível até o número de bytes especificado no `size` parâmetro o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1619">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="aed81-1620">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1620">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-1621">Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult>e extraia o buffer contido no objeto de estado resultante.</span><span class="sxs-lookup"><span data-stu-id="aed81-1621">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1622">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1622">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1623">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1623">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1624">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-1624">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-1625">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1625">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1626">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1626">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1627">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1627">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1628"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1628"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1629"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1629"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1630">O <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> foi chamado anteriormente para a leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1630"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1631">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1631">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1632">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1632">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary><span data-ttu-id="aed81-1633">Termina uma leitura assíncrona pendente de um ponto de extremidade específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1633">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-1634">Se tiver êxito, o número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1634">If successful, the number of bytes received.</span></span> <span data-ttu-id="aed81-1635">Caso contrário, retornará 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-1635">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1636">O <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> a operação de leitura assíncrona iniciada conclusão do método de <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1636">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1637">Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1637">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1638">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1638">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="aed81-1639">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1639">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1640">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> para obter o objeto de estado passado para o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1640">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-1641">Extrair o recebimento <xref:System.Net.Sockets.Socket> deste objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1641">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="aed81-1642">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1642">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="aed81-1643">O <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-1643">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-1644">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1644">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="aed81-1645">Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método lerá a quantidade de dados está disponível até o número de bytes especificado no `size` parâmetro o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1645">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-1646">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1646">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="aed81-1647">Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> objeto e, em seguida, extrair o buffer contido no objeto de estado resultante.</span><span class="sxs-lookup"><span data-stu-id="aed81-1647">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="aed81-1648">Para identificar o host de origem, extrair o <xref:System.Net.EndPoint> e convertê-lo para um <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1648">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="aed81-1649">Use o <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para obter o endereço IP e o <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para obter o número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1649">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1650">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1650">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1651">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1651">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1652">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1652">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1653">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1653">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1654">O exemplo de código a seguir encerra uma leitura assíncrona pendente de um determinado <xref:System.Net.EndPoint>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1654">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1655"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1655"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1656"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1656"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1657">O <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> foi chamado anteriormente para a leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1657"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1658">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1658">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1659">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1659">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="aed81-1660">Um <see cref="T:System.IAsyncResult" /> que armazena informações de estado e dados definidos pelo usuário para essa operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1660">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-1661">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" /> para o pacote recebido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1661">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="aed81-1662">A fonte de <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1662">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="aed81-1663">O <see cref="T:System.Net.IPAddress" /> e a interface do pacote recebido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1663">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="aed81-1664">Termina uma leitura assíncrona pendente de um ponto de extremidade específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1664">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="aed81-1665">Esse método também revela mais informações sobre o pacote que <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1665">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-1666">Se tiver êxito, o número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1666">If successful, the number of bytes received.</span></span> <span data-ttu-id="aed81-1667">Caso contrário, retornará 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-1667">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1668">Se a operação não foi concluída, esse método bloqueia até que ele faz.</span><span class="sxs-lookup"><span data-stu-id="aed81-1668">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="aed81-1669">Para executar esta operação síncrona, use o <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1669">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-1670">Examine `ipPacketInformation` se você precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.</span><span class="sxs-lookup"><span data-stu-id="aed81-1670">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1671"><paramref name="asyncResult" /> é <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="aed81-1671"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
 <span data-ttu-id="aed81-1672">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1672">-or-</span></span>  
  
 <span data-ttu-id="aed81-1673"><paramref name="endPoint" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1673"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1674"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1674"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1675">O <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> foi chamado anteriormente para a leitura assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1675"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1676">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1676">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1677">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1677">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1678">Encerra um envio assíncrono pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1678">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary><span data-ttu-id="aed81-1679">Encerra um envio assíncrono pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1679">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="aed81-1680">Se for bem-sucedido, o número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />; caso contrário, um erro <see cref="T:System.Net.Sockets.Socket" /> inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1680">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1681"><xref:System.Net.Sockets.Socket.EndSend%2A> conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1681"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="aed81-1682">Antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1682">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1683">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginSend%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1683">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="aed81-1684">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginSend%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1684">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1685">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1685">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1686">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1686">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="aed81-1687">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1687">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-1688">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueado até que algumas do buffer foi enviada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1688">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="aed81-1689">Se o valor de retorno de <xref:System.Net.Sockets.Socket.EndSend%2A> indica que o buffer não foi completamente enviadas, chame o <xref:System.Net.Sockets.Socket.BeginSend%2A> método novamente, modificando o buffer para armazenar os dados não enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1689">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="aed81-1690">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1690">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-1691">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1691">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-1692">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-1692">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1693">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1693">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1694">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1694">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1695">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-1695">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-1696">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1696">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1697">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1697">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-1698">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1698">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1699">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1699">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1700">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1700">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1701">O exemplo de código a seguir encerra um envio assíncrono pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1701">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1702"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1702"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1703"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1703"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1704">O <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> foi chamado anteriormente para o envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1704"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1705">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1705">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1706">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1706">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="aed81-1707">Um <see cref="T:System.IAsyncResult" /> que armazena as informações de estado dessa operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1707">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-1708">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1708">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="aed81-1709">Encerra um envio assíncrono pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-1709">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="aed81-1710">Se for bem-sucedido, o número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />; caso contrário, um erro <see cref="T:System.Net.Sockets.Socket" /> inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1710">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1711"><xref:System.Net.Sockets.Socket.EndSend%2A> conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1711"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="aed81-1712">Antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1712">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1713">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginSend%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1713">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="aed81-1714">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginSend%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1714">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1715">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1715">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1716">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1716">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="aed81-1717">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1717">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-1718">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueado até que algumas do buffer foi enviada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1718">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="aed81-1719">Se o valor de retorno de <xref:System.Net.Sockets.Socket.EndSend%2A> indica que o buffer não foi completamente enviadas, chame o <xref:System.Net.Sockets.Socket.BeginSend%2A> método novamente, modificando o buffer para armazenar os dados não enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1719">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="aed81-1720">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1720">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-1721">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1721">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-1722">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-1722">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1723">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1723">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1724">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1724">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1725">E/s iniciada por um determinado thread é cancelada quando que sai do thread.</span><span class="sxs-lookup"><span data-stu-id="aed81-1725">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="aed81-1726">Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1726">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1727">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1727">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-1728">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1728">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1729">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1729">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1730">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1730">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1731"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1731"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1732"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1732"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1733">O <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> foi chamado anteriormente para o envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1733"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1734">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1734">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1735">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1735">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="aed81-1736">Um objeto <see cref="T:System.IAsyncResult" /> que armazena informações de estado para essa operação assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-1736">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1737">Encerra um envio assíncrono pendente de um arquivo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1737">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1738"><xref:System.Net.Sockets.Socket.EndSendFile%2A> conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1738"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="aed81-1739">Antes de chamar <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1739">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1740">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginSendFile%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1740">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="aed81-1741">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> objeto retornado pelo <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1741">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1742">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1742">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1743">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSendFile%2A> método concluído com êxito a operação de envio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1743">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="aed81-1744">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloqueia até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1744">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="aed81-1745">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloqueia até que o arquivo inteiro seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1745">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="aed81-1746">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1746">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-1747">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1747">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-1748">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-1748">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1749">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1749">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1750">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1750">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1751">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1751">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1752">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1752">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1753">O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona e começa a enviar o arquivo "Test.txt" assincronamente para o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1753">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="aed81-1754">O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndSendFile%2A> para concluir a transmissão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1754">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-1755">Windows NT é necessário para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1755">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1756">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1756">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1757"><paramref name="asyncResult" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1757"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1758"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1758"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1759"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> foi chamado anteriormente para o <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1759"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1760">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1760">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-1761">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1761">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary><span data-ttu-id="aed81-1762">Encerra um envio assíncrono pendente para um local específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1762">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="aed81-1763">Se for bem-sucedido, o número de bytes enviados; caso contrário, um erro <see cref="T:System.Net.Sockets.Socket" /> inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-1763">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1764"><xref:System.Net.Sockets.Socket.EndSendTo%2A> conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1764"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="aed81-1765">Antes de chamar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate.</span><span class="sxs-lookup"><span data-stu-id="aed81-1765">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="aed81-1766">Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceive%2A> retorna.</span><span class="sxs-lookup"><span data-stu-id="aed81-1766">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="aed81-1767">O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1767">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="aed81-1768">Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1768">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1769">Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSendTo%2A> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1769">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="aed81-1770">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSendTo%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1770">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-1771">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSendTo%2A> será bloqueado até que o número solicitado de bytes é enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1771">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="aed81-1772">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1772">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-1773">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1773">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-1774">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-1774">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1775">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1775">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1776">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1776">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1777">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1777">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1778">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1778">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1779">O exemplo de código a seguir encerra um envio assíncrono para um local específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1779">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-1780"><paramref name="asyncResult" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1780"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-1781"><paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1781"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1782">O <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> foi chamado anteriormente para o envio assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-1782"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1783">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1783">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1784">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1784">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1785">Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> permite que um único processo se associe a uma porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1785">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1786"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> permitir que apenas um soquete se associe a uma porta específica; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1786"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="aed81-1787">O padrão é <see langword="true" /> para Windows Server 2003 e Windows XP Service Pack 2, e <see langword="false" /> para todas as outras versões.</span><span class="sxs-lookup"><span data-stu-id="aed81-1787">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1788">Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> é `false`, vários soquetes podem usar o <xref:System.Net.Sockets.Socket.Bind%2A> método para vincular a uma porta específica; no entanto, somente um dos soquetes de pode executar operações em que o tráfego de rede enviado para a porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1788">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="aed81-1789">Se mais de um soquete tenta usar o <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> método para vincular a uma porta específica, em seguida, um com o endereço IP mais específico manipulará o tráfego de rede enviado a essa porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1789">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="aed81-1790">Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> é `true`, o primeiro uso do <xref:System.Net.Sockets.Socket.Bind%2A> método para tentar associar a uma porta específica, independentemente do endereço IP (Internet Protocol), será bem-sucedida; usos subsequentes do <xref:System.Net.Sockets.Socket.Bind%2A> método para tentar associar a porta falharão até que o original associado soquete é destruído.</span><span class="sxs-lookup"><span data-stu-id="aed81-1790">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="aed81-1791">Essa propriedade deve ser definida antes de <xref:System.Net.Sockets.Socket.Bind%2A> é chamado; caso contrário, um <xref:System.InvalidOperationException> será lançada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1791">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1792">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1792">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1793">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1794">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="aed81-1795"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> foi chamado para este <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1795"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aed81-1796">Libera os recursos usados pela classe <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1796">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1797">O <xref:System.Net.Sockets.Socket> classe finalizador chamadas a <xref:System.Net.Sockets.Socket.Close%2A> método para fechar o <xref:System.Net.Sockets.Socket> e liberar recursos associados a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1797">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1798">Retorna o valor de uma opção <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1798">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-1799">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1799">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-1800">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1800">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-1801">Retorna o valor de uma opção <see cref="T:System.Net.Sockets.Socket" /> especificada, representada como um objeto.</span><span class="sxs-lookup"><span data-stu-id="aed81-1801">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="aed81-1802">Um objeto que representa o valor da opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-1802">An object that represents the value of the option.</span></span> <span data-ttu-id="aed81-1803">Quando o parâmetro <paramref name="optionName" /> for definido como <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, o valor retornado é uma instância da classe <see cref="T:System.Net.Sockets.LingerOption" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1803">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="aed81-1804">Quando <paramref name="optionName" /> for definido como <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> ou <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, o valor retornado é uma instância da classe <see cref="T:System.Net.Sockets.MulticastOption" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1804">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="aed81-1805">Quando <paramref name="optionName" /> for qualquer outro valor, o valor retornado é um inteiro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1805">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1806"><xref:System.Net.Sockets.Socket> opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1806"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1807">Use essa sobrecarga para obter o <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opções.</span><span class="sxs-lookup"><span data-stu-id="aed81-1807">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="aed81-1808">Para o <xref:System.Net.Sockets.SocketOptionName.Linger> opção, use <xref:System.Net.Sockets.Socket> para o `optionLevel` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1808">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="aed81-1809">Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1809">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="aed81-1810">Se você deseja definir o valor de qualquer uma das opções listadas acima, use o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1810">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1811">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1812">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1812">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1813">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1813">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1814">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1814">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1815">O seguinte código de exemplo recupera o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite e exibe-as no console.</span><span class="sxs-lookup"><span data-stu-id="aed81-1815">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1816">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1816">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="aed81-1817">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1817">-or-</span></span>  
  
 <span data-ttu-id="aed81-1818"><paramref name="optionName" /> foi definido para o valor sem suporte <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1818"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1819">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1819">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-1820">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1820">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-1821">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1821">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="aed81-1822">Uma matriz do tipo <see cref="T:System.Byte" /> que receberá a configuração da opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-1822">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="aed81-1823">Retorna a opção da configuração <see cref="T:System.Net.Sockets.Socket" /> especificada, representada como uma matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1823">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1824"><xref:System.Net.Sockets.Socket> opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1824"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-1825">Após a conclusão bem-sucedida desse método, a matriz especificada pelo `optionValue` parâmetro contém o valor especificado <xref:System.Net.Sockets.Socket> opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-1825">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="aed81-1826">Quando o comprimento do `optionValue` matriz é menor do que o número de bytes necessários para armazenar o valor especificado <xref:System.Net.Sockets.Socket> opção <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1826">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1827">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1827">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1828">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1828">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="aed81-1829">Use essa sobrecarga para qualquer soquetes que são representados por valores boolianos ou inteiros.</span><span class="sxs-lookup"><span data-stu-id="aed81-1829">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1830">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1830">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1831">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1831">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1832">O seguinte código de exemplo recupera o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite e exibe-as no console.</span><span class="sxs-lookup"><span data-stu-id="aed81-1832">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1833">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1833">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="aed81-1834">\- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1834">\- or -</span></span>  
  
 <span data-ttu-id="aed81-1835">Em aplicativos do .NET Compact Framework, o espaço do buffer padrão do Windows CE é definido como 32768 bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1835">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="aed81-1836">É possível alterar o espaço do buffer por soquete chamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1836">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1837">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1837">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-1838">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1838">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-1839">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1839">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="aed81-1840">O comprimento, em bytes, do valor retornado esperado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1840">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="aed81-1841">Retorna o valor da opção <see cref="T:System.Net.Sockets.Socket" /> especificada em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="aed81-1841">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="aed81-1842">Uma matriz do tipo <see cref="T:System.Byte" /> que contém o valor da opção de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1842">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1843">O `optionLength` parâmetro define o tamanho máximo da matriz de bytes retornada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1843">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="aed81-1844">Se o valor da opção requer menos bytes, a matriz conterá apenas que número de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1844">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="aed81-1845">Se o valor da opção requer mais bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1845">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-1846">Use essa sobrecarga para qualquer soquetes que são representados por valores boolianos ou inteiros.</span><span class="sxs-lookup"><span data-stu-id="aed81-1846">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1847">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1847">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1848">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1848">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1849">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1849">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1850">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1850">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1851">O seguinte código de exemplo recupera o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite e exibe-as no console.</span><span class="sxs-lookup"><span data-stu-id="aed81-1851">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1852">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1852">An error occurred when attempting to access the socket.</span></span>  
  
 <span data-ttu-id="aed81-1853">\- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1853">\- or -</span></span>  
  
 <span data-ttu-id="aed81-1854">Em aplicativos do .NET Compact Framework, o espaço do buffer padrão do Windows CE é definido como 32768 bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1854">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="aed81-1855">É possível alterar o espaço do buffer por soquete chamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1855">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1856">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1856">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1857">Obtém o identificador de sistema operacional do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1857">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-1858">Um <see cref="T:System.IntPtr" /> que representa o identificador de sistema operacional do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1858">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-1859">Define os modos de operação de nível baixo para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1859">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="aed81-1860">Um valor <see cref="T:System.Int32" /> que especifica o código de controle da operação a ser executado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1860">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="aed81-1861">Uma matriz <see cref="T:System.Byte" /> que contém os dados de entrada necessários para a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1861">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="aed81-1862">Uma matriz <see cref="T:System.Byte" /> que contém os dados de saída retornados para a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1862">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1863">Define os modos de operação de nível inferior do <see cref="T:System.Net.Sockets.Socket" /> usando códigos de controle numéricos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1863">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="aed81-1864">O número de bytes no parâmetro <paramref name="optionOutValue" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1864">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1865">O <xref:System.Net.Sockets.Socket.IOControl%2A> método fornece acesso de baixo nível para o sistema operacional <xref:System.Net.Sockets.Socket> subjacente a instância atual do <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="aed81-1865">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="aed81-1866">Para obter mais informações, consulte a documentação de WSAIoctl na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-1866">For more information, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1867">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1867">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1868">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1868">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1869">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1869">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1870">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1870">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1871">O exemplo de código a seguir compara os resultados de FIONREAD e a propriedade disponível.</span><span class="sxs-lookup"><span data-stu-id="aed81-1871">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1872">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1872">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1873">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1873">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1874">Foi feita uma tentativa de alterar o modo de bloqueio sem usar a propriedade <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1874">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-1875">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-1875">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="aed81-1876">para executar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1876">to execute unmanaged code.</span></span> <span data-ttu-id="aed81-1877">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1877">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="aed81-1878">Um valor <see cref="T:System.Net.Sockets.IOControlCode" /> que especifica o código de controle da operação a ser executada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1878">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="aed81-1879">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados de entrada necessários para a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1879">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="aed81-1880">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados de saída retornados pela operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1880">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="aed81-1881">Define modos de operação de nível inferior do <see cref="T:System.Net.Sockets.Socket" /> usando a enumeração <see cref="T:System.Net.Sockets.IOControlCode" /> para especificar códigos de controle.</span><span class="sxs-lookup"><span data-stu-id="aed81-1881">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="aed81-1882">O número de bytes no parâmetro <paramref name="optionOutValue" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1882">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1883">Esse método fornece acesso de baixo nível para o sistema operacional <xref:System.Net.Sockets.Socket> subjacente a instância atual do <xref:System.Net.Sockets.Socket> classe.</span><span class="sxs-lookup"><span data-stu-id="aed81-1883">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="aed81-1884">Para obter mais informações, consulte a documentação de WSAIoctl na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-1884">For more, see the WSAIoctl documentation in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1885">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1885">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1886">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1886">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1887">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1887">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1888">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1888">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1889">O exemplo de código a seguir compara os resultados da chamada <xref:System.Net.Sockets.Socket.IOControl%2A> com <xref:System.Net.Sockets.IOControlCode.DataToRead> e <xref:System.Net.Sockets.Socket.Available%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1889">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1890">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1890">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1891">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1891">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-1892">Foi feita uma tentativa de alterar o modo de bloqueio sem usar a propriedade <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1892">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="aed81-1893">para executar código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1893">to execute unmanaged code.</span></span> <span data-ttu-id="aed81-1894">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1894">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1895">Obtém um valor que indica se o <see cref="T:System.Net.Sockets.Socket" /> está associado a uma porta local específica.</span><span class="sxs-lookup"><span data-stu-id="aed81-1895">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1896"><see langword="true" /> e o <see cref="T:System.Net.Sockets.Socket" /> for associado a uma porta local; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1896"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1897">Um soquete é considerado associada a uma porta local se ele está vinculado explicitamente chamando o <xref:System.Net.Sockets.Socket.Bind%2A> método, ou implicitamente associada chamando membros como <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, que usa uma porta efêmera local (uma porta livre maior do que 1024, selecionados pelo sistema operacional.) Os servidores usam o <xref:System.Net.Sockets.Socket.Bind%2A> método para vincular a uma porta conhecida para que os clientes podem se conectar a eles.</span><span class="sxs-lookup"><span data-stu-id="aed81-1897">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1898">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.IsBound%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1898">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1899">Obtém ou define um valor que especifica se o <see cref="T:System.Net.Sockets.Socket" /> atrasará ao fechar um soquete em uma tentativa de enviar todos os dados pendentes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1899">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="aed81-1900">Um <see cref="T:System.Net.Sockets.LingerOption" /> que especifica como perdurar ao fechar um soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1900">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1901">O <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade altera o modo como <xref:System.Net.Sockets.Socket.Close%2A> método se comporta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1901">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="aed81-1902">Essa propriedade ao conjunto modifica as condições sob as quais a conexão pode ser redefinido com Winsock.</span><span class="sxs-lookup"><span data-stu-id="aed81-1902">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="aed81-1903">Redefinições de Conexão ainda podem ocorrer com base no comportamento de protocolo IP.</span><span class="sxs-lookup"><span data-stu-id="aed81-1903">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="aed81-1904">Essa propriedade controla o período de tempo que uma conexão orientado a conexão permanecerá aberta após uma chamada para <xref:System.Net.Sockets.Socket.Close%2A> quando os dados permanecem para serem enviadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1904">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="aed81-1905">Quando você chamar métodos para enviar dados para uma ponto a ponto, esses dados são colocados no buffer de saída de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-1905">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="aed81-1906">Essa propriedade pode ser usada para garantir que esses dados são enviados ao host remoto antes do <xref:System.Net.Sockets.TcpClient.Close%2A> método descarta a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1906">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="aed81-1907">Para habilitar remanescentes, crie um <xref:System.Net.Sockets.LingerOption> instância que contém os valores desejados e defina o <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade para essa instância.</span><span class="sxs-lookup"><span data-stu-id="aed81-1907">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="aed81-1908">A tabela a seguir descreve o comportamento do <xref:System.Net.Sockets.Socket.Close%2A> método para os valores possíveis do <xref:System.Net.Sockets.LingerOption.Enabled%2A> propriedade e o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade armazenada no <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1908">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="aed81-1909">LingerState.Enabled</span><span class="sxs-lookup"><span data-stu-id="aed81-1909">LingerState.Enabled</span></span>|<span data-ttu-id="aed81-1910">LingerState.LingerTime</span><span class="sxs-lookup"><span data-stu-id="aed81-1910">LingerState.LingerTime</span></span>|<span data-ttu-id="aed81-1911">Comportamento</span><span class="sxs-lookup"><span data-stu-id="aed81-1911">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="aed81-1912">`false` (desabilitado), o valor padrão</span><span class="sxs-lookup"><span data-stu-id="aed81-1912">`false` (disabled), the default value</span></span>|<span data-ttu-id="aed81-1913">O tempo limite não é aplicável, (padrão).</span><span class="sxs-lookup"><span data-stu-id="aed81-1913">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="aed81-1914">Tentativas de enviar dados pendentes até expira o tempo limite de protocolo IP padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1914">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="aed81-1915">`true` (habilitado)</span><span class="sxs-lookup"><span data-stu-id="aed81-1915">`true` (enabled)</span></span>|<span data-ttu-id="aed81-1916">Um tempo limite diferente de zero</span><span class="sxs-lookup"><span data-stu-id="aed81-1916">A nonzero time-out</span></span>|<span data-ttu-id="aed81-1917">Tentativas de enviar dados pendentes até expira o tempo limite especificado, e se a tentativa falhar, o Winsock redefine a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1917">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="aed81-1918">`true` (habilitado)</span><span class="sxs-lookup"><span data-stu-id="aed81-1918">`true` (enabled)</span></span>|<span data-ttu-id="aed81-1919">Um zero tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-1919">A zero timeout.</span></span>|<span data-ttu-id="aed81-1920">Descarta qualquer dados pendentes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1920">Discards any pending data.</span></span> <span data-ttu-id="aed81-1921">Para o soquete orientado a conexão (por exemplo, TCP), Winsock redefine a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1921">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="aed81-1922">A pilha de IP calcula o período de tempo limite de protocolo IP padrão para usar com base no tempo de ida e volta da conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-1922">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="aed81-1923">Na maioria dos casos, o tempo de limite calculado pela pilha é mais relevante do que um definido por um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1923">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="aed81-1924">Esse é o comportamento padrão para um soquete quando o <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade não está definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-1924">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="aed81-1925">Quando o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade armazenada no <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade é definida maior que o tempo limite de protocolo IP padrão, o tempo limite de protocolo IP padrão ainda se aplicam e substituir.</span><span class="sxs-lookup"><span data-stu-id="aed81-1925">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1926">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1926">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1927">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1927">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1928">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1928">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="aed81-1929">O comprimento máximo da fila de conexões pendentes.</span><span class="sxs-lookup"><span data-stu-id="aed81-1929">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="aed81-1930">Coloca um <see cref="T:System.Net.Sockets.Socket" /> em um estado de escuta.</span><span class="sxs-lookup"><span data-stu-id="aed81-1930">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1931"><xref:System.Net.Sockets.Socket.Listen%2A> faz com que uma conexão orientada <xref:System.Net.Sockets.Socket> para escutar as tentativas de conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1931"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="aed81-1932">O `backlog` parâmetro especifica o número de conexões de entrada que podem ser enfileirados para aceitação.</span><span class="sxs-lookup"><span data-stu-id="aed81-1932">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="aed81-1933">Para determinar o número máximo de conexões que você pode especificar, recuperar o <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valor.</span><span class="sxs-lookup"><span data-stu-id="aed81-1933">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="aed81-1934"><xref:System.Net.Sockets.Socket.Listen%2A> não bloquear.</span><span class="sxs-lookup"><span data-stu-id="aed81-1934"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="aed81-1935">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1935">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1936">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1936">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span> <span data-ttu-id="aed81-1937">Use <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> para aceitar uma conexão da fila.</span><span class="sxs-lookup"><span data-stu-id="aed81-1937">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1938">Você deve chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método antes de chamar <xref:System.Net.Sockets.Socket.Listen%2A>, ou <xref:System.Net.Sockets.Socket.Listen%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-1938">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1939">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1939">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1940">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1940">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1941">O parâmetro de lista de pendências é limitado a valores diferentes dependendo do sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="aed81-1941">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="aed81-1942">Você pode especificar um valor mais alto, mas a lista de pendências será limitada com base no sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="aed81-1942">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1943">O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket> para escutar conexões de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-1943">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1944">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1944">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1945">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1945">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1946">Obtém o ponto de extremidade local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1946">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="aed81-1947">O <see cref="T:System.Net.EndPoint" /> que o <see cref="T:System.Net.Sockets.Socket" /> está usando para comunicações.</span><span class="sxs-lookup"><span data-stu-id="aed81-1947">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1948">O <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade obtém um <xref:System.Net.EndPoint> que contém o local IP endereço e número da porta para o qual seu <xref:System.Net.Sockets.Socket> está associado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1948">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="aed81-1949">Você deve converter isso <xref:System.Net.EndPoint> para um <xref:System.Net.IPEndPoint> antes de recuperar todas as informações.</span><span class="sxs-lookup"><span data-stu-id="aed81-1949">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="aed81-1950">Em seguida, você pode chamar o <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar o local <xref:System.Net.IPAddress>e o <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar o número de porta local.</span><span class="sxs-lookup"><span data-stu-id="aed81-1950">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="aed81-1951">O <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade normalmente é definida depois de fazer uma chamada para o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1951">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-1952">Se você permitir que o sistema atribuir o endereço IP do soquete local e o número da porta, o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade será definida após a primeira operação de e/s.</span><span class="sxs-lookup"><span data-stu-id="aed81-1952">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="aed81-1953">Para protocolos orientados a conexão, a primeira operação de e/s seria uma chamada para o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-1953">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-1954">Para protocolos sem conexão, a primeira operação de e/s deve ser qualquer enviar ou receber chamadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-1954">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1955">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-1955">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-1956">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-1956">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-1957">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-1957">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-1958">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-1958">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1959">O exemplo de código a seguir recupera e exibe os pontos de extremidade locais e remotos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1959">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1960">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1960">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1961">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1961">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1962">Obtém ou define um valor que especifica se os pacotes de multicast de saída são entregues para o aplicativo de envio.</span><span class="sxs-lookup"><span data-stu-id="aed81-1962">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1963"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> receber pacotes de multicast de saída; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1963"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1964">Multicast é um método escalonável para muitos-para-muitos comunicação na Internet.</span><span class="sxs-lookup"><span data-stu-id="aed81-1964">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="aed81-1965">Um processo se inscreve para um endereço de multicast; em seguida, todos os pacotes enviados por um processo assinado são recebidos por todos os outros processos assinado ao endereço de multicast.</span><span class="sxs-lookup"><span data-stu-id="aed81-1965">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="aed81-1966">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1966">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1967">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1967">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1968">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-1968">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1969">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1969">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1970">Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> do fluxo está usando o Algoritmo de Nagle.</span><span class="sxs-lookup"><span data-stu-id="aed81-1970">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1971"><see langword="false" /> se o <see cref="T:System.Net.Sockets.Socket" /> usa o algoritmo de Nagle; caso contrário, <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1971"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="aed81-1972">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1972">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1973">O algoritmo Nagle foi projetado para reduzir o tráfego de rede, fazendo com que o soquete para o buffer de pacotes pequenos e, em seguida, combinar e enviá-los em um pacote em determinadas circunstâncias.</span><span class="sxs-lookup"><span data-stu-id="aed81-1973">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="aed81-1974">Um pacote TCP consiste em 40 bytes de cabeçalho mais os dados sendo enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1974">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="aed81-1975">Quando pacotes pequenos de dados são enviados com o TCP, a sobrecarga resultante do cabeçalho TCP pode se tornar uma parte significativa do tráfego de rede. Em redes extremamente carregados, congestionamento resultante dessa sobrecarga pode resultar em datagramas perdidas e retransmissões, bem como tempo de propagação excessiva causada pelo congestionamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-1975">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="aed81-1976">O algoritmo Nagle não permite o envio de novos segmentswhen TCP novos dados de saída chega do usuário, se os dados previouslytransmitted a conexão permanecem não confirmados.</span><span class="sxs-lookup"><span data-stu-id="aed81-1976">The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="aed81-1977">A maioria dos aplicativos de rede deve usar o algoritmo Nagle.</span><span class="sxs-lookup"><span data-stu-id="aed81-1977">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="aed81-1978">A definição dessa propriedade em um soquete do protocolo UDP (User Datagram) não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="aed81-1978">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-1979">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.NoDelay%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-1979">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-1980">Ocorreu um erro ao tentar acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1980">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-1981">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-1981">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1982">Indica se o sistema operacional subjacente e os adaptadores de rede dão suporte ao IPv4 (protocolo IP versão 4).</span><span class="sxs-lookup"><span data-stu-id="aed81-1982">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1983"><see langword="true" /> se o sistema operacional e os adaptadores de rede derem suporte ao protocolo IPv4; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1983"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1984">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-1984">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-1985">Indica se o sistema operacional subjacente e os adaptadores de rede dão suporte ao IPv6 (protocolo IP versão 6).</span><span class="sxs-lookup"><span data-stu-id="aed81-1985">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value>
          <span data-ttu-id="aed81-1986"><see langword="true" /> se o sistema operacional e os adaptadores de rede derem suporte ao protocolo IPv6; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1986"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-1987">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-1987">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="aed81-1988">O tempo de espera por uma resposta, em microssegundos.</span><span class="sxs-lookup"><span data-stu-id="aed81-1988">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="aed81-1989">Um dos valores de <see cref="T:System.Net.Sockets.SelectMode" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1989">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-1990">Determina o status do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1990">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-1991">O status do <see cref="T:System.Net.Sockets.Socket" /> com base no valor de modo de sondagem passado no parâmetro <paramref name="mode" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1991">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <span data-ttu-id="aed81-1992"><list type="table"><listheader><term> Modo</span><span class="sxs-lookup"><span data-stu-id="aed81-1992"><list type="table"><listheader><term> Mode</span></span>  
  
 <span data-ttu-id="aed81-1993"></term><description> Valor Retornado</span><span class="sxs-lookup"><span data-stu-id="aed81-1993"></term><description> Return Value</span></span>  
  
 <span data-ttu-id="aed81-1994"></description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> se <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> foi chamado e uma conexão está pendente;</span><span class="sxs-lookup"><span data-stu-id="aed81-1994"></description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span>  
  
 <span data-ttu-id="aed81-1995">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1995">-or-</span></span>  
  
 <span data-ttu-id="aed81-1996"><see langword="true" /> se os dados estiverem disponíveis para leitura;</span><span class="sxs-lookup"><span data-stu-id="aed81-1996"><see langword="true" /> if data is available for reading;</span></span>  
  
 <span data-ttu-id="aed81-1997">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-1997">-or-</span></span>  
  
 <span data-ttu-id="aed81-1998"><see langword="true" /> se a conexão foi fechada, redefinida ou terminada;</span><span class="sxs-lookup"><span data-stu-id="aed81-1998"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span>  
  
 <span data-ttu-id="aed81-1999">caso contrário, retornará <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-1999">otherwise, returns <see langword="false" />.</span></span>  
  
 <span data-ttu-id="aed81-2000"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, se houver processamento de um <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> e a conexão foi bem-sucedida;</span><span class="sxs-lookup"><span data-stu-id="aed81-2000"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span>  
  
 <span data-ttu-id="aed81-2001">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2001">-or-</span></span>  
  
 <span data-ttu-id="aed81-2002"><see langword="true" /> se for possível enviar os dados;</span><span class="sxs-lookup"><span data-stu-id="aed81-2002"><see langword="true" /> if data can be sent;</span></span>  
  
 <span data-ttu-id="aed81-2003">caso contrário, retornará <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2003">otherwise, returns <see langword="false" />.</span></span>  
  
 <span data-ttu-id="aed81-2004"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> se houver processamento de um <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> que não bloqueia e a conexão falhou;</span><span class="sxs-lookup"><span data-stu-id="aed81-2004"></description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span>  
  
 <span data-ttu-id="aed81-2005">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2005">-or-</span></span>  
  
 <span data-ttu-id="aed81-2006"><see langword="true" /> se <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> não estiver definido e dados fora de banda estiverem disponíveis;</span><span class="sxs-lookup"><span data-stu-id="aed81-2006"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span>  
  
 <span data-ttu-id="aed81-2007">caso contrário, retornará <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2007">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2008">O <xref:System.Net.Sockets.Socket.Poll%2A> método verificará o estado do <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2008">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-2009">Especifique <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> para o `selectMode` parâmetro para determinar se o <xref:System.Net.Sockets.Socket> é legível.</span><span class="sxs-lookup"><span data-stu-id="aed81-2009">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="aed81-2010">Especifique <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> para determinar se o <xref:System.Net.Sockets.Socket> é gravável.</span><span class="sxs-lookup"><span data-stu-id="aed81-2010">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="aed81-2011">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> para detectar uma condição de erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2011">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="aed81-2012"><xref:System.Net.Sockets.Socket.Poll%2A> bloqueará a execução até que o período de tempo especificado, medida em `microseconds`, expira.</span><span class="sxs-lookup"><span data-stu-id="aed81-2012"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="aed81-2013">Definir o `microSeconds` parâmetro para um inteiro negativo se você gostaria de esperar indefinidamente por uma resposta.</span><span class="sxs-lookup"><span data-stu-id="aed81-2013">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="aed81-2014">Se você quiser verificar o status de vários soquetes, talvez você prefira usar o <xref:System.Net.Sockets.Socket.Select%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2014">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2015">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2015">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2016">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2016">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2017">Este método não pode detectar determinados tipos de problemas de conexão, como um cabo de rede interrompido, ou que o host remoto foi desligado maneira brusca.</span><span class="sxs-lookup"><span data-stu-id="aed81-2017">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="aed81-2018">Você deve tentar enviar ou receber dados para detectar esses tipos de erros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2018">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2019">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2019">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2020">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2020">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2021">O exemplo de código a seguir cria um soquete, se conecta a um servidor e usa <xref:System.Net.Sockets.Socket.Poll%2A> para verificar o status do soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2021">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-2022">O parâmetro <paramref name="mode" /> não é um dos valores <see cref="T:System.Net.Sockets.SelectMode" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2022">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2023">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2023">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-2024">Consulte os comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2024">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2025">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2025">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-2026">Obtém o tipo de protocolo do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2026">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-2027">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2027">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2028">O <xref:System.Net.Sockets.Socket.ProtocolType%2A> propriedade é definida quando o <xref:System.Net.Sockets.Socket> é criado e especifica o protocolo usado pelo <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2028">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2029">O código a seguir exemplo exibe o <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> para o console.</span><span class="sxs-lookup"><span data-stu-id="aed81-2029">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-2030">Recebe dados de um limite <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2030">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2031">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2031">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="aed81-2032">Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção.</span><span class="sxs-lookup"><span data-stu-id="aed81-2032">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="aed81-2033">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2033">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2034">O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2034">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2035">Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2035">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2036">Essa sobrecarga exige somente que você forneça um buffer de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2036">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="aed81-2037">Deslocamento de buffer padrão é 0, o tamanho padrão é o comprimento do parâmetro buffer e o <xref:System.Net.Sockets.SocketFlags> valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2037">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="aed81-2038">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2038">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2039">O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2039">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2040">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2040">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2041"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2041"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2042">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2042">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2043">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2043">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2044">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2044">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2045">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2045">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2046">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2046">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2047">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2047">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="aed81-2048">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2048">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2049">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2049">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2050">Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2050">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2051">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2051">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2052">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2052">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2053">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2053">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2054">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2054">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2055">O exemplo de código a seguir recebe dados sobre conectada <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2055">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2056"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2056"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2057">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2057">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2058">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2058">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2059">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2059">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2060">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2060">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2061">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2061">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-2062">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2062">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="aed81-2063">Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado na lista de buffers de recepção.</span><span class="sxs-lookup"><span data-stu-id="aed81-2063">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="aed81-2064">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2064">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2065">Esse método lê dados para o parâmetro de buffers e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2065">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2066">Você pode chamar de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2066">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2067">Essa sobrecarga exige que você forneça um ou mais buffers de recepção.</span><span class="sxs-lookup"><span data-stu-id="aed81-2067">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="aed81-2068">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2068">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2069">O <xref:System.Net.Sockets.Socket.Receive%2A> método lerá apenas dados que chega da conexão do host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2069">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2070">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2070">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2071"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2071"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2072">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2072">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2073">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2073">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2074">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2074">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2075">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2075">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2076">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2076">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2077">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2077">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="aed81-2078">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2078">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2079">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2079">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2080">Se o datagrama receber é maior do que o tamanho do `buffers` parâmetro `buffers` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2080">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2081">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2081">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2082">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2082">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="aed81-2083">**Observação** esse membro gera informações de rastreamento, quando você habilita o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2083">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2084">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2084">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-2085">O parâmetro <paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2085">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2086">Erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2086">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2087">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2087">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2088">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2088">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2089">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2089">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2090">Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2090">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2091">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2091">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2092">O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2092">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2093">Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2093">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2094">Essa sobrecarga exige somente que você fornecer um buffer de recebimento e necessários <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2094">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="aed81-2095">Deslocamento de buffer padrão é 0 e o tamanho padrão é o comprimento do parâmetro bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2095">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="aed81-2096">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2096">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2097">O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2097">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2098">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2098">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2099"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2099"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2100">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-2100">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-2101">Se você estiver no modo sem bloqueio, e nenhum dado está disponível no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2101">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2102">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2102">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2103">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2103">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2104">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados está disponível até o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2104">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="aed81-2105">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2105">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2106">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2106">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2107">Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2107">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2108">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2108">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2109">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2109">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2110">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2110">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2111">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2111">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2112">O exemplo de código a seguir especifica um buffer de dados, e <xref:System.Net.Sockets.SocketFlags> para receber dados em um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2112">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2113"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2113"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2114">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2114">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2115">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2115">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2116">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2116">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2117">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2117">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2118">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2118">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-2119">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2119">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2120">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2120">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2121">Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado na lista de buffers de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2121">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2122">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2122">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2123">Esse método lê os dados para o `buffers` parâmetro e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2123">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2124">Você pode chamar de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2124">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2125">Essa sobrecarga exige que você forneça um ou mais buffers de recepção.</span><span class="sxs-lookup"><span data-stu-id="aed81-2125">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="aed81-2126">O <xref:System.Net.Sockets.SocketFlags> valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2126">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="aed81-2127">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2127">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2128">O <xref:System.Net.Sockets.Socket.Receive%2A> método lerá apenas dados que chega da conexão do host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2128">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2129">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2129">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2130"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2130"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2131">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2131">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2132">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamar lança um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2132">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2133">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2133">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2134">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2134">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2135">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2135">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2136">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2136">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="aed81-2137">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2137">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2138">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2138">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2139">Se o datagrama receber é maior do que o tamanho do `buffers` parâmetro `buffers` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2139">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2140">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2140">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2141">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2141">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2142">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2142">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2143">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2143">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2144">O exemplo de código a seguir demonstra como receber dados em um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2144">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2145"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2145"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2146">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2146">-or-</span></span>  
  
 <span data-ttu-id="aed81-2147"><paramref name="buffers" />.Count é zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-2147"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2148">Erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2148">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2149">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2149">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2150">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2150">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2151">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2151">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2152">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2152">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2153">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2153">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2154">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2154">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2155">Recebe o número de bytes especificado de dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2155">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2156">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2156">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2157">O <xref:System.Net.Sockets.Socket.Receive%2A> método lê os dados para o `buffer` parâmetro e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2157">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2158">Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2158">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2159">Essa sobrecarga exige somente que você forneça um buffer de recepção, o número de bytes que você deseja receber e necessários <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2159">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="aed81-2160">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2160">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2161">O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2161">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2162">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2162">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2163"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2163"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2164">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2164">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2165">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2165">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2166">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2166">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2167">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2167">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2168">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2168">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2169">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo `size` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2169">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="aed81-2170">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2170">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2171">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2171">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2172">Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2172">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2173">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2173">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2174">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2174">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2175">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2176">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2176">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2177">A seguir recebe os dados encontrados em `buffer`e especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2177">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2178"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2178"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2179"><paramref name="buffer" /> excede o tamanho de <paramref name="size" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2179"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2180">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2180">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2181">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2181">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2182">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2182">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2183">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2183">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2184">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2184">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-2185">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2185">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2186">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2186">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-2187">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2187">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="aed81-2188">Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado na lista de buffers de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2188">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2189">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2189">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2190">Esse método lê os dados para o `buffers` parâmetro e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2190">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2191">Você pode chamar de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2191">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2192">Essa sobrecarga exige que você forneça um ou mais buffers de recepção.</span><span class="sxs-lookup"><span data-stu-id="aed81-2192">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="aed81-2193">O <xref:System.Net.Sockets.SocketFlags> valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2193">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="aed81-2194">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2194">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2195">O <xref:System.Net.Sockets.Socket.Receive%2A> método lerá apenas dados que chega da conexão do host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2195">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2196">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2196">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2198">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2198">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2199">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamar lança um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2199">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2200">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2200">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2201">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2201">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2202">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2202">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2203">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2203">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="aed81-2204">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2204">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2205">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2205">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2206">Se o datagrama receber é maior do que o tamanho do `buffers` parâmetro `buffers` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2206">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2207">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2207">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2208">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2208">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2209">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2209">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2210">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2210">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2211"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2211"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2212">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2212">-or-</span></span>  
  
 <span data-ttu-id="aed81-2213"><paramref name="buffers" />.Count é zero.</span><span class="sxs-lookup"><span data-stu-id="aed81-2213"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2214">Erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2214">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2215">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2216">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2216">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2217">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2217">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2218">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2218">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-2219">O local no <c>buffer</c> para armazenar os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2219">The location in <c>buffer</c> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2220">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2220">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2221">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2221">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2222">Recebe o número de bytes especificado de um <see cref="T:System.Net.Sockets.Socket" /> associado na posição de deslocamento especificada do buffer de recepção usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2222">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2223">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2223">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2224">O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2224">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2225">Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2225">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2226">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2226">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2227">O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2227">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2228">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2228">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2229"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2229"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2230">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2230">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2231">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2231">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2232">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2232">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2233">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2233">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-2234">Consulte os comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2234">See Remarks below.</span></span> <span data-ttu-id="aed81-2235">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2235">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2236">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2236">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2237">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo parâmetro de tamanho.</span><span class="sxs-lookup"><span data-stu-id="aed81-2237">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="aed81-2238">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2238">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2239">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2239">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2240">Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2240">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2241">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2241">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2242">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2242">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2243">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2243">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2244">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2244">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2245">O exemplo de código a seguir especifica um buffer de dados, um deslocamento, um tamanho e um sinalizador de soquete antes de receber os dados em um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2245">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2246"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2246"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2247"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2247"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2248">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2248">-or-</span></span>  
  
 <span data-ttu-id="aed81-2249"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2249"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-2250">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2250">-or-</span></span>  
  
 <span data-ttu-id="aed81-2251"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2251"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2252">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2252">-or-</span></span>  
  
 <span data-ttu-id="aed81-2253"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2253"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2254"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2254"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2255">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2255">-or-</span></span>  
  
 <span data-ttu-id="aed81-2256">A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2256">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="aed81-2257">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2257">-or-</span></span>  
  
 <span data-ttu-id="aed81-2258">Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2258">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2259">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2259">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2260">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2260">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2261">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2261">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2262">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2262">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2263">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2263">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-2264">A posição no parâmetro <c>buffer</c> para armazenar os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2264">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2265">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2265">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2266">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2266">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-2267">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2267">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="aed81-2268">Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2268">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2269">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2269">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2270">O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2270">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="aed81-2271">Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2271">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="aed81-2272">Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2272">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="aed81-2273">O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2273">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2274">Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2274">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2275"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> permitirá que você receba dados recebidos de qualquer host.</span><span class="sxs-lookup"><span data-stu-id="aed81-2275"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="aed81-2276">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2276">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2277">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2277">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2278">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2278">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2279">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2279">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-2280">Consulte os comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2280">See Remarks below.</span></span> <span data-ttu-id="aed81-2281">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2281">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2282">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2282">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2283">Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo parâmetro de tamanho.</span><span class="sxs-lookup"><span data-stu-id="aed81-2283">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="aed81-2284">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2284">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="aed81-2285">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2285">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="aed81-2286">Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2286">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2287">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2287">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2288">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2288">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2289">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2289">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2290">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2290">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2291"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2291"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2292"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2292"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2293">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2293">-or-</span></span>  
  
 <span data-ttu-id="aed81-2294"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2294"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-2295">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2295">-or-</span></span>  
  
 <span data-ttu-id="aed81-2296"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2296"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2297">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2297">-or-</span></span>  
  
 <span data-ttu-id="aed81-2298"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2298"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2299"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2299"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2300">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2300">-or-</span></span>  
  
 <span data-ttu-id="aed81-2301">A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2301">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
 <span data-ttu-id="aed81-2302">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2302">-or-</span></span>  
  
 <span data-ttu-id="aed81-2303">Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2303">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2304">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2304">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2305">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2305">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2306">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2306">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2307">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2307">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-2308">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-2308">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-2309">Inicia uma solicitação assíncrona para receber dados de um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2309">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="aed81-2310">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2310">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-2311">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2311">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-2312">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-2312">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-2313">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2313">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2314">O <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método é usado em conectado soquetes ou vinculados soquetes sem conexão e é usado para ler os dados de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2314">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="aed81-2315">Endereço local do soquete deve ser conhecido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2315">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="aed81-2316">Para soquetes sem conexão associadas, esta função restringe os endereços de onde as mensagens recebidas são aceitas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2316">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="aed81-2317">A função retorna apenas as mensagens do endereço remoto especificado na conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2317">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="aed81-2318">Mensagens de outros endereços são descartadas silenciosamente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2318">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="aed81-2319">O <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriedade o `e` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a solicitação de leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2319">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="aed81-2320">Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2320">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="aed81-2321">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:</span><span class="sxs-lookup"><span data-stu-id="aed81-2321">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="aed81-2322"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="aed81-2322"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="aed81-2323"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido</span><span class="sxs-lookup"><span data-stu-id="aed81-2323"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="aed81-2324"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido</span><span class="sxs-lookup"><span data-stu-id="aed81-2324"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-2325">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2325">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-2326">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2326">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-2327">Para soquetes do estilo de fluxo de bytes, os dados de entrada são colocados no buffer até que o buffer é preenchido, a conexão é fechada ou os dados armazenados em buffer internamente são esgotados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2327">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="aed81-2328">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer associado a `e` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2328">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="aed81-2329">Se a mensagem for maior do que o buffer, o buffer é preenchido com a primeira parte da mensagem.</span><span class="sxs-lookup"><span data-stu-id="aed81-2329">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="aed81-2330">Para soquetes orientados a conexão, o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método pode indicar que o encerramento amigável do circuito virtual em uma das duas maneiras que dependem de se o soquete é orientado a mensagem ou fluxo de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2330">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="aed81-2331">Para fluxos de byte zero bytes foi lidos indica fechamento normal e que não há mais bytes nunca serão lidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2331">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="aed81-2332">Para soquetes orientado a mensagens, em que uma mensagem de zero bytes geralmente é permitida, um <xref:System.Net.Sockets.SocketException> com o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> definido como o código de erro nativo do Winsock WSAEDISCON (10101) é usado para indicar o encerramento normal.</span><span class="sxs-lookup"><span data-stu-id="aed81-2332">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="aed81-2333">Em qualquer caso, um <xref:System.Net.Sockets.SocketException> com o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> definido para o nativo WSAECONNRESET Winsock o código de erro (10054) indica um fechamento por anulação ocorreu.</span><span class="sxs-lookup"><span data-stu-id="aed81-2333">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-2334">Um argumento era inválido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2334">An argument was invalid.</span></span> <span data-ttu-id="aed81-2335">As propriedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no parâmetro <paramref name="e" /> devem referenciar buffers válidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2335">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="aed81-2336">Uma ou a outra dessas propriedades poderá ser definida, mas não ambas ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2336">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-2337">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2337">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-2338">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2338">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2339">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2339">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2340">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2340">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-2341">Obtém ou define um valor que especifica o tamanho do buffer de recepção do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2341">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-2342">Um <see cref="T:System.Int32" /> que contém o tamanho, em bytes, do buffer de recepção.</span><span class="sxs-lookup"><span data-stu-id="aed81-2342">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="aed81-2343">O padrão é 8192.</span><span class="sxs-lookup"><span data-stu-id="aed81-2343">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2344">Potencialmente, um tamanho de buffer maior reduz o número de confirmações vazios (pacotes TCP com nenhuma parte de dados), mas também pode atrasar o reconhecimento de problemas de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2344">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="aed81-2345">Considere aumentar o tamanho do buffer se estiver transferindo arquivos grandes ou se você estiver usando a largura de banda alta, a conexão de alta latência (como um satélite provedor de banda larga.)</span><span class="sxs-lookup"><span data-stu-id="aed81-2345">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2346">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2346">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2347">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2347">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2348">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2348">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-2349">O valor especificado para uma operação de definição é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2349">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-2350">Recebe um datagrama e armazena o ponto de extremidade de origem.</span><span class="sxs-lookup"><span data-stu-id="aed81-2350">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2351">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2351">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-2352">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2352">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="aed81-2353">Recebe um datagrama no buffer de dados e armazena o ponto de extremidade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2353">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-2354">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2354">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2355">O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2355">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="aed81-2356">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</span><span class="sxs-lookup"><span data-stu-id="aed81-2356">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="aed81-2357">Essa sobrecarga exige somente que você fornecer um recebimento `buffer`e um <xref:System.Net.EndPoint> que representa o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2357">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="aed81-2358">Deslocamento de buffer padrão é 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2358">The buffer offset defaults to 0.</span></span> <span data-ttu-id="aed81-2359">O tamanho padrão é o comprimento do `buffer` parâmetro e o `socketFlags` valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2359">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2360">Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2360">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-2361">Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2361">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-2362">Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-2362">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="aed81-2363">Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2363">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2364">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2364">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="aed81-2365">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2365">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="aed81-2366">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-2366">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-2367">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2367">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2368">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2368">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2369">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2369">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2370">Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</span><span class="sxs-lookup"><span data-stu-id="aed81-2370">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="aed81-2371">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2371">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2372">Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2372">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2373">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2373">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2374">Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2374">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-2375">Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até o tamanho de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-2375">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="aed81-2376">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2376">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2377">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2377">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2378">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2378">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2379">O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2379">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2380">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2380">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2381">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2381">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2382">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2382">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2383"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2383"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2384">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2384">-or-</span></span>  
  
 <span data-ttu-id="aed81-2385"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2385"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2386">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2386">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2387">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2387">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2388">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2388">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2389">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2389">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2390">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2390">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2391">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2391">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2392">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2392">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-2393">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2393">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="aed81-2394">Recebe um datagrama no buffer de dados, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena o ponto de extremidade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2394">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-2395">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2395">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2396">O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2396">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="aed81-2397">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</span><span class="sxs-lookup"><span data-stu-id="aed81-2397">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="aed81-2398">Essa sobrecarga exige somente que você forneça um buffer de recepção, o necessário <xref:System.Net.Sockets.SocketFlags>e um <xref:System.Net.EndPoint> que representa o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2398">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="aed81-2399">O deslocamento padrão é 0 e o tamanho padrão é o comprimento do parâmetro de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2399">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2400">Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2400">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-2401">Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2401">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-2402">Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-2402">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="aed81-2403">Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2403">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2404">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2404">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="aed81-2405">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2405">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="aed81-2406">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-2406">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-2407">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2407">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2408">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2408">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2409">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2409">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2410">Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</span><span class="sxs-lookup"><span data-stu-id="aed81-2410">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="aed81-2411">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2411">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2412">Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2412">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2413">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2413">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2414">Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2414">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-2415">Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até o tamanho de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-2415">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="aed81-2416">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2416">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2417">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2417">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2418">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2418">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2419">O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2419">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2420">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2420">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2421">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2421">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2422">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2422">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="aed81-2423"><xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2423"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2424"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2424"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2425">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2425">-or-</span></span>  
  
 <span data-ttu-id="aed81-2426"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2426"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2427">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2427">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2428">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2428">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2429">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2429">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2430">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2430">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2431">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2431">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2432">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2432">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2433">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2433">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2434">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2434">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-2435">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2435">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="aed81-2436">Recebe o número especificado de bytes no buffer de dados usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena o ponto de extremidade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2436">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-2437">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2437">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2438">O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2438">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="aed81-2439">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</span><span class="sxs-lookup"><span data-stu-id="aed81-2439">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="aed81-2440">Essa sobrecarga exige somente que você forneça um buffer de recepção, o número de bytes que você deseja receber as necessárias <xref:System.Net.Sockets.SocketFlags>e um <xref:System.Net.EndPoint> que representa o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2440">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="aed81-2441">Deslocamento de buffer padrão é 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2441">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="aed81-2442">Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-2442">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="aed81-2443">Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2443">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2444">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2444">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="aed81-2445">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2445">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="aed81-2446">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-2446">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-2447">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2447">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2448">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2448">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2449">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2449">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2450">Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</span><span class="sxs-lookup"><span data-stu-id="aed81-2450">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="aed81-2451">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2451">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2452">Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2452">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2453">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2453">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2454">Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2454">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-2455">Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até o número de bytes especificado pelo `size` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2455">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="aed81-2456">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2456">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2457">Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2457">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-2458">Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2458">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2459">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2459">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2460">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2460">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2461">O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2461">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2462">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2463">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2464">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2464">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="aed81-2465">O tamanho do buffer e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2465">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2466"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2466"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2467">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2467">-or-</span></span>  
  
 <span data-ttu-id="aed81-2468"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2468"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2469"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2469"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2470">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2470">-or-</span></span>  
  
 <span data-ttu-id="aed81-2471"><paramref name="size" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2471"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2472"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2472"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2473">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2473">-or-</span></span>  
  
 <span data-ttu-id="aed81-2474">A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2474">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="aed81-2475">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2475">-or-</span></span>  
  
 <span data-ttu-id="aed81-2476">Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2476">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2477">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2477">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-2478">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2478">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2479">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2479">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2480">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2480">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2481">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2481">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-2482">A posição no parâmetro <c>buffer</c> para armazenar os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2482">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2483">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2483">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2484">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2484">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-2485">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2485">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="aed81-2486">Recebe o número de bytes de dados no local especificado no buffer de dados usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena o ponto de extremidade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2486">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-2487">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2487">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2488">O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2488">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="aed81-2489">Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.</span><span class="sxs-lookup"><span data-stu-id="aed81-2489">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="aed81-2490">Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local.</span><span class="sxs-lookup"><span data-stu-id="aed81-2490">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="aed81-2491">Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2491">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2492">Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2492">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="aed81-2493">Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2493">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="aed81-2494">Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis.</span><span class="sxs-lookup"><span data-stu-id="aed81-2494">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="aed81-2495">Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2495">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2496">Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2496">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="aed81-2497">Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2497">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="aed81-2498">Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também.</span><span class="sxs-lookup"><span data-stu-id="aed81-2498">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="aed81-2499">Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2499">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-2500">Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2500">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2501">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2501">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="aed81-2502">Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2502">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-2503">Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até a quantidade de bytes especificados pelo `size` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2503">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="aed81-2504">Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2504">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2505">Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2505">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-2506">Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2506">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2507">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2507">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2508">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2508">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2509">O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2509">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2510">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2510">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2511">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2511">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2512">O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2512">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="aed81-2513">O deslocamento, o tamanho do buffer, e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2513">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2514"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2514"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2515">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2515">-or-</span></span>  
  
 <span data-ttu-id="aed81-2516"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2516"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2517"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2517"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2518">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2518">-or-</span></span>  
  
 <span data-ttu-id="aed81-2519"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2519"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-2520">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2520">-or-</span></span>  
  
 <span data-ttu-id="aed81-2521"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2521"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2522">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2522">-or-</span></span>  
  
 <span data-ttu-id="aed81-2523"><paramref name="size" /> é maior que o comprimento de <paramref name="buffer" /> menos o valor do parâmetro de deslocamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2523"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2524"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2524"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2525">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2525">-or-</span></span>  
  
 <span data-ttu-id="aed81-2526">A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2526">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="aed81-2527">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2527">-or-</span></span>  
  
 <span data-ttu-id="aed81-2528">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2528">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2529">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2529">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2530">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2530">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2531">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2531">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-2532">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-2532">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-2533">Começa a receber dados de um dispositivo de rede especificado de maneira assíncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-2533">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="aed81-2534">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2534">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-2535">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2535">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-2536">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-2536">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-2537">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2537">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2538">O <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método é usado principalmente para receber dados em um soquete sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2538">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="aed81-2539">Endereço local do soquete deve ser conhecido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2539">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="aed81-2540">O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto do qual os dados são a ser recebida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2540">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="aed81-2541">O <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriedade o `e` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a solicitação de leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2541">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="aed81-2542">Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2542">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="aed81-2543">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:</span><span class="sxs-lookup"><span data-stu-id="aed81-2543">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-2544">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2544">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-2545">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2545">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-2546">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2546">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="aed81-2547">O <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2547">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="aed81-2548">Para soquetes de fluxo estilo bytes, os dados de entrada são colocados no buffer até que o buffer é preenchido, a conexão é fechada ou os dados armazenados em buffer internamente são esgotados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2548">For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="aed81-2549">O <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2549">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-2550">O <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não pode ser nulo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2550">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-2551">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2551">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-2552">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2552">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2553">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2553">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2554">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2554">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2555">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2555">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-2556">A posição no parâmetro <c>buffer</c> para armazenar os dados recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2556">The position in the <c>buffer</c> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2557">O número de bytes a serem recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2557">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2558">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2558">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-2559">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2559">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="aed81-2560">Um <see cref="T:System.Net.Sockets.IPPacketInformation" /> que contém informações de endereço e de interface.</span><span class="sxs-lookup"><span data-stu-id="aed81-2560">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="aed81-2561">Recebe o número de bytes de dados no local especificado no buffer de dados usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena as informações de ponto de extremidade e pacote.</span><span class="sxs-lookup"><span data-stu-id="aed81-2561">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="aed81-2562">O número de bytes recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2562">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2563">O <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados, bem como informações sobre o pacote recebido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2563">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="aed81-2564">O <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método é usado principalmente para receber dados de mensagem em um soquete sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2564">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="aed81-2565">Endereço local do soquete deve ser conhecido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2565">The socket's local address must be known.</span></span> <span data-ttu-id="aed81-2566">Esse método só pode ser usado com o datagrama e soquetes brutos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2566">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="aed81-2567">O soquete deve ser inicializado com o tipo de soquete definido como <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2567">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="aed81-2568">Isso pode ser feito quando o soquete é construído usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2568">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2569">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no `buffer` parâmetro até o tamanho total especificado no `size` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2569">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="aed81-2570">O `offset` parâmetro determina onde no `buffer` os dados são colocados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2570">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="aed81-2571">A quantidade real de dados colocados no `buffer` é retornado pelo <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2571">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-2572">O <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método define automaticamente um método de <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para `true` na primeira vez que ele é chamado para um determinado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2572">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-2573">No entanto, retornado <xref:System.Net.Sockets.IPPacketInformation> objeto será válido apenas para pacotes que chegam ao computador local depois que a opção de soquete foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2573">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="aed81-2574">Se um soquete é enviado pacotes entre quando ele está associado a um ponto de extremidade local (explicitamente, o <xref:System.Net.Sockets.Socket.Bind%2A> método ou implicitamente por uma da <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) e sua primeira chamada para o <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> chamadas de método, a <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método retornará inválido <xref:System.Net.Sockets.IPPacketInformation> objetos para esses pacotes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2574">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="aed81-2575">Para garantir que todos os <xref:System.Net.Sockets.IPPacketInformation> objetos sejam válidos, um aplicativo deve definir o <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para `true` antes que ele está associado a um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2575">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="aed81-2576">Um aplicativo pode examinar o `ipPacketInformation` parâmetro se ele precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.</span><span class="sxs-lookup"><span data-stu-id="aed81-2576">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2577">O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2577">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2578">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2578">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2579">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2579">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2580"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2580"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-2581">\- ou-</span><span class="sxs-lookup"><span data-stu-id="aed81-2581">\- or-</span></span>  
  
 <span data-ttu-id="aed81-2582"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2582"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2583"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2583"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2584">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2584">-or-</span></span>  
  
 <span data-ttu-id="aed81-2585"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2585"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-2586">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2586">-or-</span></span>  
  
 <span data-ttu-id="aed81-2587"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2587"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2588">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2588">-or-</span></span>  
  
 <span data-ttu-id="aed81-2589"><paramref name="size" /> é maior que o comprimento de <paramref name="buffer" /> menos o valor do parâmetro de deslocamento.</span><span class="sxs-lookup"><span data-stu-id="aed81-2589"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2590"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2590"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2591">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2591">-or-</span></span>  
  
 <span data-ttu-id="aed81-2592">A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2592">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
 <span data-ttu-id="aed81-2593">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2593">-or-</span></span>  
  
 <span data-ttu-id="aed81-2594">O .NET Framework está em execução em um processador AMD 64 bits.</span><span class="sxs-lookup"><span data-stu-id="aed81-2594">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
 <span data-ttu-id="aed81-2595">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2595">-or-</span></span>  
  
 <span data-ttu-id="aed81-2596">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2596">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2597">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2597">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-2598">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</span><span class="sxs-lookup"><span data-stu-id="aed81-2598">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="aed81-2599">para aceitar conexões de rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2599">for accepting connections from the network.</span></span> <span data-ttu-id="aed81-2600">Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2600">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-2601">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-2601">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-2602">Inicia o recebimento de forma assíncrona do número especificado de bytes de dados no local especificado do buffer de dados, usando o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> especificado e armazena as informações de ponto de extremidade e de pacote.</span><span class="sxs-lookup"><span data-stu-id="aed81-2602">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="aed81-2603">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2603">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-2604">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2604">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-2605">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-2605">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-2606">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2606">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2607">O <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método é usado principalmente para receber dados de mensagem em um soquete sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2607">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="aed81-2608">Endereço local do soquete deve ser conhecido.</span><span class="sxs-lookup"><span data-stu-id="aed81-2608">The socket's local address must be known.</span></span> <span data-ttu-id="aed81-2609">Esse método só pode ser usado com o datagrama e soquetes brutos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2609">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="aed81-2610">O soquete deve ser inicializado com o tipo de soquete definido como <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2610">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="aed81-2611">Isso pode ser feito quando o soquete é construído usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2611">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2612">O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto do qual os dados são a ser recebida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2612">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="aed81-2613">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:</span><span class="sxs-lookup"><span data-stu-id="aed81-2613">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-2614">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2614">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-2615">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2615">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-2616">Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2616">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="aed81-2617">O <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2617">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="aed81-2618">O <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método define automaticamente o <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para `true` na primeira vez que ele é chamado para um determinado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2618">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-2619">No entanto, o <xref:System.Net.Sockets.IPPacketInformation> objeto será válido apenas para pacotes que chegam ao computador local depois que a opção de soquete foi definida.</span><span class="sxs-lookup"><span data-stu-id="aed81-2619">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="aed81-2620">Se um soquete é enviado pacotes entre quando o soquete está associado a um ponto de extremidade local (explicitamente, o <xref:System.Net.Sockets.Socket.Bind%2A> método ou implicitamente por uma da <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) e a primeira chamada para o <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> chamadas de método, para <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método resultará em inválido <xref:System.Net.Sockets.IPPacketInformation> objetos para esses pacotes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2620">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="aed81-2621">Para garantir que todos os <xref:System.Net.Sockets.IPPacketInformation> objetos sejam válidos, um aplicativo deve definir o <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para`true` antes que ele está associado a um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2621">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="aed81-2622">Um aplicativo pode examinar resultante <xref:System.Net.Sockets.IPPacketInformation> objetos se ele precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.</span><span class="sxs-lookup"><span data-stu-id="aed81-2622">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-2623">O <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não pode ser nulo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2623">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-2624">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2624">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2625">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2625">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2626">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2626">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-2627">Obtém ou define um valor que especifica o tempo após o qual uma chamada <see cref="Overload:System.Net.Sockets.Socket.Receive" /> síncrona atingirá o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-2627">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="aed81-2628">O valor de tempo limite, em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2628">The time-out value, in milliseconds.</span></span> <span data-ttu-id="aed81-2629">O valor padrão é 0, que indica um período de tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2629">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="aed81-2630">Especificar -1 também indica um período de tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2630">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2631">Essa opção se aplica a síncrona <xref:System.Net.Sockets.Socket.Receive%2A> chama somente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2631">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="aed81-2632">Se o período de tempo limite for excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> método lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2632">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2633">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2633">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2634">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2635">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-2636">O valor especificado para uma operação de definição é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="aed81-2636">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-2637">Obtém o ponto de extremidade remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-2637">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="aed81-2638">O <see cref="T:System.Net.EndPoint" /> com o qual o <see cref="T:System.Net.Sockets.Socket" /> está se comunicando.</span><span class="sxs-lookup"><span data-stu-id="aed81-2638">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2639">Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade obtém o <xref:System.Net.EndPoint> que contém o remoto IP endereço e número da porta para o qual o <xref:System.Net.Sockets.Socket> está conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2639">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="aed81-2640">Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contém o padrão de endereço IP remoto e a porta número com o qual o <xref:System.Net.Sockets.Socket> se comunicará.</span><span class="sxs-lookup"><span data-stu-id="aed81-2640">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="aed81-2641">Você deve converter isso <xref:System.Net.EndPoint> para um <xref:System.Net.IPEndPoint> antes de recuperar todas as informações.</span><span class="sxs-lookup"><span data-stu-id="aed81-2641">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="aed81-2642">Em seguida, você pode chamar o <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar o controle remoto <xref:System.Net.IPAddress>e o <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar o número de porta remota.</span><span class="sxs-lookup"><span data-stu-id="aed81-2642">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="aed81-2643">O <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> é definido após uma chamada para a <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2643">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2644">Se você tentar acessar essa propriedade anterior, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2644">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2645">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2645">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2646">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2646">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2647">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2647">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2648">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2648">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2649">O exemplo de código a seguir recupera e exibe os pontos de extremidade locais e remotos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2649">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2650">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2651">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2651">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="aed81-2652">Um <see cref="T:System.Collections.IList" /> de instâncias <see cref="T:System.Net.Sockets.Socket" /> a serem verificadas quanto à legibilidade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2652">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="aed81-2653">Um <see cref="T:System.Collections.IList" /> de instâncias <see cref="T:System.Net.Sockets.Socket" /> a serem verificadas quanto à capacidade de gravação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2653">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="aed81-2654">Um <see cref="T:System.Collections.IList" /> de instâncias <see cref="T:System.Net.Sockets.Socket" /> a serem verificadas quanto a erros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2654">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="aed81-2655">O valor de tempo limite, em microssegundos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2655">The time-out value, in microseconds.</span></span> <span data-ttu-id="aed81-2656">Um valor de -1 indica um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2656">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="aed81-2657">Determina o status de um ou mais soquetes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2657">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2658"><xref:System.Net.Sockets.Socket.Select%2A> é um método estático que determina o status de um ou mais <xref:System.Net.Sockets.Socket> instâncias.</span><span class="sxs-lookup"><span data-stu-id="aed81-2658"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="aed81-2659">Você deve colocar um ou mais soquetes em um <xref:System.Collections.IList> antes de usar o <xref:System.Net.Sockets.Socket.Select%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2659">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="aed81-2660">Verificar para facilitar a leitura chamando <xref:System.Net.Sockets.Socket.Select%2A> com o <xref:System.Collections.IList> como o `checkRead` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2660">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="aed81-2661">Para verificar seu soquetes para gravabilidade, use o `checkWrite` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2661">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="aed81-2662">Para detectar condições de erro, use `checkError`.</span><span class="sxs-lookup"><span data-stu-id="aed81-2662">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="aed81-2663">Depois de chamar <xref:System.Net.Sockets.Socket.Select%2A>, o <xref:System.Collections.IList> será preenchido com apenas esses soquetes que atendem às condições.</span><span class="sxs-lookup"><span data-stu-id="aed81-2663">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="aed81-2664">Se você estiver em um estado de escuta, legibilidade significa que uma chamada para <xref:System.Net.Sockets.Socket.Accept%2A> terá êxito sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2664">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="aed81-2665">Se você já aceitou a conexão, a legibilidade significa que os dados estão disponíveis para leitura.</span><span class="sxs-lookup"><span data-stu-id="aed81-2665">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="aed81-2666">Nesses casos, todas as operações de recebimento terá êxito sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2666">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="aed81-2667">Legibilidade também pode indicar se o computador remoto <xref:System.Net.Sockets.Socket> foi encerrado para a conexão; nesse caso uma chamada para <xref:System.Net.Sockets.Socket.Receive%2A> retornará imediatamente, com zero bytes retornados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2667">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="aed81-2668"><xref:System.Net.Sockets.Socket.Select%2A> Retorna quando pelo menos um dos soquetes de interesse (soquetes do `checkRead`, `checkWrite`, e `checkError` lista) atenda aos critérios especificados, ou o `microSeconds` parâmetro for excedido, o que ocorrer primeiro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2668"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="aed81-2669">Definindo `microSeconds` como -1 especifica um tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2669">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="aed81-2670">Se você fizer uma chamada sem bloqueio para <xref:System.Net.Sockets.Socket.Connect%2A>, gravabilidade significa que você se conectou com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2670">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="aed81-2671">Se você já tiver uma conexão estabelecida, gravabilidade significa que todos os enviem operações terão êxito sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2671">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="aed81-2672">Se você fez uma chamada sem-bloqueio para <xref:System.Net.Sockets.Socket.Connect%2A>, o `checkerror` parâmetro identifica que não tenha se conectado com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2672">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2673">Use o <xref:System.Net.Sockets.Socket.Poll%2A> método se você quiser determinar o status de um único <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2673">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2674">Este método não pode detectar determinados tipos de problemas de conexão, como um cabo de rede interrompido, ou que o host remoto foi desligado maneira brusca.</span><span class="sxs-lookup"><span data-stu-id="aed81-2674">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="aed81-2675">Você deve tentar enviar ou receber dados para detectar esses tipos de erros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2675">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2676">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2676">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2677">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2677">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2678">O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.Select%2A> para determinar quais soquetes escuta tem uma solicitação de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2678">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-2679">O parâmetro <paramref name="checkRead" /> é <see langword="null" /> ou está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2679">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
 <span data-ttu-id="aed81-2680">-e-</span><span class="sxs-lookup"><span data-stu-id="aed81-2680">-and-</span></span>  
  
 <span data-ttu-id="aed81-2681">O parâmetro <paramref name="checkWrite" /> é <see langword="null" /> ou está vazio</span><span class="sxs-lookup"><span data-stu-id="aed81-2681">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span>  
  
 <span data-ttu-id="aed81-2682">-e-</span><span class="sxs-lookup"><span data-stu-id="aed81-2682">-and-</span></span>  
  
 <span data-ttu-id="aed81-2683">O parâmetro <paramref name="checkError" /> é <see langword="null" /> ou está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2683">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2684">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2684">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-2685">Envia dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2685">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2686">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2686">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="aed81-2687">Envia dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2687">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2688">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2688">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2689"><xref:System.Net.Sockets.Socket.Send%2A> envia dados de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2689"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="aed81-2690"><xref:System.Net.Sockets.Socket.Send%2A> pode ser usado para protocolos e orientada a conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2690"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-2691">Essa sobrecarga requer um buffer que contém os dados que você deseja enviar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2691">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="aed81-2692">O <xref:System.Net.Sockets.SocketFlags> o valor padrão é 0, deslocamento de buffer padrão é 0 e o número de bytes a enviar os padrões para o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2692">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="aed81-2693">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2693">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2694">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2694">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2695">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2695">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-2696">Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2696">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2697">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2697">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2698">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2698">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2699">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2699">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2700">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2700">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2701">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2701">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="aed81-2702">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2702">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="aed81-2703">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2703">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2704">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2704">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2705">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2705">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2706">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2706">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2707">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2707">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2708">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2708">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2709">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2709">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2710">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2710">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2711">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2711">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2712">O exemplo de código a seguir demonstra o envio de dados em um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2712">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2713"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2713"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2714">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2714">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2715">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2715">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-2716">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2716">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="aed81-2717">Envia o conjunto de buffers na lista para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2717">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2718">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2718">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2719"><xref:System.Net.Sockets.Socket.Send%2A> pode ser usado para protocolos e orientada a conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2719"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-2720">Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2720">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="aed81-2721">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2721">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2722">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2722">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2723">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2723">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-2724">Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2724">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2725">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2725">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2726">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2726">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2727">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2727">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2728">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2728">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2729">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2729">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="aed81-2730">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2730">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="aed81-2731">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2731">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2732">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2732">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2733">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2733">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2734">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2734">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2735">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2735">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2736">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2736">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2737">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2737">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2738">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2739">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2740"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2740"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-2741"><paramref name="buffers" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2741"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2742">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2742">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-2743">Consulte a seção Comentários abaixo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2743">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2744">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2744">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2745">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2745">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2746">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2746">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2747">Envia dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2747">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2748">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2748">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2749"><xref:System.Net.Sockets.Socket.Send%2A> envia dados de forma síncrona ao host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2749"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="aed81-2750">O <xref:System.Net.Sockets.Socket.Send%2A> método pode ser usado para protocolos e orientada a conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2750">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-2751">Essa sobrecarga requer um buffer que contém os dados que você deseja enviar e uma combinação bit a bit de <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2751">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="aed81-2752">O buffer de deslocamento padrão é 0 e o número de bytes a enviar os padrões para o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2752">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="aed81-2753">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` o valor do parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2753">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-2754">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2754">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2755">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2755">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2756">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2756">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-2757">Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2757">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2758">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2758">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2759">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2759">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2760">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2760">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2761">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2761">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2762">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2762">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="aed81-2763">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2763">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="aed81-2764">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2764">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2765">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2765">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2766">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2766">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2767">Certifique-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2767">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-2768">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2768">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2769">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2769">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2770">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2770">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2771">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2771">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2772">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2772">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2773">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2773">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2774">Para obter mais informações, consulte[rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2774">For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2775">O exemplo de código a seguir demonstra o envio de dados em um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2775">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2776"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2776"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2777">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2777">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2778">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2778">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-2779">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2779">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2780">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2780">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2781">Envia o conjunto de buffers na lista para um <see cref="T:System.Net.Sockets.Socket" /> conectado, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2781">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2782">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2782">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2783">Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2783">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="aed81-2784">O <xref:System.Net.Sockets.SocketFlags> valor padrão é 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2784">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="aed81-2785">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketFlags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2785">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-2786">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2786">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2787">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2787">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2788">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2788">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-2789">Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2789">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2790">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2790">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2791">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2791">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2792">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2792">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2793">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2793">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2794">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2794">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="aed81-2795">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2795">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="aed81-2796">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2796">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2797">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2797">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2798">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2798">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2799">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2799">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2800">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2800">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2801">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2801">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2802">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2802">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2803">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2803">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2804">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2804">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2805"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2805"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-2806"><paramref name="buffers" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2806"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2807">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2807">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2808">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2808">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2809">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2809">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2810">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2810">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2811">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2811">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2812">Envia o número especificado de bytes de dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2812">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2813">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2813">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2814"><xref:System.Net.Sockets.Socket.Send%2A> envia dados de forma síncrona ao host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2814"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="aed81-2815"><xref:System.Net.Sockets.Socket.Send%2A> pode ser usado para protocolos e orientada a conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2815"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-2816">Essa sobrecarga requer um buffer que contém os dados que você deseja enviar, o número de bytes que você deseja enviar e uma combinação bit a bit de qualquer <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2816">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="aed81-2817">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2817">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-2818">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2818">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2819">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2819">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2820">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2820">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-2821">Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada chamada para o <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2821">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="aed81-2822">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2822">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2823">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2823">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2824">Com um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2824">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2825">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2825">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2826">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2826">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="aed81-2827">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2827">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="aed81-2828">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2828">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2829">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2829">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2830">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2830">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2831">Certifique-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2831">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-2832">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2832">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2833">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2833">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2834">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2834">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2835">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2835">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2836">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2836">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2837">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2837">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2838">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2838">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2839">O exemplo de código a seguir envia os dados encontrados no buffer e especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2839">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2840"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2840"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2841"><paramref name="size" /> é menor que 0 ou excede o tamanho do buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2841"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2842"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2842"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2843">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2843">-or-</span></span>  
  
 <span data-ttu-id="aed81-2844">Ocorre um erro de sistema operacional ao acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2844">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2845">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2845">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="aed81-2846">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2846">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2847">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2847">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-2848">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2848">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="aed81-2849">Envia o conjunto de buffers na lista para um <see cref="T:System.Net.Sockets.Socket" /> conectado, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2849">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2850">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2850">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2851">Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2851">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="aed81-2852">O <xref:System.Net.Sockets.SocketFlags> valor padrão é 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2852">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="aed81-2853">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketFlags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2853">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-2854">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2854">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2855">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2855">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2856">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2856">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-2857">Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2857">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2858">Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2858">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2859">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2859">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2860">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2860">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2861">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2861">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2862">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2862">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="aed81-2863">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2863">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="aed81-2864">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2864">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2865">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2865">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2866">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2866">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2867">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2867">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2868">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2868">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2869">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2869">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2870">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2870">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2871">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2871">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2872">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2872">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2873"><paramref name="buffers" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2873"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aed81-2874"><paramref name="buffers" /> está vazio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2874"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2875">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2875">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2876">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2876">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2877">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2877">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-2878">A posição no buffer de dados na qual o envio de dados deve começar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2878">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2879">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2879">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2880">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2880">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-2881">Envia o número especificado de bytes de dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado, começando no deslocamento especificado e usando os <see cref="T:System.Net.Sockets.SocketFlags" /> especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2881">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-2882">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2882">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2883"><xref:System.Net.Sockets.Socket.Send%2A> envia dados de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2883"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="aed81-2884"><xref:System.Net.Sockets.Socket.Send%2A> pode ser usado para protocolos e orientada a conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2884"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-2885">Essa sobrecarga, se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2885">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-2886">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar este método ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2886">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2887">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2887">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2888">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2888">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-2889">Se você não usar <xref:System.Net.Sockets.Socket.SendTo%2A>, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2889">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2890">É okey usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2890">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2891">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2891">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2892">Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2892">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-2893">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2893">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-2894">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2894">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2895">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2895">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2896">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2896">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="aed81-2897">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2897">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="aed81-2898">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2898">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2899">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2899">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2900">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2900">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2901">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2901">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2902">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2902">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2903">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2903">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2904">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2904">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2905">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2905">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2906">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2906">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2907">O exemplo de código a seguir especifica o buffer de dados, um deslocamento, um tamanho, e <xref:System.Net.Sockets.SocketFlags> para enviar dados para um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2907">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2908"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2908"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2909"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2909"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2910">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2910">-or-</span></span>  
  
 <span data-ttu-id="aed81-2911"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2911"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-2912">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2912">-or-</span></span>  
  
 <span data-ttu-id="aed81-2913"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2913"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2914">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2914">-or-</span></span>  
  
 <span data-ttu-id="aed81-2915"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2915"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2916"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2916"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2917">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2917">-or-</span></span>  
  
 <span data-ttu-id="aed81-2918">Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2918">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2919">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2919">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-2920">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2920">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-2921">A posição no buffer de dados na qual o envio de dados deve começar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2921">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-2922">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-2922">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-2923">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2923">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="aed81-2924">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2924">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="aed81-2925">Envia o número especificado de bytes de dados a um <see cref="T:System.Net.Sockets.Socket" /> conectado, iniciando no deslocamento especificado e usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado</span><span class="sxs-lookup"><span data-stu-id="aed81-2925">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="aed81-2926">O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2926">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2927"><xref:System.Net.Sockets.Socket.Send%2A> envia dados de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2927"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="aed81-2928"><xref:System.Net.Sockets.Socket.Send%2A> pode ser usado para protocolos e orientada a conexão e sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2928"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-2929">Essa sobrecarga, se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-2929">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-2930">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar este método ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2930">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2931">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2931">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-2932">Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2932">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-2933">Se você não usar <xref:System.Net.Sockets.Socket.SendTo%2A>, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2933">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="aed81-2934">É okey usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2934">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="aed81-2935">Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2935">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2936">Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2936">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-2937">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2937">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-2938">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2938">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-2939">Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2939">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-2940">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar.</span><span class="sxs-lookup"><span data-stu-id="aed81-2940">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="aed81-2941">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-2941">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="aed81-2942">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-2942">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-2943">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2943">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-2944">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-2944">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2945">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-2945">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-2946">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-2946">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2947">A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2947">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="aed81-2948">Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2948">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-2949">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2949">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-2950">Para obter mais informações, consulte[rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-2950">For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2951">O exemplo de código a seguir especifica o buffer de dados, um deslocamento, um tamanho, e <xref:System.Net.Sockets.SocketFlags> para enviar dados para um conectado <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2951">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-2952"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2952"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-2953"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2953"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2954">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2954">-or-</span></span>  
  
 <span data-ttu-id="aed81-2955"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2955"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-2956">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2956">-or-</span></span>  
  
 <span data-ttu-id="aed81-2957"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2957"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-2958">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2958">-or-</span></span>  
  
 <span data-ttu-id="aed81-2959"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2959"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-2960"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-2960"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-2961">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-2961">-or-</span></span>  
  
 <span data-ttu-id="aed81-2962">Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2962">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2963">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2963">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-2964">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-2964">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-2965">Envia dados de forma assíncrona para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2965">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="aed81-2966">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2966">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-2967">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2967">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-2968">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-2968">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-2969">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-2969">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2970">O <xref:System.Net.Sockets.Socket.SendAsync%2A> método é usado para gravar dados de saída de um ou mais buffers em um soquete orientado a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2970">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="aed81-2971">Esse método também pode ser usado, no entanto, em soquetes sem conexão que especificou um host remoto em uma operação de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2971">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="aed81-2972">O <xref:System.Net.Sockets.Socket.SendAsync%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2972">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-2973">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:</span><span class="sxs-lookup"><span data-stu-id="aed81-2973">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="aed81-2974"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="aed81-2974"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="aed81-2975"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido</span><span class="sxs-lookup"><span data-stu-id="aed81-2975"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="aed81-2976"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido</span><span class="sxs-lookup"><span data-stu-id="aed81-2976"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-2977">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.SendAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-2977">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-2978">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-2978">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-2979">O <xref:System.Net.Sockets.Socket.SendAsync%2A> método lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-2979">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="aed81-2980">Chamar o <xref:System.Net.Sockets.Socket.SendAsync%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2980">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="aed81-2981">Para soquetes orientado a mensagens, não exceda o tamanho máximo da mensagem do provedor de serviços de soquetes do Windows subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-2981">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="aed81-2982">Se os dados são muito longos para passar o provedor de serviço subjacente atomicamente, nenhum dado é transmitido e <xref:System.Net.Sockets.Socket.SendAsync%2A> método lança um <xref:System.Net.Sockets.SocketException> com o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> definido como o código de erro de Winsock WSAEMSGSIZE nativo (10040).</span><span class="sxs-lookup"><span data-stu-id="aed81-2982">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="aed81-2983">Observe que a conclusão bem-sucedida do <xref:System.Net.Sockets.Socket.SendAsync%2A> método não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-2983">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-2984">As propriedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no parâmetro <paramref name="e" /> devem referenciar buffers válidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-2984">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="aed81-2985">Uma ou a outra dessas propriedades poderá ser definida, mas não ambas ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="aed81-2985">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-2986">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2986">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-2987">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-2987">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2988">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2988">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2989">O <see cref="T:System.Net.Sockets.Socket" /> ainda não está conectado ou não foi obtido por meio de um método <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> ou <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2989">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-2990">Obtém ou define um valor que especifica o tamanho do buffer de envio do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-2990">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-2991">Um <see cref="T:System.Int32" /> que contém o tamanho, em bytes, do buffer de envio.</span><span class="sxs-lookup"><span data-stu-id="aed81-2991">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="aed81-2992">O padrão é 8192.</span><span class="sxs-lookup"><span data-stu-id="aed81-2992">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-2993">Um tamanho de buffer maior pode atrasar o reconhecimento de problemas de conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-2993">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="aed81-2994">Considere aumentar o tamanho do buffer se estiver transferindo arquivos grandes ou se você estiver usando a largura de banda alta, a conexão de alta latência (como um satélite provedor de banda larga.)</span><span class="sxs-lookup"><span data-stu-id="aed81-2994">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-2995">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.SendBufferSize%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-2995">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-2996">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-2996">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-2997">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2997">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-2998">O valor especificado para uma operação de definição é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-2998">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-2999">Envia um arquivo e dados opcionais de forma síncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-2999">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="aed81-3000">Um <see cref="T:System.String" /> que contém o caminho e o nome do arquivo a ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3000">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="aed81-3001">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3001">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="aed81-3002">Envia o arquivo <paramref name="fileName" /> para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado com o sinalizador de transmissão <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3002">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3003">Essa sobrecarga envia o arquivo `fileName` para o soquete conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="aed81-3004">O `flags` parâmetro padrão <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) e o `preBuffer` e `postBuffer` parâmetros padrão para `null`.</span><span class="sxs-lookup"><span data-stu-id="aed81-3004">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="aed81-3005">Se `fileName` está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3005">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="aed81-3006">Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3006">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="aed81-3007">Se o arquivo não for encontrado, a exceção <xref:System.IO.FileNotFoundException> é lançada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3007">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="aed81-3008">Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aed81-3008">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="aed81-3009">Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-3009">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="aed81-3010"><xref:System.Net.Sockets.Socket.SendFile%2A> envia um arquivo de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3010"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-3011"><xref:System.Net.Sockets.Socket.SendFile%2A> pode ser usado para ambos orientado a conexão e protocolos sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3011"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-3012">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, caso contrário, <xref:System.Net.Sockets.Socket.SendFile%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3012">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="aed81-3013">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3013">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-3014">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.SendFile%2A> bloqueia até que o arquivo é enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3014">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="aed81-3015">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.SendFile%2A> pode ser concluído com êxito antes do arquivo inteiro foi enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3015">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="aed81-3016">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-3016">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-3017">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3017">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-3018">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-3018">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3019">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3019">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3020">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3020">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3021">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3021">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3022">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3022">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3023">O exemplo de código a seguir cria e se conecta a um soquete e, em seguida, envia um arquivo para o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3023">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="aed81-3024">O arquivo "test.txt" está localizado no diretório raiz da máquina local.</span><span class="sxs-lookup"><span data-stu-id="aed81-3024">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-3025">O soquete não está conectado a um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3025">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3026">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3026">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-3027">O objeto <see cref="T:System.Net.Sockets.Socket" /> não está no modo de bloqueio e não pode aceitar essa chamada síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-3027">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="aed81-3028">O arquivo <paramref name="fileName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3028">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3029">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3029">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="aed81-3030">Um <see cref="T:System.String" /> que contém o caminho e o nome do arquivo a ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3030">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="aed81-3031">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3031">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="aed81-3032">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados antes de o arquivo ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3032">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="aed81-3033">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3033">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="aed81-3034">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados depois de o arquivo ser enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3034">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="aed81-3035">Esse parâmetro pode ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3035">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="aed81-3036">Um ou mais valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3036">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="aed81-3037">Envia o arquivo <paramref name="fileName" /> e buffers de dados a um <see cref="T:System.Net.Sockets.Socket" /> conectado usando o valor <see cref="T:System.Net.Sockets.TransmitFileOptions" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3037">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3038">Essa sobrecarga requer o nome do arquivo que deseja enviar e uma combinação bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-3038">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="aed81-3039">O `preBuffer` parâmetro contiver dados deve preceder o arquivo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3039">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="aed81-3040">`postBuffer` contém dados que você deseja que execute o arquivo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3040">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="aed81-3041">Se `fileName` está no diretório de trabalho atual, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3041">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="aed81-3042">Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3042">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="aed81-3043">O `flags` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3043">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="aed81-3044">Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3044">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="aed81-3045">Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aed81-3045">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="aed81-3046">Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-3046">For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="aed81-3047"><xref:System.Net.Sockets.Socket.SendFile%2A> envia um arquivo de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3047"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-3048"><xref:System.Net.Sockets.Socket.SendFile%2A> pode ser usado para ambos orientado a conexão e protocolos sem conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3048"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="aed81-3049">Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método; caso contrário, <xref:System.Net.Sockets.Socket.SendFile%2A> lança um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3049">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3050">Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3050">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="aed81-3051">Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.SendFile%2A> bloqueia até que o arquivo inteiro seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3051">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="aed81-3052">No modo sem bloqueio, <xref:System.Net.Sockets.Socket.SendFile%2A> pode ser concluído com êxito antes do arquivo inteiro foi enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3052">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="aed81-3053">Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-3053">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-3054">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3054">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-3055">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-3055">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3056">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3056">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3057">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3057">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3058">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3058">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3059">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3059">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3060">O exemplo de código a seguir cria e se conecta a um soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3060">The following code example creates and connects a socket.</span></span> <span data-ttu-id="aed81-3061">O arquivo "test.txt" está localizado no diretório raiz da máquina local.</span><span class="sxs-lookup"><span data-stu-id="aed81-3061">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="aed81-3062">Neste exemplo, criamos um prebuffer e postbuffer de dados e enviá-los ao host remoto com o arquivo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3062">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="aed81-3063">O padrão <xref:System.Net.Sockets.TransmitFileOptions> são usados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3063">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-3064">O sistema operacional não é o Windows NT ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aed81-3064">The operating system is not Windows NT or later.</span></span>  
  
 <span data-ttu-id="aed81-3065">\- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3065">\- or -</span></span>  
  
 <span data-ttu-id="aed81-3066">O soquete não está conectado a um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3066">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3067">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3067">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-3068">O objeto <see cref="T:System.Net.Sockets.Socket" /> não está no modo de bloqueio e não pode aceitar essa chamada síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-3068">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="aed81-3069">O arquivo <paramref name="fileName" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3069">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3070">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3070">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-3071">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-3071">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-3072">Envia uma coleção de arquivos ou buffers de dados na memória assincronamente para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3072">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="aed81-3073">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3073">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-3074">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3074">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-3075">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-3075">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-3076">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3076">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3077">O <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é usado para enviar uma coleção de arquivos ou na memória buffers de dados para o host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3077">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="aed81-3078">O <xref:System.Net.Sockets.Socket> já deve estar conectado ao host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3078">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="aed81-3079">Se um <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> faz referência a um arquivo no diretório de trabalho, que pode ser identificado pelo nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3079">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="aed81-3080">Há suporte para curingas e nomes de compartilhamento UNC.</span><span class="sxs-lookup"><span data-stu-id="aed81-3080">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="aed81-3081">Se o arquivo não for encontrado, <xref:System.IO.FileNotFoundException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3081">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="aed81-3082">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="aed81-3082">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="aed81-3083">O <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriedade o `e` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3083">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="aed81-3084">Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3084">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="aed81-3085">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:</span><span class="sxs-lookup"><span data-stu-id="aed81-3085">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-3086">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3086">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-3087">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-3087">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-3088">Esse método usa a função TransmitPackets encontrada na API do Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="aed81-3088">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="aed81-3089">Para obter mais informações sobre a função TransmitPackets e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="aed81-3089">For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</span></span>  
  
 <span data-ttu-id="aed81-3090">Embora destinado protocolos orientados a conexão, o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método para estabelecer um host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3090">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="aed81-3091">Com protocolos sem conexão, você também deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3091">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-3092">Se isso acontecer, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3092">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="aed81-3093">O <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é otimizado de acordo com o sistema operacional no qual ele é usado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3093">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="aed81-3094">Em edições do Windows server, o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é otimizado para alto desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-3094">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="aed81-3095">Em edições de cliente do Windows, o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é otimizado para a utilização de recursos e de memória mínima.</span><span class="sxs-lookup"><span data-stu-id="aed81-3095">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="aed81-3096">Usar o <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> sinalizador no <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriedade no `e` parâmetro pode fornecer benefícios significativos de desempenho.</span><span class="sxs-lookup"><span data-stu-id="aed81-3096">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="aed81-3097">Se o thread iniciar o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> chamada de método está sendo usada para cálculos pesados, é possível, embora seja improvável, que APCs podem ser impedidos de iniciar.</span><span class="sxs-lookup"><span data-stu-id="aed81-3097">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="aed81-3098">Observe que há uma diferença entre APCs kernel e o modo de usuário.</span><span class="sxs-lookup"><span data-stu-id="aed81-3098">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="aed81-3099">Inicie o kernel APCs quando um thread está em um estado de espera.</span><span class="sxs-lookup"><span data-stu-id="aed81-3099">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="aed81-3100">Modo de usuário APCs iniciem quando um thread está em um estado de espera podem gerar alertas</span><span class="sxs-lookup"><span data-stu-id="aed81-3100">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="aed81-3101">O arquivo especificado na propriedade <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> não foi encontrado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3101">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-3102">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3102">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-3103">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3103">Windows XP or later is required for this method.</span></span> <span data-ttu-id="aed81-3104">Essa exceção também ocorre se o <see cref="T:System.Net.Sockets.Socket" /> não estiver conectado a um host remoto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3104">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3105">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3105">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3106">Um <see cref="T:System.Net.Sockets.Socket" /> sem conexão está sendo usado e o arquivo sendo enviado excede o tamanho máximo do pacote de transporte subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3106">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-3107">Obtém ou define um valor que especifica o tempo após o qual uma chamada <see cref="Overload:System.Net.Sockets.Socket.Send" /> síncrona atingirá o tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-3107">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="aed81-3108">O valor de tempo limite, em milissegundos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3108">The time-out value, in milliseconds.</span></span> <span data-ttu-id="aed81-3109">Se você definir a propriedade com um valor entre 1 e 499, o valor será alterado para 500.</span><span class="sxs-lookup"><span data-stu-id="aed81-3109">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="aed81-3110">O valor padrão é 0, que indica um período de tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3110">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="aed81-3111">Especificar -1 também indica um período de tempo limite infinito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3111">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3112">Essa opção se aplica a síncrona <xref:System.Net.Sockets.Socket.Send%2A> chama somente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3112">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="aed81-3113">Se o período de tempo limite for excedido, o <xref:System.Net.Sockets.Socket.Send%2A> método lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3113">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3114">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.SendTimeout%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-3114">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3115">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3115">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3116">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3116">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-3117">O valor especificado para uma operação de definição é menor que -1.</span><span class="sxs-lookup"><span data-stu-id="aed81-3117">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-3118">Envia dados para um ponto de extremidade específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3118">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-3119">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3119">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-3120">O <see cref="T:System.Net.EndPoint" /> que representa o destino dos dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3120">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="aed81-3121">Envia dados ao ponto de extremidade especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3121">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="aed81-3122">O número de bytes enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3122">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3123">Essa sobrecarga, o buffer de deslocamento padrão é 0, o número de bytes a enviar os padrões para o tamanho do `buffer` parâmetro e o <xref:System.Net.Sockets.SocketFlags> valor padrão é 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-3123">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="aed81-3124">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3124">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-3125">Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3125">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="aed81-3126">Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3126">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="aed81-3127">Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3127">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="aed81-3128">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3128">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="aed81-3129">Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3129">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="aed81-3130">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3130">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-3131">Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3131">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3132">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3132">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-3133">Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3133">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-3134">Bloquear soquetes será bloqueado até que todos os bytes no buffer são enviadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3134">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="aed81-3135">Como um sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, ele pode enviar todos os bytes não o `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-3135">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="aed81-3136">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envie todos os bytes de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-3136">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="aed81-3137">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-3137">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-3138">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3138">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="aed81-3139">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-3139">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="aed81-3140">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3140">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-3141">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3141">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-3142">Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3142">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-3143">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3143">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3144">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3144">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3145">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3145">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3146">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3146">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3147">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3147">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3148">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3148">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-3149"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3149"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-3150">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3150">-or-</span></span>  
  
 <span data-ttu-id="aed81-3151"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3151"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3152">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3152">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3153">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-3154">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3154">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-3155">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3155">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-3156">O <see cref="T:System.Net.EndPoint" /> que representa o local de destino dos dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3156">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="aed81-3157">Envia dados para um ponto de extremidade específico usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3157">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-3158">O número de bytes enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3158">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3159">Essa sobrecarga, o buffer de deslocamento padrão é 0 e o número de bytes a enviar os padrões para o tamanho do `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-3159">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="aed81-3160">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3160">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-3161">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3161">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-3162">Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3162">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="aed81-3163">Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3163">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="aed81-3164">Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3164">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="aed81-3165">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3165">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="aed81-3166">Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3166">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="aed81-3167">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3167">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-3168">Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3168">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3169">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3169">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-3170">Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3170">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-3171">Bloquear soquetes será bloqueado até que o solicitado todos os bytes de `buffer` são enviadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3171">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="aed81-3172">Como um sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, ele pode enviar todos os bytes não o `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-3172">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="aed81-3173">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envie todos os bytes de `buffer`.</span><span class="sxs-lookup"><span data-stu-id="aed81-3173">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="aed81-3174">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-3174">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-3175">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3175">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="aed81-3176">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-3176">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="aed81-3177">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3177">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-3178">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3178">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-3179">Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3179">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-3180">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3180">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3181">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3182">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3182">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3183">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3184">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3185">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3185">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="aed81-3186"><xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3186"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-3187"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3187"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-3188">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3188">-or-</span></span>  
  
 <span data-ttu-id="aed81-3189"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3189"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3190">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3190">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3191">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3191">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-3192">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3192">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-3193">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3193">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-3194">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3194">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-3195">O <see cref="T:System.Net.EndPoint" /> que representa o local de destino dos dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3195">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="aed81-3196">Envia o número especificado de bytes de dados para um ponto de extremidade especificado usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3196">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-3197">O número de bytes enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3197">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3198">Essa sobrecarga, o buffer de deslocamento padrão é 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-3198">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="aed81-3199">Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3199">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-3200">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3200">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-3201">Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3201">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="aed81-3202">Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3202">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="aed81-3203">Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3203">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="aed81-3204">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3204">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="aed81-3205">Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3205">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="aed81-3206">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3206">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-3207">Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3207">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3208">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3208">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-3209">Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3209">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-3210">Bloquear soquetes será bloqueado até que o número solicitado de bytes é enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3210">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="aed81-3211">Como um sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, pode não enviar todos os bytes solicitados em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3211">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="aed81-3212">É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-3212">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="aed81-3213">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-3213">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-3214">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3214">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="aed81-3215">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-3215">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="aed81-3216">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3216">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-3217">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3217">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-3218">Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3218">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-3219">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3219">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3220">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3220">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3221">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3221">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3222">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3222">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3223">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3223">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3224">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3224">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="aed81-3225">O tamanho e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3225">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-3226"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3226"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-3227">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3227">-or-</span></span>  
  
 <span data-ttu-id="aed81-3228"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3228"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-3229">O <paramref name="size" /> especificado excede o tamanho de <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3229">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3230">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3230">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3231">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="aed81-3232">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3232">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="aed81-3233">A posição no buffer de dados na qual o envio de dados deve começar.</span><span class="sxs-lookup"><span data-stu-id="aed81-3233">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="aed81-3234">O número de bytes a serem enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3234">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="aed81-3235">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3235">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="aed81-3236">O <see cref="T:System.Net.EndPoint" /> que representa o local de destino dos dados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3236">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="aed81-3237">Envia o número especificado de bytes de dados para o ponto de extremidade especificado, começando no local especificado no buffer e usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3237">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="aed81-3238">O número de bytes enviados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3238">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3239">Essa sobrecarga, se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3239">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-3240">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3240">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="aed81-3241">Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3241">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="aed81-3242">Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3242">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="aed81-3243">Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3243">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="aed81-3244">Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3244">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="aed81-3245">Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3245">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="aed81-3246">Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3246">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="aed81-3247">Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3247">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3248">Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3248">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="aed81-3249">Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3249">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="aed81-3250">Bloquear soquetes será bloqueado até que o número solicitado de bytes é enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3250">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="aed81-3251">Desde sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, pode não enviar todos os bytes solicitados em uma única operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3251">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="aed81-3252">É sua responsabilidade de aplicativos para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-3252">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="aed81-3253">Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede.</span><span class="sxs-lookup"><span data-stu-id="aed81-3253">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="aed81-3254">Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3254">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="aed81-3255">Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.</span><span class="sxs-lookup"><span data-stu-id="aed81-3255">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="aed81-3256">Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3256">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="aed81-3257">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3257">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="aed81-3258">Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3258">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-3259">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3259">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3260">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3260">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3261">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3261">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3262">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3262">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3263">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3263">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3264">O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3264">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="aed81-3265">O deslocamento, tamanho, e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.SendTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3265">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-3266"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3266"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="aed81-3267">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3267">-or-</span></span>  
  
 <span data-ttu-id="aed81-3268"><paramref name="remoteEP" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3268"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aed81-3269"><paramref name="offset" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-3269"><paramref name="offset" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-3270">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3270">-or-</span></span>  
  
 <span data-ttu-id="aed81-3271"><paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3271"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
 <span data-ttu-id="aed81-3272">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3272">-or-</span></span>  
  
 <span data-ttu-id="aed81-3273"><paramref name="size" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="aed81-3273"><paramref name="size" /> is less than 0.</span></span>  
  
 <span data-ttu-id="aed81-3274">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3274">-or-</span></span>  
  
 <span data-ttu-id="aed81-3275"><paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3275"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <span data-ttu-id="aed81-3276"><paramref name="socketFlags" /> não é uma combinação válida de valores.</span><span class="sxs-lookup"><span data-stu-id="aed81-3276"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
 <span data-ttu-id="aed81-3277">- ou -</span><span class="sxs-lookup"><span data-stu-id="aed81-3277">-or-</span></span>  
  
 <span data-ttu-id="aed81-3278">Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3278">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3279">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3279">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aed81-3280">Um chamador na pilha de chamadas não tem as permissões necessárias.</span><span class="sxs-lookup"><span data-stu-id="aed81-3280">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="aed81-3281">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</span><span class="sxs-lookup"><span data-stu-id="aed81-3281">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="aed81-3282">Envia dados de maneira assíncrona para um host remoto específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3282">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="aed81-3283">Retorna <see langword="true" /> se a operação de E/S está pendente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3283">Returns <see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="aed81-3284">O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3284">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="aed81-3285">Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona.</span><span class="sxs-lookup"><span data-stu-id="aed81-3285">Returns <see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="aed81-3286">Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3286">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3287">O <xref:System.Net.Sockets.Socket.SendToAsync%2A> método inicia uma operação de envio assíncrono para o host remoto especificado no <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade o `e` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3287">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="aed81-3288">Chamar o <xref:System.Net.Sockets.Socket.SendToAsync%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3288">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="aed81-3289">Embora esse método destina-se a protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendToAsync%2A> funciona com protocolos sem conexão e orientada a conexão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3289">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="aed81-3290">Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="aed81-3290">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="aed81-3291">As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:</span><span class="sxs-lookup"><span data-stu-id="aed81-3291">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="aed81-3292">O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.SendToAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada.</span><span class="sxs-lookup"><span data-stu-id="aed81-3292">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="aed81-3293">Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.</span><span class="sxs-lookup"><span data-stu-id="aed81-3293">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="aed81-3294">Se você estiver usando um protocolo orientado a conexão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3294">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="aed81-3295">Caso contrário, <xref:System.Net.Sockets.Socket.SendToAsync%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3295">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3296">Ao usar um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> método irá ignorar o <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade e enviar dados para o <xref:System.Net.EndPoint?displayProperty=nameWithType> estabelecido no <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3296">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-3297">Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3297">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="aed81-3298">Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.SendAsync%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3298">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="aed81-3299">Se você chamar o <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendToAsync%2A>, o <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade substituirá o host remoto padrão especificado para que enviar apenas a operação.</span><span class="sxs-lookup"><span data-stu-id="aed81-3299">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="aed81-3300">Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3300">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="aed81-3301">Nesse caso, o provedor de serviço subjacente atribuirá o mais apropriado local de rede IP endereço e número da porta.</span><span class="sxs-lookup"><span data-stu-id="aed81-3301">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="aed81-3302">Use um número de porta de zero se quiser que o provedor de serviço subjacente para selecionar uma porta livre.</span><span class="sxs-lookup"><span data-stu-id="aed81-3302">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="aed81-3303">Se for necessário identificar o número de porta e endereço IP atribuído de rede local, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento é sinalizado e delegados associados são chamados.</span><span class="sxs-lookup"><span data-stu-id="aed81-3303">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="aed81-3304">Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> como true.</span><span class="sxs-lookup"><span data-stu-id="aed81-3304">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="aed81-3305">Você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3305">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="aed81-3306">Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendToAsync%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3306">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="aed81-3307">Se você especificar o sinalizador de DontRoute a <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriedade, os dados que você está enviando não serão roteadas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3307">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="aed81-3308">Para soquetes orientado a mensagens, deve-se ter cuidado para não exceder o tamanho máximo da mensagem de transporte subjacente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3308">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="aed81-3309">Se o tamanho do buffer excede o tamanho máximo do pacote do provedor de serviço subjacente, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.SendToAsync%2A> lançará um <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3309">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="aed81-3310">A conclusão bem-sucedida de uma <xref:System.Net.Sockets.Socket.SendToAsync%2A> método não indica que os dados foi entregue com êxito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3310">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="aed81-3311">O <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não pode ser nulo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3311">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-3312">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3312">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-3313">É necessário o Windows XP ou posterior para esse método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3313">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3314">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3314">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3315">O protocolo especificado é orientado para a conexão, mas o <see cref="T:System.Net.Sockets.Socket" /> ainda não está conectado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3315">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="aed81-3316">O nível de proteção IP a ser definido nesse soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3316">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="aed81-3317">Defina o nível de proteção IP em um soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3317">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3318">O <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método permite restringir um um soquete IP ou IPv6 para escutar em um escopo especificado, como endereços com o mesmo locais do link ou prefixo local do site.</span><span class="sxs-lookup"><span data-stu-id="aed81-3318">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="aed81-3319">Essa opção de soquete permite que os aplicativos colocar as restrições de acesso em soquetes IP ou IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-3319">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="aed81-3320">Essas restrições permitem que um aplicativo em execução em uma LAN privada proteja-se de modo simples e robusto contra ataques externos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3320">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="aed81-3321">Essa opção de soquete também pode ser usada para remover as restrições de acesso se o `level` parâmetro está definido como <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3321">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="aed81-3322">Essa opção de soquete amplia ou reduz o escopo de um soquete de escuta, permitindo acesso irrestrito de usuários públicos e privados, quando apropriado, ou restringindo o acesso somente ao mesmo site, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="aed81-3322">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="aed81-3323">Essa opção de soquete definiu os níveis de proteção especificados na enumeração <xref:System.Net.Sockets.IPProtectionLevel>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3323">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="aed81-3324">O <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método é usado para habilitar ou desabilitar a passagem de endereços de rede (NAT) para um <xref:System.Net.Sockets.Socket> instância.</span><span class="sxs-lookup"><span data-stu-id="aed81-3324">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="aed81-3325">Percurso de NAT pode ser fornecido usando um túnel ISATAP, 6to4 ou Teredo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3325">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="aed81-3326">Quando o `level` parâmetro está definido como <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, ou <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, isso desabilita o percurso de NAT para explicitamente um <xref:System.Net.Sockets.Socket> instância.</span><span class="sxs-lookup"><span data-stu-id="aed81-3326">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="aed81-3327">Quando o `level` parâmetro está definido como <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, isso pode permitir percurso de NAT para um <xref:System.Net.Sockets.Socket> dependendo de regras de firewall em vigor no sistema.</span><span class="sxs-lookup"><span data-stu-id="aed81-3327">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="aed81-3328">O parâmetro <paramref name="level" /> não pode ser <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3328">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="aed81-3329">O nível de proteção IP não pode ser definido como não especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3329">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-3330">O <see cref="T:System.Net.Sockets.AddressFamily" /> do soquete deve ser <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3330">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="aed81-3331">Define uma opção <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3331">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-3332">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3332">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-3333">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3333">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="aed81-3334">O valor da opção, representado como um <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3334">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="aed81-3335">Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada para o valor especificado de <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3335">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3336"><xref:System.Net.Sockets.Socket> opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3336"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-3337">Definir `optionValue` para `true` para habilitar a opção, ou `false` para desabilitar a opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3337">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="aed81-3338"><xref:System.Net.Sockets.Socket> opções são agrupadas por nível de suporte de protocolo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3338"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="aed81-3339">Abaixo estão as várias <xref:System.Net.Sockets.Socket> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3339">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="aed81-3340">Essas opções são agrupadas por apropriada <xref:System.Net.Sockets.SocketOptionLevel> valor.</span><span class="sxs-lookup"><span data-stu-id="aed81-3340">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="aed81-3341">Se você pretende definir qualquer uma dessas opções, certifique-se de usar apropriada <xref:System.Net.Sockets.SocketOptionLevel> valor para o `optionLevel` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3341">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="aed81-3342">A opção que você optar por definir deve ser especificada no `optionName` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3342">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="aed81-3343">Se você deseja obter o valor atual de qualquer uma das opções listadas, use o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3343">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-3344"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3344"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="aed81-3345"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3345"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="aed81-3346"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3346"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="aed81-3347"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3347"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="aed81-3348">Para obter mais informações sobre essas opções, consulte o <xref:System.Net.Sockets.SocketOptionName> enumeração.</span><span class="sxs-lookup"><span data-stu-id="aed81-3348">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3349">Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3349">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3350">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3350">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3351">O exemplo de código a seguir abre um soquete e permite que o `DontLinger` e `OutOfBandInline` opções de soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3351">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3352">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3352">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3353">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3353">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-3354">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3354">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-3355">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3355">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="aed81-3356">Uma matriz do tipo <see cref="T:System.Byte" /> que representa o valor da opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3356">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="aed81-3357">Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada para o valor especificado, representado como uma matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="aed81-3357">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3358"><xref:System.Net.Sockets.Socket> opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3358"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-3359">Use essa sobrecarga de configurá-los <xref:System.Net.Sockets.Socket> opções que exigem uma matriz de bytes como um valor de opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3359">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3360">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3360">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3361">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3361">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3362">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3362">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3363">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3363">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3364">O seguinte exemplo de código define o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-3364">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3365">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3365">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3366">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3366">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-3367">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3367">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-3368">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3368">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="aed81-3369">Um valor da opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3369">A value of the option.</span></span></param>
        <summary><span data-ttu-id="aed81-3370">Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada para o valor inteiro especificado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3370">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3371"><xref:System.Net.Sockets.Socket> opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3371"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-3372">Para uma opção com um <xref:System.Boolean> de tipo de dados, especifique um valor diferente de zero para habilitar a opção e um valor igual a zero para desabilitar a opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3372">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="aed81-3373">Para uma opção com um tipo de dados inteiro, especifique o valor apropriado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3373">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="aed81-3374"><xref:System.Net.Sockets.Socket> opções são agrupadas por nível de suporte de protocolo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3374"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="aed81-3375">Abaixo estão as várias <xref:System.Net.Sockets.Socket> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3375">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="aed81-3376">Essas opções são agrupadas por apropriada <xref:System.Net.Sockets.SocketOptionLevel>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3376">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="aed81-3377">Se você pretende definir qualquer uma dessas opções, certifique-se de usar apropriada <xref:System.Net.Sockets.SocketOptionLevel> para o `optionLevel` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3377">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="aed81-3378">A opção que você optar por definir deve ser especificada no `optionName` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3378">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="aed81-3379">Se você deseja obter o valor atual de qualquer uma das opções listadas, use o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3379">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="aed81-3380"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3380"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="aed81-3381"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3381"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="aed81-3382"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3382"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="aed81-3383"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3383"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="aed81-3384"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> opções que podem ser definidas usando essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="aed81-3384"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="aed81-3385">Para obter mais informações sobre essas opções, consulte o <xref:System.Net.Sockets.SocketOptionName> enumeração.</span><span class="sxs-lookup"><span data-stu-id="aed81-3385">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3386">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3386">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3387">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3387">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3388">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3388">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3389">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3389">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3390">O seguinte exemplo de código define o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-3390">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3391">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3391">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3392">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3392">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="aed81-3393">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3393">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="aed81-3394">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3394">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="aed81-3395">Uma <see cref="T:System.Net.Sockets.LingerOption" /> ou <see cref="T:System.Net.Sockets.MulticastOption" /> que contém o valor da opção.</span><span class="sxs-lookup"><span data-stu-id="aed81-3395">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="aed81-3396">Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada com o valor especificado, representado como um objeto.</span><span class="sxs-lookup"><span data-stu-id="aed81-3396">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3397"><xref:System.Net.Sockets.Socket> opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3397"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-3398">Use essa sobrecarga para definir o <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opções.</span><span class="sxs-lookup"><span data-stu-id="aed81-3398">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="aed81-3399">Para o <xref:System.Net.Sockets.SocketOptionName.Linger> opção, use <xref:System.Net.Sockets.Socket> para o `optionLevel` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3399">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="aed81-3400">Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3400">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="aed81-3401">Se você deseja obter o valor atual de qualquer uma das opções listadas acima, use o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.</span><span class="sxs-lookup"><span data-stu-id="aed81-3401">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3402">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3402">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3403">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3403">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3404">O seguinte exemplo de código define o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aed81-3404">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aed81-3405"><paramref name="optionValue" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3405"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3406">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3406">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3407">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3407">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="aed81-3408">Um dos valores <see cref="T:System.Net.Sockets.SocketShutdown" /> que especifica a operação que não será mais permitida.</span><span class="sxs-lookup"><span data-stu-id="aed81-3408">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="aed81-3409">Desabilita envios e recebimentos em um <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3409">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3410">Ao usar uma conexão orientada <xref:System.Net.Sockets.Socket>, sempre chamar o <xref:System.Net.Sockets.Socket.Shutdown%2A> método antes de fechar o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3410">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-3411">Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3411">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="aed81-3412">Chamar o <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos os recursos gerenciados e associados a <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3412">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="aed81-3413">Não tente reutilizar o <xref:System.Net.Sockets.Socket> após fechar.</span><span class="sxs-lookup"><span data-stu-id="aed81-3413">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="aed81-3414">A tabela a seguir mostra o <xref:System.Net.Sockets.SocketShutdown> valores de enumeração válidos para o `how` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3414">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="aed81-3415">Valor</span><span class="sxs-lookup"><span data-stu-id="aed81-3415">Value</span></span>|<span data-ttu-id="aed81-3416">Descrição</span><span class="sxs-lookup"><span data-stu-id="aed81-3416">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="aed81-3417">Enviar</span><span class="sxs-lookup"><span data-stu-id="aed81-3417">Send</span></span>|<span data-ttu-id="aed81-3418">Desabilitar envio neste <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3418">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="aed81-3419">Receber</span><span class="sxs-lookup"><span data-stu-id="aed81-3419">Receive</span></span>|<span data-ttu-id="aed81-3420">Desabilitar o recebimento neste <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3420">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="aed81-3421">Ambos</span><span class="sxs-lookup"><span data-stu-id="aed81-3421">Both</span></span>|<span data-ttu-id="aed81-3422">Desabilitar enviando e recebendo neste <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3422">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="aed81-3423">Configuração `how` para <xref:System.Net.Sockets.SocketShutdown.Send> Especifica que subsequentes chamadas para <xref:System.Net.Sockets.Socket.Send%2A> não são permitidas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3423">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="aed81-3424">Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, especificando <xref:System.Net.Sockets.SocketShutdown.Send> não terá efeito.</span><span class="sxs-lookup"><span data-stu-id="aed81-3424">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="aed81-3425">Configuração `how` para <xref:System.Net.Sockets.SocketShutdown.Receive> Especifica que subsequentes chamadas para <xref:System.Net.Sockets.Socket.Receive%2A> não são permitidas.</span><span class="sxs-lookup"><span data-stu-id="aed81-3425">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="aed81-3426">Isso não tem nenhum efeito em camadas inferiores de protocolo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3426">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="aed81-3427">Se você estiver usando um protocolo orientado a conexão, a conexão será encerrada, se uma das seguintes condições for verdadeira após uma chamada para <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="aed81-3427">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="aed81-3428">Dados estão no buffer de rede de entrada aguardando para ser recebida.</span><span class="sxs-lookup"><span data-stu-id="aed81-3428">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="aed81-3429">Mais dados são recebidos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3429">More data has arrived.</span></span>  
  
 <span data-ttu-id="aed81-3430">Se você estiver usando um protocolo sem-conexão, datagramas são aceitos e em fila.</span><span class="sxs-lookup"><span data-stu-id="aed81-3430">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="aed81-3431">No entanto, se nenhum espaço de buffer está disponível para os datagramas de entrada adicionais, eles serão descartados e nenhum erro será retornado para o remetente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3431">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="aed81-3432">Usando <xref:System.Net.Sockets.Socket.Shutdown%2A> em sem uma conexão <xref:System.Net.Sockets.Socket> não é recomendado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3432">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="aed81-3433">Configuração `how` para <xref:System.Net.Sockets.SocketShutdown.Both> desabilita os dois envia e recebe conforme descrito acima.</span><span class="sxs-lookup"><span data-stu-id="aed81-3433">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3434">Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar o <xref:System.Net.Sockets.Socket.Shutdown%2A> método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3434">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3435">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3435">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aed81-3436">Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3436">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="aed81-3437">Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="aed81-3437">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3438">O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.Shutdown%2A> para desabilitar o <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3438">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3439">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3439">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3440">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-3441">Obtém o tipo do <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3441">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-3442">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3442">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3443"><xref:System.Net.Sockets.Socket.SocketType%2A> é somente leitura e é definido quando o <xref:System.Net.Sockets.Socket> é criado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3443"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3444">O código a seguir exemplo exibe o <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> para o console.</span><span class="sxs-lookup"><span data-stu-id="aed81-3444">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-3445">Obtém um valor que indica se o suporte para IPv4 está disponível e habilitado no host atual.</span><span class="sxs-lookup"><span data-stu-id="aed81-3445">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-3446"><see langword="true" /> Se o host atual oferece suporte o protocolo IPv4. Caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3446"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3447">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-3447">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-3448">Obtém um valor que indica se o Framework dá suporte a IPv6 para determinados membros <see cref="T:System.Net.Dns" /> obsoletos.</span><span class="sxs-lookup"><span data-stu-id="aed81-3448">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-3449"><see langword="true" /> Se o Framework oferece suporte a IPv6 para determinados obsoleto <see cref="T:System.Net.Dns" /> métodos; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3449"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3450">O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.</span><span class="sxs-lookup"><span data-stu-id="aed81-3450">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-3451">Obtém ou define um valor que especifica o valor TTL (vida útil) de pacotes IP (Protocolo de Internet) enviados pelo <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3451">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="aed81-3452">O valor TTL.</span><span class="sxs-lookup"><span data-stu-id="aed81-3452">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3453">O valor de TTL indica o número máximo de roteadores que o pacote pode percorrer antes do roteador descarta o pacote e uma mensagem de protocolo ICMP (Internet Control) "TTL excedido" mensagem de erro é retornada para o remetente.</span><span class="sxs-lookup"><span data-stu-id="aed81-3453">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="aed81-3454">O valor de TTL pode ser definido como um valor de 0 a 255.</span><span class="sxs-lookup"><span data-stu-id="aed81-3454">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="aed81-3455">Quando essa propriedade não é definida, o valor TTL padrão para um soquete é 32.</span><span class="sxs-lookup"><span data-stu-id="aed81-3455">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="aed81-3456">A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) é ignorada pela pilha de TCP/IP, se foi estabelecida uma conexão bem-sucedida com o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3456">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="aed81-3457">Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico.</span><span class="sxs-lookup"><span data-stu-id="aed81-3457">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="aed81-3458">Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.</span><span class="sxs-lookup"><span data-stu-id="aed81-3458">After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aed81-3459">O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.Ttl%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="aed81-3459">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="aed81-3460">O valor TTL não pode ser definido como um número negativo.</span><span class="sxs-lookup"><span data-stu-id="aed81-3460">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="aed81-3461">Essa propriedade pode ser definida apenas para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3461">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="aed81-3462">Ocorreu um erro ao tentar acessar o soquete.</span><span class="sxs-lookup"><span data-stu-id="aed81-3462">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="aed81-3463">Esse erro também é retornado quando tiver sido feita uma tentativa para definir o TTL como um valor maior que 255.</span><span class="sxs-lookup"><span data-stu-id="aed81-3463">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="aed81-3464">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</span><span class="sxs-lookup"><span data-stu-id="aed81-3464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="aed81-3465">Especifica se o soquete deve usar apenas o modo de E/S Sobreposta.</span><span class="sxs-lookup"><span data-stu-id="aed81-3465">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value>
          <span data-ttu-id="aed81-3466"><see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> usa apenas E/S sobreposta; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3466"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="aed81-3467">O padrão é <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="aed81-3467">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aed81-3468">Defina essa propriedade como `true` para um <xref:System.Net.Sockets.Socket> você pretende chamar <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3468">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="aed81-3469">Caso contrário, a estrutura pode atribuir uma porta de conclusão no soquete, o que impeça o uso de <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="aed81-3469">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="aed81-3470">O soquete foi associado a uma porta de conclusão.</span><span class="sxs-lookup"><span data-stu-id="aed81-3470">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>